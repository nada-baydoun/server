ID: https://www.aupress.ca/app/uploads/OER-202301_Wang_2023-Introduction-to-Computer-Programming-with-Python.pdf
Document: INTRODUCTION 
TO COMPUTER 
PROGRAMMING  
WITH PYTHON
Harris Wang
Introduction 
to 
Computer 
Programming 

with 
Python
This page intentionally left blank
Introduction 
to 
Computer 
Programming 

with 
Python
Harris Wang
Copyright © 2023 Athabasca University
1 University Drive, Athabasca, AB Canada
DOI: https://doi.org/10.15215/remix/9781998944088.01
Published by Remix, an imprint of Athabasca University 
Press. For more information, please visit aupress.ca or 
email OERpublishing@athabascau.ca.
Cover design by Lisa Mentz
Images that appear in this text are created by the author.
Library and Archives Canada Cataloguing in Publication
Title: Introduction to computer programming with Python 
/ Harris Wang.
Names: Wang, Harris, author.
Identifiers: Canadiana (print) 20230509916 | Canadiana 
(ebook) 20230509924 | ISBN 9781998944071 (softcover) | 
ISBN 9781998944088 (PDF) | ISBN 9781998944095 (EPUB)
Subjects: LCSH: Python (Computer program language)—­
Textbooks. | LCGFT: Textbooks.
Classification: LCC QA76.73.P98 W36 2023 | DDC 
005.13/3—­
dc23
Introduction to Computer Programming with Python 
by Harris Wang is licensed under a Creative Commons 
Attribution-­
NonCommercial-­
ShareAlike 4.0 International 
License, except where otherwise noted. This license 
allows users to copy and redistribute the material in 
any medium or format and to remix, transform, and 
build upon the material as long as the original source is 
properly credited, the work is not used for commercial 
purposes, and the new creation is licensed under the 
same terms.
Remix name, Remix logo, and Remix book covers are not 
subject to the Creative Commons license and may not be 
reproduced without the prior and express written consent 
of Athabasca University.
Contents
	Chapter 1	 Introduction	
1
	 	
Learning Objectives	
1
	
1.1	 A Brief History of Computers	
1
	
1.2	 Fundamentals of Computing and Modern Computers	
5
Number Systems and the Foundation of Computing	
6
Computability and Computational Complexity	
9
The Construction of Modern Computers	
11
Analog Computers	
11
Digital Computers	
12
Mechanic-­
Based Components	
13
Vacuum Tube–­
Based Components	
14
Transistors	
14
Integrated Circuits and Very Large-­
Scale Integrated Circuits	
14
	
1.3	 Programming and Programming Languages	
15
	
1.4	 Python Programming Language	
17
The Development and Implementation of Python	
17
Advantages of Python	
18
Resources for Python and Python Education	
19
	
1.5	 Getting Ready to Learn Programming in Python	
20
Installing and Setting Up the Python Programming Environment	
21
Installing Python	
21
Setting Up a Virtual Environment for a Python Project	
24
Installing Jupyter Notebook	
26
Installing Visual Studio Code	
27
Additional Tools Supporting Software Development in Python	
27
Buildbot	
27
Trac	
28
Roundup	
28
	
vi	
Contents
	
1.6	 Getting a Taste of Programming with Python	
28
Program Interactively with Python Interactive Shell	
28
Program with VS Code IDE	
30
Use Jupyter Notebook Within VS Code to Program Interactively	
32
Write Documentation in Markdown	
33
Headings	
33
Paragraphs	
34
New Lines	
34
Italic, Bold, and Strikethrough Texts	
34
Horizontal Rules	
35
Keyboard Keys	
35
Unordered Lists	
35
Ordered Lists	
36
Definition Lists	
36
Links	
37
Links to Internal Sections	
37
Images	
38
Blockquotes	
38
Tables	
39
Inline Program / Script Code	
39
Code Block	
40
Mathematical Formulas and Expressions	
40
To-­
Do List	
42
Escape Sequence for Special Characters	
42
Programming Interactively with Jupyter Notebook 
Within VS Code	
42
Run Python Programs Outside IDE	
48
Make the Python Program File Executable	
50
Errors in Programs	
52
	
1.7	 Essentials of Problem Solving and Software Development	
54
Design Algorithms to Solve Problems	
54
Phases of Software System Development	
56
Phase 1. Understand the Project	
57
Phase 2. Analyze the Requirements to Identify 
Computer-­
Solvable Problems and Tasks	
57
Phase 3. Design the System	
58
Phase 4. Implement the System	
58
Phase 5. Test the System	
58
Phase 6. Maintain the System	
58
	
Contents	
vii
	
1.8	 Manage Your Working Files for Software Development 
Projects	
58
Set Up Git on Your Computer and Version-­
Control Locally	
59
Set Up an Account on GitHub and Version-­
Control with Remote 
Repositories	
62
	 	
Chapter Summary	
67
	 	
Exercises	
69
	 	
Projects	
71
	Chapter 2	 Essential Building Blocks of Computer 
Programs	
73
	 	
Learning Objectives	
73
	
2.1	 Primary Constructs of Computer Programs in Python	
74
Vocabulary of the Programming Language	
74
Rules of Naming Identifiers	
76
Python Naming Conventions	
79
Names with Leading and/or Trailing Underscores	
79
Rules of Scope Resolution for Identifiers	
81
Simple Data Types	
82
Signed Integers (int)	
83
Float (float)	
87
Boolean (bool)	
88
Complex (complex)	
89
Compound Data Types	
89
String (str)	
90
List	
95
Tuple	
97
Set	
98
Dictionary	
99
Object	
99
Variables and Constants	
101
Variables	
101
Built-­
In Constants	
104
Operators	
106
Arithmetic Operators	
106
Comparison Operators	
108
Logical Operators	
109
Bitwise Operators	
111
Assignment Operators	
112
Identity Operators	
115
	 viii	
Contents
Sequence Operators	
115
Membership Operator	
116
Built-­
In Functions	
117
Expressions	
135
	
2.2	 Higher-­
Level Constructs of Python Programs	
137
Structure of Python Programs	
137
Documentation and Comments	
139
Simple Statements	
141
Expression Statement	
141
Assignment Statement	
143
print Statement	
146
input Statement	
149
assert Statement	
150
pass Statement	
151
del Statement 
151
return Statement	
152
open Statement	
152
yield Statement	
153
raise Statement	
154
break Statement	
155
continue Statement	
155
import Statement	
156
global Statement	
156
nonlocal Statement	
157
help Statement	
158
Compound Statements	
159
Code Blocks	
159
Rules of Indentation	
160
Rules of Spacing	
160
if Statement	
161
if-­
else Statement	
162
if-­
elif Statement	
163
if-­
elif-­
else Statement	
165
while Statement	
165
for Statement	
166
def Statement	
167
class Statement	
168
try-­
except Statement	
168
with Statement	
169
	 	
Chapter Summary	
170
	
Contents	
ix
	 	
Exercises	
171
	 	
Projects	
172
	Chapter 3	 Flow Control of Statements	
175
	 	
Learning Objectives	
175
	
3.1	 Selective with the if Statement	
175
	
3.2	 Single-branch selective with if Statement	
176
	
3.3	 Multiple-Branch Selective with if-elif-… and if-elif-…-else 
Statements	
177
	
3.4	 Iterate with for Statement	
180
Using break and continue Statements and an else Clause 
Within Loops	
184
Common Coding Mistakes with the for Loop	
185
	
3.5	 Iterate with the while Statement	
185
Common Coding Mistakes with a while Loop	
190
	
3.6	 Iterate with for Versus while	
190
	 	
Chapter Summary	
195
	 	
Exercises	
195
	 	
Projects	
196
	Chapter 4	 Handle Errors and Exceptions in 
Programs	
201
	 	
Learning Objectives	
201
	
4.1	 Errors in Your Programs	
202
Exception	
203
ArithmeticError	
204
OverflowError	
204
ZeroDivisionError	
204
FloatingPointError	
205
AssertionError	
205
AttributeError	
205
BufferError	
206
EOFError	
206
GeneratorExit	
206
ImportError	
206
IndexError	
207
KeyError	
207
KeyboardInterrupt	
207
MemoryError	
207
	
x	
Contents
ModuleNotFoundError	
207
NameError	
208
NotImplementedError	
208
OSError	
208
BlockingIOError	
208
ChildProcessError	
208
ConnectionError	
208
BrokenPipeError	
209
ConnectionAbortedError	
209
ConnectionRefusedError	
209
ConnectionResetError	
209
FileExistsError	
209
FileNotFoundError	
209
IsADirectoryError	
209
NotADirectoryError	
209
PermissionError	
209
ProcessLookupError	
210
TimeoutError	
210
RecursionError	
210
ReferenceError	
210
RuntimeError	
210
StopIteration	
210
StopAsyncIteration	
210
SyntaxError	
210
IndentationError	
211
TabError	
211
SystemError	
211
SystemExit	
211
TypeError	
211
UnboundLocalError	
212
UnicodeError	
212
UnicodeEncodeError	
212
UnicodeDecodeError	
212
UnicodeTranslateError	
212
ValueError	
212
	
4.2	 Handling Runtime Errors and Exceptions	
216
	 	
Chapter Summary	
219
	 	
Exercises	
220
	
Contents	
xi
	Chapter 5	 Use Sequences, Sets, Dictionaries, and 
Text Files	
221
	 	
Learning Objectives	
221
	
5.1	 Strings
222
Methods of Built-­
In Class str	
222
Built-­
In Functions and Operators for Strings	
232
Constructing and Formatting Strings	
234
Regular Expressions	
242
	
5.2	 Lists
251
	
5.3	 Tuples
258
	
5.4	 Sets
261
	
5.5	 Dictionaries	
266
	
5.6	 List, Set, and Dictionary Comprehension	
271
List Comprehension	
272
Set Comprehension	
273
Dictionary Comprehension	
274
	
5.7	 Text Files	
274
Opening and Closing a File	
275
Write or Append to a File	
278
Reading from a File	
280
Update Existing Content of a Text File	
284
Deleting Portion of a Text File	
286
	 	
Chapter Summary	
289
	 	
Exercises	
291
	 	
Projects	
292
	Chapter 6	 Define and Use Functions	
295
	 	
Learning Objectives	
295
	
6.1	 Defining and Using Functions in Python	
296
	
6.2	 Parameters and Arguments in Functions	
299
	
6.3	 Recursive Functions	
304
	
6.4	 Anonymous Functions: lambda Expressions	
308
	
6.5	 Special Functions: Mapping, Filtering, and Reducing	
310
Mapping	
310
Filtering	
311
Reducing	
312
	
6.6	 Generators: Turning a Function into a Generator of Iterables	 312
	
6.7	 Closures: Turning a Function into a Closure	
316
	
6.8	 Decorators: Using Function as a Decorator in Python	
317
	 xii	
Contents
	
6.9	 Properties of Functions	
320
	 	
Chapter Summary	
322
	 	
Exercises	
322
	 	
Projects	
323
	Chapter 7	 Object-­
Oriented Programming with 
Python	
325
	 	
Learning Objectives	
325
	
7.1	 Introduction to Object-­
Oriented Programming (OOP)	
326
Abstraction	
326
Information Hiding or Data Encapsulation	
326
Inheritance	
327
	
7.2	 Defining and Using Classes in Python	
327
Inheritance: Subclass and Superclass	
333
Public, Private, and Protected Members of a Class	
334
Class Methods	
336
Static Methods	
337
Class Attributes	
338
	
7.3	 Advanced Topics in OOP with Python	
340
Dunder Methods in Class Definition	
340
Using Class as Decorator	
346
Built-­
In Property() Function and Property Decorator	
348
Creating a New Class Dynamically and Modify a Defined 
Class or Instance	
352
Keeping Objects in Permanent Storage	
356
	 	
Chapter Summary	
358
	 	
Exercises	
359
	 	
Project
361
	Chapter 8	 Modules and Packages	
363
	 	
Learning Objectives	
363
	
8.1	 Creating Modules and Packages	
364
	
8.2	 Using Modules and Packages	
367
	
8.3	 Install and Learn About Modules Developed by Others	
369
	
8.4	 Module for Generating Random Numbers	
377
Functions for Bookkeeping	
379
Functions for Generating Random Integers	
379
Functions for Randomly Generating Float Numbers	
380
Functions for Randomly Selected Item(s) from Sequences	
382
	
8.5	 Module for Mathematical Operations	
385
	
Contents	
xiii
	
8.6	 Modules for Time, Date, and Calendar	
395
The Datetime Module	
395
The Time Module	
405
The Calendar Module	
410
	
8.7	 Modules for Data Representation and Exchange	
415
	
8.8	 Modules for Interfacing Operating Systems and Python 
Interpreter	
418
OS Module for Interacting with the Operating System	
418
The path Submodule from os for Manipulating File Paths	
423
The sys Module for Interaction Between the Python and 
Python Interpreter or Python Virtual Machine (PVM)	
426
	
8.9	 Module for Logging Events During Program Runtime	
434
	
8.10	Modules for Playing and Manipulating Audio and 
Video Files	
436
winsound	
436
PyGame	
439
	
8.11	Modules for Creating and Manipulating Graphics and 
Images	
442
Create Graphics with Tkinter	
443
Manipulate Images with Pillow	
448
	
8.12	Modules for Data Analytics	
451
	 	
Chapter Summary	
455
	 	
Exercises	
456
	 	
Projects	
457
	Chapter 9	 Develop GUI-­
Based Applications	
459
	 	
Learning Objectives	
459
	
9.1	 Terminal-­
Based Applications Versus GUI-­
Based 
Applications	
460
	
9.2	 Designing and Developing GUI-­
Based Applications 
in Python	
461
Tkinter Module	
463
tkinter.ttk—­
Tk-­
Themed Widgets	
475
	 	
Chapter Summary	
482
	 	
Exercises	
483
	 	
Projects	
484
This page intentionally left blank
 https://doi.org/10.15215/remix/9781998944088.01
Chapter 1
Introduction
This chapter prepares you to learn how to program with Python. Preparation 
includes a brief introduction to computers and computing, programming, 
and programming languages, as well as the installation of Python and Python 
interactive programming and integrated development environments (IDEs), 
including Jupyter Notebook for interactive programming and VS Code as a 
required IDE.
Learning Objectives
After completing this chapter, you should be able to
•	 talk about the history of computers.
•	 describe the basic components of modern computers and their roles.
•	 explain the basic principles of modern computers.
•	 discuss the basics of computability and computational complexity.
•	 explain how the construction of modern computers has evolved.
•	 explain what computer systems are made of.
•	 discuss computer programming languages.
•	 describe Python and discuss its development, features, and advantages.
•	 install Python and required Python IDEs on the computer.
•	 get Python and Python IDEs running for the learning activities included 
in this textbook.
1.1 A Brief History of Computers
The history of human tools, devices, or instruments to help us count, compute, 
and think can be traced back to the Stone Age, when our ancestors used knots 
on ropes, marks on bark, stones, and balls of clay. One of the most well-­
known 
	
2	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
and widely used devices for computing in human history is the abacus, shown 
in Figure 1-­
1.
The exact origin of the abacus is unknown, but before the adoption of the 
written Hindu-­
Arabic numeral system, the abacus had already been widely 
used in many countries, including China, Russia, and some European coun­
tries. Abacuses continued to be widely used by almost all accountants in China 
before the adoption of modern computers and calculators.
Today, although abacuses are rarely used in real applications such as 
accounting, their working principles are still used to train people to do men­
tal math, such as in programs like the Universal Concept of Mental Arithmetic 
System (UCMAS; see ucmas​
.ca). UCMAS holds annual competitions worldwide, 
including in Canada.
The invention and development of today’s modern computers can be 
attributed to the invention and development of all previous relevant concepts, 
principles, and technologies. The concept of a digital, programmable computer 
originated with Charles Babbage, an English mathematician, philosopher, 
inventor, and machine engineer. In 1822, he designed a steam-­
driven calcu­
lating machine for automatically computing tables of numbers. Although his 
government-­
funded project failed, the many ideas he developed and used in 
his analytical engine were adopted and used in the world’s first modern pro­
grammable computer, built a century later. That is why Charles Babbage is 
considered to be one of the “fathers of computers.”
In 1847, George Boole, an English mathematician introduced Boolean logic, 
propositional calculus, and Boolean algebra as the laws of thinking, which later 
became the foundation of modern electronic computers and digital devices in gen­
eral. For that reason, George Boole is regarded as a founder of computer science.
In 1890, Herman Hollerith successfully designed and built a punch-­
card-­
based system for the US government to calculate its 1890 census. It saved the 
US government US$5 million by finishing the calculation in one year instead 
of 10 years it would have taken using traditional methods, as in the previous 
census. In 1896, Herman Hollerith established a company called the Tabulating 
Machine Company to make the machines. This company ultimately became IBM.
Figure 1-­
1: A traditional abacus
	
Introduction	
3
 https://doi.org/10.15215/remix/9781998944088.01
The central concept and theory of modern computers were conceived in 
1936 by English mathematician Alan Turing in his “universal machine,” which 
became known as the Turing machine in his honour. He successfully proved 
that his universal machine could calculate anything that is computable. Alan 
Turing is also considered by some to be “a father of computers”—­
or more 
precisely, “a father of computing”—­
for his seminal paper on the theory of 
computation. In the eyes of the general public, Alan Turing is more famous 
for his role in cracking the so-­
called unbreakable codes used by the German 
army during World War II, as presented in The Imitation Game, a well-­
known 
Hollywood movie.
Until 1937, all computing machines or computers were mechanically based, 
using gears, cams, belts, or shafts. John Vincent Atanasoff, an American math­
ematician and physician at Iowa State University, attempted in 1937 to build the 
first electronic computer. He and Clifford Berry, one of his graduate students at 
the time, designed and built a special-­
purpose digital computer, ABC. For that 
reason, he is considered to be “the father of the modern computer.” It was in 
the ABC machine that binary math and Boolean logic were successfully used 
for the first time.
In 1943, across the Atlantic Ocean in England, Colossus Mark I, a prototype 
of a special-­
purpose computer, was built. A year later, in 1944, Colossus Mark II 
was built and used to break the encrypted radiotelegraphy messages transmitted 
by the German army at the end of World War II.
In 1946, the first general-­
purpose digital computer, the Electronic Num­
erical Integrator and Computer (ENIAC), was built by two professors at the 
University of Pennsylvania: John Mauchly and J. Presper Eckert. The computer 
had over 18,000 vacuum tubes and weighed 30 tons. A rumour at the time said 
that whenever the computer was turned on, the lights in some districts of 
Philadelphia would dim.
During the same time, the same group of people at the University of Pennsyl­
vania also designed and built EDVAC (the Electronic Discrete Variable Automatic 
Computer, completed in 1949), BINAC (the Binary Automatic Computer, also 
completed in 1949), and UNIVAC I (the Universal Automatic Computer I, com­
pleted in 1950), which were the first commercial computers made in the US. 
Although the computing power of these computers was not even comparable 
to that of today’s smartphone, their contributions to the development of today’s 
modern computers are enormous. These contributions include the concepts, 
principles, and technology of stored programs, subroutines, and programming 
languages.
Around the same time that ENIAC was built, the Harvard Mark I auto­
matic sequence-­
controlled calculator was also built at Harvard University. It is 
	
4	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
believed that John von Neumann, a mathematician and physicist working at the 
Los Alamos National Laboratory, was the first user of the Harvard Mark I, which 
he used to run programs on the machine to calculate for the Manhattan Project.
In 1944, Von Neumann had an opportunity to join a discussion with J. Pres­
per Eckert and John Mauchly, who were developing ENIAC and EDVAC machines 
at the time. He wrote up a report on the EDVAC, First Draft of a Report, in which 
he described a computer architecture later known as Von Neumann architec­
ture (see Figure 1-­
2). The key idea behind the architecture is a stored-­
program 
computer that includes the following components:
•	 a processing unit that contains an arithmetic logic unit and processor 
registers
•	 a control unit that contains an instruction register and program counter
•	 internal memory that stores data and instructions
•	 external mass storage
•	 input and output mechanisms
The unpublished report was widely circulated. It had great impact on the 
later development of modern computers, although to many people, Turing was 
the originator of this key idea and architecture, and many others, including J. 
Presper Eckert and John Mauchly, made significant contributions to its evo­
lution as well. Regardless, it is Von Neumann architecture that has guided the 
design of modern computers. All computers we use today are essentially still 
Von Neumann computers.
Modern computers can be categorized into three generations based on the 
core hardware technology used. The first generation of computers (1937–­
46) 
used vacuum tubes, the second generation (1947–­
62) used transistors, and the 
third generation (1963–­
present) used integrated circuits (IC).
Central Processing Unit
Control Unit
Arithmetic/Logic Unit
Memory
Input
Output
Storage
Figure 1-­
2: Von Neumann architecture
	
Introduction	
5
 https://doi.org/10.15215/remix/9781998944088.01
Both hardware and software play important roles in computers. On the hard­
ware front, in the first generation of modern computers, magnetic tapes and disks 
were developed and used for storage, and printers appeared and were used for 
output. On the software side, simple operating systems (OSs) were developed and 
used, and over 100 high-­
level programming languages were developed.
During the second generation of computers, the Universal Automatic Com­
puter (UNIVAC I), the first computer for commercial use, was introduced to 
the public (1951). The International Business Machines Corporation (IBM) also 
brought their IBM650 and IBM700 series computers to the computer world 
(1953).
Since 1963, the beginning of the third generation of modern computers, 
advances in hardware have made computers smaller and smaller but much 
more powerful, with a higher speed of CPU and a bigger memory with faster 
throughput.
In 1980, Microsoft developed MS-­
DOS, short for Microsoft Disk Operating 
System, and in 1981, IBM introduced the first personal computer (PC) for home 
and office use. In 1984, Apple brought its Macintosh computer with its icon-­
driven interface to the world, and in the 1990s, Microsoft brought the world the 
Windows operating system. Billions of computer users around the world have 
enjoyed both Microsoft Windows and Apple’s macOS.
More information about the history of computers can be found on the inter­
net by searching for “history of computers,” including the following articles:
https://​
en​
.wikipedia​
.org/​
wiki/​
Computer
https://​
www​
.computerhistory​
.org/​
timeline/​
computers/
https://​
www​
.explainthatstuff​
.com/​
historyofcomputers​
.html
https://​
www​
.britannica​
.com/​
technology/​
computer/​
History​
-of​
-computing
1.2 Fundamentals of Computing and Modern 
Computers
The development of modern computers is the result of the collective efforts of 
many great mathematicians, scientists, and engineers and advances in both 
theories and technologies. This section looks at the theoretical and technical 
fundamentals of computing and modern computers in order to show how 
modern computers work internally.
	
6	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Number Systems and the Foundation of Computing
Initially, computers and computing devices were developed to deal with num­
bers. They later made their way into the realm of text handling and information 
processing. This is done through encoding. When properly coded, all text can be 
represented as numbers—­
codes—­
and all ways of manipulating text can be accom­
plished through operations on those codes. Number systems and operations on 
numbers are really a basic foundation of computing and modern computers.
We all know numbers, and the number system we have known since child­
hood is base-­
10, which is represented using 10 digits from 0 to 9. A base-­
10 
number such as 2539867 can be written as
2 * 106 + 5 * 105 + 3 * 104 + 9 * 103 + 8 * 102 + 6 * 101 + 7 * 100
In general, an n-digit number dn−1dn−2…d1d0 (where n is any positive integer 
and each d ∈ [0, 1, 2, …, 9], where 0 < i < n ) in a base-­
10 number system can 
be rewritten as
dn−1 * 10n−1 + dn−2 * 10n−2 + … + d1 * 101 + d0 * 100
In fact, a number system can be based on any whole number other than 
0 and 1. There is a base-­
7 system for weeks, a base-­
12 system for the Chinese 
zodiac and imperial foot and inch, and a base-­
24 number system for the 24-­
hour 
clock. A long list of different numbering systems that have appeared since pre­
history can be found at https://​
en​
.wikipedia​
.org/​
wiki/​
List​
_of​
_numeral​
_systems.
In general, a base-­
Q number system will require Q unique symbols repre­
senting 0, 1, … Q−1, respectively. The base-­
10 equivalence of an n-digit base-­
Q 
number dn−1dn−2…d1d0 can be represented as
dn−1 * Qn−1 + dn−2 * Q−2 + … + d1 * Q1 + d0 * Q0
The evaluation of the expression above will result in its base-­
10 equivalence. 
This is how we convert a number from base-­
Q to base-­
10.
For Q = 2, the numbers 0 and 1 are used to represent digits; for Q = 3, the 
numbers 0, 1, and 2 are used; for Q = 8, the numbers 0, 1, 2, 3, 4, 5, 6, and 7 are 
used; for Q = 16, the numbers 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a/A, b/B, c/C, d/D, e/E, 
and f/F are used.
The expression above also shows how to convert a number from base-­
10 
to base-­
Q: divide the number by Q repeatedly, and the remainders will be the 
digits. The details of these conversions can be found on the internet.
For a number dn−1dn−2…d1 d0 in a base-­
Q number system, it is often necessary 
to add Q as a subscription of the sequence, as shown below:
dn−1dn−2…d1d0Q or (dn−1dn−2…d1d0)Q
	
Introduction	
7
 https://doi.org/10.15215/remix/9781998944088.01
This explicitly indicates that the number is in a base-­
Q number system. For 
example, number 657 in a base-­
8 number system will be written as 6578 or 
(657)8, especially if the context does not indicate which number system the 
number is in.
All number systems have the same operations that we are already familiar 
with in a base-­
10 system, such as addition, subtraction, multiplication, and 
division. The only difference is that in a base-­
Q number system, a 1 carried to 
or borrowed from a higher digit is equal to Q instead of 10.
For example, in a base-­
2 number system, 101 can be written as 1 * 22 + 0 
* 21 + 1 * 20, and its 10-­
base equivalence is 1 * 4 + 0 + 1 = 5, and for 101 + 110, 
the operation is
101
+ 110
______
1011
110
− 101
______
001
Given the four basic mathematical operations—­
addition, subtraction, multi­
plication, and division—­
it is very simple to prove that multiplication can be done 
by repeated addition, whereas division can be done by repeated subtraction. 
Therefore, if you know how to do addition and subtraction and are able to 
count, you will be able to do multiplication and division as well.
More importantly, because a − b can be rewritten as a + (−b), you may be 
able to eliminate subtraction if you can represent −b without the minus sign. 
In a base-­
Q number system, (a − b) can be conveniently handled through a + 
b′, in which b′ is the Q-complement of b representing (−b).
Given a negative number, −N, in which N is called the magnitude of −N, how 
do you get N′, the Q’s complement to N? It turns out to be very easy.
For a number N written as dndn−1…d0 in a base-­
Q number system, its 
Q-complement N′ is a number, also in a base-­
Q number system, such that N + 
N′ = Qn, and N′ can be easily calculated in the following two steps:
	
1.	 For each di in dn−1dn−2…d0, find ti such that di + ti = Q−1, to 
get tn−1tn−2…t0
	
2.	 Add 1 to tn−1tn−2…t0 to get N’s complement cn−1cn−2…c0
For b in a − b, if b has fewer digits than a, add 0s to the left of b to make up the 
missing digits before working on the above steps. For example, for 768 − 31, 
do 768 + (−31) or 768 + the 10’s complement of 31.
	
8	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
To get 10’s complement of 31, first add one 0 to the front of 3 to get 031, 
then find out the 10’s complement of 031, which is 968 + 1 = 969. Then do 768 
+ 969 to get 1737, and ignore the last carried digit, 1, to get 737, which is the 
result of 768 − 31.
It is easy to see that if C is N’s complement, then N is C’s complement as 
well. Using the notation given above, this can be written as (N′)′ = N.
What about floating-­
point numbers—­
that is, numbers with fractions, such 
as 3.1415926?
In a base-­
Q number system, a floating-­
point number can be represented 
much like integers, as shown below:
dn−1 * Qn−1 + dn−2 * Qn−2 + … + d1Q1 + d−1 * Q−1 + d−2 * Q−2 + … + d−mQ−m
This may give us a hint that a floating-­
point number can be represented by 
two sequences of digits: one for the integer portion and the other for the frac­
tion portion. If floating-­
point numbers are represented this way in computers, 
addition and subtraction could be performed on the two portions separately, 
but with a mechanism to deal with carrying from the fraction to the integer in 
the case of addition, and a mechanism to deal with borrowing from the integer 
to the fraction in the case of subtraction. This would be rather clumsy, and it 
would be even more clumsy when doing multiplication and division.
In reality, floating-­
point numbers are represented in scientific notation, 
such as 1.3 * 102 in a base-­
10 or decimal system, where 1.3 is called the frac­
tion, 2 is called the exponent, and 10 is the radix. In a base-­
2 system, the radix 
would be 2.
In scientific notation, arithmetic operations on floating-­
point numbers 
can be easily done, especially if the fractions of all floating-­
point numbers are 
normalized—­
that is, if the number of digits before the radix point is fixed for 
all floating-­
point numbers. For example, to perform the addition or subtrac­
tion of two floating-­
point numbers, all you need to do is shift the digits of one 
floating-­
point number based on the difference of the two exponents, then per­
form addition or subtraction in the same way as on integers. More surprisingly, 
multiplying and dividing floating-­
point numbers in scientific notation is much 
easier than adding and subtracting. There is no need to shift the digits because
a * rm * b * rn = a * b * rm+n
and
a * rm / b * rn = a / b * rm−n
All you need to build a computer capable of adding, subtracting, multiply­
ing, and dividing in a base-­
Q number system is the ability to add and count, 
	
Introduction	
9
 https://doi.org/10.15215/remix/9781998944088.01
which is needed for multiplication and division. Moreover, counting itself can 
be done by addition when counting up or subtraction when counting down. 
This is very encouraging.
The following discoveries are even more encouraging:
•	 Many mathematical and scientific problems can be represented and 
reformulated based on the basic mathematical operations discussed 
above.
•	 If we can build a computing device capable of doing basic mathematical 
operations, the machine can solve many computing and information 
processing problems.
The remaining question is how to make such a machine work faster. On a 
computing machine with only an addition and counting unit, if each step of an 
operation has to be enabled by a human, the computation would be very slow 
because it would have to wait for the human to input instructions and data. To 
speed things up, the entire problem solving process needs to be automated. This 
requirement has led to the introduction of memory to computing machines to 
store both the operating instructions (the program) and data needed during the 
computation. For the central processing unit (CPU) and memory (RAM) to com­
municate and work together, a communication channel and control unit need to 
be added. For human users to communicate with the computing machine, input 
and output units are also needed. Together these include everything described in 

Von Neumann’s architecture for modern computers.
Computability and Computational Complexity
Now comes the question of how powerful the computing machine described 
above can be. In particular, we should ask,
•	 What problems can or cannot be computed with a computing machine?
•	 How difficult is it to solve a given problem with a computing machine, 
assuming that the machine can take as many steps and use as much 
memory as needed to solve the problem?
Answering the first problem is the study of computability. Answering the second 
question is the study of computational complexity.
A well-­
known computability problem was raised by David Hilbert, a very 
famous German mathematician in the 19th century. The 10th problem in his list 
of 23 important mathematical problems he published in 1900 is the decidability 
problem, which is about finding an algorithm that can determine whether a 
	 10	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Diophantine equation such as xn + yn = zn, where n is an integer and greater 

than 2, has integer solutions. It was proved in 1970 that such an algorithm 
doesn’t exist, meaning that the problem of deciding whether a Diophantine 
equation has integer solutions is unsolvable, or incomputable.
Between the 1930s and 1940s, before the existence of modern computers, 
Alan Turing invented a simple yet powerful abstract machine called the Tur­
ing machine. He proved that the abstract machine could simulate the logic of 
any given algorithm and further determine whether an algorithm is comput­
able. The operation of the machine will halt if the algorithm is incomputable. 

During the same time, computability was also well studied by Alonzo Church 
based on lambda calculus. The two works later intertwined in a formal theory 
of computation known as the Church-­
Turing thesis.
In computer science, the computational complexity of an algorithm devised 
to solve a problem is about the number of resources—­
CPU time and memory, 
in particular—­
needed to run the algorithm on a computer. A problem may be 
solved in different ways using different algorithms with different computational 
complexities. Sometimes it is necessary to find a better algorithm that runs 
faster and/or uses less memory.
The time required to run an algorithm is also related to the size of the 
problem to be solved. For example, finding someone in a classroom would be 
much easier than finding someone in a city. If you denote the size of a problem 
with n, then in computer science, O(f(n))—­
called the big O of f(n)—­
is used to 
describe asymptotically the upper bound of running time: the time complexity 
of an algorithm for solving the problem.
For example, assume you want to sort the numbers in a list. The size of the 
problem will be the number of numbers in the list. One algorithm is called 
selection sort, which begins with selecting the smallest number from the 
list, then selecting the smallest number from the remaining of the list, and 
so on. Assume the size of the list is n. The first time it will need to do n − 1 
comparisons. The second time it will need n − 2 comparisons. When these are 
only two numbers left in the list, only one comparison is needed to finish. So 
the complexity of the algorithm in terms of the total number of comparisons 
needed will be
(n − 1) + (n − 2) + (n − 3) … + 2 + 1 = (n − 1 + 1) / 2 * (n − 1) = n * (n − 1) / 2 
= (n2 − n) / 2 = O(n2)
You may have noted in the big-­
O notation that we have kept only the highest-­
order term and have removed the constant ½ as well. This is because, with the 
big-­
O asymptotic notation, only the scale of complexity increased when the size 
of the problem increases is of interest.
	
Introduction	
11
 https://doi.org/10.15215/remix/9781998944088.01
In computer science, problems can be classified as P (for polynomial), 
NP (for nondeterministic polynomial), NP-­
complete, or NP-­
hard problems. A 
problem is said to be in P if it can be solved using a deterministic algorithm in 
polynomial time—­
that is, if the complexity is a big O of a polynomial. A prob­
lem is said to be in NP if it can be solved with a nondeterministic algorithm in 
polynomial time. A problem is NP-­
complete if a possible solution can be quickly 
verified but there is no known algorithm to find a solution in polynomial time. 
A problem is NP-­
hard if every NP problem can be transformed or reduced to 
it within polynomial time.
In the above, a deterministic algorithm refers to the one in which, given the 
same input, the output would always be the same, whereas a nondeterministic 
algorithm may give different outputs even for the very same input.
The complexity of algorithms, which is closely related to the response and 
processing speed of programs and computer systems, is the concern of good 
programmers, especially when dealing with resource-­
intensive applications. 
It is also an important topic to be studied in senior or graduate courses in 
computing and computer science. When writing a program or just a function 
for assignments or an application, always think about the time and space com­
plexity and ask yourself, Is there a better way to get the job done?
The Construction of Modern Computers
In general, computers can be categorized into two types: analog computers and 
digital computers. The computers in use today are almost all digital computers. 
But analog computers do have their advantages.
ANALOG COMPUTERS
As a computing machine, an analog computer uses the properties of certain 
objects or phenomena to directly analogize the values of variables (such as 
the speed of a vehicle) of a problem to be solved. Examples of the properties 
include the voltage and amperage of electricity, the number of teeth of a gear, 
or even the length of a wood or metal stick.
Analog computing machines were often built for some special purpose, with 
a very wide range of difficulties and complexities. A simple analog computer 
could be built with three gears for addition and subtraction. For addition, using 
both operands to drive the third gear in the same direction will yield the sum 
of the two operands on the third gear, whereas for subtraction, the difference 
can be calculated by driving the two gears in two different directions.
Historically, even as early as 100  BC, complicated analog computing 
machines were built for various applications, from astronomy in ancient Greece 
to the differential machine for solving differential equations in the late 1800s 
	 12	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
and early 1900s. Some of the most complicated analog computing machines in 
modern history include those for flight simulation and gunfire control. Analog 
computing machines continued well into the early age of modern digital com­
puters because the special applications analog computers were developed for 
were still too hard for digital computers in the 1960s or even 1970s.
DIGITAL COMPUTERS
Different from analog computers, digital computers use sequences of digits 
to represent the values of variables involved in the problems to be solved. In 
digital computers, the machine representation of a problem is often abstract, 
with no analogy to the original problem.
Theoretically, in accordance with the earlier discussion about general num­
ber systems, digital computers’ digits can be in any base, from 2 up. Hence a 
digital computer could be base-­
2, base-­
3, … base-­
10, base-­
16, and so on. The 
digital computers we are using today are all base-­
2, or binary, computers, 
although it has been proved that base-­
3 computers would be even more effi­
cient than base-­
2 computers.
This is because it is more convenient and cheaper to build components 
with the two easily distinguishable states needed to represent base-­
2 numbers.
Also, in a binary system, signed numbers can be naturally represented 
using the highest sign bit: 0 for positive numbers and 1 for negative numbers, 
for example. Moreover, the addition and subtraction of signed binary numbers 
can be easily done by using 2’s complements to represent negative numbers.
For example, to do −2−3, we would do
(−2) + (−3)
or
(−00000010)b + (−00000011)b
Next, we need to convert (−00000010)b and (−00000011)b into their 2’s comple­
ment representations. According to the two steps we described in the section 
above, “Number Systems and the Foundation of Computing,” with Q = 2, you 
first get 1’s complement of the magnitude of each negative number above by 
flipping each bit, then adding 1 to 1’s complement, as shown below:
(00000010)b (1’s complement by flipping each bit) → (11111101)b 
(then + 1) → (11111110)b
(00000011)b (1’s complement by flipping each bit) → (11111100)b 
(then + 1) → (11111101)b
	
Introduction	
13
 https://doi.org/10.15215/remix/9781998944088.01
The addition above will become
(11111110)b + (11111101)b
which is equal to
(11111011)b
The 1 on the highest bit of the result means that the result is 2’s comple­
ment representation of a negative number. Interestingly, the magnitude of the 
negative number is the complement of (11111011)b, which is
(11111011)b (1’s complement by flipping each bit) → (00000100)b 
(then + 1) → (000000101)b,
which is 5, meaning that the result of −2−3 is −5.
It is very easy to calculate the 2’s complement of a binary number. Adding a 
negative number can be done by adding its 2’s complement. That is the advan­
tage that the binary system has offered for the construction and development 
of modern digital computers.
As such, in principle, the key component needed in our modern digital 
computers for computing and information processing is a unit to add two 
binary numbers, since the three other basic arithmetic operations can be done 
based on addition, using respective algorithms or routines such as the ones 
mentioned above. In the real implementation and construction of digital com­
puters, all basic arithmetic operations, including bitwise operations on integer 
binary numbers such as the operations needed to find 2’s complements, are 
hardwired into a unit called the arithmetic logic unit (ALU), which is the core 
of the central processing unit (CPU) that you have heard about often.
A digital computer also needs to compute real or floating-­
point numbers as 
well as process graphics. To get these two jobs done more efficiently, modern 
computers also have a floating-­
point unit (FPU) for floating-­
point numbers, 
and a graphics processing unit (GPU) for graphics.
MECHANIC-­
BASED COMPONENTS
Mechanical components such as levels, gears, and wheels can be used to build 
analog computers. In fact, digital computers can also be built with mechanical 
components. The earliest special-­
purpose mechanic-­
based digital computer 
was the difference engine designed by Charles Babbage. A general-­
purpose 
mechanic-­
based digital computer, called the analytical engine, was also first 
proposed by Charles Babbage. In the design, the machine has memory and 
CPU. It would have been programmable and, therefore, would have become a 
general-­
purpose digital computer, if ever actually built.
	 14	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
VACUUM TUBE–­
BASED COMPONENTS
Invented in 1904 by John Ambrose Fleming of England, a vacuum tube is a 
tube made of glass with gas/air removed, with at least two electrodes inserted 
for allowing or controlling the flow of electrons. Vacuum tubes can be made 
to be switches or amplifiers. As switches, the two states of on and off can be 
used to represent the 0 and 1 of binary arithmetic or Boolean logic. When 
the state of output can be controlled by input or inputs, the switch is made to 

be a gate to perform different logical operations. That’s how vacuum tubes could be 

used to implement modern computers; as amplifiers, they found their uses in 
many electronic devices and equipment such as radio, radar, television, and 
telephone systems. It was the vacuum tube that made electronic computers 

and other electronic devices possible for the first time. Vacuum tubes played 
very important roles in the development and construction of all electronic 
devices and systems in the first half of the 20th century.
However, vacuum tubes disappeared from computers and most other elec­
tronic devices soon after transistors were developed at the Bell Laboratories 
by John Bardeen, Walter Brattain, and William Shockley in 1947 because, com­
pared to transistors, vacuum tubes were too big, too heavy, too unreliable and 
consumed too much power to operate. That limited the construction and uses 
of vacuum tube–­
based computers and devices.
TRANSISTORS
Recall that in the construction of computers, the ALU or CPU requires two-­
state 
switches to represent 0 and 1 and logical gates to perform additions and sub­
tractions of binary number systems. Vacuum tubes could be made to construct 
electronic computers, but the computers became too bulky and too heavy to 
be more useful.
INTEGRATED CIRCUITS AND VERY LARGE-­
SCALE INTEGRATED 
CIRCUITS
Integrated circuits (ICs) are chips with many electronic circuits built in, while 
very large-­
scale integrated (VLSI) circuits are those with millions and even bil­
lions of electronic circuits built into very small semiconductor chips. According 
to Moore’s law (attributed to Gordon Moore, the cofounder and former CEO of 
Intel), the number of transistors in a dense integrated circuit doubles about 
every two years. This has been the case over the last few decades since 1975, 
though advancement in VLSI technology has slowed since 2010.
Today, computers are all using VLSI chips. That is why computers have 
become smaller and smaller, while computing power has increased expo­
nentially in accordance with Moore’s law.
	
Introduction	
15
 https://doi.org/10.15215/remix/9781998944088.01
1.3 Programming and Programming Languages
One of the key principles of modern computers is using stored programs, which 
are sequences of instructions telling computers what to do. The task of writing 
programs for computers is called programming.
During the first generation of computers, machine languages and assembly 
languages were used to write programs. Machine languages use sequences of 
0 and 1 to code instructions for computers. Programs in a machine language 
can be directly understood by the CPU of the target computer. The following 
is an example of machine language for the Intel 8088 CPU:
00000011 00000100
10001000 11000011
As you can see, although machine language is friendly to computers, it is 
not friendly to people, because the instruction itself does not tell us what it 
does in a human-­
readable language. To solve this problem, assembly language 
was invented. The two instructions above are written in assembly language as 
follows:
ADD AX, [SI]
MOV BL, AL
The instruction in assembly language is much more friendly to people 
because one can more easily tell what each instruction does. However, assembly 
language is not as friendly to computers. For computers to understand programs 
in assembly language, an assembler is needed to translate the programs into 
code in machine language.
With assembly language, programming is still a difficult task because 
instructions in an assembly language are mostly direct mapping of their 
machine-­
language equivalent and only describe fine and tiny steps of CPU 
operations. It is difficult to program in assembly language to solve real-­
world 
problems.
The idea of using a high-­
level, more human-­
friendly programming lan­
guage was attributed to Konrad Zuse for his work between 1942 and 1945. 
He developed a high-­
level programming language called Plankalkül for a 
non–­
Von Neumann computer called Z4 that he made during the same period 
of time. The language was not implemented and used on Z4 or any other real 
computer during that time, but Konrad Zuse did write a computer chess pro­
gram in the language.
	 16	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The first high-­
level programming language for our modern computers 
(Von Neumann machines) is ALGOL 58, but it was soon surpassed by ALGOL 
60, a structured programming language.
During the second generation of modern computers, more than 100 high-­
level programming languages were developed. The most popular programming 
languages include COBOL, for programming business systems; Fortran (an 
imperative procedural programming language), for scientific calculation; ADA, 
used by the military and National Defense in the US; Lisp (a functional pro­
gramming language), used for symbolic or information processing; and Prolog 
(a logic programming language), for logic programming, especially during the 
first revival of artificial intelligence in the 1980s. There have been thousands of 
programming languages since the invention of the modern computer, according 
to the list at https://​
en​
.wikipedia​
.org/​
wiki/​
List​
_of​
_programming​
_languages.
However, most of these programming languages have never been used 
in real application development. The most popular programming languages 
used today include Python, Kotlin (for Android applications), Java, R (for data 
analysis and machine learning), JavaScript, C++, C#, PHP, Swift (for iOS appli­
cations), Go, and C, which has been a popular language for more than half of 
the century and is considered a foundational language of many other popular 
programming languages.
High-­
level programming languages are friendly to people but not friendly 
to computers. For computers to understand and execute programs written in 
a high-­
level programming language, they must be translated into machine lan­
guage. Based on how programs in high-­
level languages are translated into target 
machine language, high-­
level programming languages are either compiled or 
interpreted. A program written in a compiled programming language such as 
C or C++ needs to be compiled into its target machine’s codes and linked with 
copies of code in static libraries, or linked with references to code in dynamic 
or shared libraries, so that the resulting object can then be executed by the 
target computer.
Programs written in an interpreted programming language can be executed 
directly by the interpreter of the programming language, in view of program­
mers and users. Behind the scenes, however, to speed up the execution of 
programs written in an interpreted programming language, the programs are 
often translated first into some intermediate codes, often called bytecodes. 
The bytecodes are then executed within a so-­
called virtual machine built 

into the interpreter of the programming language.
More readings about the history of computer programming languages can 
be found on the internet by searching for “history of computer programming.” 
The following are some of the articles:
	
Introduction	
17
 https://doi.org/10.15215/remix/9781998944088.01
https://​
en​
.wikipedia​
.org/​
wiki/​
History​
_of​
_programming​
_languages
http://​
www​
.softschools​
.com/​
inventions/​
history/​
computer​
_programming​
_history/​
369/
https://​
www​
.datarecoverylabs​
.com/​
company/​
resources/​
history​
-computer​
-programming​
-languages
https://​
www​
.computerhistory​
.org/​
timeline/​
software​
-languages/
https://​
www​
.thecoderschool​
.com/​
blog/​
the​
-history​
-of​
-coding​
-and​
-computer​
-programming/
A good overview of programming languages can be found at https://​
en​
.wikipedia​
.org/​
wiki/​
Programming​
_language.
It is worth noting that although well-­
formed computer programming lan­
guages only came into existence in the late 1940s, Ada Lovelace, an English 
mathematician who lived between 1815 and 1852, is considered the first com­
puter programmer. When she was commissioned to translate an article based 
on Charles Babbage’s speech about his analytical engine, she wrote extensive 
notes alongside the translation to explain the principles and mechanism of the 
analytical engine. Those notes were later considered to be the first computer 
programs in history. For example, one set of those notes would calculate a 
sequence of Bernoulli numbers if executed on the analytical engine.
1.4 Python Programming Language
Python is an interpreted, high-­
level, general-­
purpose programming language. 
It is one of the most popular programming languages in the world, second only 
to Java. The 2023 rankings for programming language popularity can be found 
at https://​
www​
.hackerrank​
.com/​
blog/​
most​
-popular​
-languages​
-2023/.
The Development and Implementation of Python
Python was originally conceived and developed in the Netherlands by Guido 
van Rossum in the late 1980s. Its first release was Python 0.9.0 in 1991. Python 2.0 

was released in 2000, nine years after the release of Python 0.9.0.
Most of the development of Python was accomplished between 2005 and 
2013, when Guido van Rossum was working at Google, where he spent half of 
his time on the development of the programming language. The latest Python 2 
release is Python 2.7.16, whereas the latest release of Python 3 is Python 3.9.0, 
at the time of writing.
Python is an interpreted programming language rather than a compiled 
programming language. Programs written in Python don’t need to be com­
piled into target machine code. Instead, they only need to be translated into 
	 18	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
bytecodes, then executed by a Python Virtual Machine (PVM), which is built 
into the Python interpreter.
Python language has different implementations with different names. 

CPython, written in C and known simply as Python, is what we will be using, 
and it is the implementation you will get from Python standard distribution at 
python​
.org by default. In addition to CPython, the following are some alterna­
tive implementations of Python:
	
1.	 JPython or Jython, and implementation for running on Java Virtual 
Machine (JVM)
	
2.	 IronPython, an implementation for running on .NET
	
3.	 PyPy, an implementation for working with a just-­
in-­
time (JIT) 
compiler
	
4.	 Stackless Python, an implementation of a branch of CPython 
supporting microthreads
	
5.	 MicroPython, an implementation for running on microcontrollers
These implementations may be of interest only for some special applications.
Advantages of Python
Python was designed with the principle of “programming for everyone.” Programs 
written in Python are clean and easy to read. Yet Python is a general-­
purpose 
programming language and very powerful to code in. Programming in Python 
has the least overhead, especially when compared to Java. Let’s take the famous 
“Hello World!” application as an example. In Java, to create this application, you 
need to write a class with a main method like the following:
class first {
    public static void main(String args[]){
    System.out.println("Hello World!");
    }
}
Then save it to a file and compile the file into Java bytecode by running the 
following command, provided you have a JDK correctly installed:
javac myhelloworld.java
This command will generate a file named first.class. You can then run 
command java first to have “Hello World!” spoken out.
	
Introduction	
19
 https://doi.org/10.15215/remix/9781998944088.01
In Python, however, you only need to write the following code and save to 
a file, say, myhelloworld​
.py:
print("Hello World!")
Then run the following command:
python myhelloworld​
.py
More importantly, Python supports different programming paradigms, 
including structured programming, imperative programming, object-­
oriented 
programming, functional programming, and procedural programming. 

Logic programming is probably the only exception; it is not supported by Python.
Python is very powerful for two reasons. The first reason, as you will see 
later, is that Python has many powerful language constructs and statements to 
represent data and operations on various data. The second reason is that there 
are thousands of third-­
party packages/libraries/modules available for all kinds 
of programming needs in addition to the large standard libraries included 
with every release of Python. For example, Python is widely used for data 
analytics and machine learning with the support of the NumPy, SciPy, Pandas, 

Matplotlib, and TensorFlow libraries.
Resources for Python and Python Education
The ultimate resource for Python and API libraries is the official website of the 
Python software foundation at https://​
www​
.python​
.org/. From that website, you 
will be able to access all the releases of Python and other packages and libraries 
that you may be interested in, in addition to the standard libraries that come 
with the official release of Python.
At the time of writing, the latest release of Python is 3.11.1, but you can 
always check and locate the latest release for your platform at https://​
www​
.python​
.org/​
downloads/. However, for your convenience and for your future 
study and use of Python, we will use a package management system called 
Anaconda to install and manage Python and all tools and libraries that you will 
need for this textbook, as detailed later.
There are plenty of resources on the internet for eager learners to learn 
almost anything, including programming in Python. To learn effectively on the 
internet, however, a learner must be able to choose the right materials from 
thousands—­
even millions—­
of choices, and that has proved to be a very difficult 
task. That’s probably one of the reasons why universities and professors are 
	 20	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
still needed: to set the right learning paths and to select the right resources 
for learners.
On the internet, the most authoritative learning source about the Python 
language is the documentation (https://​
docs​
.python​
.org/​
3/), including language 
references (https://​
docs​
.python​
.org/​
3/​
reference/​
index​
.html) and library refer­
ences (https://​
docs​
.python​
.org/​
3/​
library/​
index​
.html), although they may not be 
articulated for beginners.
For learners who prefer to learn by reading, the following are some of the 
best resources on the web:
•	 https://​
docs​
.python​
.org/​
3/: This resource is from the official Python 
website, so the terms and jargons used should be deemed official at 
least within the Python community. It is a comprehensive section as 
well.
•	 https://​
www​
.w3schools​
.com/​
python/: This is a very popular site that 
offers resources covering many different languages.
•	 https://​
www​
.learnpython​
.org/: This is another good site for learning 
Python. it has many resources on specific topics.
For learners who love to watch videos and lectures, the following are 
recommended:
•	 Python Crash Course for Beginners, at https://​
www​
.youtube​
.com/​
watch​
?v​
=​
JJmcL1N2KQs, by Traversy Media. This video uses VS Code IDE to 
illustrate the program examples so that you can follow along once you 
have the required programming environment set up.
•	 Learn Python—­
Full Course for Beginners, at https://​
www​
.youtube​
.com/​
watch​
?v​
=​
rfscVS0vtbw, by freeCodeCamp​
.org and narrated by Mike 
Dane. This video is one of the best. Please note that the video lecture 
recommends the installation and use of PyCharm IDE. However, the 
installation and use of VS Code IDE is required in this book.
1.5 Getting Ready to Learn Programming in Python
To learn the content covered in the rest of this book, you first need to have the 
following installed on your computer:
	
1.	 A newer version of Python from https://​
www​
.python​
.org/. The 
latest version, at the time of writing, is Python 3.11.1. The standard 
	
Introduction	
21
 https://doi.org/10.15215/remix/9781998944088.01
distribution includes everything you need to interpret and execute 
Python programs, which are also called Python scripts.
	
2.	 A newer version of Jupyter Notebook, from https://​
jupyter​
.org/. 
Jupyter Notebook is a powerful interactive programming 
environment supporting up to 40 programming languages, including 
Python.
	
3.	 A newer version of Visual Studio Code (VS Code) from https://​
code​
.visualstudio​
.com/. VS Code is a free and open-­
source code 
editor developed by Microsoft, and it will be used as an integrated 
development environment (IDE) and to host Jupyter Notebook for 
interactive programming.
In this section, we will learn how to install Python, Jupyter Notebook, and 
Visual Studio Code IDE on our computer. A standard distribution of Python 
includes a large volume of libraries for general programming needs. Special 
applications such as those in data science and machine learning will require 
special libraries to be installed. We will learn about that in later units when 
we need them.
Installing and Setting Up the Python Programming Environment
There are different ways of setting up your Python programming environ­
ment. The method we present below is believed to be more reliable and less 
subject to future changes.
INSTALLING PYTHON
The first package we need to install is Python. The steps are as follows:
	
1.	 To ensure a clean installation of Python, uninstall all old versions of 
Python that may have previously been installed on your computer 
and check the value of the PATH environment variable to delete all 
those, and only those, related to Python. To ensure that all have been 
deleted properly, open a shell terminal such as CMD or PowerShell on 
Windows and check if a Python installation still exists by trying to run 
it. You should be told that Python is not recognized.
	
2.	 Go to https://​
www​
.python​
.org/​
downloads/ and look for the newest 
release of Python for your platform. For example, if you want to install 
Python on your Windows machine, download the latest release for 
Windows. Normally, the website should be able to detect the type of 
system you are using to access the website and show you the right 
	 22	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Python package for you to download. You should, however, be aware 
of what you will be getting from the website.
	
3.	 Run the installer to install it. If installing Python on a Windows 
platform, all you need to do to start the installation is to double-­
click 
the downloaded file or press the run button if it does not start the 
installation automatically.
After the installation has started, a window will pop up, as shown 
here:
Python 3.11.1 (64-­
bit) Setup
Install Python 3.11.1 (64-­
bit)
Select Install Now to install Python with default settings, or choose 
Customize to enable or disable features.
→ Install Now
C:\Users\james\AppData\Local\Programs\Python\Python311
Includes IDLE, pip and documentation
Creates shortcuts and file associations
→ Customize installation
Choose location and features
☑ Use admin privileges when installing py.exe
☑ Add gython.exe to PATH!
Cancel
You can either let it install Python automatically for you by clicking 
“Install Now” or choose “Customize installation.” When you choose 
“Customize installation,” you have the opportunity to choose where 
Python will be installed on your computer and what optional modules 
and features will be installed.
In either case, you must check the box to add Python to the PATH 
environment variable. Choose yes to add Python to the system 
PATH environment variable so that Python and other related 
commands can be found.
Do a customized installation so that you will see what is to be installed 
and where. When doing customized installation, remember to check 
	
Introduction	
23
 https://doi.org/10.15215/remix/9781998944088.01
the box to install pip, Python package manager, and other components 
within the distribution, as shown here:
Python 3.11.1 (64-­
bit) Setup
Optional Features
☑ Documentation
Installs the Python documentation files.
☑ pip
Installs pip, which can download and install other Python packages.
☑ td/tk and IDLE
Installs tkinter and the IDLE development environment.
☑ Python test suite
Installs the standard library test suite.
☑ py launcher    ☑ for all users (requires admin privileges)
Use Programs and Features to remove the 'py' launcher.
Back    Next    Cancel
Check the following advanced options, as shown here:
Python 3.11.1 (64-­
bit) Setup
Advanced Options
❑ Install Python 3.11 for all users
☑ Associate files with Python (requires the 'py' launcher)
☑ Create shortcuts for installed applications
☑ Add Python to environment variables
❑ Precompile standard library
❑ Download debugging symbols
❑ Download debug binaries (requires VS 2017 or later)
Customize install location
d:\Programs\Python\Python311
You will require write permissions for the selected location.
Back    Install    Cancel
	 24	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
To check whether Python has been installed successfully on your 
computer, open a shell terminal and run the following command:
$ python -­
-­
version
If the installation was successful, the version of Python will be 
displayed and should be the same as the one you have downloaded 
from python​
.org.
SETTING UP A VIRTUAL ENVIRONMENT FOR A PYTHON PROJECT
When programming in Python, you will need a Python interpreter and any 
additional libraries required for the project. Libraries required for one project 
are different from those for other projects. To ensure that each project has the 
right programming environment without interfering with others, Python uses a 
technology called a virtual (programming) environment, which can be created 
and activated for each project. When you work in a virtual environment for a 

specific project, all installations of additional libraries will be used only for 
that specific project.
To create and use a virtual environment, take the following steps:
	
1.	 Check whether you have a tool called pipenv installed with your 
Python installation by running the following command on Windows:
where.exe pipenv
or the following command on Linux or Mac:
which pipenv
If it is installed, the command will tell you where it is located on your 
computer, and you can go to step 3.
	
2.	 If the command cannot be located on your system, you will need to 
install it by running the following command on a shell terminal:
pip install pipenv
If you are running the shell terminal as a regular user, pipenv will be 
installed under your home directory, so that you will have to add the 
location to the environment variable PATH. It is better to start a shell 
	
Introduction	
25
 https://doi.org/10.15215/remix/9781998944088.01
terminal as an administrator, then run the above command as root/
administrator to ensure that pipenv will be installed globally and be 
accessible for all users with the already set value for PATH.
	
3.	 Once you are sure that pipenv is installed, create a directory for your 
new project and change the work directory to that directory, say c:\
dev\testproject as an example, by running the following commands in 
sequence:
c:\dev> mkdir testproject
c:\dev> cd testproject
	
4.	 Within the testproject directory, run the following command:
c:\dev\testproject> pipenv install
This will create a virtual environment for your project rooted at c:\de\
firstproject.
	
5.	 To work on the project with the virtual programming environment, 
you need to activate the virtual environment for the project by 
running the following command within the project directory:
c:\dev\testproject> pipenv shell
Once the virtual environment has been activated, the prompt of the 
shell terminal will become something similar to the following:
(testproject-­
UCP5-­
sdH)c:\dev\testproject>
Please note the text within the parentheses. It contains the name 
of the project directory. It means that you are now working in a 
subshell terminal invoked by pipenv.
	
6.	 From now on, any package installed by running the pip command on 
this subshell terminal will be only part of this virtual environment, 
without interfering with installations elsewhere for other projects.
	
7.	 To get out of the virtual environment, simply type “exit” to close the 
subshell, as shown below:
(testproject-­
UCP5-­
sdH)c:\dev\testproject>exit
	 26	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The prompt will become
c:\dev\testproject>
	
8.	 If you want to remove the virtual environment created for a project, 
run the following command within the subshell on the root of the 
project directory:
(testproject-­
UCP5-­
sdH)c:\dev\testproject> pipenv 
-­
-­
 rm
INSTALLING JUPYTER NOTEBOOK
The second package that needs to be installed is Jupyter Notebook. The steps 
are as follows:
	
1.	 After you have successfully installed Python, install Jupyter 
Notebook with pip, the Python package manager that comes with 
the Python installation, by running the following command at a 
shell terminal:
pip install Jupyter
or use the following command if pip itself is not recognized as a 
command, but only installed as a module of Python:
python -­
m pip install jupyter
To see if it has been successfully installed, run the following command 
from a shell terminal:
jupyter-notebook
The command will start a web service on your computer, then launch 
Jupyter Notebook Service within your default web browser.
Start a new notebook by clicking “New” and “Choose Python 3.” You 
can then start the program interactively within the notebook, as 
shown in Figure 1-­
3.
	
Introduction	
27
 https://doi.org/10.15215/remix/9781998944088.01
INSTALLING VISUAL STUDIO CODE
The last package to be installed is Visual Studio Code, a free and open-­
source 
IDE developed by Microsoft that can be used for Python programming. The 
steps are as follows:
	
1.	 Go to https://​
code​
.visualstudio​
.com/, click “Download,” and download 
the installer for your platform.
If you want to see other download options, such as a version for a 
platform other than the one identified by the VS Code website, you can 
scroll down further to check.
	
2.	 Double-­
click “Downloaded Installer” for your platform to run and 
install Visual Studio Code.
To run Visual Studio Code on Windows, click the Start menu, scroll down to 
find Visual Studio Code, and click.
Additional Tools Supporting Software Development in Python
To make software development more efficient, the Python community has 
made the following frameworks or systems available for Python developers.
BUILDBOT
Buildbot is a framework intended to automate all aspects of software develop­
ment. It supports parallel and distributed job execution across multiple 
Figure 1-­
3: Jupyter Notebook in browser
	 28	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
platforms, with version control and job status reporting and automated job 
scheduling when required resources become available. It is hosted at https://​
buildbot​
.net/. An introductory section can be found at http://​
docs​
.buildbot​
.net/​
current/​
tutorial/​
firstrun​
.html.
TRAC
Compared to Buildbot, Trac is a simpler web-­
based software project manage­
ment system that can track issues and bugs. It requires access to a database 
such as SQLite or MySQL. Trac is hosted at https://​
trac​
.edgewall​
.org/, but 

the latest release can be found at https://​
pypi​
.org/​
project/​
Trac/.
ROUNDUP
Compared to Trac, Roundup is an even simpler tool to track issues in a software 
development project. You can do so via the command line, the web, or email. 
The system can be found at https://​
pypi​
.org/​
project/​
roundup/.
1.6 Getting a Taste of Programming with Python
In this section, you will see how to solve simple problems or do simple tasks 
with Python. At this time, you do not need to understand every piece of code 
because you will learn all those details later.
Program Interactively with Python Interactive Shell
Programming for computers is writing instructions for computers to execute. 
Interactive programming is programming in an environment in which you 
can interact with a computer, the interpreter of the programming language, 
more precisely, instruction by instruction. The opposite of interactive pro­
gramming is batch programming, in which you will need to write a complete 
program and then feed the entire program to a language engine such as an 
interpreter, language runtime, or virtual machine in order to execute it. In 
interactive programming, a piece can be a single statement or a group of 
statements, but not a complete program. One of the advantages of inter­
active programming is immediate feedback on the code pieces from the 

interpreter.
The simplest interactive programming environment for Python is the Python 
interactive shell. It can be quickly started by running command Python at a 
command prompt such as within a Windows PowerShell, as shown here:
PS S:\Dev> python
	
Introduction	
29
 https://doi.org/10.15215/remix/9781998944088.01
The started interactive Python programming environment should look 
like this:
PS S:\Dev> python
Python 3.11.1 (tags/v3.11.1:a7a450f, Dec 6 2022, 
19:50:39) [M.06 v.1934 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more 
information.
>>>
Here, >>> is the prompt of the Python interactive shell, waiting for your 
input, which will then be evaluated by the interpreter. This is how you program 
interactively within this environment.
As the de facto standard, our first program in the interactive Python pro­
gramming environment is to say “Hello World!” as shown here:
PS S:\Dev> python
Python 3.11.1 (tags/v3.11.1:a7a450f, Dec 6 2022, 
19:58:39) [MSC v.1934 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more 
information.
>>> print("Hello World!")
Hello World!
>>>
As can be seen above, this program in Python needs only one statement 
made of one line of code, whereas in C/C++ or Java, it would need a dozen 
lines of code.
Please note that in the previous example, the characters behind the Python 
prompt >>> are Python statements you need to type, and the rest are output 
from Python interpreter or Python Virtual Machine (PVM).
Our next sample program within the Python interactive shell is to assign 
8 to variable x and assign 9 to variable y, then print out the sum of x and y, as 
shown here:
PS S:\Dev> python
Python 3.11.1 (tags/v3.11.1:a7a450f, Dec 6 2022, 
19:58:39) [MSC v.1934 64 bit (AMD64)] on win32
Type .help., "copyright", "credits" or "license" for more 
information.
	 30	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> print("Hello World!")
Hello World!
>>> x = 8 # assign 8 to variable x
>>> y = 9 # assign 9 to variable y
>>> print(f'{x} + {y} = {x+y}')
8 + 9 = 17
>>>
Within this interactive programming environment, you can type any Python 
expression directly behind >>>, and it will then be evaluated. An example is 
shown here:
PS S:\Dev> python
Python 3.11.1 (tags/v3.11.1:a7a450f, Dec 6 2022, 
19:58:39) [MSC v.1934 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more 
information.
>>> 1350-­
789*3/26
1258.9615384615386
>>>
You may have realized that the interactive Python programming environ­
ment can be used as a powerful scientific or financial calculator, with all the 
functions you need, as long as you know where to find the functions and how 
to import and use them to write formulas.
Throughout the textbook, we will occasionally give examples in Python 
interactive shell when it is more convenient and proper in context. However, 
our preferred interactive programming environment is Jupyter Notebook within 
VS Code IDE, as you will see later in this section.
Program with VS Code IDE
Interactive programming environments like Python Shell and Jupyter 
Notebook are good for testing Python statements, code blocks, and some 
real programming tasks such as data analytics, where interactive program­
ming is more suitable. However, writing programs that contain thousands 
of lines of code in a Python interactive shell or Jupyter Notebook is 

inconvenient.
As previously mentioned, we will be using VS Code as our IDE. Our first 
small project is to write a program that takes an integer from the user input 
	
Introduction	
31
 https://doi.org/10.15215/remix/9781998944088.01
and tells whether it is a prime number or not. The first step to do this is to start 

VS Code from the Windows Start menu or desktop. In Windows or iOS, you may 
type “VS Code” in the search bar to launch the application.
To create a Python program file within VS Code, choose “New File” from 
File, and then save the file as xyz​
.py, where xyz is your preferred name 
for the small project. Here, we use “primetest​
.py.” VS Code will ask you to 
choose a folder for the program, and you may create one and then select it 
to open after the file is created. The program in VS Code will look like the 
one in Figure 1-­
4.
At this time, you are not required to fully understand the program, but if you 
are interested, you may type the code line by line into your VS Code and run it 
by clicking the play button at the top-­
right corner of the VS Code window, just 
to get a taste of programming in VS Code with Python.
Please note that if you have multiple Python program files open in VS Code 
and want to run a particular one within the IDE, you will need to click the 
file to make it active; then, within the editing area, click the right button of 

the mouse to pop up a menu and select run for your particular program. This 
is even more important if you have multiple editing tabs open for different 
programs.
Figure 1-­
4: Python program in VS Code
	 32	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Use Jupyter Notebook Within VS Code to Program Interactively
You may recall that Jupyter Notebook can be launched and run in a web browser, 
but for the purposes of this text, Jupyter Notebook will be run and used within 
VS Code to program interactively to allow you to benefit from many of the 
features that VS Code has.
Because Jupyter Notebook is natively supported within Visual Studio Code 
(as long as Jupyter Notebook is installed in your Python environment), all you 
need to do to get Jupyter Notebook running within VS Code is to open or create 
a notebook file, with extension ipynb in VS Code.
There are two ways to create a Jupyter Notebook file. One is to press 
Ctrl+Shift+P to search for the command “create new blank Jupyter Notebook,” 
then click the command. A new blank Jupyter Notebook will be created within 
VS Code.
Alternatively, we can also simply create a new text file, and then save the 
file as xyz.ipynb, where xyz is a name you prefer and ipynb is the file’s exten­
sion. Please note that to ensure the file type is ipynb, you have to select Jupyter 
(.ipynb) or all files (*.*) from the “Save as Type” list.
In either case, you may be asked to install an extension for Jupyter Notebook 
support. Click yes when you are asked to. You may also be asked to install Python 
if you have not done so yet or if the installation path has not been added to the 
environment variable. Click yes too to make sure you have Python properly 
installed on your computer.
Once a new Jupyter Notebook is created, you can then use it to program 
interactively within VS Code and enjoy many of the smart features of VS Code, 
such as those offered by IntelliCode.
Another advantage of using Jupyter Notebook within VS Code is that you 
can export a notebook as an HTML, PDF, or Python Script file. If you use Mark­
down cells to document your coding in code cells, you can produce a very nice 
document as a PDF or in HTML.
Later on, you will be required to create a Jupyter Notebook for each chapter or 
section, if there are many coding examples to work on in a section. You will use 
the Jupyter Notebook to interactively program all sample codes in that chapter 
or section or to test your own code to reinforce your learning. For chapter x, 
the Jupyter Notebook should be named chapter-­
x.ipynb, and for section x.y, the 
notebook should be named section-­
x.y.ipynb.
In the next section, we will provide a brief introduction to Markdown lan­
guage that you can use to document your work either within Markdown cells of 
Jupyter Notebook or within a Markdown file, a file with md as the file extension.
	
Introduction	
33
 https://doi.org/10.15215/remix/9781998944088.01
Write Documentation in Markdown
Markdown is a simple and straightforward markup language with a plaintext-­
formatting syntax. It was created by John Gruber and Aaron Swartz in 2004. 
With Markdown, you can write a document in an easy-­
to-­
write and easy-­
to-­
read 
format, then convert it to HTML. Within VS Code IDE, a Markdown file, with 
md as the extension, can be converted to PDF as well as HTML. Moreover, 
documentation written in Markdown cells of a Jupyter Notebook can be auto­
matically converted into docstrings when the Jupyter Notebook is exported 
into a Python script file, and when the notebook is exported into PDF, scripts 
in code cells will be nicely embedded into documentation written in Mark­
down cells. Together with markup syntax for program code, Markdown cells 

within Jupyter Notebook running in VS Code provide a much more user-­
friendly 
way to include program code in rich and formatted documents.
The Markdown language has been extended since its initial release by John 
Gruber. You will be introduced to both the basic syntax and some extended 
syntax (but only those supported by Jupyter Notebook within VS Code) to serve 
our purposes in this book.
HEADINGS
In Markdown documents, headings are simply led by one or more hash symbols. 
As we have seen in previous sections, a Level 1 heading is led by a single hash 
symbol, a Level 2 heading is led by two hash symbols, and a Level 3 heading 
is led by three hash symbols. You can have up to six levels of headings in a 
document, as shown below:
# This is a Level 1 heading
This is a Level 1 heading
## This is a Level 2 heading
This is a Level 2 heading
### This is a Level 3 heading
This is a Level 3 heading
#### This is a Level 4 heading
This is a Level 4 heading
##### This is a Level 5 heading
This is a Level 5 heading
	 34	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
###### This is a Level 6 heading
This is a Level 6 heading
Please note the space between the formatting symbol or symbols and the text to 
be formatted. A single space should be placed between the formatting symbol 
and the text being formatted in Markdown.
PARAGRAPHS
In Markdown, paragraphs are separated with one or more blank lines.
This is a paragraph.
This is another paragraph.
This is a paragraph.
This is another paragraph.
NEW LINES
In Markdown, to break a line like you would with <br/> in HTML, use more 
than one single space to break the line.
This line will break.  This line starts on a new line.
This line will break.
This line starts on a new line.
ITALIC, BOLD, AND STRIKETHROUGH TEXTS
To format text to be italic in Markdown, simply lead it with a * or underscore 
_ and use another * or _ to indicate the end of the text; to make text bold, use 
** or __; to make text both bold and italic, use ***; to have a line strikethrough 
the text, use ~~. The following are examples:
_ Italic_
Italic
** Bold **
Bold
	
Introduction	
35
 https://doi.org/10.15215/remix/9781998944088.01
*** both italic and bold ***
Italic and bold
~~ strikethrough ~~
Strikethrough
HORIZONTAL RULES
To add a horizontal line within a document, like <hr /> in HTML, use three 
hyphens -­
-­
-­
. Most of the time, this has the same effect in Word.
-­
-­
-­
KEYBOARD KEYS
In computing documentation, we often need to explain what key is used on the 
keyboard. To represent a key on the keyboard, we use HTML kbd tags directly, 
as shown below:
<kbd> Ctrl </kbd> <kbd> A </kbd>
Ctrl+A
<kbd> Ctrl+Shift+F3 </kbd>
Ctrl+Shift+F3
UNORDERED LISTS
With Markdown, writing an unordered list is rather straightforward, as shown 
below:
* first list item
* second list item
 * first item of sublist
 * second item of sublist
* third list item
The rendered result will be the following:
	 36	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
	 •	 first list item
	 •	 second list item
	 -­
	first item of sublist
	 -­
	second item of sublist
	 •	 third list item
We can also use -­
 in place of *.
ORDERED LISTS
To write an ordered list in Markdown is straightforward too, as shown below:
1. first list item
2. second list item
 * first item of sublist
 * second item of sublist
3. third list item
The rendered result will be
	
1.	 first list item
	
2.	 second list item
	
-­
	 first item of sublist
	
-­
	 second item of sublist
	
3.	 third list item
DEFINITION LISTS
The simple Markdown syntax for a definition list does not work in Jupyter 
Notebook within VS Code. However, we can use HTML <dl> tags directly to 
make such a list, as shown below:
<dl>
<dt> Python </dt>
<dd> It is a popular programming language, widely used in 
AI and Data Science. </dd>
<dt> AI </dt>
<dd> Short for Artificial Intelligence.
It is the study of how to design and develop smart 
artifacts.</dd>
</dl>
	
Introduction	
37
 https://doi.org/10.15215/remix/9781998944088.01
The rendered result will be:
Python
It is a popular programming language, widely used in AI and Data 
Science.
AI
Short for Artificial Intelligence. It is the study of how to design and 
develop smart artifacts.
LINKS
To add a link with Markdown, put the anchor name in a square bracket, and 
put the URL in a pair of parentheses, as shown below:
[Markdown Home]​
(https://​
www​
.markdownguide​
.org/)
The rendered result will be the following text, which will take the user to 
https://​
www​
.markdownguide​
.org/ when clicked:
Markdown Home
As in Word and some other editors, legitimate URLs are usually automatically 
linked without any markup tags. In Markdown, if you don’t want a URL to be 
automatically linked, you can enclose it with a pair of backticks, just treating 
it as program code, as shown below:
`https://​
www​
.markdownguide​
.org/`
LINKS TO INTERNAL SECTIONS
A specific ID can be added to each header. Such IDs can be used as internal 
anchors in a link, as shown below:
[Assignment 1] (#assignment_1)
Assignment 1
	 38	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
IMAGES
To add an image to your documentation, use a syntax similar to that used for 
adding links, but with an exclamation mark at the front of the open square 
bracket, as shown below:
![Markdown logo](AU_and_50_logo.png)
The image will be rendered as
BLOCKQUOTES
To include a blockquote in your documentation, use an angle bracket at the 
start of each line, as shown in the following example:
> COVID-­
19 UPDATES
>
> EXAMS
>
> HELP & SUPPORT
>
> FACULTY OF BUSINESS STUDENTS
>
> FACULTY OF SCIENCE STUDENTS
COVID-­
19 UPDATES
EXAMS
HELP & SUPPORT
FACULTY OF BUSINESS STUDENTS
FACULTY OF SCIENCE STUDENTS
	
Introduction	
39
 https://doi.org/10.15215/remix/9781998944088.01
TABLES
To create a table in Markdown, use the pipe character | to divide columns and a 
sequence of dashes/hyphens to separate the header of a table, as shown below:
    | Markdown symbol | Description | HTML equivalent  |
 
    | :-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
| :-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
: | -­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
: |
 
    | # | Level 1 heading | h1 |
 
    | ## | Level 2 heading | h2 |
The table will be rendered as
Markdown symbol
Description
HTML equivalent
#
Level 1 heading
h1
##
Level 2 heading
h2
Please note the colons used in the formatting syntax. A single colon to the 
left of dashes means to align all the text in the column to the left, a single colon 
to the right of dashes means to align all the text in the column to the right, and 
adding a colon to both sides means to align the text at centre. You can also use 
other Markdown syntax on the text in the table, such as italic, bold, and so on.
INLINE PROGRAM / SCRIPT CODE
When writing a report on a software project, you may need to include code 
samples in the report. To include a code sample within a single sentence, 
enclose the code within a pair of backticks `, as shown below:
The ` range(start, end, step) ` function is used to 
produce a sequence of integer numbers.
The rendered result will be:
The range(start, end, step) function is used to produce a sequence of 
integer numbers.
	 40	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
CODE BLOCK
In Markdown, a block of program code can be marked up using a pair of triple 
backticks ```, as shown below:
```Python
for i in range(1, 10):
for j in range(1, i + 1):
print(f'{i} * {j} = {i * k}')
```
The rendered result will be:
for i in range(1, 10):
  for j in range(1, i + 1):
    print(f'{i} * {j} = {i * k}')
Please note that the name of the programming language right behind the 
opening triple backticks is optional, though with the name, the code will be 
automatically highlighted in a way specific for the language.
MATHEMATICAL FORMULAS AND EXPRESSIONS
With Markdown in Jupyter Notebook, you can embed LaTeX representation 
mathematical formulas directly within your text. LaTeX is a typesetting system 
used for scientific publications. It would take you some time to learn the com­
plete system. The following examples show you how to represent mathematical 
formulas in your documentation.
1.  $\hat{Y} = \hat{\beta}_{0} + \sum \limits _{j=1} ^{p} 
X_{j}\hat{\beta}_{j} $
2.  $\frac{n!}{k!(n-­
k)!}$
3.  $\binom{n}{k}$
4.  $\frac{\frac{x}{1}}{x -­
 y}$
5.  $\sqrt{k}$
6.  $\sqrt[n]{k}$
7.  $\sum_{i = 1}^{10} t_i$
8.  $\int_0^\infty \mathrm{e}^{-­
x},\mathrm{d}x$
9.  $f(x) = x^2 + 2, if\ x = 2$
10. $\oint_C x^3\, dx + 4y^2\, dy$
11. $2 = \left(
\frac{\left(3 -­
 x\right) \times 2}{3 -­
 x}
	
Introduction	
41
 https://doi.org/10.15215/remix/9781998944088.01
\right)$
12. $\sum_{m = 1}^\infty\sum_{n = 1}^\infty\frac{m^2\, n}
{3^m\left(m\, 3^n + n\, 3^m\right)}$
13. $\phi_n(\kappa) =
\frac{1}{4\pi^2\kappa^2} \int_0^\infty
\frac{\sin(\kappa R)}{\kappa R}
\frac{\partial}{\partial R}
\left[R^2\frac{\partial D_n(R)}{\partial R}\right]\,dR$
The rendered result of the above Markdown code is shown in Figure 1-­
5. You 
can get the same result if you export the notebook file to PDF or HTML format.
Figure 1-­
5: Rendered result of the Markdown code
	 42	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
TO-­
DO LIST
You may wish to have a to-­
do list in your learning notebook. With Markdown, you 
can get that accomplished as follows:
-­
 [ ] a bigger project
 -­
 [x] first subtask
 -­
 [x] follow-­
up subtask
 -­
 [ ] final subtask
-­
 [ ] a separate task
The rendered result will look like this:
•	 ☐ a bigger project
–­
	 ☑ first subtask
–­
	 ☑ follow-­
up subtask
–­
	 ☐ final subtask
•	 ☐ a separate task
ESCAPE SEQUENCE FOR SPECIAL CHARACTERS
Because, as we have seen, some characters have special meaning in Mark­
down syntax, we need to use the backslash to allow these characters to keep 
their normal meaning. These characters include the backslash \, backtick `, 

asterisk *, underscore _, the pound hash symbol #, plus sign +, hyphen/
dash -­
, period ., and exclamation mark !, as well as curly braces {}, square 
brackets [], and parentheses (). For example, if we want to have * in our 
documentation, we need to use \* instead of a simple *. This is especially 
necessary since confusion may arise from using these symbols without the 
backslash. Otherwise, you can use a special character directly, such as in 
the following example:
# A heading with a plus sign \+
This will be rendered as:
A heading with a plus sign +
Programming Interactively with Jupyter Notebook Within 
VS Code
Earlier in this section, we learned how to program interactively within a 
Python Shell launched within a CMD or PowerShell window, and how to 
	
Introduction	
43
 https://doi.org/10.15215/remix/9781998944088.01
start Jupyter Notebook within VS Code. In this section, we will find out how 
to use Jupyter Notebook within VS Code to program interactively as well as 
how to document your work and learning journey in both code cells and 
Markdown cells of Jupyter Notebook within VS Code.
Compared to the Python interactive shell, Jupyter Notebook is a much 
better and more powerful environment for interactive programming and has 
the following advantages:
	
1.	 Everything you typed and the output from the Python interpreter are 
kept in a notebook file so that you can go back and review your work 
whenever needed. In the Python interactive shell, however, everything 
within the shell will be lost as soon as you exit from it.
	
2.	 Within a programming cell of Jupyter Notebook, you can write and 
edit as many Python statements as you want, and the interpreter 
will wait until you hit Shift+Enter to run all the statements within 
the active cell, whereas the simplest interactive programming 
environments run only one statement at a time.
	
3.	 You can go back to a previous programming cell and edit the code 
in it, and then rerun the code as you wish, which you cannot do in a 
Python Shell.
Again, our first example to program interactively in Jupyter Notebook is to 
say Hello World! But before we begin, we need to create a new Jupyter Note­
book named section-­
1.6.ipynb for this section. If you are using this book for 
a course, we recommend that on your desktop, you create a folder using the 
course name or number, and then create this and all the Jupyter Notebook files 
within this folder or subfolders to better organize all the files for the course. 
For the purposes of this textbook, we will give this folder the name “comp218.” 

In the example shown here, the notebook file section-­
1.6.ipynb is under a 
subfolder named “VS Code.”
With Jupyter Notebook in VS Code, you can use Markdown cells to present 
your ideas and thoughts about the program you are to write, and use code cells 
to write program code and Python documentation on your code. In this first 
example, we first write the following in a Markdown cell:
# First program in Jupyter Notebook within VS Code
As is tradition in teaching computer programming, our 
first program in Jupyter Notebook is to say Hello World!.
	 44	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
## How to start a program
As always, a program should begin with a brief 
description of the program, including what it does, 
who wrote it and when, and how it works and/or should 
be used. This is especially necessary for independent 
program files such as the Python script files you will 
be developing using VS Code IDE. Within a code cell of 
Jupyter Notebook, brief documentation is still needed 
if the code within the cell is complicated either 
grammatically or logically. You do not need to document 
if the code is only a scribble for testing.
In Python, brief documentation at the beginning of a 
program file is enclosed with a pair of triple single/
double quotation marks, such as
"""
brief documentation
"""
or
'''
brief documentation
'''
This is called a docstring. Different from comments made 
on program code using a single hash symbol #, docstrings 
are meant to be formal documentation of the code that can 
be retrieved from an object.
We then write the following in a code cell:
    """
    This simple program is just to say Hello world!
    Everything between the two triple quotation marks is
    treated as documentation about the program.
    """
 
    print('Hello world!')   # a single statement of the 
program -­
 inline comment
	
Introduction	
45
 https://doi.org/10.15215/remix/9781998944088.01
This results in the notebook printing, outside of the code cell, the following:
Hello world!
In Jupyter Notebook, there are two types of cells for input. One is the code 
cell for you to write actual program code in. The other is the Markdown cell for 
you to write more detailed notes or reports about your work within the notebook 
using the Markdown language we have introduced in the previous section.
When a new cell is created in a Jupyter Notebook within VS Code, by click­
ing the plus sign + on the left side of the notebook window, you will get a code 
cell by default. To change a code cell to a Markdown cell, click the M↓ button 
at the top of the cell; to change a Markdown cell back to code cell, click the {} 
button at the top of the cell.
Please note that when using Jupyter Notebook within a web browser, to 
switch a code cell to Markdown cell you will need to click “Code” at the top of 
the cell, and then choose “Markdown” from the pop-­
up menu.
In the Jupyter Notebook example above, two cells are used. The first is a 
Markdown cell, in which we explain in more detail what we are going to do for 
our first Python program and how we will do it, whereas the second cell is a 
code cell, in which actual Python code is written, together with docstring and 
inline comments, for the program.
In the simple program above, a pair of triple quotation marks is used to 
enclose some string literals, called docstrings, as the formal documentation 
for the program or module. In addition to each program file or each module 
file, a docstring is also recommended, and even required, for each func­
tion, class, and method. Docstrings should be placed at the very beginning 
of a program file, module file, or right after the header of the definition of 

a class, function, or method. The docstrings will be retrieved and stored as 
the __doc__ attribute of that respective object and can be displayed when help 
is called on that object. Python also has a utility program called pydoc that 
can be used to generate documentation from Python modules by retrieving 
all the docstrings.
Right after the docstring is a print statement that will print out Hello World! 
when the program is executed by pressing Shift+Enter while the cell is still 
active. A cell is active if there is a vertical blue bar on the left side of the cell. 
To execute statements inside an active cell, we can also click the play button 
(the thick right-­
facing arrow) at the top of the cell.
Our next sample program is to assign integers to two variables and then print 
the sum, difference, product, quotient, integer quotient, remainder, power, and 
root. The Python statements to accomplish these operations are as follows:
	 46	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
#Operators and expressions in Python
In the next cell we will show the use of operators and 
expressions in Python.
#Operators
+ operator for addition
-­
 operator for subtraction
* operator for multiplication
/ operator for division
% operator for modulus
** operator for exponentiation
// operator for floor division
We then write the following in a code cell:
i = 5 # assign 5 to variable i. Everything behind the 
hash mark is comment
j = 3 # assign 3 to variable j
print(f"{i} + {j} = {i + j}") # print i + j
print(f"{i} -­
 {j} = {i -­
 j}") # print i -­
 j
print(f"{i} x {j} = {i * j}") # print i * j
print(f"{i} / {j} = {i / j}") # print i / j (/ is division)
print(f"{i} // {j} = {i // j}") # print i // j (// is 
quotient)
print(f"{i} % {j} = {i % j}") # print i % j (% is modulus)
print(f"{i} ** {j} = {i ** j}") # print the result of i 
power of j
print(f"root {j} of {i} = {i ** (1/j)}") # print the 
result of root j of i
This prints the following:
5 + 3 = 8
5 − 3 = 2
5 x 3 = 15
5 / 3 = 1.6666666666666667
5 // 3 = 1
5 % 3 = 2
5 ** 3 = 125
root 3 of 5 = 1.7099759466766968
	
Introduction	
47
 https://doi.org/10.15215/remix/9781998944088.01
As you can see, in this interactive programming environment, you can write 
and edit many Python statements within a single cell. You may simply write some 
statements to accomplish certain calculation or data analysis tasks that cannot 
be done even on an advanced scientific finance calculator.
This next example in Jupyter Notebook within VS Code calculates the sum 
and the product of 1, 2, 3, … 100:
"""
This is to calculate the sum of 1,2,…,100.
"""
 
s=0
for i in range(100):
    s+=i+1
print(f"Sum of 1,2…,100 is {s})
 
"""
This is to calculate the product of 1,2,…,100
"""
 
p=1
for i in range(100):
    p*=i+1
print(f"The product of 1,2,…,100 is {p}")
This prints the following:
Sum of 1,2,…,100 is 5050
The product of 1,2,…,100 is 9332621544394415268169923885626670
049071596826438162146859296389521759999322991560894146
397615651828625369792082722375825118521091686400000000
0000000000000000
Our next sample program in Jupyter Notebook within VS Code creates a 
simple data visualization to showcase how Python can be used for that purpose.
The data for x-axis are a list of letter grade in a grading system; the data for 
y-axis contain a list of numbers representing how many students received each 
corresponding grade in a class. The purpose of visualization is to see how the 
grades are distributed within the class.
	 48	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
import matplotlib.pyplot as plt
 
x = ['D','C-','C','C+','B-','B','B+','A','A','A+']
y = [6,9,12,19,23,28,15,13,7,5]
plt.bar(x,y)
plt.title('A showcase')
plt.xlabel('Letter Grade')
plt.ylabel('# of Students')
plt.show()
Here we use a module called Matplotlib to visualize the data by plotting 
graphs. The result of the program as shown in Figure 1-­
6.
D
C-
C
C+
B-
B
B+
A
A+
0
5
10
15
20
25
Letter Grade
A Showcase
 # of students
Figure 1-­
6: Graph produced by a Python script in Jupyter Notebook
As you can see, with only 11 lines of code, you can produce a nice graph to 
visualize the data in Python.
Run Python Programs Outside IDE
The VS Code IDE we used in previous sections is good for developing programs 
or applications, but it is impractical to start an IDE each time you need to run 
a Python program.
So how can we run a Python program or scripts stored in a file? In a previous 
section, we wrote a program called primetest​
.py. To run the program without 
invoking VS Code, we need to take the following steps:
	
1.	 Start Windows PowerShell or Windows Command Prompt by typing 
“terminal” in the search field on the Windows taskbar if you are on 
	
Introduction	
49
 https://doi.org/10.15215/remix/9781998944088.01
other platforms such as Linux. A shell terminal will come up; type the 
following:
PS S:\Dev\Learn_Python>
	
2.	 Within the terminal, go to the directory where the Python program 
file is located.
	
3.	 Change the working directory to that folder by typing the following 
PowerShell command:
cd  S:\Dev\Learn_Python\samples\
	
4.	 Run the Python program file by typing the following command at the 
PowerShell prompt:
python .\primetest​
.py
the result is shown below:
PS S:\Dev\Learn_Python> cd .\samples\
PS S:\Dev\Learn_Python\samples> python .\primetest​
.py
give me an integer that is greater then 1, and I 
will tell you if it is a prime: 23
23 is a prime
PS S:\Dev\Learn_Python\samples>
Note that to run a Python program from a terminal, two conditions must be met: 
(1) The location of the Python interpreter (python.exe) must be in the PATH 
system variable, so that Windows is able to find it. (2) The Python program 
file should be in the current working directory of the terminal. If that is not 
the case, you must either change your current working directory to where the 
Python program file is located or specify the path to the program file. Assume 
we change the current working directory from the one shown at the end of 

the list above to the one shown here using the command cd:
PS S:\Dev\Learn_Python>
	 50	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Because now the primetest​
.py program is one-­
level down from the cur­
rent working directory at .\samples, where the leading dot (.) refers to the 
current directory, to run the program, you will have to specify the path to 
the program, as shown here:
PS S:\Dev\Learn_Python> python .\samples\primetest​
.py
give me an integer that is greater than 1, and I will 
tell you if it is a prime: 91
91 is divisible by 7, so that 91 is not a prime
PS S:\Dev\Learn_Python> python .\semples\primetest​
.py
give me an integer that is greater than 1, and I will 
tell you if it is a prime: 23
23 is a prime
PS S:\Dev\Learn_Python>
Make the Python Program File Executable
Sometimes, we may still consider it inconvenient to run a Python program file 
from a terminal by feeding the file to the Python interpreter and rather prefer to 
make the program executable on its own so that it can be run by clicking the file 
within Windows File Explorer. Luckily, a tool called pyinstaller can be installed 
and used to do that. To install it, you need to run PowerShell or another shell 
terminal as an administrator. Within the terminal, run the command shown 
here to install pyinstaller using the pip tool:
PS S:\Dev\Learn_Python> pip install pyinstaller
Requirement already satisfied: pyinstaller in s:\python\
python311\lib\site-­
packages (5.7.0)
Requirement already satisfied: setuptools>=42.0.0 in s:\
python\python311\lib\site-­
packages (from pyinstaller) 
(67.4.0)
Requirement already satisfied: altgraph in s:\python\
python311\lib\site-­
packages (from pyinstaller) (0.17.3)
Requirement already satisfied: pyinstaller-­
hooks-­
contrib>=2021.4 in s:\python\python311\lib\site-­
packages 
(from pyinstaller) (2022.15)
Requirement already satisfied: pefile>=2022.5.30 in s:\
python\python311\lib\site-­
packages (from pyinstaller) 
(2023.2.7)
	
Introduction	
51
 https://doi.org/10.15215/remix/9781998944088.01
Requirement already satisfied: pywin32-­
ctypes>=0.2.0 in 
s:\python\python311\lib\site-­
packages (from pyinstaller) 
(0.2.0)
PS S:\Dev\Learn_Python>
Before you can use the pyinstaller tool to make the conversion, you will 
need to copy the Python library into Windows’ system32 directory, as shown 
below:
PS C:\WINDOWS\system32> cp S:\Python\Python311\python311.
dll .
PS C:\WINDOWS\system32>
Now you can simply run the command pyinstaller <Python program file 
name> to make the conversion, as shown here.
PS S:\Dev\Learn_Python\samples> pyinstaller 
.\primetest​
.py
1435 INFO: PyInstaller: 5.7.0
1435 INFO: Python: 3.11.1
1445 INFO: Platform: Windows-­
10-­
10.0.22621-­
SPO
1445 INFO: wrote S:\Dev\Learn_Python\samples\primetest.
spec
1460 INFO: UPX is not available.
1460 INFO: Extending PYTHONPATH with paths ['S:\\Dev\\\
Learn_Python\\samples']
pygame 2.3.0 (SDL 2.24.2, Python 3.11.1)
Hello from the pygame community. https://​
www​
.pygame​
.org/​
contribute​
.html
5243 INFO: checking Analysis
5254 INFO: Building because inputs changed
5254 INFO: Initializing module dependency graph…
5254 INFO: Caching module graph hooks…
5285 WARNING: Several hooks defined for module 'numpy'.
The created executable is under .\build\primetest, named primetest.exe.
Please note, however, that the executable file requires the Python DLL 
library in order to run, so that you can either (1) make the DLL library 
searchable and accessible by Windows OS or whatever OS you are using, 
if you have many executables generated from Python program files, or 

	 52	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
(2) copy the Python DLL to where the executable file is located. In this case, 
since we are using Python3.11, the library is named python311.dll—­
which is 
located within the installation directory of Python3.11, which is s:\python\
python311—­
we can simply copy the DLL file to .\build\primetest for a test, 
as shown below:
-­
a-­
-­
-­
    2022-­
12-­
06  8:12 PM        1463681    NEWS.txt
-­
a-­
-­
-­
    2022-­
12-­
06  8:10 PM         101752    python.exe
-­
a-­
-­
-­
    2022-­
12-­
06  8:10 PM          65912    python3.dll
-­
a-­
-­
-­
    2022-­
12-­
06  8:10 PM        5761912    python311.dll
-­
a-­
-­
-­
    2022-­
12-­
06  8:10 PM         100216    pythonw.exe
-­
a-­
-­
-­
    2022-­
12-­
06  8:10 PM
         49488    vcruntime140_1.dll
-­
a-­
-­
-­
    2022-­
12-­
06  8:10 PM
         109392    vcruntime140_1.dll
 
PS S:\Dev\Learn_Python\samples> cp S:\Python\Python311\
python3.dll .\build\primetest\
PS S:\Dev\Learn_Python\samples>
Once you have done all the steps above, you can run the program like all 
other apps on your computer, as shown here:
PS S:\Dev\Learn_Python\samples> .\build\primetest\
primetest.exe
give me an integer that is greater than 1, and I will 
tell you if it is a prime: 31
31 is a prime
PS S:\Dev\Learn_Python\samples>
Errors in Programs
Errors in programs are hardly avoidable, and you should be prepared to see 
a lot of errors in your programs, especially at the beginning. The nice thing 
about programming within an IDE such as Visual Studio Code is that the IDE can 
point out many syntax errors and coach you to code along the way by showing 
you a list of allowable words or statements that you may want to use in that 
context, although you will have to decide which one to use for your program 
by highlighting the words that are problematic.
	
Introduction	
53
 https://doi.org/10.15215/remix/9781998944088.01
Syntax errors often include the following:
	
1.	 Missing, misspelled, or misplaced keywords such as for, while, if, 
elif, else, with, class, def, and so on. Remember that Python language 
is case-­
sensitive so for and For are totally different words to Python 
Virtual Machine (PVM).
	
2.	 Missing or misspelled operators such as >=, <=, +=, -­
=, *=, /=, and 
so on.
	
3.	 Missing symbols, such as a colon, comma, square or curly bracket, or 
parenthesis.
	
4.	 Mismatched parentheses, double quotation marks, single quotation 
marks, curly brackets, and square brackets.
	
5.	 Incorrect indentation because Python uses indentation to form code 
blocks.
	
6.	 Empty code blocks. If you do not know what to write in a code block, 
you can simply use a pass statement as a placeholder, as shown in the 
following examples.
"""
This function will find the best student in a class based 
on their over performance, but at this time we don't know 
how.
"""
 
def findBest():
 pass   # the pass statement is used to hold the place 
for a code block
The second type of errors you may encounter are runtime errors. While syntax 
errors may be easily avoided when programming within VS Code IDE, run­
time errors can only be found during runtime. Examples of runtime errors 

include dividing a number with 0 and using a variable that has not been 
defined or that has no value before it is used. The discussion of error and 
exception handling, covered in Chapter 4, is mostly about runtime errors.
The following are some common runtime errors in Python programs:
	
1.	 ZeroDivisionError, when dividing something by 0.
	
2.	 TypeError, when an operation is performed on incompatible data 
types.
	 54	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
	
3.	 ValueError, when an incorrect value is used in a function call or 
expression.
	
4.	 NameError, when an identifier is used that has not been defined. In 
Python, define means that it has been assigned a value, even if the 
value is None.
	
5.	 IndexError, when the index used to access a sequence is out of 
boundary.
	
6.	 KeyError, when an incorrect key is used to access a dictionary value.
	
7.	 AttributeError, when an object attribute is sued that does not exist.
	
8.	 FileNotFoundError, when a file that one is trying to open to read 
does not exist. It is OK to open a file to write that does not exist. The 
operation will create a new file in that case.
In addition to syntax and runtime errors, you can also have logical errors in 
your programs. These errors can be found only by you or users of the program. 
An example of logical errors is when you are supposed to add two numbers, 
but you subtract one from the other instead.
Throughout the text, you will learn and gradually gain the ability to make 
your programs logically correct and to identify logical errors in your programs.
1.7 Essentials of Problem Solving and Software 
Development
Before you learn how to program in Python, you need to gain a basic under­
standing of the steps taken by computers to solve a problem and the steps taken 
by programmers to develop a software system for real-­
world application. The 
former, steps taken by computers to solve a problem, is called an algorithm. 
The latter, steps taken by programmers to develop an information system for 
real-­
world application, is in the area of system analysis and design.
Design Algorithms to Solve Problems
An algorithm is a sequence of instructions showing steps to solve a problem or 
get something done. The recipe for cooking a dish is an example of an algorithm 
from our everyday lives. Unlike algorithms for people to follow, algorithms for 
computers must show definitive steps of explicit operation.
Consider a very simple task for a computer to complete: give a computer 
two numbers and ask the computer to find the sum and print out the result. 
The algorithm can be described as follows:
	
Introduction	
55
 https://doi.org/10.15215/remix/9781998944088.01
[algorithm 1] Get two numbers from user, calculate, and print out 
the sum.
Step 1. Get the first number to n1.
Step 2. Get the second number to n2.
Step 3. Calculate the sum of n1 and n2, and store the result to s.
Step 4. Print out s.
[end of algorithm 1]
Describing the steps of operations as shown above is just one way to present 
algorithms. In computing and software development, algorithms can also be, 
and more often are, presented using pseudocode or a flowchart.
Pseudocode is a language that is easier for humans to understand but that 
is written like a computer program. There is no widely standard vocabulary 
and grammar for pseudocode. However, within an organization or even a 
class, the same pseudocode language should be used for collaboration and 
communication.
The above algorithm can be described in pseudocode as follows:
Start
Input from user → n1 # get an input from user and 
assign it to n1
Input from user → n2 # get another input from user 
and assign it to n2
n1 + n2 → s # n1 + n2 and assign the sum to s
print(s)
End
This simple algorithm can also be described using a flowchart, as in Figure 1-­
7.
In problem solving and computing, conditional operations and repetitive 
operations are often needed. An example is to calculate the sum of number 1, 

2,…10000. One might think that the sum could be calculated by writing 

1 + 2 + 3 + … + 10000, but that is wrong because that mathematical expression 
cannot be precisely understood by computers. The correct algorithm should be:
[algorithm 2] Calculate the sum of all positive integers that are no 
greater than 10000.
Step 1. 1 → i, 0 → s
Step 2. s + i → s, i +1 → i
Step 3. If i <= 10000 go to step 2 # loop back and make repetition 
under condition
	 56	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Step 4. Print s
[end of algorithm 2]
In pseudocode, the algorithm can be described as follows:
Start
Initialization: i = 1, s = 0
Repeat
   s = s + i
   i = i + 1
Until i > 10000
End
The algorithm can be depicted using a flowchart, as in Figure 1-­
8.
When programming to solve a problem, first develop an algorithm describ­
ing the steps of how the problem can be solved using computers, even if it is 
not explicitly and formally formulated as above.
Phases of Software System Development
Algorithm design and representation are essential when programming for 
computers to solve a problem or complete a task, but it is only part of software 
Start
Input n1
Input n2
S = n1 + n2
Print s
Stop
Figure 1-­
7: Flowchart of a simple algorithm
	
Introduction	
57
 https://doi.org/10.15215/remix/9781998944088.01
system development. Developing a software system to satisfy the requirements 
of a client requires several phases.
PHASE 1. UNDERSTAND THE PROJECT
When developing a software system at the request of a client or customer, the 
first thing to do is to understand what the client really needs so that you can get 
a clear definition of the problems to be solved and the tasks to be completed 
by the software system.
PHASE 2. ANALYZE THE REQUIREMENTS TO IDENTIFY 
COMPUTER-­
SOLVABLE PROBLEMS AND TASKS
This phase is very important in turning people problems into computer problems, 
problems that can be solved by computers. Your clients and customers often have 
limited knowledge of what computers can do, and their requirements may be 
clear for humans, but not directly doable for computers. Requirement analysis 
will turn client’s requirements into problems and tasks suitable for computers to 
solve or complete. This often involves a strategy called divide and conquer, which 
means dividing big problems or tasks into smaller ones to solve. This strategy is 
widely used not only in computing but also in other disciplines and practices. Your 
understanding of the application domain and your knowledge of all aspects of 
computing are very important during this phase of software system development.
Start
i = 1
s = 0
s = s + i
i = i + 1
i <= 10000
Print s
Stop
yes
Figure 1-­
8: Flowchart of an algorithm
	 58	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
PHASE 3. DESIGN THE SYSTEM
System design involves the identification of modules and their connections. 
Module identification can be based on an understanding of the project and 
analysis of the requirements. The problems and tasks identified in phase 2 
should be clustered into different modules of the system, though the same 
problem or task may exist in different modules. The next important thing 
at the system design phase is to design algorithms for each of the identified 
problems and tasks. Your knowledge and skill in system design, problem 
solving, and mathematical and logical thinking play important roles at this 
phase.
PHASE 4. IMPLEMENT THE SYSTEM
System implementation is programming, which turns the algorithms into 
computer programs. Your knowledge of the language chosen to implement 
the system is vital. Implementation involves programming to solve the prob­
lems and complete the tasks identified at phase 2, based on the structure 

of the system and algorithms designed at phase 3, as well as integration of all 
the subsystems and modules to make them work together.
PHASE 5. TEST THE SYSTEM
The system implemented at phase 4 may not correctly reflect what the client 
wants and may have errors and bugs. A thorough test is needed to find the 
bugs and close up the gaps between what has been implemented and what 

the client really wants.
PHASE 6. MAINTAIN THE SYSTEM
After the system has been fully tested and accepted by the client, the system 
will be delivered to the client. But that is not the end of the project. Maintaining 
the system is often an even bigger task after the release and delivery of the 
software because there is no guarantee that all bugs were found during the test, 

no guarantee that the implementation genuinely reflects the needs of the 
client, and no guarantee that the client will not come up with a “better” idea 
or requirements after the fact.
1.8 Manage Your Working Files for Software 
Development Projects
When working on a software development project, you need to deal with many 
files and make many changes to the files. Later, you might realize that some 
changes to a file are incorrect or do not improve the file, so you might want to 
	
Introduction	
59
 https://doi.org/10.15215/remix/9781998944088.01
go back and use a previous version of the file. It may not be a big issue if you 
are only dealing with one or just several files, but it will be very difficult when 
many files are involved in a project. That is why a version-­
control system is 
needed. Use a version-­
control system called Git to manage all your working 
files on the exercises and projects included in this text.
Originally developed by Linus Torvalds, Git is an open-­
source-­
distributed 
version-­
control system for tracking changes in any set of files, including Jupyter 
Notebook files with the extension ipynb.
In this section, you will learn
	
1.	 how to install and set up Git on your computer and use it to version-­
control your project files locally.
	
2.	 how to set up an account at GitHub and version-­
control your project 
files using Git and remote repositories on GitHub.
	
3.	 how to use Git and GitHub within VS Code to version-­
control your 
project files.
Set Up Git on Your Computer and Version-­
Control Locally
Git can be freely downloaded from https://​
git​
-scm​
.com/​
downloads and installed 
on your computer. After installing Git, you can create a local Git repository on 
your computer by running the git init command within a shell window such 
as CMD or PowerShell on Windows. A preferred one is Git-­
Bash shell, which 
comes with Git. It can be started within Windows File Explorer.
For example, if you want to start a project called Learn_Python, you can 
create a folder called Learn_Python on your desktop within Windows File 
Explorer, then right-­
click the folder icon, and choose from the pop-­
up menu. 
A Git-­
Bash window will open with Learn_Python as the current working dir­
ectory, as shown here:
james@trustshop MINGW64 /s/Dev/Learn_Python
$
Within this Git-­
Bash shell window, you can run the following command to 
initialize:
$ git init
You have to run this Git command once to create a local repository for a 
project. It will create an empty Git repository on your local computer, which is 
a directory named .git with specific subdirectories and files that Git will use to 
	 60	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
version-­
control your project files. It will also create a master/main branch for 
the project. Other branches can be created if the project is divided into smaller 
ones to be worked on in parallel and then later merged.
Before running the command, you can set up an environment variable 
called $GIT_DIR to determine where the local repository will be placed on 
your computer. If $GIT_DIR is not set, the local Git repository—­
that is, the 
.git subdirectory—­
will be created right under the current working directory; 
if $GIT_DIR is set in a different location of your choosing, .git will be created 
right under $GIT_DIR. The common location of .git for a project is right under 
the project directory.
For the system to know who has made changes to the files and how to 
communicate with them, the following two commands need to run to config 
the Git that you installed on your computer:
$ git config -­
global user​
.name "Jon Doe"
$ git config -­
global user.email "Jon​
.Doe​
@gmail​
.com"
These commands will configure the user’s name and email address. Please 
keep in mind that this username is different from the username that you will 
use to sign up for your account with GitHub later in this section.
When changes have been made to a file and you want Git to manage the 
changes to the file, the first step is to stage the file by running the following 
command:
$ git add <file/files>
This is called “staging changes to the file,” which is the first step Git takes 
to version-­
control files.
For example, if you want to stage changes to all Python program files under 
the current project directory, run the following command:
$ git add *.py
To stage changes to all files and even subdirectories under the current 
working directory, run the following command:
$ git add .
The next step Git will take to version-­
control your project files is called 
commit. It is done by running the following command:
	
Introduction	
61
 https://doi.org/10.15215/remix/9781998944088.01
$ git commit -­
m "A brief message about this commitment"
Now changes to the files have been committed to the local repository. 
Please note that the stuff inside the quotation marks behind option -­
m are the 
comments or notes about the changes. If you run Git commit without option 
-­
m, a text editor will pop up to let you enter comments.
You can check the status of your Git system by running the following 
command:
$ git status
On branch master
No commits yet
Changes to be committed:
(use "git rm -­
-­
cached <file>…" to unstage)
   new file: start​
.py
This shows that the file start​
.py has been staged but not committed yet. You 
can still use the git rm command to unstage the file (remove it from the staged 
list).
In the above, we basically described a process of making changes to a file, 
staging the files for the changes, and committing the changes to the repository. 
You may, and most likely want to, reverse the process to undo some changes.
To a file that has been staged but not committed, use the following com­
mand to unstage it:
$ git rm -­
cached <file>
or
$ git reset HEAD <file>
To a file that has not been staged, use the following command to discard 
the changes to the file:
$ git checkout -­
-­
 file
To revert a commit that has been made, run the following command:
$ git revert HEAD
	 62	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
To restore a file to one that is n versions back in the master branch of the 
repository, run the following command:
$ git restore -­
source master~n <file>
There are some other Git commands available for various needs of version 
control, and each has many options providing powerful functionalities. A list of 
these commands can be found at https://​
git​
-scm​
.com/​
docs/​
git​
#​
_git​
_commands. 
You can also get the GitHub-­
Git cheat sheet at https://​
training​
.github​
.com/​
downloads/​
github​
-git​
-cheat​
-sheet/.
For Git, files that have been staged or committed for changes are called 
tracked, and those that have not been staged or committed are called untracked. 
In software development, some files, such as those objects and executable 
files derived from code files, do not need to be tracked for changes, so they 
should be ignored by Git. To tell Git what files under a project directory can be 

ignored, especially when running the command to stage all, you can add the 

file names or ignore patterns to a special file called .gitignore right under 

the project directory. You need to manage the list in the .gitignore file by edi­
ting the file using a text editor. Details of ignored file patterns can be found 

from Git documentation at https://​
git​
-scm​
.com/​
docs/​
gitignore. For our pur­
poses, it may be sufficient to just describe the files based on what you already 
know, such as a file name or file names with a wildcard such as *.log.
Note that unlike other version-­
control systems, Git does not work with files 
for different versions, but works only with the changes that led to the current 
version of the file. For each file, Git will only keep one copy of the file for its 
current version in its repository and keep only the changes that led to the cur­
rent version for all older versions.
Set Up an Account on GitHub and Version-­
Control with Remote 
Repositories
With Git, you can also use remote repositories on GitHub, which is a web-­
based 
system that you can use to create, access, and manage your remote repositories 
on a GitHub server. The benefits of working on a remote repository like GitHub 
for a software development project are twofold: the first is that you do not need 
to worry about the possible loss of your computer or the corruption of the file 
system; the second is that a team of programmers can work on a project at the 
same time efficiently and globally.
To use the remote repository on GitHub, first create an account with GitHub​
.com. GitHub offers students use of their repositories free of charge but also 
provides a pack of paid professional tools for software development.
	
Introduction	
63
 https://doi.org/10.15215/remix/9781998944088.01
Once you have signed into GitHub​
.com, you can create a repository for 
each of your projects under your account. Once created, each repository 
will have a unique URL where project files can be synchronized between the 
local repository and the remote repository, which can be cloned/downloaded. 

A repository on GitHub can be either public or private. A private repository can 
be accessed only by the owner, whereas a public repository can be accessed by 
everyone on the internet. Because you will be using the remote repository for 
your assignment projects, you should choose private so that your assignment 
work will not be shared with any others. You can create public repositories for 
projects that are substantially different from projects in the assignments and 
interesting enough for others to collaborate with you on the projects.
Now you know how to create both a local repository and a remote repository, 
and you’ve learned how to use Git commands to move project files to and from 
the local repository.
To continue work on a remote repository for the version-­
control of project 
files, you need to tell the computer where the remote repository is by using 
the following Git command:
$ git remote add <remote repository name> URL
Git supports several network protocols to communicate between your local 
computer and remote repository servers such as GitHub, including SSH and 
HTTPS. Because using SSH requires additional setup on your computer, we rec­
ommend HTTPS. The following is an example of adding the remote repository 
previously created for Jupyter Notebooks to our local notebook repository for 
Jupyter Notebooks:
$ git remote add notebooks https://​
github​
.com/​
jamesatau/​
comp218​
-­
notebooks​
.git
You can also use the following to delete a remote repository:
$ git remote remove <remote repository name>
And you can use
$ git remote rename <remote repository old name> <remote 
repository new name>
to rename a remote repository.
	 64	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
You can also make changes to the URL of an existing repository, as shown 
in the following example:
$ git remote set-­
url origin https://​
github​
.com/​
jamesatau/​
allgitcases​
.git
To view which remote repository is configured for the current project, use 
the following Git command:
$ git remote -­
v
The command below initializes a git repository and adds remote notebooks:
$ git init
Initialized empty Git repository in S:/Dev/Learn_Python/.
git/
 
james@trustshop MINGW64 /s/Dev/Learn_Python (master)
$ git remote add notebooks https://​
github​
.com/​
jamesatau/​
comp218​
-­
notebooks​
.git
 
james@trustshop MINGW64 /s/Dev/Learn_Python (master)
The text below shows a git command to display the remote connections 
configured after running the commands above:
$ git remote -­
v
notebooks   https://​
github​
.com/​
jamesatau/​
comp218​

-­
notebooks​
.git (fetch)
notebooks   https://​
github​
.com/​
jamesatau/​
comp218​

-­
notebooks​
.git (posh)
 
james@trustshop MINGW64 /s/Dev/Learn_Python (master)
$
Between the local repository and the remote repository, project files can 
go in two directions. Moving files from the local to the remote repository is 
referred to as a push; moving files from the remote to the local repository is a 
pull or fetch. Between pull and fetch, pull is the default mode of moving files 
	
Introduction	
65
 https://doi.org/10.15215/remix/9781998944088.01
from remote to local, and fetch provides additional power, such as is needed 
when moving files from several repositories at the same time.
Please note that pull or push operations are not just transferring files. Key 
points of the operation are merging the changes to files in the target repository 
and versioning. Git has special commands for those key operations, but those 
operations often run behind the scenes without anyone noticing.
After you have added a remote repository to your project, you can push 
the already committed changes to the local repository by running the git 
push command in a shell terminal within the project directory, as shown 
here:
$ git push -­
-­
set-­
upstream notebooks master
Enumerating objects: 3, done.
Counting objects: 100% (3/3), done.
Delta compression using up to 6 threads
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 545 bytes | 272.00 KiB/s, 
done.
Total 3 (delta 0), reused 0 (delta 0), pack-­
reused 0
remote:
remote: Create a pull request for 'master' on GitHub by 
visiting:
remote:   https://​
github​
.com/​
jamesatau/​
comp21B​
-­
notebooks/​
pull/​
new/​
master
remote:
To https://​
github​
.com/​
jamesatau/​
comp218​
-­
notebooks​
.git
* [new branch] master -­
> master
branch 'master' set up to track 'notebooks/master'.
 
james@trustshop MINGW64 /s/Dev/Learn_Python (master)
$ git push notebooks
Everything up-­
to-­
date
 
james@trustshop MINGW64 /s/Dev/Learn_Python (master)
$
Sometimes you might be interested in a project in a repository and would 
like to make a local copy of the entire project. The operation of copying an 
entire project in a remote repository onto a local computer is called cloning. 
For example, say there is a repository called learn-­
python3 in GitHub containing 
	 66	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
sample code, and you want to download all the code to play with it. You can do 
that by doing the following:
	
1.	 Open a terminal on a file folder in which the project is to be 
placed—­
say, the desktop.
	
2.	 From GitHub​
.com, copy the HTTPS URL from the “Code” dropdown menu 
of the learn-­
python3 repository and run the following Git command:
$ git clone https://​
github​
.com/​
michaelliao/​
learn​
-­
python3​
.git
You will then have all the code samples on your computer.
To work with Git and GitHub, you can use Git GUI, a GUI-­
based system, by 
invoking Git GUI on the project folder within Windows File Explorer.
Another way, our preferred way to use Git and GitHub for versioning on 
both local and remote repositories, is to operate within VS Code, which has 
native support for Git and GitHub, as long as Git is properly installed on the 
local computer, as shown earlier in this section.
	
1.	 Create a new folder on your local drive for a project.
	
2.	 Open the folder from VS Code. The new folder can also be created 
when you open the file folder in VS Code.
	
3.	 Initialize the local repository for the project by running git initialize 
in VS Code command palette by pressing Ctrl+Shift+P. Type “git” and 
click “git initialize.” You will be asked to do the following:
	
a.	 Choose a local workspace folder to initialize.
	
b.	 Set the email address of the programmer/developer/author.
	
c.	 Set the name of the programmer/developer/author.
Now the local repository is ready for versioning your project files 
locally.
	
4.	 Create or copy project files under the project folder.
	
5.	 Click the source control icon on the left navigation bar, type a brief 
message about the changes to the files or project, and press Ctrl+Enter 
or click the commit icon above.
	
6.	 To push the changes to the project files and the project to the remote 
repository in GitHub, click the Git Sync icon at the bottom-­
left of the 
VS Code window.
	
Introduction	
67
 https://doi.org/10.15215/remix/9781998944088.01
	
a.	 If this is the first time you are pushing the project to your GitHub 
account, the command palette dialogue will pop up and ask you 
to choose whether to publish the project into a public repository 
or private repository under your account. The project folder name 
will be used as the repository name by default, but you can use a 
different name.
	
b.	 You may be asked to sign into your GitHub account if you have not 
accessed GitHub from VS Code before.
	
c.	 You may also be asked to either use the existing username 
and email associated with your GitHub account or provide a 
different email and/or username to identify yourself as the author 
of the project being pushed.
If you have already created a repository for the project on GitHub, you can 
copy the URL of the repository and add the remote repository to the project 
in VS Code by running git add remote in the command palette. You will also 
be asked to provide a name for the remote repository after entering the URL.
Chapter Summary
•	 The first chapter has introduced you to computers and programming 
languages and guided you in setting up the programming environment.
•	 The introduction to modern computers included a brief history as well 
as a description of the fundamental architecture of modern computers. 
Knowing who made significant contributions to the development of 
computers, what contributions they made, and how they made those 
contributions can be very inspiring.
•	 The computers we use today are called Von Neumann machines 
because they are based on Von Neumann architecture, which consists 
of a control unit, an arithmetic logic unit (ALU), registers, and a 
memory unit (collectively called CPU) plus inputs and outputs. That’s 
why Von Neumann is often credited as one of the fathers of modern 
computers.
•	 The key features of modern computers are that they are digital, 
programmable, and automatic, with stored programs, although these 
features were already in the design of the analytical engine by British 
mathematician Charles Baggage in the 1800s. Hence Charles Babbage is 
also credited as a father of modern computers, although his machines 
were not electronic.
	 68	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
•	 Binary or Boolean algebra is one of the important theories behind 
today’s modern computers. It can be proved that computing with a 
ternary number system would be more efficient, but it would be more 
costly to make computing components to build computing machines 
based on a ternary number system than on a binary number system.
•	 Signed numbers, including both integers and real numbers, need to 
and can be represented by a sequence of digits, using the highest bit to 
represent the sign (0 for positive, 1 for negative). A certain number of 
digits are assigned for decimals.
•	 To apply arithmetic operations more easily and efficiently on 
computers, 2’s complements are used to represent signed numbers. 
With 2’s complements, the addition of signed numbers can be easily 
done.
•	 How do you know what modern computers are and are not capable of? 
Alan Turing, independently from Alonzo Church, laid the foundational 
work on computability with his Turing machine. Because of that, Alan 
Turing is credited as a father of modern computing.
•	 There is also the question of how difficult it is to solve a problem 
with computers, which is the study of computational complexity. The 
computational complexity of a problem is often measured in terms 
of the total number of basic computations, such as addition and 
multiplication, which can be converted into the time needed to solve 
the problem on specific computers. The space required to solve a 
problem can be a concern as well, but most of the time, when people 
are talking about computational complexity, they are talking about the 
steps or time required to solve the problem.
•	 Problems to be solved on computers are often divided into three classes 
of problems: P, NP-­
complete, and NP, in which P is short for polynomial 
and NP is short for nondeterministic polynomial.
•	 If, on a deterministic and sequential machine like a computer, for 
a problem of size n, if the time or number of steps needed to find 
the solution is a polynomial function of n, the problem is said to be 
in the P class. If a problem can be solved in polynomial time on a 
nondeterministic machine, the problem is in the NP class. A problem 
is said to be NP-­
complete if proposed answers can be verified in 
polynomial time, and if an algorithm can solve it in polynomial time, 
the algorithm can also be used to solve all other NP problems.
•	 Programs are the computers’ soul. The task of writing programs for 
computers is called programming. Languages in which programs can 
be written for computers are programming languages.
	
Introduction	
69
 https://doi.org/10.15215/remix/9781998944088.01
•	 Programming languages play important roles in building soul into 
computers. Programming languages can be machine languages, 
assembly languages, and high-­
level languages.
•	 Ada Lovelace, who wrote code for Charles Babbage’s analytical engine, 
was credited as the first programmer of modern computers. The Ada 
programming language was named in her honour.
•	 An algorithm describes the steps a computer needs to take to solve a 
problem or complete a task.
•	 Pseudocode and flowcharts are two ways of describing algorithms.
•	 System analysis and design are the steps taken to design and develop an 
information system for real-­
world application.
•	 The official website for the Python programming language is at www​
.python​
.org. Use the Anaconda package to install Python, Jupyter 
Notebook, Visual Studio Code IDE, and other tools for your study of 
programming with Python.
•	 Python interactive shell and Jupyter Notebook are recommended for 
learning Python programming interactively.
•	 Create a Jupyter Notebook for each chapter and/or section, and 
work through all the examples within that part of the course in that 
notebook to keep a record of your learning activities for review and 
evaluation.
•	 Visual Studio Code (VS Code) is the IDE recommended for you to 
complete the projects and programming projects in the assignments.
Exercises
	
1.	 Convert the following numbers in their respective bases into their 
binary equivalence:
(78)10
(1F)16
(27)8
(121)10
(3E)16
(33)8
(29)10
(CD)16
(52)8
	
2.	 Complete the following binary operations:
10111 + 1101
1101010 − 101101
10101 + 1110
10101 − 1111
1101 * 101
111011 / 11
	 70	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
	
3.	 Complete a thorough review of computer history by reading library 
books and online articles. Compile a table showing the significant 
developments of theories and technologies of modern computers in 
Europe and a similar table for America. For each development, the 
table should show the time, a description of the development, the 
key players/contributors, and its impact on the later development of 
modern computers.
	
4.	 Investigate the classification and development of computer 
programming languages and explain the features of the 
following programming languages:
	
a.	 Machine code
	
b.	 Assembly languages
	
c.	 High-­
level programming languages
	
d.	 Procedural programming languages
	
e.	 Structured programming languages
	
f.	 Imperative programming languages
	
g.	 Functional programming languages
	
h.	 Logic programming languages
	
i.	 Object-­
oriented programming languages
	
5.	 Create a new folder called comp218, open it with VS Code, then create 
a new file and rename it comp218start.ipynb, which is recognized by 
VS Code as Jupyter Notebook. Start working in the cells and use it as 
a calculator to see what expressions and statements you can perform 
correctly with Python, based on what you have learned so far. Please 
note that you may wish to choose a Python interpreter in order to run 
the code or make sure the notebook is working properly.
	
6.	 In a cell of a newly created notebook comp218start.ipynb, type the 
following code and then press Shift+Enter to run it to see what you 
will get:
In [ ]:
first_name = 'John'
last_name = 'Doe'
full_name = first_name + ' ' +last_name
print(full_name)
	
7.	 In a new cell of notebook comp218start.ipynb, type the following code 
and then press Shift+Enter to run the code to see what you will get.
In [ ]:
for i in range(11):
 p = (2**i)
  print(f'{bin(p)}')
	
Introduction	
71
 https://doi.org/10.15215/remix/9781998944088.01
	
8.	 Write an algorithm in pseudocode describing the steps to make a pizza.
	
9.	 Write an algorithm in pseudocode describing the steps to cook rice.
	
10.	 Write an algorithm in a flowchart describing the steps you usually take in 
the morning, from getting up until leaving home to go to work or school.
Projects
	
1.	 Research the history of computers online, then write a summary 
about each of the following:
	
a.	 The computing machines designed and developed in history that 
are significant to the development of today’s computers
	
b.	 The people in history who have made significant contributions to 
the development of computers
	
c.	 The concepts, theories, designs, and technologies in history that 
are important to the development of modern computers
	
2.	 Research the history of programming languages online, then write a 
summary for each of the following:
	
a.	 Machine languages that have been important to the development 
of computer systems
	
b.	 The differences between machine languages, assembly languages, 
and high-­
level programming languages
	
c.	 The essence (what defines it and differentiates it from others) 
of structural programming, the pros and cons of structural 
programming, and some well-­
known programming languages that 
support structural programming
	
d.	 The essence of imperative programming, the pros and cons of 
imperative programming, and some well-­
known programming 
languages that support imperative programming
	
e.	 The essence of declarative programming, the pros and cons of 
declarative programming, and some well-­
known programming 
languages that support declarative programming
	
f.	 The essence of functional programming, the pros and cons of 
functional programming, and some well-­
known programming 
languages that support functional programming
	
g.	 The essence of logical programming, the pros and cons of logical 
programming, and some well-­
known programming languages that 
support logical programming
	
h.	 The essence of object-­
oriented programming, the pros and cons of 
object-­
oriented programming, and some well-­
known programming 
languages that support object-­
oriented programming
This page intentionally left blank
 https://doi.org/10.15215/remix/9781998944088.01
Chapter 2
Essential Building Blocks 
of Computer Programs
This chapter introduces the fundamental elements and building blocks of com­
puter programs in the Python language. These fundamental building blocks 
include the words, keywords, and reserved words that can be used in Python 
programs. You will also learn the primary data types and data models, the 
operators, and some built-­
in functions that can be applied to the data and data 
models in Python, as well as some important statements or sentences that can 
be used to instruct computers.
Learning Objectives
After completing this chapter, you should be able to
•	 make and use names correctly to identify various items in your Python 
programs.
•	 use different types of data and data models correctly.
•	 use the proper operators for different types of data and data models.
•	 correctly compose expressions using variables, data, operators, and the 
built-­
in functions of Python.
•	 write an assignment statement to assign values to variables.
•	 write augmented assignment statements.
•	 write input statements correctly to get input from users.
•	 write correct statements using print.
	 74	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
2.1 Primary Constructs of Computer Programs in 
Python
Computer programs tell computers how to complete specific tasks. These 
specific tasks may be as small as what you would do on a calculator or as big 
as mission control for space exploration. Believe it or not, computer programs 
for all these different tasks are composed of the same types of statements on 
the same types of primary data. The difference is in how the data are struc­
tured and how the statements are organized. In computing, the study of the 
first “how” is the subject of data structures, whereas the study of the second 
“how” is the subject of algorithms. In computing, there are dedicated courses 
providing in-­
depth coverage on data structures and algorithms. While studying 
introductory computer programming, keep in mind the importance of data and 
algorithms in solving problems and try to identify the data involved and describe 
the algorithms needed to solve a problem using the methods introduced in 1.7.
Vocabulary of the Programming Language
Vocabulary is the foundation of any language. In computer languages, identifi­
ers are an important part of the vocabulary used to write computer programs. 
As in all programming languages, identifiers in Python are used to identify 
variables, functions and methods, classes, objects, and modules. They are 
called identifiers because, for computers, the only purpose of these names is 
to identify specific locations of computer memory that hold or can be used to 
hold specific data or code blocks.
Figure 2-­
1 illustrates how a variable named “grade” is identified as the mem­
ory location that holds the integer 98. Please note that we use 98 in the diagram 
for illustration purposes, although, in fact, both data and program codes are 
stored as sequences of binary (0s and 1s).
grade
98
Figure 2-­
1: The variable “grade” and its memory location
Although an identifier in computer programs does not need to be mean­
ingful to humans, it must be unique in a given context, which is often called 
namespace. In Python, a namespace is a mapping from names to objects and 
is implemented as a Python dictionary.
	
Essential Building Blocks of Computer Programs	
75
 https://doi.org/10.15215/remix/9781998944088.01
In a program, different identifiers may be used to refer to the same memory 
location and hold the same data or program code, as shown in Figure 2-­
2. This 
is accomplished through the following Python code:
In [ ]:
x = 'John'
y = x
Out [ ]:
John
To check what x and y hold, we use the print statement as follows:
In [ ]:
print('x holds ', x, ', y holds', y)
Out [ ]:
x holds John, y holds John
X
Y
‘John’
Figure 2-­
2: X and Y point to the same memory location
If we change one identifier to refer to something else, the value referred 
to by the other identifier will remain the same, as shown in Figure 2-­
3. This is 
done with the following code:
In [ ]:
x = 'Smith'
print('x holds ', x, ', y holds ', y)
Out [ ]:
x holds Smith, y holds John
X
Y
‘Smith’
‘John’
Figure 2-­
3: Now X and Y point to different memory locations
	 76	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Please note that in the examples above and other examples in the remainder 
of the textbook, the box behind In [ ] represents a code cell in Jupyter Notebook, 
whereas everything behind Out [ ] is the output from the code contained in the 
code cell when you press Shift+Enter or click the play button.
RULES OF NAMING IDENTIFIERS
In addition to uniqueness, identifiers used in Python programs must be named 
according to the following rules:
	
1.	 An identifier can be a combination of letters (a–­
z, or A–­
Z), numbers 
(0–­
9), and underscores (_).­
	
2.	 It must begin with a letter (a–­
z or A–­
Z) or underscore (_).
	
3.	 In Python, identifiers are case-­
sensitive, so x and X are different 
identifiers.
	
4.	 Identifiers can be of any length.
	
5.	 User-­
defined identifiers cannot be the same as words reserved by the 
Python language.
According to these rules, the following are legitimate user-­
defined identifiers 
in Python:
AB, zf, cd, hz, d_2, c5E, falling, to_be
Whereas the following are not:
1d, d/, f-, g.d
In Python, identifiers shown in Table 2-­
1 are reserved and hence called 
reserved words or keywords, with predefined special meaning in the language, 
which means that you must not use them to name your variables, functions/
methods, classes, or modules.
Table 2-­
1: Reserved words in the Python programming language
Reserved 
word
Special meaning
Reserved 
word
Special meaning
and
logical and
if
conditional statement
as
used together with import 
and with to create new 
alia
import
to import modules
	
Essential Building Blocks of Computer Programs	
77
 https://doi.org/10.15215/remix/9781998944088.01
Reserved 
word
Special meaning
Reserved 
word
Special meaning
assert
to make an assertion for 
handling possible errors
in
membership test
break
to get out of some code 
blocks such as during 
iteration
is
identity test
class
to define class
lambda
to create a lambda function
continue
to omit the rest of the code 
block and continue the 
loop
not
logic negation
def
to define functions
or
logical or
del
to delete an object
pass
to pass the code block
elif
used together with if to 
create a conditional 
statement
print
to output
else
used together with if to 
create a conditional 
statement
raise
to raise an exception 
intentionally
except
used together with try to 
handle errors
return
to return values from a 
function in function 
definition
exec
to execute some 
dynamically generated 
code in a string or object
try
used for exception handling
finally
used together with try and 
except to handle errors
while
to make loop/iteration 
statements
for
to create a loop
with
to introduce context for a 
code block
from
used together with import
yield
used in place of return, 
to turn a function into a 
generator
global
to access a global variable 
from inside of a function
In addition to the reserved words in Table 2-­
1, you should also avoid using 
names that have been used by Python for built-­
in types and built-­
in functions, 
Table 2-­
1: Reserved words in the Python programming language 
(continued)
	 78	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
classes, and modules. These names are collectively called built-­
in names. It is 
grammatically fine to use built-­
in names as user-­
defined identifiers, but using 
them may cause confusion.
Furthermore, Python also uses the underscore _ as an identifier for a very 
special variable to hold the result of the last evaluation when Python is running 
in interactive mode, as shown in the following example:
>>> sum ([1,2,3,4,5,6])
21
>>> sum (list(range(1000)))
499500
>>> _
499500
>>> |
This use of _ as a special variable can also be seen in Jupyter Notebook, as 
shown in the following example:
In [ ]:
pow(9, 3)
Out [ ]:
729
In [ ]:
_
Out [ ]:
729
When Python is not running in interactive mode, _ has no predefined meaning, 
however. Even within Jupyter Notebook, the value of _ is often unpredictable 
unless explicitly assigned.
Syntactically, the special variable _ can be used in the same way as others, 
especially when the value is to be thrown away and not used, as shown below:
In [ ]:
p, n = 1, 10   # assign 1 to variable p, and assign 10 
to variable n
for _ in range(n):   # note that _ is not used 
elsewhere
  p *= 2
print(f'2^{n} = {p}')   # format the output with 
f-string
Out [ ]:
2^10 = 1024
	
Essential Building Blocks of Computer Programs	
79
 https://doi.org/10.15215/remix/9781998944088.01
PYTHON NAMING CONVENTIONS
Although identifiers used in Python programs don’t have to be meaningful 
to humans, you should always try to use more meaningful identifiers in your 
programs because it is not only easy for you to tell what the identifiers are used 
for but also easier for other programmers to understand your programs when 
you work in a team or want to share your code with others.
For the same reason, you should also follow common practices and widely 
accepted coding conventions when programming. In terms of composing 
identifiers these conventions include:
	
1.	 Lower case identifiers are usually used for variables and function 
names.
	
2.	 Capitalized identifiers are used for class names.
	
3.	 Upper case identifiers are used for constants, such as PI = 3.1415926, 
E = 2.7182, and so on.
	
4.	 When an identifier has multiple words, the underscore _ is used to 
separate the words. So we use your_name instead of yourname, use to_
be instead of tobe. Some programmers prefer not to use an underscore, 
but to capitalize each word, except for the first word, when an 
identifier is used as a variable or the name of a function or method.
Along with the programming technologies, these practices and conventions 
have developed over the years and may further evolve in the future. A good 
Python programmer should follow the developments and trends of the Python 
programming community.
NAMES WITH LEADING AND/OR TRAILING UNDERSCORES
As mentioned above, identifiers for variables, function/method names, 
and class names may begin and/or end with a single underscore, double 
underscores, or even triple underscores, and those names may have special 
meanings.
When a name has both leading and trailing double underscores, such as 
__init__, it is called a dunder (double-­
underscore) name. Some dunder names 
have been given special meanings in Python Virtual Machine (PVM) or a Python 
interpreter. They are either reserved as special variables holding special data 
or as special function/method names.
The following are some special dunder names used as special values or 
special variables holding special data.
	 80	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
__MAIN__
Used as a special value. When a Python program/script file runs as the main 
program other than a module, the special variable __name__ will be assigned 
special value __main__.
__NAME__
Used as a special variable in a Python program to hold special value indicating 
how the program file is called or used. If the program file is used as the main 
program, __name__ will hold __main__. If it is used as a module, __name__ 
will hold the name of the module.
__PACKAGE__
Used as a special variable to hold the package’s name if a module imported is 
a package. Otherwise, __package__ will hold an empty string.
__SPEC__
Used as a special variable to hold the module specification used when the 
module is imported. If the Python program file is not used as a module, it will 
hold the special value None.
__PATH__
Used as a special variable to hold the path to the module in a package. If the 
module is not within a package, __path__ is not defined.
__FILE__
Used as a special variable to hold the name of a Python program file.
__CACHED__
A special variable often used together with the special variable __file__, refer­
ring to a precompiled bytecode. If the precompiled bytecode is not from a 
program file, __file__ is not defined.
__LOADER__
Used as a special variable to hold the object that loads or imports the module 
so that you would know who is using the module.
__DOC__
Used as a special variable to hold the documentation of a module or Python 
program if it is used as the main program, documentation of a class, or function 
or method of a class.
	
Essential Building Blocks of Computer Programs	
81
 https://doi.org/10.15215/remix/9781998944088.01
Dunder names used for special functions and methods will be discussed in 
Chapter 6 and Chapter 7.
RULES OF SCOPE RESOLUTION FOR IDENTIFIERS
Big programs for complicated applications often use hundreds or even thou­
sands of identifiers to name variables, functions, classes, and other objects. 
When so many names are used, it is unavoidable that some names will be 
used more than once. How can we ensure in a program that each name can 
be mapped to an object without confusion and ambiguity? The answer is to 
follow the LEGB rule, in which L, E, G, and B refer to different scopes from 
small to big: L is for local, referring to the inside of a function or class; E is 
for enclosed, referring to the inside of a function enclosing another function; 
G is for global, referring to the space outside of all classes and function in a 
Python program file; and B is for built-­
in, referring to all the names defined 
within Python’s built-­
in module. The relationships of LEGB scopes are illus­
trated in Figure 2-­
4.
Built-in names
Global names
Enclosed names: Inside an 
enclosure
Local names: Inside a
function or class
Figure 2-­
4: LEGB rules for scope resolution for names
The illustration above should be viewed in reference to a name used within 
a function or class. To resolve the name or to link it to a specific object, apply 
the following LEGB rules:
	
1.	 Look at the names defined locally (L) within the function/method or 
class. If not defined, proceed to the next rule.
	
2.	 Check whether the name has been defined in the enclosure (E) 
function (note that enclosures are not often used, so this is just for 
discussion right now). If not, proceed to the next rule.
	
3.	 Check whether it has been defined globally (G).
	
4.	 Check whether it is a built-­
in (B) name of Python.
The following sample shows how matching local and global names are resolved:
	 82	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
g_name = 'John'   # global name g_name
l_name = 'Smith'   # global name l_name
def display_names():   # define a function
  l_name = input('What is your name:')   # get input
  print(f'Local name is {l_name}')   # l_name is 
defined again
  print(f'Global name is {g_name}')   # g_name is 
global
display_names()
Out [ ]:
What is your name: Kevin
local name is Kevin
Global name is John
You may have noted in the example above that variable l_name is defined 
both locally in definition of the function display_names() and globally. When it 
is used within the function, its local definition is used; variable g_name, on the 
other hand, is only defined globally, and when it is used within the function, 
it is resolved to its global definition.
In addition to the LEGB rules, please keep in mind the following:
	
1.	 A local name defined in a function will not be seen anywhere outside 
the function.
	
2.	 A local name defined in a class can be seen outside the class or its 
objects if the name is not a private member of the class, with an 
explicit reference to the name with dot notation. For example, a 
name X defined in class C can be accessed using C.X, or O.X if O 
is an object of C.
	
3.	 A name Nx globally defined in a Python script file named M1​
.py can 
be seen inside another Python script file by either importing the 
name explicitly from M or by importing M1 as a whole and using dot 
notation M1.Nx to access Nx.
Simple Data Types
Computers solve problems and accomplish various tasks by processing infor­
mation. This information is represented in the form of data. It is important to 

know what data we can use or process and what operations we can apply 

to different types of data. In Python, there are simple data types and compound 
data types. The latter are also called models of data.
Simple data types include numbers, strings, and Boolean values. Numbers 
are used to represent numerical information, strings are used to represent 
	
Essential Building Blocks of Computer Programs	
83
 https://doi.org/10.15215/remix/9781998944088.01
literal information, and Boolean values are used to represent the result of tests, 
either True or False.
In Python, numbers can be signed integers, float numbers, and complex 
numbers. They all can be values of variables, as we shall see in the next section.
Although a string can be used conveniently as simple data, it has all the 
properties and supported operations of a compound data type. As such, it will 
be discussed in full detail later in this section.
SIGNED INTEGERS (INT)
Signed integers in Python are …−2, −1, 0, 1, 2…, as examples. In Python 3, 

signed integers can be of arbitrary size, at least theoretically, as long as com­
puter memory is not exhausted. In implementation, however, the biggest 
integer is defined by sys.maxsize, a variable named maxsize in a module called 
sys, which specifies the maximum number of bytes that can be used to rep­
resent an integer number. The notation of sys.maxsize here means maxsize, 
defined in module sys.
Operations on integer numbers include the following:
addition (x + y)
subtraction (x − y)
multiplication (x * y)
division (x / y)
negation (−x)
exponentiation (x ** y)
modular (x % y)
integer division (x // y)
You should be able to use the above operations, which you should already 
be familiar with, as well as the following bitwise operations you may never 
have heard about:
bitwise or (x | y)
>>> 1 | 4
5
bitwise exclusive or, often called XOR (x ^ y)
>>> 1 ^ 2
3
bitwise and (x & y)
>>> 1 & 5
1
	 84	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
shifted left (x << n)
>>> 2 << 3
16
shifted right (x >> n)
>>> 256 >> 5
8
invert (~x)
>>> ~128
-­
129
The following are a few more samples from the Python interactive shell 
that show how these operators are used:
>>> 12 + 23
35
>>> 35 -­
 12
23
>>> -­
123
-­
123
>>> 123 * 567
69741
>>> 69741/123   # the result is a real or float-­
point 
number
567.0
>>> 69741//123   # get the quotient of two integers
567
>>> 69741%12   # operation % will get the remainder
9
The next few examples are about bitwise operations. The first two operations 
on the first line show the binary form of the two numbers. In Python, you can 
have two or multiple statements on a single line, but you are not encouraged 
to do so.
>>> bin(123); bin(567)   # how to have two or more 
statements on one line
'0b1111011'
'0b1000110111'
>>> bin(123 | 567)   # it will be 0001111011 | 1000110111
'0b1001111111'
	
Essential Building Blocks of Computer Programs	
85
 https://doi.org/10.15215/remix/9781998944088.01
>>> bin(123 ^ 567)   # it will be 0001111011 ^ 1000110111
'0b1001001100'
>>> bin(123 & 567)   # it will be 0001111011 & 1000110111
'0b110011'
>>> bin(123 << 5)   # it will be 1111011 << 5
'0b111101100000'
>>> bin(123 >> 5)   # it will be 1111011 >> 5
'0b11'
>>> bin(~123)
'-­
0b1111100'
There are also many built-­
in functions available for operations on integers. 
All the built-­
in functions of Python will be discussed in detail below.
In addition, the following methods are also available to use for operations 
on integer objects.
N.BIT_LENGTH()
This returns the number of necessary bits representing the integer in binary, 
excluding the sign and leading zeros.
>>> n = -­
29
>>> print(f'Binary string of {n} is {bin(n)}')
binary string of -­
29 is -­
0b11101
>>> print(f'# of significant bits of {bin(n)} is 
{n.bit_length()}')
# of significant bits of -­
0b11101 is 5
N.TO_BYTES(LENGTH, BYTEORDER, *, SIGNED=FALSE)
This returns an array of bytes representing an integer, where length is the 
length of bytes used to represent the number. byteorder can take Big-­
Endian 
or Little-­
Endian byte order, depending on whether higher-­
order bytes (also 
called most significant) bytes come first or lower-­
order bytes come first, and 
an optional signed argument is used to tell whether 2’s complement should be 
used to represent the integer.
>>> n = 256
>>> n.to_bytes(2, byteorder = 'big') # big means higher 
bytes first
b'\x01\x00'
	 86	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Recall that modern computers use 2’s complements to represent negative 
numbers. So if the integer n is negative while signed remains False, an Over­
flowError will be raised, as shown below:
>>> n = -­
23567
>>> n.to_bytes(3, 'big')
 
OverflowError Traceback (most recent call last)
<ipython-­
input-­
4-­
66989275e22d> in <module>
1 n = -­
23567
-­
-­
-­
-­
> 2 n.to_bytes(3, 'big')
OverflowError: can't convert negative int to unsigned
So a correct call of the method would be
>>> n = -­
23567
>>> n.to_bytes(3, 'big', signed = True)
 
b'\xff\xa3\xf1'
INT.FROM_BYTES(BYTES, BYTEORDER, *, SIGNED = FALSE)
This classmethod returns the integer represented by the given array of bytes.
>>> n = 256
>>> bin(n)
'0b100000000'
>>> # convert '0b100000000' in Big Endian to int
>>> int.from_bytes(n.to_bytes(2, byteorder = 'big'), 
'big')
256
>>> # convert '0b100000000' in Little Endian to int
>>> n.from_bytes(n.to_bytes(2, byteorder = 'big'), 
'little')
1
Note that when two bytes are used to represent integer 256, 0b100000000 will 
be expanded to 00000001 00000000. In Big Endian, it represents 256, but in Little 
Endian, 00000001 becomes the less significant byte, while 00000000 becomes the 
most significant byte, and the corresponding number for 256 becomes 00000000 
00000001.
	
Essential Building Blocks of Computer Programs	
87
 https://doi.org/10.15215/remix/9781998944088.01
For more advanced operations on integers, there are some special modules 
such as the standard math module, math; the free open-­
source mathematics 
software system SAGE; (https://​
www​
.sagemath​
.org/); SymPy (https://​
www​
.sympy​
.org/​
en/​
index​
.html); and, for operations in number theory, eulerlib 
(https://​
pypi​
.org/​
project/​
eulerlib/).
FLOAT (FLOAT)
Float numbers are numbers with decimals, in the form of 12.5 in decimal 
notation or 1.25e1 in scientific notation, for example. Operations on float 
numbers include addition (+), subtraction (−), multiplication (*), division (/), 
and exponentiation (**), as shown below:
In [ ]:
x = 12.5 * 32.7 / 23.9 -­
 53.6 + 28.9 ** 2.7
print(f"x = {x}")   # prefix f tells to format the 
string
Out [ ]:
x = 8762.31728619258
In the example above, the equal sign (=) is an assignment operator in Python 
(and almost all other programming languages as well). We will explain all 
operators fully later in this section.
Python can handle very big integers and floating-­
point numbers. When a 
number is too big, it becomes difficult to count and check for accuracy. To solve 
that problem, Python allows using the underscore to separate the numbers, 
in the similar way that accounting and finance use a comma. The following 
is an example:
>>> 123_456_789_987.56+234_456_678_789
357913468776.56
Using an underscore to separate the digits has made it much easier to tell 
how big the number is.
R.AS_INTEGER_RATIO()
This returns a pair of integers whose ratio is exactly equal to the original float 
r and with a positive denominator. It will raise OverflowError on infinities and 
a ValueError on NaNs.
>>> r.as_integer_ratio()
(7093169413108531, 562949953421312)
	 88	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
R.IS_INTEGER()
This returns True if r is finite with integral value, and False otherwise.
>>> r.is_integer()
False
R.HEX()
This returns a representation of a floating-­
point number as a hexadecimal 
string. For finite floating-­
point numbers, this representation will always include 
a leading 0x and a trailing p and exponent.
>>> r.hex()
'0x1.9333333333333p+3'
FLOAT.FROMHEX(S)
This returns the float represented by a hexadecimal string s. The string s may 
have leading and trailing whitespace.
>>> float.fromhex('0x1.9333333333333p+3')
12.6
BOOLEAN (BOOL)
Boolean data have only two values: True and False. They are used to repre­
sent the result of a test or an evaluation of logical expressions, as we will see. 
Technically, Python does not need a special Boolean data type, since it treats 
0 and None as Boolean False, and treats everything else as Boolean True, as 
shown below:
In [ ]:
b = None   # assign None to variable b. None in Python 
represents 'no value'
print(f"b = {b}")   # print out what b holds
if not b:   # if (not b) is True then print
  print("Print this out when b is None!")
Out [ ]:
b = None
Print this out when b is None!
However, having a Boolean data type with two Boolean values of True and 
False does clearly remind Python programmers, especially beginners, that 
there are special types of data and expressions called Boolean data and Bool­
ean expressions.
	
Essential Building Blocks of Computer Programs	
89
 https://doi.org/10.15215/remix/9781998944088.01
COMPLEX (COMPLEX)
If you have never heard about complex numbers, quickly search the internet 
for complex numbers and read some articles or watch some videos.
Briefly, a complex number is a representation of a point on a plane with 
X and Y axes that take the form of x + yj, in which x and y are float numbers 
that represent and define the location of a point on the plane. Examples of 
complex numbers are 1 + 1j, 3 − 6j, 2.5 − 8.9j, and so on.
The same operations on float numbers can also be applied to complex 
numbers, as shown below:
In [ ]:
x = 3.5 + 6.7j   # assign a complex number to x
y = 12.3 -­
 23.9j   # assign another complex number to y
z = x + y   # assign the sum of x and y to z
print(x, '+', y, '=', z)   # print out the value of the 
variable
print(x, '-­
', y, '=', x -­
 y)   # the difference between 
x and y
print(x, '*', y, '=', x * y)   # the product of x and y
print(x, '/', y, '=', x / y)   # the result of x 
divided by y
Out [ ]:
(3.5 + 6.7j) + (12.3 -­
 23.9j) = (15.8 -­
 17.2j) (3.5 + 6.7j) -­
 (12.3 -­
 23.9j) 
= (-­
8.8 + 30.599999999999998j) (3.5 + 6.7j) * (12.3 -­
 23.9j) = 
(203.18 -­
 1.2399999999999807j) (3.5 + 6.7j) / (12.3 -­
 23.9j) = 
(-­
0.16204844290657439 + 0.229840830449827j)
Compound Data Types
In previous sections, we saw data in pieces. Sometimes it is more convenient, 
more effective, and even necessary to use some data together to represent 
certain kinds of information. Examples are when we refer to the days of the 
week, months of the year, and so on. Courses in universities are often iden­
tified using compound data, a tuple made of a course number and course 
title or name.
In Python, compound data types provide means of structuring data. They 
are also referred to as data structures.
Compound data types in Python can be categorized into sequence and nonse­
quence data types. Items in sequence compound data are ordered and indexed. 
Sequence compound data types include string, list, and tuple. Items in a nonse­
quence compound data are not ordered. Nonsequence compound data include 
set and dictionary.
	 90	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
STRING (STR)
Sequences are a group of data in order, and a string is a good example of a sequence.
Like numbers, strings are very important in all programming languages. It 
is hard to imagine what a number means without its context. For that reason, 
in most programming languages, strings are also considered a primary data 
type in terms of their importance and the role that they play.
In Python, strings are sequences of characters, symbols, and numbers 
enclosed in a pair of double quotation marks or a pair of single quotation marks. 
Table 2-­
2 is a list of ASCII characters that can be used in strings. The following 
are some examples of strings:
In [ ]:
s1 = "this is my first string in double quotes"
s2 = 'string in single quotes'
print('s1 = ', s1)   # print out s1 = the value of 
variable s1
print('s2 = ', s2)   # print out s2 = the value of 
variable s2
Out [ ]:
s1 = this is my first string in double quotes
s2 = string in single quotes
When a string is too long and needs to span more than one line, a pair of 
triple quotation marks can be used, as shown in the following example:
In [ ]:
long_string = """ASCII stands for American Standard 
Code for Information Interchange.
Computers can only understand numbers, so an ASCII code 
is the numerical representation of a character such 
as "a" or "@" or an action of some sort.
ASCII was developed a long time ago, and now the 
nonprinting characters are rarely used for their 
original purpose. Below is the ASCII character table. 
The first 32 characters are nonprinting characters. 
ASCII was designed for use with teletypes, so the 
descriptions in ASCII are somewhat obscure.
If someone says they want your CV in ASCII format, 
all this means is they want "plain" text with no 
formatting such as tabs, bold or underscoring—­
the raw 
format that any computer can understand.
This is usually so they can easily import the file into 
their own applications without issues. Notepad.exe 
creates ASCII text, and MS Word lets you save a file 
as "text only."
"""
print('long_string =', long_string)
	
Essential Building Blocks of Computer Programs	
91
 https://doi.org/10.15215/remix/9781998944088.01
Out [ ]:
long_string = ASCII stands for American Standard Code for Information 
Interchange. Computers can only understand numbers, so an ASCII code 
is the numerical representation of a character such as "a" or "@" or an 
action of some sort. ASCII was developed a long time ago and now the 
nonprinting characters are rarely used for their original purpose. Below 
is the ASCII character table. The first 32 characters are nonprinting 
characters. ASCII was designed for use with teletypes and so the 
descriptions in ASCII are somewhat obscure. If someone says they want 
your CV in ASCII format, all this means is they want "plain" text with no 
formatting such as tabs, bold or underscoring—­
the raw format that any 
computer can understand. This is usually so they can easily import the 
file into their own applications without issues. Notepad.exe creates 
ASCII text, and MS Word lets you save a file as "text only."
This can be very useful in cases such as when you want to print out instruc­
tions for users to use with an application you developed.
Otherwise, you would need to use backslash at the end of each line except 
the last one to escape the invisible newline ASCII character, as shown below:
In [ ]:
s0 = 'Demo only. This string is not too long \
to be put on one line.'
print(f's0 = {s0}')
Out [ ]:
s0 = Demo only. This string is not too long to be put on one line.
This is OK if the string only spans across two or three lines. It will look 
clumsy if the string spans across a dozen lines.
In the example above, we use backslash \ to escape or cancel the invisible 
newline ASCII character. In Python and almost all programming languages, 
some characters have special meanings, or we may want to assign special 
meaning to a character. To include such a character in a string, you need to 
use a backslash to escape from its original meaning. The following are some 
examples:
In [ ]:
print("This string will be put \n on two lines")
# \n will start a new line
print("This string will add \t a tab -­
 a big space")
# \t will add a tab -­
 big space
Out [ ]:
This string will be put
on two lines
This string will add    a tab -­
 a big space
	 92	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In the examples above, putting a backslash in front of n assigns the com­
bination \n a special meaning, which is to add a new line to the string; putting 
a backslash in front of t assigns the combination \t a special meaning, which 
is to add a tab (a number of whitespaces) to the string. The next example uses 
backslash to escape the quotation from its original meaning defined in Python.
In [ ]:
print("This is \"President\" quoted")
# \" puts quotation marks in a string
Out [ ]:
This is "President" quoted
Table 2-­
2: ASCII table showing the codes of characters
Dec
Char
Dec
Char
Dec
Char
Dec
Char
0
NUL (null)
32
SPACE
64
@
96
`
1
SOH (start of heading)
33
!
65
A
97
a
2
STX (start of text)
34
"
66
B
98
b
3
ETX (end of text)
35
#
67
C
99
c
4
EOT (end of 
transmission)
36
$
68
D
100
d
5
ENQ (enquiry)
37
%
69
E
101
e
6
ACK (acknowledge)
38
&
70
F
102
f
7
BEL (bell)
39
'
71
G
103
g
8
BS (backspace)
40
(
72
v
104
h
9
TAB (horizontal tab)
41
)
73
I
105
i
10
LF (NL line feed, new 
line)
42
*
74
J
106
j
11
VT (vertical tab)
43
+
75
K
107
k
12
FF (NP form feed, new 
page)
44
,
76
L
108
l
13
CR (carriage return)
45
-­
77
M
109
m
14
SO (shift out)
46
.
78
N
110
n
	
Essential Building Blocks of Computer Programs	
93
 https://doi.org/10.15215/remix/9781998944088.01
Dec
Char
Dec
Char
Dec
Char
Dec
Char
15
SI (shift in)
47
/
79
O
111
o
16
DLE (data link escape)
48
0
80
P
112
p
17
DC1 (device control 1)
49
1
81
Q
113
q
18
DC2 (device control 2)
50
2
82
R
114
r
19
DC3 (device control 3)
51
3
83
S
115
s
20
DC4 (device control 4)
52
4
84
T
116
t
21
NAK (negative 
acknowledge)
53
5
85
U
117
u
22
SYN (synchronous 
idle)
54
6
86
V
118
v
23
ETB (end of trans. 
block)
55
7
87
W
119
w
24
CAN (cancel)
56
8
88
X
120
x
25
EM (end of medium)
57
9
89
Y
121
y
26
SUB (substitute)
58
:
90
Z
122
z
27
ESC (escape)
59
;
91
[
123
{
28
FS (file separator)
60
<
92
\
124
|
29
GS (group separator)
61
=
93
]
125
}
30
RS (record separator)
62
>
94
^
126
~
31
US (unit separator)
63
?
95
_
127
DEL
These 128 ASCII characters, including both printable and unprintable ones, 
are defined for communication in English between humans and machines. 
There is an extended set of ASCII characters defined for communication in 
other Western languages such as German, French, and others.
To enable communication between human and machines in languages 
such as Chinese, Unicode was designed. Details about Unicode can be found at 
https://​
unicode​
.org/. For information on how Unicode is used in Python, read 
the article at https://​
docs​
.python​
.org/​
3/​
howto/​
unicode​
.html.
Table 2-­
2: ASCII table showing the codes of characters (continued)
	 94	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In earlier versions of Python, if you want to use a non-­
ASCII character 
encoded in Unicode in a string, you need to know the code, assuming it is 
NNNN, and use escape sequence \uNNNN within the string to represent 
the non-­
ASCII character. You can also use built-­
in function chr(M) to get 
a one-­
character string encoded in Unicode, where M is code of the char­
acter in the Unicode table. The reverse built-­
in function order(Unicode 
character) is used to get the code of the Unicode character in the Unicode 

table.
In Python 3.0, however, the default encoding of Python programs was 
changed to UTF-­
8, which includes Unicode, so you can simply include any 
Unicode character in a string and PVM will recognize and handle it correctly, 
as shown in the following example:
In [ ]:
print("秦时明月汉时关 can be directly included in a 
string")
print(f"though you can still use chr(31206) for 
{chr(31206)}, chr(27721) for {chr(27721)}")
Out [ ]:
秦时明月汉时关 can be directly included in a string
though you can still use chr(31206) for 秦, chr(27721) for 汉
When representing strings, some prefixes or flags can be put in front 

of the opening quotation mark. These flags are also called prefixes, used before 
the opening quote of a string. These prefixes are listed in Table 2-­
3 with their 
meaning and some coding samples.
Table 2-­
3: Prefixes used for string formatting and construction
Flag
What it does
Code sample in Jupyter Notebook
F, f
F/f for formatting. Causes the 
evaluation of expressions 
enclosed within {}.
In:
name="John"
s0 = f"Your name is {name}."
print(s0)
Out:
Your name is John.
R, r
R/r for raw string. Nothing in 
the string is evaluated, not 
even \".
In:
name = "John"
s0 = r"Your name is\t {name} 
\""
print(s0)
Out:
Your name is \t {name} \"
	
Essential Building Blocks of Computer Programs	
95
 https://doi.org/10.15215/remix/9781998944088.01
Flag
What it does
Code sample in Jupyter Notebook
U, u
U/u for Unicode, indicating 
Unicode literals in a string. 
It has no effect in Python 
3 since Python 3’s default 
coding is UTF-­
8, which 
includes Unicode.
In:
print(u"秦时明月汉时关", end=":")
print("秦时明月汉时关")
Out:
秦时明月汉时关:秦时明月汉时关
B, b
B/b for byte. Literals in the 
string become byte literals, 
and anything outside of 
ASCII table must be escaped 
with backslash.
In:
print(b"2005-­
05-­
26-­
10458.68")
Out:
b"2005-­
05-­
26-­
10458.68"
LIST
List is a very useful compound data type built into Python. A list of elements, 
which can be different types of data, is enclosed in square brackets. The fol­
lowing are some examples of lists:
[1, 2, 3, 4, 5]
['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']
In Python, an element in a list can be any type of data or object, to use 
a more common computer-­
science term. So an element can be a list too, 
such as,
[[1,2,3],[4, 5, 6]]
Assume that
week = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 
'Friday', 'Saturday', 'Sunday']
The term week[0] refers to the first element of the list, and week[1] refers to the 

second element of the list, where 0 and 1 are called index. An index can be 
negative as well, meaning an item counted from the end of the list. For example, 
week[-­
1] will be Sunday, the first item from the end; week[-­
2] will be Saturday, 
the second item from the end.
Table 2-­
3: Prefixes used for string formatting and construction 
(continued)
	 96	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
To get a sublist of a list L we use notation L[s: e], where s is the starting point 
in the list, e is the ending point within the list, and the sublist will include all 
items from s till e but excluding the item at e. For example, to get all weekdays 
from the list week, we use week[0,5], as shown below:
In [ ]:
week = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 
'Friday', 'Saturday', 'Sunday']
week[0:5]
Out [ ]:
['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']
Negative indexing becomes convenient when a list, or any sequence, is too 
long to count from the beginning. In the example above, it is much easier to 
count from the end to find out that the weekdays stop right before Saturday, 
whose index is −2, as shown below:
In [ ]:
week = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 
'Friday', 'Saturday', 'Sunday']
week[0:-­
2]
Out [ ]:
['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']
Within the notation of L[s:e], s or e or both may be missing. When s is 
missed, it means the sublist is indexed from the beginning of the list; when e 
is missed, it means the sublist is indexed from the end of the list. So week[:] 
will include all the items of the list week, as shown below:
In [ ]:
week[:]
Out [ ]:
['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
Multiple lists can be joined together with operator +. Assume we have the 
following two lists:
weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 
'Friday']
weekend = ['Saturday', 'Sunday']
We can then combine weekdays and weekend into one list and assign the 
new list to week using operator +, as shown below:
	
Essential Building Blocks of Computer Programs	
97
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
weekdays = ['Monday', 'Tuesday', 'Wednesday', 
'Thursday', 'Friday']
weekend = ['Saturday', 'Sunday']
week = weekdays + weekend
print(week)
Out [ ]:
['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
A copy of a list can be easily made by sublisting all its members, as shown below:
week0 = week[:]
We can create a list from a string using the built-­
in function list():
In [ ]:
l0 = list("How are you?")
print(l0)
Out [ ]:
['H', 'o', 'w', ' ', 'a', 'r', 'e', ' ', 'y', 'o', 'u', '?']
We can also create a list using the built-­
in function list() and range():
In [ ]:
l1 = list(range(10))
l2 = list(range(10, 20))
print(l1, l2)
Out [ ]:
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
We can use the built-­
in function len() to find out how many elements are 
in the list:
In [ ]:
print(len(week))
Out [ ]:
4
TUPLE
Tuple is another type of sequence, but members of a tuple are enclosed in 
parentheses. The following are some sample tuples:
(12, 35)
('Canada', 'Ottawa')
('China', 'Beijing')
	 98	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
You can create a tuple from a list by using the tuple() function. For example,
TPL = TUPLE(WEEK)
This will create a tuple, as shown below:
('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 
'Saturday', 'Sunday')
Similarly, you can create a list from a tuple, as shown below:
week = list(tpl)
Members of a tuple can be accessed in the same way as lists because the 
members are also indexed. For example, tpl[0] refers to Monday.
Moreover, most of the operations used on lists can be applied to tuples, 
except those that make changes to the member items, because tuples are 
immutable.
Why are tuples immutable? You may consider it like this: A tuple is used 
to represent a specific object, such as a point on a line, or even a shape. If any 
member of the tuple is changed, it will refer to a different object. This is the 
same for numbers and strings, which are also immutable. If you change any digit 
of a number, or any character of a string, the number or string will be different.
SET
In Python, a set is a collection of elements or objects enclosed in a pair of 
curly brackets. Like sets in mathematics, members in a set are unordered and 
unindexed. The following are two examples of sets:
grades = {'A', 'A+', 'A−', 'B', 'B+', 'B−', 'C', 'C+', 
'C−', 'D', 'D+', 'D−'}
My_friends = {'John', 'Jack', 'Jim', 'Jerry', 'Jeromy'}
You can use built-­
in function set() to build a set from a list or tuple:
week_set = set(('Monday', 'Tuesday', 'Wednesday', 
'Thursday', 'Friday', 'Saturday', 'Sunday'))
Built-­
in functions set(), list(), tuple(), float(), int(), str() are also called con­
structors or converters, because they are used to construct or convert to one 
respective type of data from another type.
	
Essential Building Blocks of Computer Programs	
99
 https://doi.org/10.15215/remix/9781998944088.01
You can use membership operator in to test if an object is a member of a 
set. For example,
'John' in My_friends
will give you a True value because John is a member of set My_friends con­
structed above.
You can use built-­
in function len() to get the size of a set—­
that is, how many 
members are in the set. So len(grades) will be 12.
DICTIONARY
In Python, a dictionary is a collection of comma-­
separated key-­
value pairs 
enclosed in curly brackets and separated by a colon :. The members of a dic­
tionary are unordered and unindexed. The following is an example:
In [ ]:
weekday = {'Mon':'Monday', 'Tue':'Tuesday', 
'Wed':'Wednesday', 'Thu':'Thursday', 'Fri':'Friday'}
print(weekday['Mon'], ' of ', weekday)
Out [ ]:
Monday of {'Mon': 'Monday', 'Tue': 'Tuesday', 'Wed': 'Wednesday', 'Thu': 
'Thursday', 'Fri': 'Friday'}
Because the keys are used to retrieve the values, each key must be unique 
within a dictionary. For example, we use Weekday['Mon'] to retrieve its corres­
ponding value, Monday.
In this case, you can also use integer numbers as keys, as shown below:
In [ ]:
weekday = {1:'Monday', 2:'Tuesday', 3:'Wednesday', 
4:'Thursday', 5:'Friday'}
print(weekday[1], ' of ', weekday)
Out [ ]:
Monday of {1: 'Monday', 2: 'Tuesday', 3: 'Wednesday', 4: 'Thursday', 5: 
'Friday'}
OBJECT
Although you can code almost any application in Python without object-­
oriented 
thinking, you should be aware that Python fully supports object-­
oriented pro­
gramming. In fact, Python treats everything as an object, including classes, 
functions, and modules. For example, numbers are treated as objects in the 
following statements:
	100	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
print((2.35).hex())
print((23).bit_length())
Out [ ]:
0x1.2cccccccccccdp+1
5
There are some special types of objects in Python, as shown in Table 2-­
4.
Table 2-­
4: Types of objects in Python
Name
Meaning
Example of usage
type
Because in Python everything 
is an object, so are classes, 
whose class is type, which is 
again an object as well as a 
special object.
It has no real usage in 
programming but is rather a 
philosophical and ideological 
concept.
None
An object representing “no 
value.” It is the only object of 
data type NoneType. For a 
logical expression, None is the 
same as 0, null, empty string, 
and False.
In:
if not None:
  print('there is no 
value')
Out:
There is no value
file
A file object can be created 
by calling the file() or open() 
methods, which allow us to 
use, access, and manipulate 
all accessible files.
f = open("resume.xml", "r")
function
In Python, functions are first-­
class objects and can be 
passed as arguments in 
another function call.
sort(method, data_list)
module
A special type of object that all 
modules belong to.
It is more a philosophical and 
ideological concept.
class
A type of all classes.
It is more a philosophical and 
ideological concept.
class Instance
An individual object of a given 
class.
It is more a philosophical and 
ideological concept.
method
A method of a given class.
It is more a philosophical and 
ideological concept.
code
A code object is the internal 
representation of a piece of 
runnable Python code.
It is used in internal Python 
program running.
	
Essential Building Blocks of Computer Programs	
101
 https://doi.org/10.15215/remix/9781998944088.01
Name
Meaning
Example of usage
frame
A table containing all the local 
variables.
It is used in function calling.
traceback
A special object for exception 
handling.
It provides an interface to 
extract, format, and print stack 
traces of Python programs, 
especially when an exception 
is raised.
ellipsis
A single object called ellipsis, a 
built-­
in name in Python 3.
It is rarely used except in slicing.
Variables and Constants
Data values, variables, and constants are important constructs of any pro­
gramming language. We have presented all standard simple or primary data 
types and compound data types and their values in the previous section. In the 
following section, we will study variables and constants.
VARIABLES
A variable is a name that identifies a location in computer memory to store 
data. A variable must conform to the rules of naming discussed earlier in this 
section, and it also must not be used for other purposes within the same con­
text of the program. For example, you cannot use reserved words or keywords 
as variables.
An important operation on a variable is to assign a value to it or put a value 
into the memory location identified by the variable. In Python, this is done by 
using the assignment operator =.
For example, the following statement assigns COMP 218 to the variable course, 
assigns Smith to the variable student, and assigns 99 to the variable grade:
In [ ]:
course = 'COMP 218'
student = 'Smith'
grade = 99
print("course is {}, student is {}, grade is {}".
format(course, student, grade))
Out [ ]:
course is COMP 218, student is Smith, grade is 99
Table 2-­
4: Types of objects in Python (continued)
	102	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Unlike other programming languages, in Python, there is no need to declare 
its type before a variable is introduced and used in your program for the first 
time. Its type is determined by the value assigned to it. In the above example, 
the type of grade is integer, because 99 is an integer.
In [ ]:
type(grade)
Out [ ]:
int
You may convert the value of a variable into another type using specific 
built-­
in functions, such as int(), float(), str(), etc.
In [ ]:
marks = 90.8   # assign float mark to variable marks
int_mark = int(marks)   # convert into integer mark and 
assign it to variable int_mark
print(int_mark)
Out [ ]:
90
CODING PRACTICE
Task 1
In a Jupyter Notebook cell, type the following code and run it by hitting 
Shift+Enter to see what you will get:
pi = 3.1415
r = 6
area = pi * r ** 2
print(F"The type of pi is {type(pi)}, and its value is 
{pi}")
print("The type of r is ", type(r), ", its value is ", r)
print("The type of area is {:^10}".
format(str(type(area))), end='')
print(", and its value is {:^12}.".format(area))
Task 2
In a new cell of Jupyter Notebook, write and run the following state­
ments, which calculate the circumference of a circle with radius r = 10, 
and print the result:
	
Essential Building Blocks of Computer Programs	
103
 https://doi.org/10.15215/remix/9781998944088.01
pi = 3.1415
r = 10
circumference = 2 * pi * r
print("The circumference of a circle with radius {:d} is 
{:f}".format(r, circumference))
Please note that in Jupyter Notebook, if you need a new cell, simply click 
the plus sign button under the notebook menu.
Please also note that the type of variable area is the same as the type of 
variable pi, but not of variable r. We can check what type the result will be when 
a different arithmetic operator is applied to a pair of numbers of the same or 
different types, as shown in Tables 2-­
5a and 2-­
5b:
Table 2-­
5a: Semantics of operator +, -­
, *
+, -­
, *
integer
float
complex
integer
integer
float
complex
float
float
float
complex
complex
complex
complex
complex
Table 2-­
5b: Semantics of / (division) operator
/
integer
float
complex
integer
float
float
complex
float
float
float
complex
complex
complex
complex
complex
The following coding example in Jupyter Notebook confirms that the result 
will be a complex number when an integer is divided by a complex number:
In [ ]:
i = 12
cx = 23 + 35j
icx = i / cx
print(icx, type(icx))
Out [ ]:
(0.1573546180159635-­
0.2394526795895097j) <class 'complex'>
You may copy and modify the code above to check other combinations in 
Jupyter Notebook.
	104	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
BUILT-­
IN CONSTANTS
We have seen some values of various data types. Some values have special 
meanings in Python. We call them constants. The following table lists all the 
constants you may see and use when programming with Python.
Table 2-­
6: Python built-­
in constants
Constant 
name
Meaning
Code sample in Python 
interactive mode
True
Logical true
>>> x = True
>>> if x:
… print(f"x is {x}")
… 
x is True
False
Logical false
>>> x = False
>>> if not x:
… print(f"x is {x}")
… 
x is False
None
No value assigned
>>> x = None
>>> if not x:
… print(f"{x} is treated 
as False")
… 
None is treated as False
Ellipsis
Same as …, often used in slicing 
multiple dimensional arrays
>>> Ellipsis == …
True
>>> Ellipsis is …
__debug__
Contains True if Python is started 
without the -­
O option
C:\Users\comp218>python 
-­
O
Python 3.7.2
>>> __debug__
False
quit
Contains information displayed 
when Python quits and 
terminates
>>> quit
Use quit() or 
Ctrl+Z+Enter to exit
exit
Contains information displayed 
when Python quits and 
terminates
>>> exit
Use exit() or 
Ctrl+Z+Enter to exit
	
Essential Building Blocks of Computer Programs	
105
 https://doi.org/10.15215/remix/9781998944088.01
Constant 
name
Meaning
Code sample in Python 
interactive mode
copyright
Contains copyright information
>>> copyright
Copyright (c) 2001–­
2018 
Python Software 
Foundation.
All Rights Reserved.
Copyright (c) 2000 
BeOpen.com.
All Rights Reserved.
Copyright (c) 1995–­
2001 
Corporation for 
National Research 
Initiatives.
All Rights Reserved.
Copyright (c) 1991–­
1995 
Stichting Mathematisch 
Centrum, Amsterdam.
All Rights Reserved.
credits
Contains credit information
>>> credits
Thanks to CWI, CNRI, 
BeOpen.com, Zope 
Corporation and a 
cast of thousands 
for supporting Python 
development. See 
www.python.org for more 
information.
license
Contains licensing information
>>> license
Type license() to see the 
full license text
__name__
When a Python file is started, 
some special variables are 
initialized with specific values, 
and __name__ is one such 
variable. This variable will have 
value __main__ if the Python file 
is started as the main program; 
otherwise, it will contain the 
module name or the function or 
class name if that is imported 
from the module.
C:\comp218> python prime.
py
.
…
>>> __name__
__main__
More information about these constants can be found at https://​
docs​
.python​
.org/​
3/​
library/​
constants​
.html.
Table 2-­
6: Python built-­
in constants (continued)
	106	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Operators
As we learned in previous sections, data are used to represent information, 
while variables and constants are used to refer to data stored in computer 
memory. In the following sections, we will learn about operators and built-­
in 
functions that can be used to process and manipulate data.
ARITHMETIC OPERATORS
Arithmetic operators are used on numbers. These operators are well-­
known. 
Table 2-­
7 provides a list of these operators, their meaning, and code samples you 
may take and practise in Python interactive mode. Please copy only the expres­
sions or statements behind >>>, which is the Python prompt for your input.
Table 2-­
7: Arithmetic operators
Operator
Operation
Code samples in Python 
interactive mode
+
Add two operands
or unary plus
+ operator can be redefined in a 
class for its objects defining 
__add__
>>> x = 10
>>> y = 20
>>> x + y
30
>>> +y
20
−
Subtract right operand from the 
left or unary minus
>>> x, y = 10, 20
>>> x -­
 y
-­
10
>>> -­
y
-­
20
*
Multiply two operands
>>> x, y = 10, 20
>>> y * x
200
/
Divide left operand by the right one 
(always results into float)
>>> x, y = 10, 20
>>> y / x
2.0
//
Floor division—­
division that results 
into integer number by omitting 
all the decimals
>>> x, y = 32, 7
>>> x, y
(32, 7)
>>> x // y
4
%
Modulus—­
remainder of the 
division of left operand by the 
right
>>> x, y = 32, 7
>>> x, y
(32, 7)
>>> x % y
4
	
Essential Building Blocks of Computer Programs	
107
 https://doi.org/10.15215/remix/9781998944088.01
Operator
Operation
Code samples in Python 
interactive mode
**
Exponent—­
left operand raised to 
the power of right
>>> x, y = 32, 7
>>> x, y
(32, 7)
>>> x ** y
34359738368
When two or more of these arithmetic operators are used in an expression, 
the precedence rules you learned in high school or university math courses 
apply. In brief, the precedence rules for all the operators are as follows:
	
1.	 Exponent operation (*) has the highest precedence.
	
2.	 Unary negation (−) is the next.
	
3.	 Multiplication (*), division (/), floor division (//), and modulus operation 
(%) have the same precedence and will be evaluated next unary 
negation.
	
4.	 Addition (+) and subtraction (−) are next, with the same 
precedence.
	
5.	 Comparison operators are next, with the same precedence.
	
6.	 The three logical operators (not, and, or) are next, with not having the 
highest precedence among the three, followed by and, then or.
	
7.	 When operators with equal precedence are present, the expression 
will be evaluated from left to right, hence left association.
	
8.	 Parentheses can be used to change the order of evaluation.
The following are some examples of how expressions are evaluated.
>>> 12 + 3 * 21
75
In the expression 12 + 3 * 21, because * has higher precedence than +, 3 * 
21 is evaluated first to get 63, and then 12 + 63 is evaluated to get 75.
>>> ((23 + 32) // 6 -­
 5 * 7 / 10) * 2 ** 3
44.0
In this example, because ** has the highest precedence, 2 ** 3 is evaluated 
first, to get
Table 2-­
7: Arithmetic operators (continued)
	108	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
((23 + 32) // 6 -­
 5 * 7 / 10) * 8
In this intermediate result, because of parentheses, we will need to evaluate 
((23 + 32) // 6 − 5 * 7 / 10) first, and in this subexpression, because of parentheses, 
23 + 32 will be evaluated first to get 55//6 − 5 * 7 /10. According to the precedence 
rules, this subexpression will be evaluated to 9 − 35 / 10, and then 9 − 3.5 = 5.5. 
Then the expression above will be
5.5 * 8
which is evaluated to be 44.0.
COMPARISON OPERATORS
Comparison operators are used to compare two objects. It is easy to understand 
how they work on numbers and even strings. When a comparison is applied 

to lists or tuples, the comparison will be applied to pairs of items, one from 
each list or tuple, and the final result is True if there are more Trues; otherwise 
it will be False, as shown in the example below:
In [ ]:
l1 = ['apple', 'orange', 'peach']
l2 = ['tomato', 'pepper', 'cabbage']
l1 < l2
Out [ ]:
True
Table 2-­
8 explains all the comparison operators, with samples.
Table 2-­
8: Python comparison operators
Operator
Operation
Code sample in Python 
interactive mode
>
Greater than—­
True if left operand 
is greater than the right
>>> x, y = 23, 53
>>> x > y
False
>>> l1 = ('apple', 
'orange', 'peach')
>>> l2 = ('tomato', 
'pepper', 'cabbage')
>>> l2 > l1
True
	
Essential Building Blocks of Computer Programs	
109
 https://doi.org/10.15215/remix/9781998944088.01
Operator
Operation
Code sample in Python 
interactive mode
<
Less than—­
True if left operand is 
less than the right
>>> x, y = 23, 53
>>> x, y
(23, 53)
>>> x < y
True
>>> s1 = "Albert"
>>> s2 = "Jeremy"
>>> s1 < s2
True
==
Equal to—­
True if both operands 
are equal
>>> x, y = 23, 53
>>> x, y
(23, 53)
>>> x == y
False
!=
Not equal to—­
True if operands are 
not equal
>>> x, y = 23, 53
>>> x, y
(23, 53)
>>> x != y
True
>=
Greater than or equal to—­
True if 
left operand is greater than or 
equal to the right
>>> x, y = 23, 53
>>> x, y
(23, 53)
>>> x >= y
True
<=
Less than or equal to—­
True if left 
operand is less than or equal to 
the right
>>> x, y = 23, 53
>>> x, y
(23, 53)
>>> x <= y
True
LOGICAL OPERATORS
Logical operators are used to form logical expressions. Any expression whose 
value is a Boolean True or False is a logical expression. These will include 
expressions made of comparison operators discussed above. Table 2-­
9 sum­
marize the details of these logical variables.
Table 2-­
8: Python comparison operators (continued)
	110	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Table 2-­
9: Python logical operators
Operator
Meaning
Code sample in Python 
interactive mode
and
A and B
True if both A and B are true
>>> (x, y) = (23, 53)
>>> (m, n) = (12, 9.6)
>>> x, y, m, n
(23, 53, 12, 9.6)
>>> x > y and m > n
False
or
A or B
True if either A or B is true
>>> (x, y) = (23, 53)
>>> (m, n) = (12, 9.6)
>>> x, y, m, n
(23, 53, 12, 9.6)
>>> x > y or m > n
True
not
not A
True if A is false
>>> (x, y) = (23, 53)
>>> x, y
(23, 53)
>>> not x < y
False
Logical expressions are often used in if and while statements, and it is 
important to ensure that the logical expressions used in your programs are 
correctly written. Otherwise, catastrophic results may occur in some real appli­
cations. Common errors in writing logical expressions include:
	
1.	 Using > instead of <, or using < instead of >
	
2.	 Using >= instead of >, or using > instead >=
	
3.	 Using <= instead of <, or using < instead <=
For example, suppose you are writing a program to control the furnace at home, 
and you want to heat the home to 25 degrees Celsius. The code for this should be
if t < 25 : heating()
However, if instead you wrote,
if t > 25 : heating()
the consequence would be either the home will not heat at all (if the initial 
temperature is below 25 when the program starts) or it will overheat (if the 
initial temperature is greater than 25).
	
Essential Building Blocks of Computer Programs	
111
 https://doi.org/10.15215/remix/9781998944088.01
BITWISE OPERATORS
We know that data in computer memory are represented as sequences of bits, 
which are either 1 or 0. Bitwise operators are used to operate bit sequences bit 
by bit. These bitwise operations may look strange to you, but you will appre­
ciate these operations when you need them. Table 2-­
10 provides a summary 
of bitwise operators. Please note that built-­
in function bin() converts data 
into their binary equivalents and returns a string of their binary expressions, 
with a leading 0b.
Table 2-­
10: Python bitwise operators
Operator
Meaning
Code sample in Python 
interactive mode
&
Bitwise and
>>> m, n = 12, 15
>>> bin(m), bin(n)
('0b1100', '0b1111')
>>> bin(m & n)
'0b1100'
|
Bitwise or
>>> bin(m), bin(n)
('0b1100', '0b1111')
>>> bin(m | n)
'0b1111'
~
Bitwise not
>>> ~ m
-­
13
>>> bin(~ m)
'-­
0b1101'
^
Bitwise XOR
>>> bin(m), bin(n)
('0b1100', '0b1111')
>>> bin(m ^ n)
'0b11'
>> 
Bitwise right shift
>>> bin(m)
'0b1100'
>>> bin(m>>2)
'0b11'
<< 
Bitwise left shift
>>> bin(m)
'0b1100'
>>> bin(m<<2)
'0b110000'
	112	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
ASSIGNMENT OPERATORS
In Python, and all programming languages, the assignment operation is one 
of the most important operations because assignment operations store data 
in variables for later use.
In previous sections, we have seen many examples of using the assignment 
operator =, the equal sign. However, Python provides many augmented assign­
ment operators. Table 2-­
11 lists all the assignment operators you can use in 
your Python programs.
Table 2-­
11: Python assignment operators
Operator
Operation
Code samples in Python 
interactive mode
x = e
Expression e is evaluated, and the 
value is assigned to variable x.
Note that in Python and in 
previous code samples, 
assignments can be made to 
more than one variable with one 
statement.
>>> m, n = 23, 12
>>> m, n
(23, 12)
>>> x = m + n
>>> x
35
x += e
Expression x + e is evaluated, 
and the value is assigned to 
variable x.
x = x + e
>>> x, m, n = 35, 23, 12
>>> x, m, n
(35, 23, 12)
>>> x += m + n
>>> x
70
>>> x, m, n
(70, 23, 12)
x = e
Expression x − e is evaluated, 
and the value is assigned to 
variable x.
x = x − e
>>> x, m, n = (70, 23, 
12)
>>> x, m, n
(70, 23, 12)
>>> x -­
= m + n
>>> x, m, n
(35, 23, 12)
x *= e
Expression x * e is evaluated, 
and the value is assigned to 
variable x.
x = x * e
>>> x, m, n = (35, 23, 
12)
>>> x, m, n
(35, 23, 12)
>>> x *= m + n
>>> x, m, n
(1225, 23, 12)
	
Essential Building Blocks of Computer Programs	
113
 https://doi.org/10.15215/remix/9781998944088.01
Operator
Operation
Code samples in Python 
interactive mode
x /= e
Expression x / e is evaluated, 
and the value is assigned to 
variable x.
x = x / e
>>> x, m, n = (1225, 23, 
12)
>>> x, m, n
(1225, 23, 12)
>>> x /= m + n
>>> x, m, n
(35.0, 23, 12)
x %= e
Expression x % e is evaluated, 
and the value is assigned to 
variable x.
x = x % e
>>> x, m, n = (28, 23, 
12)
>>> x, m, n
(28, 23, 12)
>>> x %= m + n
>>> x, m, n
(28, 23, 12)
x //= e
Expression x // e is evaluated, 
and the value is assigned to 
variable x.
x = x // e
>>> x, m, n = 989, 23, 12
>>> x, m, n
(989, 23, 12)
>>> x //= m + n
>>> x, m, n
(28, 23, 12)
x **= e
Expression x ** e is evaluated, 
and the value is assigned to 
variable x.
x = x ** e
>>> x, m, n = 98, 3, 2
>>> x **= m + n
>>> x, m, n
(9039207968, 3, 2)
x &= e
Expression x & e is evaluated, 
and the value is assigned to 
variable x.
x = x & e
>>> x, m, n = 9, 3, 2
>>> bin(x), bin(m), 
bin(n)
('0b1001', '0b11', 
'0b10')
>>> x &= m * n
>>> bin(x), bin(m), 
bin(n)
('0b0', '0b11', '0b10')
x |= e
Expression x | e is evaluated, 
and the value is assigned to 
variable x.
x = x | e
>>> x, m, n = 9, 3, 2
>>> bin(x), bin(m), 
bin(n)
('0b1001', '0b11', 
'0b10')
>>> x |= m * n
>>> bin(x), bin(m), 
bin(n)
('0b1111', '0b11', 
'0b10')
Table 2-­
11: Python assignment operators (continued)
(continued on next page)
	114	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Operator
Operation
Code samples in Python 
interactive mode
x ^= e
Expression x ^ e is evaluated, 
and the value is assigned to 
variable x.
x = x ^ e
>>> x, m, n = 9, 3, 2
>>> bin(x), bin(m), 
bin(n)
('0b1001', '0b11', 
'0b10')
>>> x ^= m * n
>>> bin(x), bin(m), 
bin(n)
('0b1111', '0b11', 
'0b10')
x >>= e
Expression x >> e is evaluated, 
and the value is assigned to 
variable x.
x = x >> e
>>> x, m, n = 9, 3, 2
>>> bin(x), bin(m), 
bin(n)
('0b1001', '0b11', 
'0b10')
>>> x >>= m * n
>>> bin(x), bin(m), 
bin(n)
('0b0', '0b11', '0b10')
x <<= e
Expression x << e is evaluated, 
and the value is assigned to 
variable x.
x = x << e
>>> x, m, n = 9, 3, 2
>>> bin(x), bin(m), 
bin(n)
('0b1001', '0b11', 
'0b10')
>>> x <<= m * n
>>> bin(x), bin(m), 
bin(n)
('0b1001000000', '0b11', 
'0b10')
CODING PRACTICE
Type the following code to a scratch file in VS Code or a code cell in 
Jupyter Notebook and run. Explain why bin(8 << 2) is equal to bin(8 * 4).
print(bin(8))
print(bin(8 << 2), bin(8 * 4))
Table 2-­
11: Python assignment operators (continued)
	
Essential Building Blocks of Computer Programs	
115
 https://doi.org/10.15215/remix/9781998944088.01
IDENTITY OPERATORS
Identity operators are used to test if two operands, usually two identifiers, 
are identical, which in most implementations of Python means that they are 
referring to the same memory block of the computer. The examples Table 2-­
12 
tell you more about this. Note that in the example, the built-­
in function id(o) is 
used to get the id of object o.
Table 2-­
12: Python identity operators
Operator
Meaning
Example
is
True if the operands are identical 
(refer to the same object)
Note that 3 and 2 + 1 have the 
same id, and so does 6 // 2, but 
not 6 / 2 because 6 / 2 = 3.0, 
which is different from 3.
>>> x = list(range(3))
>>> y = list(range(3))
>>> x, y
([0, 1, 2], [0, 1, 2])
>>> id(x), id(y)
(10049456, 10049016)
>>> x is y
False
>>> id(3)
258398416
>>> id(2 + 1)
258398416
is not
True if the operands are not 
identical (do not refer to the 
same object).
Note that when assigning variable 
y to variable x, the operation 
points x to the same memory 
block y is pointing to (so that the 
two have the id) and shares the 
same memory block. However, 
when a new assignment is 
made to x or y, the two will have 
different ids, unless they both 
hold the same integer or string.
>>> x = list(range(3))
>>> x = y
>>> id(x), id(y)
(10049016, 10049016)
>>> x is y
True
>>> y = list(range(3))
>>> id(x),id(y)
(10090256, 10090336)
>>> x, y
([0, 1, 2], [0, 1, 2])
>>> x is not y
True
SEQUENCE OPERATORS
In 2.1, we learned that sequences include strings, lists, and tuples because 
elements in strings, lists, and tuples are ordered and indexed. Sets and dic­
tionaries are not sequences because elements in dictionaries and sets are not 
ordered, or not in sequence.
Sequence operators are made available for operations on strings, lists and 
tuples, as shown in Table 2-­
13.
	116	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Table 2-­
13: Python sequence operators
Operator
Operation
Code sample in Python 
interactive mode
*
Repeat a sequence such as string, 
list or tuple multiple times
>>> "Python " * 3
'Python Python Python '
>>> [1, 2, 3] * 5
[1, 2, 3, 1, 2, 3, 1, 2, 
3, 1, 2, 3, 1, 2, 3]
+
Join two sequences
>>> [1, 2, 3] + [5, 6, 7]
[1, 2, 3, 5, 6, 7]
[n]
Slice out a single member of the 
sequence
>>> name = 'John'
>>> name[1]
'o'
[n:m]
Slice a sequence start from n to m.
>>> name
'John'
>>> name[1:3]
'oh'
MEMBERSHIP OPERATOR
Membership operators are used to test whether an element is a member of a 
sequence. There are three membership operators in Python, and two of them 
are shown in Table 2-­
14.
Table 2-­
14: Python membership operators
Operator
Operation
Code sample in Python 
interactive mode
v in s
True if value v is found in 
sequence s
>>> l = list(range(10))
>>> l
[0, 1, 2, 3, 4, 5, 6, 7, 
8, 9]
>>> 3 in l
True
>>> 2 + 1 in l
True
>>> 'x' in "Welcome to 
COMP218"
False
	
Essential Building Blocks of Computer Programs	
117
 https://doi.org/10.15215/remix/9781998944088.01
Operator
Operation
Code sample in Python 
interactive mode
v not in s
Checks whether value/variable is 
not found in the sequence
>>> l
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> 30 in l
False
>>> 30 not in l
True
The third membership operator is used to access members of objects, mod­
ules, or packages. It is the dot (.) operator. The example in Table 2-­
15 shows 
how to access a function in module math.
Table 2-­
15: Dot operator
Operator
Operation
Code sample in Python 
interactive mode
p.q
q is a member of p where p and 
q refer to an object (variable, 
constant, function or method 
name), package, or module 
name
>>> import math
>>> type(math)
<class 'module'>
>>> type(math.sqrt)
<class 'builtin_function_
or_method'>
>>> math.sqrt(35)
5.916079783099616
Built-­
In Functions
As with operators, built-­
in functions are also important in processing and 
testing data in programs. As the name implies, built-­
in functions are built into 
Python Virtual Machine (PVM). A built-­
in function can be used directly without 
importing any module or noting what it belongs to.
Built-­
in functions, and functions or methods in general, can be put into two 
categories. One is based on the data they return, whereas the other is based 
on the operations performed, although sometimes the returned data from 
a built-­
in function in the second category may still be useful in subsequent 
executions of the program.
We will first explain built-­
in functions in the first category, followed by 
built-­
in functions in the second category. To best understand these functions, 
read through these built-­
in functions and test the sample code in a Python 
interactive shell or Jupyter Notebook.
Table 2-­
14: Python membership operators (continued)
	118	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
ABS(X)
This returns the absolute value of x, which can be any number.
>>> abs(-­
99)
99
>>> abs(-­
b110010)   # a binary number
50
>>> abs(-­
0o32560)   # an octal number
13680
>>> abs(0xdef21a)   # a hexadecimal(16) number
13610970
INT(S, BASE = 10)
This converts a number s in a specific base to an integer in base-­
10. The default 
base is 10. If the base is explicitly given, s must be a string containing a legit­
imate literal for the base.
>>> int(19.9)
19
>>> int("22", 8)   # in the quote must be a legitimate 
literal for base-­
8
18
>>> int('0x123', base = 16)   # a number in base-­
16
291
POW(X, P)
This returns the value of x to the power of p.
>>> pow(2.9, 12.8)
829266.980472172
FLOAT(S)
This converts s to float. s can be a number, or a string of numbers.
>>> float('18.23')
18.23
>>> float(19)
19.0
	
Essential Building Blocks of Computer Programs	
119
 https://doi.org/10.15215/remix/9781998944088.01
MAX(ITERABLE, *[, DEFAULT = OBJ, KEY = FUNC])
MAX(ARG1, ARG2, *ARGS, *[, KEY = FUNC])
These find and return the biggest element from an iterable such as a list, tuple 
or string, or from two or more arguments. The default keyword-­
only argument 
specifies what will be returned if the iterable is empty. The key keyword-­
only 
argument specifies how the maximum is defined if it is out of the ordinary.
>>> max(2, 1, 5, 65, 89)   # variable-­
length list of 
arguments
89
>>> max("this")   # the given sequence is a string
't'
>>> max((2, 3, 5, 1, 78))   # numbers in a tuple
78
>>> max([2, 3, 5, 1, 78])   # numbers in a list
78
MIN(ITERABLE, *[, DEFAULT = OBJ, KEY = FUNC])
MIN(ARG1, ARG2, *ARGS, *[, KEY = FUNC])
These find and return the smallest number from an iterable such as a list, tuple 
or string, or from two or more arguments. The default keyword-­
only argument 
specifies what will be returned if the iterable is empty. The key keyword-­
only 
argument specifies how the minimum is defined if it is out of the ordinary.
>>> min(6, 5, 8, 3, 2)
2
>>> min([2, 3, 5, 1, 78])   # numbers in a list
>>> min([], default = 0)   # 0 will be returned because 
the list is empty
0
ROUND(F)
This rounds number f to the closest integer and returns the integer.
>>> round(3.1415926)
3
ORD(C)
This finds and returns the order of a character, as a single char string, in the 
ASCII table.
	120	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> ord('c')
99
SUM(…)
This calculates and returns the sum of numbers in a list, a tuple, or a range() call.
>>> sum([23, 56, 67, 12, 89])
247
>>> sum((23, 56, 67, 12, 89))
247
>>> sum(range(88))
3828
SET(S)
This converts a set from a list or tuple.
>>> set([23, 56, 67, 12, 89])
{23, 56, 67, 12, 89}
DICT()
DICT(ITERABLE)
DICT(A = V,…)
These convert an empty dictionary, construct a dictionary from the iterable of 
(k, v) tuples, and from key=value pairs, respectively.
>>> dict()
{}
>>> dict([(1,'Turing'), (2,'Bool'), (3,'Babbage'), 
(4,'Neumann'), (5,'Knuth')])
{1: 'Turing', 2: 'Bool', 3: 'Babbage', 4: 'Neumann', 5: 
'Knuth'}
>>> dict(a = 1, b = 2, c = 3)
{'a': 1, 'b': 2, 'c': 3}
BIN(N)
This converts a number to its binary equivalence as a string.
>>> bin(98)
'0b1100010'
	
Essential Building Blocks of Computer Programs	
121
 https://doi.org/10.15215/remix/9781998944088.01
HEX(N)
This converts a number to its hex equivalence as a string.
>>> hex(19)
'0x13'
OCT(N)
This converts a number to its oct equivalence as a string.
>>> oct(28)
'0o34'
BOOL(O)
This converts o to Boolean True or False. In Python, 0, '', and None are equiva­
lent to False, everything else is equivalent to True.
>>> bool(1)
True
>>> bool('school')
True
>>> bool(0)
False
TUPLE(S)
This constructs a tuple from a list, a string, or range() call.
>>> tuple("this is tuple")
('t', 'h', 'i', 's', ' ', 'i', 's', ' ', 't', 'u', 'p', 
'l', 'e')
LEN(S)
This returns the length of a sequence.
>>> len(my_tuple)
13
>>> len("I like Python so much!")
22
LIST(S)
This constructs a list from a sequence or range() call.
	122	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> list(range(5))
[0, 1, 2, 3, 4]
RANGE(START, STOP
, STEP)
This returns a sequence of numbers starting from 0 by default, ending right 
before stop and increasing by one step by default.
>>> list(range(1, 9, 2))
[1, 3, 5, 7]
COMPLEX(A, B)
This constructs a complex number from a pair of numbers and returns the 
complex number.
>>> complex(1, 8)
1 + 8j
HASH(S)
This generates a hash for a given string s and returns the hash. One use is for 
transmitting and saving passwords.
>>> hash("Python is a great language for programming")
6145305589036905122
DIVMOD(A, B)
This returns a tuple of the quotient and the remainder of one integer or float 
number divided by another integer or float number.
>>> divmod(23, 5)
(4, 3)
STR(X)
This converts object x literally to a string and returns the converted string.
>>> str([23, 56, 67, 12, 89])
'[23, 56, 67, 12, 89]'
	
Essential Building Blocks of Computer Programs	
123
 https://doi.org/10.15215/remix/9781998944088.01
CHR(N)
This returns the character n with its code in the Unicode table. Note that 0 <= 
n <= 0x10ffff as a legitimate code.
>>> chr(90)
'Z'
>>> chr(99)
'c'
TYPE(O)
TYPE(C, BASES, DICT)
type(o) returns the data type of object o, whereas type(C, bases, dict) will create 
a new type/class whose name is C and whose base classes are in bases, which 

is a tuple, and the dictionary defines the attributes of the new class, with 
assigned values. This gives programmers a way to dynamically define 

classes.
>>> type(list(range(9)))
<class 'list'>
In [ ]:
X = type('X', (object), dict(a = 1, b = 3))   # create 
a new class named X
x = X()   # create an instance of X
print(f'x.a = {x.a}, x.b = {x.b}')
x.a, x.b = 23, 35   # assign values to x's attribute a 
and b
print(f'x.a = {x.a}, x.b = {x.b}')
Out [ ]:
x.a = 1, x.b = 3
x.a = 23, x.b = 35
ALL(ITERABLE)
This returns True if all the elements of iterable are true.
>>> all(range(9))
False
 
>>> all(range(1,9))
True
	124	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
ANY(ITERABLE)
This returns True if any of the arguments true.
>>> any(range(9))
True
>>> any([0,0,0,0])
False
DIR()
DIR(O)
dir() returns a list of names in the current namespace. dir(o) returns a list of 
the attributes of object o.
>>> dir()
['__annotations__', '__builtins__', '__doc__', '__
loader__', '__name__', '__package__', '__spec__']
 
>>> dir(math)
['__doc__', '__loader__', '__name__', '__package__', 
'__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 
'atan2', 'atanh', 'ceil', 'copysign', 'cos', 'cosh', 
'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 
'factorial', 'floor', 'fmod', 'frexp', 'fsum', 
'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 
'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 
'log1p', 'log2', 'modf', 'nan', 'pi', 'pow', 'radians', 
'remainder', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 
'trunc']
NEXT(IT)
This returns the next element of an iterable such as list, string, tuple, and so on.
>>> l=iter(list(range(3,99)))
>>> next(l)
3
>>> next(l)
4
ASCII(O)
This returns a string containing a printable ASCII representation of an object.
	
Essential Building Blocks of Computer Programs	
125
 https://doi.org/10.15215/remix/9781998944088.01
>>> ascii(math)
"< module 'math' (built-­
in)>"
>>> ascii(int)
"<class 'int'>"
ID(O)
This returns object o’s “identity,” which is a unique integer within a given con­
text, usually the address of the object in memory.
>>> i = 10
>>> id(i)   # return the id of variable i
263313728
>>> i *= 98
>>> id(i)   # id is different, but still the same i
2809440
SORTED(S)
This returns a new sorted list of elements in iterable s.
>>> il = [12, 0, 9, 32, 8, 5, 3, 99] # il is a list of 
integers
>>> sorted(il)   # default is to sort in ascending order
[0, 3, 5, 8, 9, 12, 32, 99]
>>> sorted(il, reverse = 1)   # sorted in descending order
[99, 32, 12, 9, 8, 5, 3, 0]
REVERSED(S)
This returns a reversed iterator.
>>> il = [0, 3, 5, 8, 9, 12, 32, 99]
>>> list(reversed(il))
[99, 32, 12, 9, 8, 5, 3, 0]
>>> list(reversed(range(9))) # range(9) return a sequence 
of 0,1,…9
[8, 7, 6, 5, 4, 3, 2, 1, 0]
ENUMERATE(S, START = 0)
This returns a list of tuples from a sequence in which the elements are counted 
and each element is paired with its count to form a tuple.
	126	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> list(enumerate("this is"))   # default value for 
optional argument start is 0
[(0, 't'), (1, 'h'), (2, '€'), (3, 's'), (4, ' '), (5, 
'€'), (6, 's')]
>>> list(enumerate("this is", 2))   # now counting start 
from 2
[(2, 't'), (3, 'h'), (4, '€'), (5, 's'), (6, ' '), (7, 
'€'), (8, 's')]
>>>
EVAL(S, GLOBALS = NONE, LOCALS = NONE, /)
This evaluates the expression in s as a string or a compiled Python code in s 
and returns the value. Global and local namespaces can be specified for the 
expression or code object using the keyword arguments.
>>> eval("1 / (1 + (1 / math.e) ** 12)")
0.9999938558253978
EXEC(S)
This executes the statement in string s and provides a way to dynamically 
execute the Python code.
>>> exec("print('Hello World!')")
Hello World!
In [ ]:
def cubbie(n):
  return n * n * n
src = "print(cubbie(23))"
exec(src)
Out [ ]:
12167
ZIP(*ITERABLES)
This returns a list of tuples by taking one element from each of the iterables 
to make a tuple until reaching the end of the shortest iterable, and then 
returning the tuple. In Python, *p notation means p takes multiple argu­
ments. In this case, multiple iterables such as lists, tuples, or strings are 

expected.
	
Essential Building Blocks of Computer Programs	
127
 https://doi.org/10.15215/remix/9781998944088.01
>>> grade_n = [50, 70, 80, 90, 100]
>>> grade_c = ['F', 'D', 'C','B', 'A']
>>> list(zip(grade_n, grade_c))
[(50, 'F'), (70, 'D'), (80, 'C'), (90, 'B'), (100, 'A')]
In [ ]:
chars = [chr(i) for i in range(32,97)] # a list of chars
asc_table = zip(range(32,97), chars)
for coding in asc_table:
  print(coding)
Out [ ]:
(32, ' ') (33, '!') (34, '"') (35, '#') (36, '$') (37, '%') (38, '&') (39, "'")(40, '(') (41, ')') 
(42, '*') (43, '+') (44, ',') (45, '-­
') (46, '.') (47, '/') (48, '0') (49, '1') (50, '2') (51, 
'3') (52, '4') (53, '5') (54, '6') (55, '7') (56, '8') (57, '9') (58, ':') (59, ';') (60, '<') 
(61, '=') (62, '>') (63, '?') (64, '@') (65, 'A') (66, 'B') (67, 'C') (68, 'D') (69, 'E') 
(70, 'F') (71, 'G') (72, 'H') (73, 'I') (74, 'J') (75, 'K') (76, 'L
') (77, 'M') (78, 'N') 
(79, 'O') (80, 'P') (81, 'Q') (82, 'R') (83, 'S') (84, 'T') (85, 'U') (86, 'V') (87, 'W') 
(88, 'X') (89, 'Y') (90, 'Z') (91, '[') (92, '\\') (93, ']') (94, '^') (95, '_') (96, '`')
The code sample above prints a portion of ASCII table showing the codes 
from 32 to 96 and their corresponding characters. It is only to show how zip 
function is used. There is a much simpler way to print such a table using just 
one for loop.
MAP(F, *ITERABLES)
This applies function f to every item of an iterable and returns the resulted 
iterator.
>>> import math
>>> list(map(math.sqrt, range(17))
[0.0, 1.0, 1.4142135623730951, 1.7320508075688772, 2.0, 
2.23606797749979, 2.449489742783178]
>>> list(map(sum, ([1, 2, 3], [4, 5, 6], [7, 8, 9, 10])))
[6, 15, 34]
GETATTR(O, ATTR)
This returns the value of object o’s attribute attr, the same as o.attr.
>>> getattr(math, 'sqrt')
<built-­
in function sqrt>
>>> getattr(math, 'e')
2.718281828459045
	128	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
HASATTR(O, ATTR)
This tests if object o has attribute attr and returns True if it does.
>>> hasattr(math, 'e')
True
>>> hasattr(math, 'sqrt')
True
>>> hasattr(math, 'power')
False
SETATTR(O, A, V)
This sets or adds an attribute a to object o and assigns value v to the attribute.
>>> class Student:   # defining a class named Student. By 
convention, class names should be capitalized
…pass   # this defines a class without any attribute
…
>>> s1 = Student()   # create an instance of Student
>>> setattr(s1, 'name', 'John')   # add an attribute 
called name, and assign 'John' to it
>>> s1​
.name
'John'
>>> hasattr(s1, 'name')
True
DELATTR(O, A)
This deletes attribute a from object o.
>>> delattr(s1, 'name') # delete attribute name from 
object s1
>>> hasattr(s1, 'name') # check if s1 has attribute name
False
ISINSTANCE(O, C)
This returns True if o is an instance of class c or a subclass of c.
>>> class Student:
…pass
…
>>> s1 = Student()
	
Essential Building Blocks of Computer Programs	
129
 https://doi.org/10.15215/remix/9781998944088.01
>>> isinstance(s1, Student)
True
ISSUBCLASS(C, C)
This returns True if class c is a subclass of C.
>>> class Graduate(student):
…pass
…
>>> issubclass(Graduate, Student)
True
REPR(O)
This returns a string representation of object o.
>>> repr(Graduate)
"<class "__main__.graduate'>'
FILTER(F, ITERATOR)
This returns an iterator containing only the elements of the iterable for which 
the function returns true.
>>> def even(n):
…return not n%2 # return True if n can be divided by 2
…
>>> list(filter(even, range(9)))   # odd numbers will be 
taken out
[0, 2, 4, 6, 8]
CALLABLE(O)
This returns True if o is a callable object such as a defined function.
>>> callable(even)   # it will return True since even is 
defined
True
LOCALS()
This updates and returns a dictionary of local names/symbols.
	130	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> locals()
{'__name__': '__main__', '__doc__': None, '__package__': 
None, '__loader__': <class '_frozen_importlib.
BuiltinImporter'>, '__spec__': None, '__annotations__': 
{}, '__builtins__': <module 'builtins' (built-­
in)>, 
'math': <module 'math' (built-­
in)>, 'l': <list_iterator 
object at 0x00370230>, 'student': <class '__main__.
student'>, 's1': <__main__.student object at 0x00CE3DB0>, 
'graduate': <class '__main__.graduate'>, 'even': 
<function even at 0x0029F7C8>}
VARS()
VARS(O)
vars() returns the same as locals(), whereas vars(o) returns the _dict_ attribute 
of object o.
>>> setattr(s1, 'name', 'John')
>>> vars(s1)
{'name': 'John'}
GLOBALS()
This updates and returns a dictionary of global names/symbols in the current scope.
>>> globals()
{'__name__': '__main__', '__doc__': None, '__package__': 
None, '__loader__': <class '_frozen_importlib.
BuiltinImporter'>, '__spec__': None, '__annotations__': 
{}, '__builtins__': <module 'builtins' (built-­
in)>, 
'math': <module 'math' (built-­
in)>, 'student': <class 
'__main__.student'>, 's1': <__main__.student object at 
0x00CE3DB0>, 'graduate': <class '__main__.graduate'>, 
'even': <function even at 0x0029F7C8>}
BYTEARRAY([SOURCE[, ENCODING[, ERRORS]]])
This returns a bytearray object which is an array of the given bytes.
>>> s = "Hello Python lover!"
>>> barry = bytearray(s, 'utf-­
8')
>>> print(barry)
bytearray(b'Hello Python lover!')
	
Essential Building Blocks of Computer Programs	
131
 https://doi.org/10.15215/remix/9781998944088.01
BYTES([SOURCE[, ENCODING[, ERRORS]]])
>>> bs = bytes(s, 'utf-­
8')
>>> print(bs)
b'Hello Python lover!'
BREAKPOINT(*ARGS, **KWS)
This function break the program and takes it into debug mode, calls sys.
breakpointhook(), and passes a list of arguments (args) and a list of keyword 
arguments (**kws) to the system function.
@CLASSMETHOD
The at sign @ is called a decorator in Python. This particular decorator is used to 
declare a method as class method, which receives the class as its first argument.
# define a class Person
class Person:
    # define a class attribute
    species = "human"
    # define an instance method
    def __init__(self, name, age):
        self​
.name = name
        self.age = age
    # define a class method using the @classmethod 
decorator
    @classmethod
    def from_birth_year(cls, name, birth_year):
        # calculate the age from the birth year
        age = 2023 -­
 birth_year
        # return a new instance of Person with the given 
name and age
        return cls(name, age)
# create an instance of Person using the class method
p1 = Person.from_birth_year("Alice", 1995)
# print the instance attributes
print​
(p1​
.name) # output: Alice
print(p1.age) # output: 28
print(p1.species) # output: human
	132	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The code above was taken from a code cell in Jupyter Notebook. The output 
is as follows when you hit the Ctrl+Enter key to run the code:
Alice
28
Human
COMPILE(SOURCE, FILENAME, MODE, FLAGS = 0, DONT_INHERIT 
= FALSE, OPTIMIZE = −1)
This is used to compile the source into a code that can be executed using eval() 
or exec().
FORMAT(VALUE[, FORMAT_SPEC])
This is used to convert a value to a “formatted” representation, as controlled 
by format_spec.
>>> print("Modern computers have over {h:3d} years of 
history".format(h = 80))
Modern computers have over 80 years of history
FROZENSET([ITERABLE])
This returns a new frozenset object, with the option to display it with elements 
taken from an iterable. frozenset is also a built-­
in class.
>>> l = list(range(10))
>>> print(frozenset(l))
frozenset({0, 1, 2, 3, 4, 5, 6, 7, 8, 9}) # {…} is 
a set
HELP([OBJECT])
This invokes the built-­
in help system on the object.
>>> help(frozenset)
Using help on class frozenset in module builtins displays the following:
class frozenset(object)
 |  frozenset() -­
> empty frozenset object
 |  frozenset(iterable) -­
> frozenset object
 |
	
Essential Building Blocks of Computer Programs	
133
 https://doi.org/10.15215/remix/9781998944088.01
 |  Build an immutable unordered collection of unique 
elements.
 |…
.
INPUT([PROMPT])
This is used to read a line from input, convert it to a string with trailing newline 
characters stripped, and return the string. The optional prompt argument will 
be displayed without a trailing newline character so that the cursor will just 
wait at the end of the prompt for input.
>>> s = input("please give me an integer:")
please give me an integer:
ITER(OBJECT[, SENTINEL])
This returns an iterator object. If the second argument doesn’t exist, the first 
argument must be a collection object.
>>> for c in range(6): print(next(l))
…
P
y
t
h
o
n
MEMORYVIEW(OBJ)
This returns a “memory view” object of obj. Note that obj must be a bytes-­
like 
object.
>>> mv = memoryview(b"Hello Python Lover")
>>> print(mv)
<memory at 0x000001B932AD4A00>
OBJECT
This returns a new featureless object, a base for all classes.
>>> O = object
>>> print(O)
<class 'object'>
	134	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
OPEN(FILE, MODE = 'R', BUFFERING = −1, ENCODING = NONE, 
ERRORS = NONE, NEWLINE = NONE, CLOSEFD = TRUE, 
OPENER = NONE)
This opens the file in the desired mode and returns a corresponding file object. 
The default mode is read.
>>> f = open('scoresheet.txt', 'w')
The example opens a file named scoresheet.txt for writing and assigns the 
handle to f.
PRINT(*OBJECTS, SEP = ' ', END = '\N', FILE = SYS.STDOUT, 
FLUSH = FALSE)
This prints objects to the text stream file, separated by separator and followed by 
end. sep, end, file, and flush, if present, must be given as keyword arguments.
>>> print("Hello Python Lover!")
Hello Python Lover!
PROPERTY(FGET = NONE, FSET = NONE, FDEL = NONE, 
DOC = NONE)
This returns a property attribute. fget, sfet, and fdel take functions for getting, 
setting, and deleting an attribute value.
SLICE(STOP)
SLICE(START, STOP[, STEP])
These return a slice object representing the set of indices specified by 
range(start, stop, step).
>>> s = "Hello Python Lover!"
>>> slicing = slice(3)   # slicing the first 3 items out 
of an object
>>> print(s[slicing])   # this will take the first three 
characters from the s
Hel
@STATICMETHOD
This function decorator is used to declare a method as static. A static method 
can be called on the class or an instance.
	
Essential Building Blocks of Computer Programs	
135
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
class FTool():
    @staticmethod
    def percentage(a, b):
        return a/b
r = FTool.percentage(13, 265)
print(f"{13}/{256} is {r}")
Out [ ]:
13/256 is 0.04905660377358491
SUPER([TYPE[, OBJECT-­
OR-­
TYPE]])
This returns a proxy object that delegates method calls to a parent or sibling 
type class. It is used for accessing inherited methods that have been overridden 
in a class.
In [ ]:
class FTool():
    @staticmethod
    def percentage(a, b):
        return a/b
print(super(FTool))
Out [ ]:
<super: <class 'FTool'>, NULL>
The superclass is NULL because FTool is not a subclass of any class except 
object, which doesn’t count.
Expressions
Expressions are important program constructs. An expression is made up of 
data items, variables, constants, and function calls joined by proper operators. 
The precedencies of the operators are as follows:
	
1.	 Within arithmetic operators, other operators take precedence over 
addition and subtraction.
	
2.	 Arithmetic operators take precedence over comparison operators.
	
3.	 Membership operators, identity operators, and comparison operators 
take precedence over logic operators.
	
4.	 Among logic operators, the order of precedence, from high to low, is 
not > and > or.
	136	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
CODING ALERT
Python language is case-­
sensitive. Be sure to use the right case when 
typing!
Expressions are used almost everywhere in a program and will be evaluated 
to a value or object in a general term. According to the type of the value or object 
from evaluation, an expression can be any of the following.
ARITHMETIC EXPRESSIONS
An arithmetic expression’s value is always one of the following: an integer, 
float, or complex. An arithmetic expression can be made of data, variables, 
function calls, and arithmetic operators. When mixed data types appeared in 
an expression, the value type of the expression will be the most general data 
type. For example, the value of 3 + 5.6 will be a float number.
STRING EXPRESSIONS
The string expression’s value is a string. String expressions are made of strings, 
string operators, functions and methods that return a string.
BOOLEAN EXPRESSIONS
The Boolean expression’s value is either True or False. Boolean expressions 
can be made of data, comparison operators, and logical operators. Note that 
although Python has True and False defined as logical true and false, it treats 
0, None, empty string, empty list, empty tuple, set, and dictionary as False and 
treats everything else as True.
OTHER EXPRESSIONS
The values of some expressions may be a list, tuple, set, dictionary or even a 
complex object. For example, some functions and methods can return a list or 
an object of a user-­
defined class, and the operator + can be used to combine 
two strings or lists together.
The following are some examples of expressions in Python:
12 + 35.6 -­
 36 * 3 + x   # integer and float numbers can 
be mixed
235 + x ** k   # 235 plus x to the power of k
2 < j and j in list_x   # 2 is less than j and j is a 
member of list x
	
Essential Building Blocks of Computer Programs	
137
 https://doi.org/10.15215/remix/9781998944088.01
Expressions are often used on the right-­
side of an assignment operator, 
such as
total = a1 + a2 + a3
i *= j + 2   # the same as i = i * (j + 2)
CODING ALERT
In Python, # is used to add end-­
of-­
line comments. Anything behind # is 
ignored by PVM.
CODING PRACTICE
Within VS Code, create a new Jupyter Notebook and rename it 
section-­
2.1, or double-­
click the notebook name on the left-­
hand file 
navigation area to open the notebook if you have already created one. 
In a cell, type the following code and hit Shift+Enter to run the code. 
Then manually evaluate the expression within the curly braces of the 
print statement and compare your result to the one given by the code. 
Explain why the results are different.
x, y = 10.23, 5.2
m, n = 27, 8
print(f'{x * y + 27 // n}')
2.2 Higher-­
Level Constructs of Python Programs
The constructs you learned in section 2.1 are small and meant to be used as 
parts of bigger ones. The big constructs of programs are called statements, 
which give explicit instructions to computers to act upon.
Structure of Python Programs
Before diving into the details of writing statements in Python, this section will 
first look at the general structure of a Python program and the coding style 
widely agreed upon among the Python community, which will make it so the 
programs that you write are readable to others.
For a simple application, a single Python file (with py as its extension) may 
be enough to contain all the program code needed to implement the application; 
	138	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
for a more complex application, however, several or even hundreds of Python 
files may be needed. Of these files, there will be only one Python file defin­
ing the starting point of the program that implements the application, while 
all other files are used as modules to be imported into the main Python file, 
either directly or indirectly. So essentially, the relationships of all the Python 
files used for an application can be depicted as a tree in which the root is the 
main Python file.
The modules used directly or indirectly by the main Python program may 
be from the standard libraries installed with Python or from those installed 
later using the conda or pip command as needed.
Regarding coding style, see PEP 8: Style Guide for Python Code (https://​
pep8​
.org/), which describes in great detail how Python code should be writ­
ten. Read it thoroughly and review it whenever you are unsure. Below are 
the highlights:
	
1.	 A Python program/script file should begin with a docstring as the 
main documentation of the program file, stating the application 
and functionality of the program, as well as the author and revision 
history.
	
2.	 In a script file, use double blank lines to separate the actual program 
code from the documentation section at the beginning of the file.
	
3.	 Also use double blank lines to separate top-­
level function and class 
definitions.
	
4.	 Use a single blank line to surround the definition of a method in a 
class definition.
import
import
import
import
import
import
Main PY
ﬁle
Module 1
Module 2
Module m
Module 11
Module 21
Module m1
Figure 2-­
5: Illustration of the structure of files for a Python application
	
Essential Building Blocks of Computer Programs	
139
 https://doi.org/10.15215/remix/9781998944088.01
	
5.	 Pay attention to indentation, especially when an expression, a simple 
statement, or the header of a compound statement is too long and 
needs to cross multiple lines.
	
a.	 When an expression or a statement needs a closing brace, bracket, 
or parenthesis mark to complete it, there is no need to escape (\) 
newline at the end of an unfinished line.
	
b.	 When a string needs to cross multiple lines, newline must be 
escaped by putting a backslash at the end of each unfinished 
line.
	
c.	 The four-­
space rule is optional. The next line can be started 
wherever it makes more sense, such as in the column next to the 
opening delimiter.
In addition to the rules of coding, it’s important to maintain a consistent coding 
style and to make sure that the programs not only are easy to read and under­
stand but also look neat and nice.
Documentation and Comments
As mentioned above, some lines of documentation, called docstring, are needed 
at the very beginning of each Python script/program file to state the purpose and 
functionality of the program, who made it and when, and notes for you and others 
who may read the program.
The following sample program calculates the area of a circle for a given 
radius. It shows how docstring is used in the program file.
1
"""
2
This program is used to calculate the area of a circle. It 
will take an input as
3
a radius, then calculate and print out the area.
4
5
File name: circle.py
6
Author: John Doe
7
Date: March 30, 2019
8
Version: 1.0
9
"""
10
11
12
radius = int(input("tell me the radius:"))   # take input 
from user
13
area = 3.14 * radius ** 2   # calculate the area
14
print(f"The area of a circle with radius {radius} is 
{area}")   # print
15
	140	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Please note the triple quotation marks on line 1 and line 9. The triple quota­
tion marks on line 1 mark the start of the docstring, whereas the triple quotation 
marks on line 10 mark the end of the docstring. The quotation marks can 
be single or double, but they must be the same. You can also add docstrings 
for functions, classes, class methods, or other code blocks in the program as 
needed, but the opening triple quotation marks and ending triple quotation 
marks must be indented the same amount as the code block. You will see how 
this should be done in later chapters, with examples.
Please also note the comments starting with a # at the end of lines 13, 14, 
and 15. They are called end-­
of-­
line comments or block notes. An end-­
of-­
line 
comment is usually used to explain what the code on the line does. Everything 
behind the # mark on that line is ignored by Python Virtual Machine (PVM) 
and intended for only humans to read. An end-­
of-­
line comment can also be 
started at the beginning of a line.
The difference between docstrings and end-­
of-­
line comments is that doc­
strings are formal documentation of the program or module and are accessible 
through the built-­
in help() function, with the _doc_ variable automatically 
attached to each module, function, class and method, whereas end-­
of-­
line 
comments are not. As well, utility tools such as pydoc are available for gen­
erating formal documentation for a program or module from the docstrings 
within each Python file. The revised version of program circle​
.py is shown 
below, in which we defined a function named area, with docstrings added to 
the function and the program.
1
"""
2
The purpose: revised circle.py program with more 
docstrings, to demonstrate how docstrings and
3
inline documentation is used in Python programs.
4
5
This program is designed to calculate the area of a circle. 
It takes an input from the user for the radius and
6
calculates and prints out the area.
7
8
File name: circle-­
v2.py
9
Author: John Doe
10
Date: March 30, 2019
11
Version: 1.0
12
"""
13
14
def area(r):
15
"""To calculate the area of a circle for a given 
radius."""
16
  return 3.14 * r ** 2   # calculate the area
	
Essential Building Blocks of Computer Programs	
141
 https://doi.org/10.15215/remix/9781998944088.01
17
"""Add docstring after return statements?"""
18
19
radius = int(input("tell me the radius:"))   # take input 
from user
20
print(f"The area of a circle with radius {radius} is 
{area(radius)}")   # printout
21
22
"""I want to add more docstrings."""
The following are some general rules for program documentation:
	
1.	 A docstring should also be written for every function, class, and public 
method right after the header of the definition. Docstrings must be 
indented the same amount as the suite of function or class definition.
	
2.	 Limit the maximum line length to 79 or 72 characters if the line is part 
of a docstring.
	
3.	 Use inline comments whenever necessary.
	
4.	 Some code may need more than one line of comments, which makes 
it a block comment. A block comment should be written right before 
the code and indented to the same level as the code below.
CODING TRICK
Document! Document! Document!
Documentation is necessary not only for users but for the programmer 
who made the program. The programmer may think they know every­
thing about the program, but time can blur their memory.
Simple Statements
Normally, a simple statement is contained within a single logical line, though 
Python allows several simple statements to appear on one line separated by 
semicolons. There will be examples of this later.
EXPRESSION STATEMENT
Simply put, expression statements in Python programs are just expressions in 
mathematical terms. Any expression can be used as a statement, and PVM will 
evaluate every expression statement, but the result is only displayed in Python 
interactive mode, as shown in the following code sample in the Python Shell:
	142	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Code sample in Python interactive mode
1
2
>>> 2 * 3.14 * 15
3
94.2
4
>>> 3.14 * 15 ** 2
5
706.5
6
>>>
7
8
So if you are using Python in interactive mode, you can simply type expressions 
without using the print statement to see the result of the calculation, just like 
a powerful calculator.
We can also have expression statements in Jupyter Notebook, but when 
there are several expression statements in the same cell, it will only show the 
result of the last expression, as shown in the following example:
In [ ]:
2 * 3.14 * 15
3.14 * 15 ** 2
Out [ ]:
706.5
We mentioned earlier in this subsection that you can also put several simple 
statements on the same line, but you must separate them with semicolons. This 
is shown in the following examples:
Code sample in Python interactive mode
1
2
>>> 2 * 3.14 * 15; 3.14 * 15 ** 2
3
94.2
4
706.5
5
>>> 
6
7
8
The expression statement above can also be given in Jupyter Notebook, as 
shown below. In Jupyter Notebook, however, you have to press Shift+Enter or 
click the play button to run the scripts in an active cell:
	
Essential Building Blocks of Computer Programs	
143
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
2 * 3.14 * 15; 3.14 * 15 ** 2
Out [ ]:
706.5
Again, in Jupyter Notebook, even if multiple expression statements are 
on the same line, only the result of the last expression statement will be 
displayed.
ASSIGNMENT STATEMENT
The assignment statement is one of the most important statements and is used 
most often in programs because it is a common requirement to keep the result 
of computing or information processing in the computer memory for future 
uses. It does so by assigning the result to a variable.
In section 2.1, we saw a list of assignment operators. Formally, an assign­
ment statement is made of a variable on the left and an expression on the right 
of an assignment operator, either = or an augmented one such as +=. We have 
already seen some examples of assignment statements before, but the following 
code sample includes a few more examples:
In [ ]:
d = 15
r = d / 2
x = d * 3.14
a = r * r * 3.14
print(f"diameter = {d}; radius = {r}; circumference = 
{x}; area is {a}")
Out [ ]:
diameter = 15; radius = 7.5; circumference = 47.1; area is 176.625
AUGMENTED ASSIGNMENT
In programming, we often take the value of a variable, perform an operation 
on it, then put the result back to the variable. That is when augmented assign­
ment comes into play.
In section 2.1, we saw several augmented assignment operators. In general, 
for an assignment in the form of
x = x <operator> v
the augmented assignment can be used in the following form:
x <operator>= v
	144	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The following are some examples of augmented assignments:
In [ ]:
y = 10
n = 5
print(f"y is {y}; n is {n}")
y *= n   # y * n is assigned to y; it is equivalent to 
y = y * n
print(f"y is {y}; n is {n}")
n += 2
y /= n
print(f"y is {y}; n is {n}")
Out [ ]:
y is 10; n is 5
y is 50; n is 5
y is 7.142857142857143; n is 7
To understand these augmented assignment statements, we need to consider 
the memory location referred to by a variable, such as y with respect to time. Take 
y *= n as an example. At time t0 before the actual assignment starts, the value 

of y (data stored in the memory referred to by y, which is 10 at time t0) is taken out, 
and multiplied by n, whose value is 5 at time t0; then time t1—­
the result, which 
is 50 (from 10 * 5)—­
is stored in the memory location referred to by variable y.
CODING ALERT
The number of value items must be enough for the variables to be 
assigned.
MULTIPLE ASSIGNMENTS
Also, for convenience and efficiency, you can assign values to multiple variables 
in a single assignment statement. There are several ways of doing multiple 
assignments, as shown in the following examples:
In [ ]:
x, y = 1, 2   # assign 1 to x, assign 2 to y
(x, y) = (1, 2)   # it is the same as x, y = 1, 2
x, y = [1, 2]   # it is the same as x, y = 1, 2
k, *l = [1, 2, 3, 5]   # this will assign 1 to k, and 
assign the rest to l as list, because of *l
x, *y, z = [1, 2, 3, 5, 6, 7]   # this will assign 1 to 
x, 7 to z, [2, 3, 5, 6] to y
print(f"x = {x}; y = {y}; z = {z}")
Out [ ]:
x = 1; y = [2, 3, 5, 6]; z = 7
	
Essential Building Blocks of Computer Programs	
145
 https://doi.org/10.15215/remix/9781998944088.01
In the last example above, *l, *y tells PVM that variable l and y can take a 
variable-­
length list of values.
CONDITIONAL ASSIGNMENTS
Additionally, in Python, you may even assign different values to a variable under 
different conditions, as shown in the following example:
Code sample in Python interactive mode
1
>>> marks = 90
2
>>> gr = 'pass' if marks >= 60 else 'fail'   # note that 
elif clause does not work on the conditional assignment
3
>>> gr
4
'pass'
5
>>> marks = 50
6
>>> gr = 'pass' if marks >= 60 else 'fail'
7
>>> gr
8
'fail'
As you will see throughout the text, there are many fancy ways of making state­
ments in Python, and that’s why Python is a very powerful language. Indeed, 
the full power of a programming language can only be materialized by the 
best programmers.
ANNOTATED ASSIGNMENT STATEMENT
We know that variables in Python are dynamically typed. Sometimes, however, 
it is nice to indicate what type of data is expected for a variable. In Python, this 
is done by annotating the variable using a colon followed by the name of the 
data type, as shown in the following example:
marks: float = 86.5   # variable marks will hold a float 
number
However, Python will not complain if other types of data are assigned, as 
shown below:
>>> marks: float = "Python"
>>> marks
'Python'
>>>
To annotate the type of value returned from a function, you need to use -­
> fol­
lowed by the data type, right before the colon, as shown in the following example:
	146	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
def literal_grade(marks:float) -­
> str:
  return 'fail' if marks < 60 else 'pass'
print(literal_grade(88))
Out [ ]:
pass
In this example, marks:float determines that a float number is expected for 
marks when calling the function, and -­
> str dictates that a string is to be returned.
It must be made clear that the actual type of a variable is still determined 
by the value it holds, and annotation added to a variable or function doesn’t 
really change the type of the variable or the value returned from a function. 
So annotations are more for programmers as reminders.
PRINT STATEMENT
The print statement is another one of the most important statements. It 

is used to output (to a terminal by default) so that a program can tell human 
users the result of calculations or information processing, the value of an 
object, or the status of the program. The following are some examples of 
print statements:
In [ ]:
print("this is my first print statement.")
print("it will take about ", round(300/110), "hours to 
drive from Edmonton to Calgary")
Out [ ]:
this is my first print statement.
it will take about 3 hours to drive from Edmonton to Calgary
The print statement can evaluate multiple arguments and print out the val­
ues. If the arguments are all constant strings, there will be no need to separate 
them into multiple arguments. Separate arguments are needed only when some 
arguments are expressions, like the round(300/110) in the above example. If 
you do not like separations, introduced in release 3.0, Python provides a neat 
way to include expressions all in a single pair of quotation marks, as shown in 
the following example:
In [ ]:
print(f"it will take about {round(300/110)} hours to 
drive from Edmonton to Calgary")
Out [ ]:
it will take about 3 hours to drive from Edmonton to Calgary
	
Essential Building Blocks of Computer Programs	
147
 https://doi.org/10.15215/remix/9781998944088.01
Please note the f—­
which is a flag or prefix—­
before the opening quotation 
mark and the curly brackets around the expression. Without the f flag, every­
thing will be taken literally as part of the string, without evaluation.
If you want one portion of the string to be put on one line and the other 
portion on the next line, you may insert \n between the two portions in the 
string, as below:
In [ ]:
print(f"it will take about {round(300/110)} hours \nto 
drive from Edmonton to Calgary")
Out [ ]:
it will take about 3 hours
to drive from Edmonton to Calgary
In addition to \n, other escape sequences that we discussed previously may 
also be included in a string.
There may be times that you want to include an escape sequence such as 
\n in a string as is. To achieve that effect, you either use the r flag before the 
opening double quotation mark or use another backslash \ before the escape 
sequence to cancel the first backslash (escape), as shown in the following 
example:
In [ ]:
print(r"there will be no escape \n to newline")   # 
using the r flag
print("there will be no escape \\n to newline")   # 
using double backslash
Out [ ]:
there will be no escape \n to newline
there will be no escape \n to newline
Without the r flag, the sentence will be printed on two lines, as shown in the 
following example:
In [ ]:
print("there will be no escape \nto newline")
Out [ ]:
there will be no escape
to newline
Normally, a \n (newline) will be automatically appended to the output from 
each print statement by default, so that the output from the next print state­
ment will print on a new line. If you want the output from a print statement 
to end with something else rather than a new line, you may use the end key­
word argument to specify how the output should be ended. In the following 

	148	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
example, output from the first print statement will be ended with a whitespace, 
so that outputs from the two print statements will be on the same line:
In [ ]:
print("this is my first print statement.", end=" ")
print("it will take about ", round(300/110), "hours to 
drive from Edmonton to Calgary")
Out [ ]:
this is my first print statement. it will take about 3 hours to drive from 
Edmonton to Calgary
Formally, a print statement may take the following form when used:
print(value0, value1, value2,…, sep=' ', end = '\n', file 
= sys.stdout, flush = False)
where value0, value1,… are values to be printed to a file stream; optional 
keyword argument sep defines what is used to separate value0, value1,…; 
optional keyword argument end tells how the output from the print statement 
should end; optional keyword argument file defines what file stream the 
output should be printed on; and optional keyword argument flush tells how 
the output should be flushed. The meanings and purposes of these optional 
keyword arguments are explained in Table 2-­
16.
Table 2-­
16: Key arguments of the print statement
Keyword argument
Values that can be taken
Default value
sep
it takes a string as its argument and 
inserts it between values
a space
end
it also takes a string as argument but 
appends it to the last value of the 
output stream
a new line
file
it is a file handle such as that returned 
by an open statement
sys.stdout
flush
it takes a Boolean value (True or 
False) indicating whether to forcibly 
flush the output stream
False
Please note that a program may need to output different types of data 
not only correctly but also nicely. In 5.1, we will learn how to construct well-­
formulated strings from various types of data.
	
Essential Building Blocks of Computer Programs	
149
 https://doi.org/10.15215/remix/9781998944088.01
INPUT STATEMENT
The input statement is another important one you must learn and use correctly 
and effectively. Contrary to the print statement, the input statement is used to 
get information from users through the keyboard, as shown in the following 
example in Jupyter Notebook:
In [ ]:
your_age = input("Please tell me your age:")
print("Now I know your age is", your_age)
Out [ ]:
Please tell me your age: 39
Now I know your age is 39
Please note that everything taken from users through the input statement is 
treated as a string. If you are expecting a number, such as an integer, you must 
convert the string into its respective data type, as shown in the following example:
In [ ]:
your_age = input("Please tell me your age:")
your_age = int(your_age)
print(f"In 50 years your age will be {your_age + 50}")
Out [ ]:
Please tell me your age: 39
In 50 years, your age will be 89
As you may have guessed already, the input statement takes one argument as 
a prompt to tell users what to do and what the program is expecting from the user.
If you want to provide more detailed instructions in the prompt to the user, 
you may use the triple quotation marks to include multiple lines of instruction 
as prompt:
In [ ]:
sl = input("""Your choices
A: to get the average mark
M: to get the mean of all marks
H: to get the highest mark
L: to get the lowest mark
Q: to exit the program
Please select___""")
Out [ ]:
Your choices
A: to get average the mark
M: to get the mean of all marks
H: to get the highest mark
L: to get the lowest mark
Q: to exit the program
Please select___
	150	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
As you can see, this can be a good way to make a menu for some terminal-­
based applications.
ASSERT STATEMENT
The assert statement is used to test if a condition is true in a program. It may 
take one of two forms, as shown in Table 2-­
17.
Table 2-­
17: Semantics of assert statement
Syntax
Meaning
assert <condition>
if <condition> is false, the program will stop and raise 
AssertionError
if <condition> is True, the program will run ahead
assert <condition>,
<error message>
if <condition> is false, the program will stop and raise 
AssertionError, along with <error message>
The assertion statement is very useful in debugging your programs, because 
it can be used to check the value of a variable or a certain condition of the pro­
gram. If the condition is not met as expected, the program would stop and let 
you check what’s going on, as shown in the following examples:
In [ ]:
def average_incomes(incomes):
  assert len(incomes) != 0, "Error: need at least one 
income"
  return sum(incomes) / len(incomes)
incomes = [35892, 13487, 56852, 135278, 87542]
print("Average of incomes is",average_incomes(incomes))
incomes = []
print("Average of incomes is",average_incomes(incomes))
Out [ ]:
Average of incomes is 65810.2
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
AssertionError Traceback (most recent call last)
<ipython-­
input-­
2-­
201cb13363c6> in <module>
6 print("Average of incomes is",average_incomes(incomes))
7 incomes = [] -­
-­
8 print("Average of incomes is","average_incomes(incomes))
<ipython-­
input-­
2-­
201cb13363c6> in average_incomes(incomes)
1 def average_incomes(incomes):
-­
-­
 2 assert len(incomes) != 0, "Error: there must be at least one income"
3 return sum(incomes)/len(incomes)
4
5 incomes = [35892, 13487, 56852, 135278, 87542]
AssertionError: Error: there must be at least one income
	
Essential Building Blocks of Computer Programs	
151
 https://doi.org/10.15215/remix/9781998944088.01
PASS STATEMENT
As the name implies, this statement does nothing. It is used as a placeholder 
in places where you don’t have the actual code yet. As an example, assume you 
have the class Student in your design for a project, but the implementation 
details of the class, except the name, are yet to be worked out. You can use the 
pass statement to hold the place of the details, as shown below:
In [ ]:
class Student():
  pass
s1 = Student()
s2 = Student()
With the pass statement in place, this piece of code can run as part of a big 
program without raising an exception.
Note that a pass statement won’t let you get out of a loop. You will need to 
use the break statement to get out of a loop.
DEL STATEMENT
This statement is used to delete an object. Because Python treats everything 
as an object, you can use this statement to delete everything you’ve defined.
In [ ]:
grade = 99
print(f"grade = {grade}")
del grade
print(f"grade = {grade}")
Out [ ]:
grade = 99
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
NameError Traceback (most recent call last)
<ipython-­
input-­
9-­
2b1bea6f987e> in <module>
3
4 del grade
-­
-­
 5 print(f"grade = {grade}")
NameError: name 'grade' is not defined
Deleting an object will free up the memory locations occupied by the object. 
Computer memory is a precious resource in computing. Python objects, even 
objects of built-­
in data types—­
such as list, tuple, set, and dictionary—­
can take 
up a great deal of memory. Deleting the objects that are no longer used will 
free up memory and make it available for other objects and other applications.
	152	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
RETURN STATEMENT
The return statement is one of the most important statements in Python (and 
some other languages as well). It is used to return a value from a function—­
a 
very important construct of all programs. The following is an example:
In [ ]:
def cube(n):
  return n ** 3
print(f'The cube of 23 is {cube(23)}')
Out [ ]:
The cube of 23 is 12167
This function simply takes a number and returns n to the power of 3.
Please note that in Python, the return statement doesn’t have parentheses 
around the value to be returned. Even if you want to return multiple values 
from a function, you only need to use commas to separate the values behind 
the return keyword. The return statement will automatically pack all the values 
in a tuple and then return them.
In the following example, we define a function of a modular operation but 
return the quotient and the remainder at the same time:
In [ ]:
def modular(a, b):
  assert b != 0, 'Zero divisor'
  return a // b, a % b
print(modular(13, 6))
Out [ ]:
(2, 1)
OPEN STATEMENT
The open statement is used to open a file for writing, reading, appending, or 
updating (reading and writing). The following is an example:
f = open("c:\\workbench\\myprimes.txt", 'r')
This opens the file specified by c:\\workbench\\myprimes.txt and creates a 
file object ready for reading. Reading is the default mode when you open a file 
without the second argument. Hence the following statement does the same 
as the above statement:
f = open("c:\\workbench\\myprimes.txt")
	
Essential Building Blocks of Computer Programs	
153
 https://doi.org/10.15215/remix/9781998944088.01
To open a file for writing, w is used for the second argument:
f = open("c:\\workbench\\myprimes.txt", 'w')
When a file is opened for writing, the old data will be overwritten if there is 
already data in the file. To keep the old data and append new data to the file, 
use a for the second argument instead:
f = open("c:\\workbench\\myprimes.txt", 'a')
If you want to create a file only if the file doesn’t exist, use x for the second 
argument, to mean exclusive creation of the file:
f = open("c:\\workbench\\myprimes.txt", 'x')
This would avoid accidentally overwriting a file.
By default, data written to a file opened with w, a, or x is text. The data on 
a file can also be in binary format. To explicitly indicate whether data on a file 
are or should be text or binary, you can use t or b with r, w, a, or x, as shown 
in the following examples:
f3 = open("c:\\workbench\\mykey.dat", 'bw')
f5 = open("c:\\workbench\\mykey.dat", 'br')
YIELD STATEMENT
The yield statement is used in place of the return statement in some special 
circumstances when defining a function. When the yield statement is used 
in defining a function, the function becomes a generator in Python terms, as 
shown in the following example:
In [ ]:
def odds(n):
  for i in range(n):
    yield 2 * i + 1 # yield makes the function a generator
odd_numbers = odds(12)
print(f"type of object odd_numbers is 
{type(odd_numbers)}")
for i in odd_numbers:
  print(i, end = ' ')
Out [ ]:
type of object odd_numbers is <class 'generator'>
1 3 5 7 9 11 13 15 17 19 21 23
	154	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
When we say a function becomes a generator, we mean that an object of 
the generator class is returned from the function.
What is a generator object? For now, you may consider it a dynamic list 
whose members are generated and used dynamically on the fly, without using 
a big bunch of memory to store the whole list. The following is an example 

of a generator:
Object_generator = (x ** 3 for x in range(13))
If we run
for i in Object_generator:
  print(i)
we will see the following members:
0, 1, 8, 27, 64, 125, 216, 343, 512, 729, 1000, 1331, 1728,
However, if we try to get the length of the generator object with the follow­
ing statement:
print(f"{len(object_generator)}")
we will get the following error:
TypeError: object of type 'generator' has no len()
This confirms that an object of type generator has no length.
RAISE STATEMENT
When some errors occur in a Python program, exceptions will be automatically 
raised and the program will stop running, unless the exception is handled 
with the try-­
except statement. Such errors include operations deemed illegal 
by Python. In some cases, an exception needs to be explicitly applied when a 
certain condition is met. In the previous section, we saw how an exception can 
be raised with the assert statement. In the following example, we show how to 
raise an exception with the raise statement.
	
Essential Building Blocks of Computer Programs	
155
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
total = 0
for i in range(39):
  mark = int(input("Tell me a mark:"))
  if mark < 0:
    raise Exception("No negative mark is accepted!")
    total += mark
print(f'average mark is {total / 39}')
Out [ ]:
Tell me a mark: -­
12
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
Exception Traceback (most recent call last)
<ipython-­
input-­
13-­
f4aa3f6c4326> in <module>
3 mark = int(input("Tell me a mark:"))
4 if mark < 0:
-­
-­
 5 raise Exception("No negative mark is accepted!")
6 total += mark
7 print(f'average mark is {total / 39}')
Exception: No negative mark is accepted!
This piece of code is used to calculate the average marks of 39 students, but 
it considers a negative mark unacceptable and will raise an exception.
BREAK STATEMENT
The break statement is used to get out of a loop and continue to the next state­
ment. Here is an example:
In [ ]:
for i in range(10):
  print(i, end = " ")
  if i == 8:
    print(f"\nget out of the loop when i = {i}")
  break
Out [ ]:
0 1 2 3 4 5 6 7 8
get out of the loop when i = 8
CONTINUE STATEMENT
The continue statement is used within a loop code block to continue to the next 
iteration of the loop and ignore the rest of the code block. This statement can 
be very useful if you don’t want to run some statements when some condition 
is met.
	156	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
IMPORT STATEMENT
The import statement is used to import modules into a program file or a specific 
class within the module. The following is an example of how to import the 
standard math module into the program:
In [ ]:
import math
print(f"98 ** 3 = {math.pow(98, 3)}")
Out [ ]:
98 ** 3 = 941192.0
GLOBAL STATEMENT
A global statement simply declares, within a code block such as function or 
class, that some identifiers/names such as variables should be treated as globally 
writable. Without a global statement, a variable defined outside of a function or 
class may be read, but writing to the variable will raise an exception, as shown 
in the following examples:
In [ ]:
gravity = 9.807   # gravity on the earth's surface, 
global variable
r_earth = 6371000   # the earth's mean radius 6371000 
metres
def changed_gravity(m):   # m is the distance from the 
earth
  gravity = gravity * (r_earth/(r_earth+m)) ** 2   # 
decrease gravity by 2
  return gravity
print(f'gravity at 99999 metres above sea level is 
{changed_gravity(99999)} or {gravity}')
Out [ ]:
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
UnboundLocalError Traceback (most recent call last)
<ipython-­
input-­
36-­
7f10379e5fb0> in <module>
6 return gravity
7
-­
-­
 8 print(g_force(99999))
<ipython-­
input-­
36-­
7f10379e5fb0> in g_force(m)
3
4 def changed_gravity(m):
-­
-­
 5 gravity = gravity * (r_earth/(r_earth+m))**2
6 return gravity
7 UnboundLocalError: local variable 'gravity' referenced before assignment
	
Essential Building Blocks of Computer Programs	
157
 https://doi.org/10.15215/remix/9781998944088.01
In the code above, gravity is first introduced outside the function definition. It 

became a global variable by the rule of naming scopes. Inside the definition 
of function changed_gravity, the name was defined again by putting it on the 
left side of the assignment, but only locally by default, according to the rules. 
However, this local variable is used on the right side of the same assignment 
statement. That is how the exception has occurred.
Since what we actually want is to use the globally defined variable gravity 
on both sides of the assignment statement within the function definition, we 
need to explicitly declare that, as shown in the following example revised 
from above:
In [ ]:
gravity = 9.807   # gravity on the earth's surface, 
global variable
r_earth = 6371000   # the earth's mean radius is 
6371000 metres
def changed_gravity(m):   # m is the distance from the 
earth
  global gravity
  gravity = gravity * (r_earth / (r_earth+m)) ** 2
  return gravity
print(f'gravity at 99999 metres above sea level is 
{changed_gravity(99999)} or {gravity}')
Out [ ]:
gravity at 99999 metres above sea level is 9.506238807104731 or 
9.506238807104731
As you can see, the value of global variable gravity has now been changed 
within the function.
NONLOCAL STATEMENT
We have seen global variables and local variables, and how global variables 
are accessible globally, whereas local variables are only accessible within 
a local scope such as a function. There is something between global and 
local called nonlocal. The nonlocal statement can be used to declare a list 
of variables that are not local but refer to variables defined in the nearest 
enclosing scope but excluding global variables. This may happen when 
defining a function within another function, as shown in the following 

example:
	158	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
def outer_logger():
  event = 'Something has happened.'
def inner_logger():
  nonlocal event
  event += "Something else has happened as well."
  print("inner log:", event)
inner_logger()
  print("outer log:", event)
outer_logger()
Out [ ]:
inner log: Something has happened. Something else has happened 
as well.
outer log: Something has happened. Something else has happened as 
well.
HELP STATEMENT
The help statement is used to invoke a helping system and is often used in 
Python interactive mode to get help on modules, statements, functions, or 
methods.
Code sample in Python interactive mode
1
>>> help(str)
2
Help on class str in module builtins:
3
4
 class str(object)
5
 | str(object = '') -­
> str
6
 | str(bytes_or_buffer[, encoding[, errors]]) -­
> str
7
 |
8
 | Create a new string object from the given object. If 
the encoding or
9
 | any errors are specified, then the object must expose a 
data buffer
10
 | that will be decoded using the given encoding and error 
handler.
11
 | Otherwise, returns the result of object.__str__() (if 
defined)
12
 | or repr(object).
13
 | encoding defaults to sys.getdefaultencoding().
14
 | errors defaults to 'strict'.
15
 |
16
 | Methods defined here:
17
 |
	
Essential Building Blocks of Computer Programs	
159
 https://doi.org/10.15215/remix/9781998944088.01
18
 | __add__(self, value, /)
19
 | Return self+value.
20
 |
21
 | __contains__(self, key, /)
22
 | Return key in self.
23
 |
24
 | __eq__(self, value, /)
25
 | Return self==value.
26
 |
27
 | __format__(self, format_spec, /)
28
 | Return a formatted version of the string as described 
by format_spec.
29
 |
30
 |
31
 | __ge__(self, value, /)
32
 -­
-­
 More -­
-­
Compound Statements
In the previous section, we studied individual statements that can be used in 
programming with Python. In this section, we study compound statements 
and ways to make various compound statements in Python.
In Python, a compound statement consists of at least one clause, and each 
clause is made of a header and a suite, or code block. A header starts with a 
keyword such as if, for, while, class, def, try, else, except, finally, and so on 
and ends with a colon :, as described below:
<header>:
    <code block>
What can be on the header line depends on the keyword leading the header. 
You will learn more about this in the following chapters.
CODE BLOCKS
In programs, some statements are grouped and run in sequence as a unit or a 
suite. We call such a group of statements a code block.
Unlike C, C++, Java, and some other languages that use curly brackets to 
make code blocks, Python uses indentation to form code blocks. In Python, a 
program can have multiple code blocks, and code blocks can be nested with 
proper indentation. Statements intended to be in the same code block must 
use the same indentation. The following is an example:
	160	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Code sample
1
 i, s = 1, 1   # the first statement must be started at 
the very beginning
2
3
 while I <= 100:   # this compound statement is in the 
same code block
4
    s *= i   # this is the first statement in the code 
block/suite
5
    i += 1   # this is the second statement in the code 
block/suite
6
7
 print("the product of 1x2x3 … 100 is ", s)
The sample program above has two simple statements on lines 1 and 7, and one 
compound statement on lines 3 to 5. The header of the compound statement 
begins with the keyword while, and its suite is a code block that consists of 
two simple statements. Because statements on lines 1, 3, and 7 are in the same 
code block, they must be indented the same, whereas statements on lines 4 
and 5 must be further indented to form a code block as a suite for the while 
compound statement.
RULES OF INDENTATION
To ensure that your programs are properly indented, follow the following rules:
	
1.	 The first line of code of a program must start at the very first column 
of line, though there can be some blank lines before the first line of 
code, for better readability, if you like.
	
2.	 All lines of code in the same code block must be indented the same.
	
3.	 The suite of a compound statement must be indented further than the 
header of the compound statement.
	
4.	 All code blocks that are at the same level must use the same indentation.
	
5.	 All lines of code in the same suite must use the same indentation.
RULES OF SPACING
The rules of spacing are about how to space out words within a line of script or code 
and how to space lines of scripts. Some of the rules must be followed, while other 
rules are for readability or are merely convention among Python programmers:
	
1.	 There must be at least one space between two words.
	
2.	 As a convention, there should be only one space between two words.
	
Essential Building Blocks of Computer Programs	
161
 https://doi.org/10.15215/remix/9781998944088.01
	
3.	 Also as a convention, there should be one space before each operator 
and one space behind each operator in an expression. So x>y should 
be written as x > y.
	
4.	 For better readability, there should be no space between a unary 
negation operator (−) and the term it negates. So -­
 x should be written 
as -­
x.
	
5.	 Also for readability, in a function call, there should be no space 
between a function name and the list of parameters. So abs (y) 
should be written as abs(y).
	
6.	 The same goes for definitions of functions. There should be no space 
between the function name and the list of arguments.
	
7.	 There should be no blank lines between lines of simple statements if 
they are intended to be in the same code block.
	
8.	 For better readability, there should be a blank line between simple 
statement(s) and compound statements if they are in the same code 
block, as shown in the following sample code:
Code sample
1
i, s = 1, 1   # first statement must be started at the 
very beginning
2
3
while I <= 100:   # this compound statement is in the same 
code block
4
  s *= i   # statement must be indented
5
  i += 1   # second statement in the code block/suite
6
7
print("the product of 1x2x3 … 100 is ", s)
8
Please note the blank line between line 1 and line 3, as well as between 
lines 5 and 7.
IF STATEMENT
An if statement is used to run a block of statements under a condition. The 
header of an if statement begins with the keyword if, followed by a logical 
expression of a condition, and then a colon, as shown below:
if <condition>:
    <suite or code block>
	162	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Here is an example:
Code sample
1
 mark = float(input("Please input your mark:"))
2
3
 if mark >= 0:
4
   print(f"The mark is {mark}.")
5
Note that although Python allows the suite to be on the same line as the header, 
as shown in the following sample, for readability, that is not preferable.
if mark >= 0: print(f"The mark is {mark}.") # allowed but 
not preferred
IF-­
ELSE STATEMENT
In the example above, the if statement can only make one selection. To do 
something in particular if the condition is not met, the else clause can be 
added. The syntax of if-­
else statement is shown below, and the corresponding 
flowchart is shown in Figure 2-­
7.
if <condition>:
  <code block 1>
else:
  <code block 2>
Condition
met?
suite
No
Yes
Figure 2-­
6: Flowchart of an if statement
	
Essential Building Blocks of Computer Programs	
163
 https://doi.org/10.15215/remix/9781998944088.01
The code sample shown above can be rewritten as follows by adding an 
else clause:
Code sample
1
 mark = float(input("please input your mark:"))
2
3
 if mark >= 0:>
4
    print(f"The mark is {mark}.")
5
 else:
6
    print("Incorrect input! A mark cannot be a negative 
number.")
7
IF-­
ELIF STATEMENT
The if-­
else statement can only handle double selections. How can we handle 
multiple selections in Python? For example, in addition to telling whether a 
mark is legitimate or not, we may also want to convert the percentage mark to a 
letter grade. In Python, that can be done with an if-­
elif or if-­
elif-­
else statement. 
The syntax of the if-­
elif statement is shown below:
if <condition 1>:
  < suite 1 >
elif <condition 2>:
  < suite 2 >
elif <condition 3>:
  < suite 3 >
…
Condition
met?
suite 1
suite 2
No
Yes
Figure 2-­
7: Flowchart of the if-­
else statement
	164	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The code that can tell the letter grade from a percentage grade is shown 
below:
Code sample
1
 number_grade = round(float(input("please tell me a 
numeric grade between 0 and 100:")))
2
if number_grade >= 90:
3
  print(f"alpha/letter grade for {number_grade}% is A+")
4
elif number_grade >= 85:
5
  print(f"alpha/letter grade for {number_grade}% is A")
6
elif number_grade >= 80:
7
  print(f"alpha/letter grade for {number_grade}% is A-")
8
elif number_grade >= 76:
9
  print(f"alpha/letter grade for {number_grade}% is B+")
10
elif number_grade >= 73:
11
  print(f"alpha/letter grade for {number_grade}% is B")
12
elif number_grade >= 70:
13
  print(f"alpha/letter grade for {number_grade}% is B-")
14
elif number_grade >= 67:
15
  print(f"alpha/letter grade for {number_grade}% is C+")
16
elif number_grade >= 64:
17
  print(f"alpha/letter grade for {number_grade}% is C")
Condition
met?
suite 1
Condition
met?
suite 2
Condition
met?
suite 2
suite 2
No
Yes
No
Yes
No
Yes
Figure 2-­
8: Flowchart of the if-­
elif-­
elif-­
…
	
Essential Building Blocks of Computer Programs	
165
 https://doi.org/10.15215/remix/9781998944088.01
18
elif number_grade >= 60:
19
  print(f"alpha/letter grade for {number_grade}% is C-")
20
elif number_grade >= 55:
21
  print(f"alpha/letter grade for {number_grade}% is D+")
22
elif number_grade >= 50:
23
  print(f"alpha/letter grade for {number_grade}% is D")
24
elif number_grade >= 0:
25
  print(f"alpha/letter grade for {number_grade}% is F")
26
else:
27
  print("Numeric grade must be a positive integer!")
IF-­
ELIF-­
ELSE STATEMENT
An else clause can be added to the end of an if-­
elif statement in case something 
special needs to be done if all the conditions are not met.
WHILE STATEMENT
The while statement is used to run a block of code repeatedly as long as a given 
condition is met. The syntax of the statement is as follows:
while <condition>:
  < a suite >
Condition 1
met?
suite 1
Condition 2
met?
suite 2
Condition 3
met?
suite 3
suite 4
No
Yes
No
Yes
No
Yes
Figure 2-­
9: Flowchart of an if-­
elif-…elif-­
else statement
	166	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The following is an example:
Code sample
1
 i = 1
2
3
 while i <= 10:
4
    print(f"I am counting to {i}")
5
    i += 1
The loop is ended when not (I <= 10). The while statement is more advantageous 
when used to form a loop if we only know when the loop should end, as shown 
in the following word-­
guessing program:
Code sample
1
 cnt, your_guess = 0, ""
2
3
 while (your_guess.lower()) != "python":
4
    your_guess = input("Guess which programming language 
is my favourite: ")
5
6
    cnt += 1
7
 print(f"Congratulations! You got it in just {cnt} guesses")
FOR STATEMENT
A for statement provides another way to form a loop and is best for when the 
loop runs through an iterable, such as a list, a tuple, a string, a generator, a set, 
or even a dictionary. The syntax of the for statement is as follows:
for <iteration variable(s)> in <iterable>:
  < a suite >
Note that there can be more than one iteration variable if needed, but it is 
more common to have only one iteration variable.
The following is an example:
Code sample: for statement with a string
1
 cnt = 0
2
 my_string = "this is a secret"
3
 for c in my_string:
4
    print(c)
5
    cnt += 1
6
7
	
Essential Building Blocks of Computer Programs	
167
 https://doi.org/10.15215/remix/9781998944088.01
8
 print(f"there are {cnt} characters in ({my_string})")
9
Code sample: for statement with a set
1
 week_set = set(('Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 
'Sun'))
2
 for w in week_set:
3
    print(w)
4
Code sample: for statement with a dictionary
1
 week = {1: 'Mon', 2: 'Tue', 3: 'Wed', 4: 'Thu', 5: 'Fri', 
6: 'Sat', 7: 'Sun'}
2
 for w in week.keys():
3
    print(week[w], " in key and value pair in dictionary")
4
DEF STATEMENT
The def statement is used to define new functions or methods if defined within 
a class definition. The syntax of def statement is as follows:
def <function_name>(<list of arguments>):
  < code block >
where function_name should be a unique identifier within the current scope, 
and the list of arguments can be empty. The details of defining and using func­
tions will be presented in Chapter 6. For now, you need only be concerned with 
the definition of a simple function so that you know how the def statement is 
used. The function is to calculate a given number x to the power of 10, and 
return x*x*x*x*x*x*x*x*x*x:
In [ ]:
def power10(x):
  s = x
  for i in range(9):
    s *= x
    return s
print(f'power10({2}) = {power10(2)}')
Out [ ]:
2 to the power of 10 = 1024
	168	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
CLASS STATEMENT
The class statement is used to define new classes. The syntax of defining a new 
class that only inherits from the base class (object) is as follows:
Class class_name:
  < suite >
or
Class class_name(object):
  < suite >
To define a new class that inherits from classes other than object, the syntax 
is as follows:
Class Class_name(<list of base classes>):
  < suite >
TRY-­
EXCEPT STATEMENT
The try-­
except statement is used to handle errors and exceptions, especially 
when certain errors are expected. The following are some common types of 
errors that you may encounter in your programs:
ArithmeticError
FileExistsError
LookupError
FloatingPointError
FileNotFoundError
IndexError
OverflowError
InterruptedError
KeyError
ZeroDivisionError
IsADirectoryError
MemoryError
AssertionError
NotADirectoryError
NameError
AttributeError
PermissionError
UnboundLocalError
BufferError
ProcessLookupError
BrokenPipeError
EOFError
TimeoutError
ConnectionAbortedError
ImportError
ReferenceError
ConnectionRefusedError
ModuleNotFoundError
RuntimeError
ConnectionResetError
Refer to https://​
docs​
.python​
.org/​
3/​
library/​
exceptions​
.html for a detailed 
discussion about the exceptions and error types defined in Python.
	
Essential Building Blocks of Computer Programs	
169
 https://doi.org/10.15215/remix/9781998944088.01
The following is an example showing how to handle errors from user input 
that use 0 for the denominator.
Code sample: for statement with dictionary
1
 try:
2
    a = int(input("give me a number:"))
3
    b = int(input("give me another number:"))
4
    print(f"{a} / {b} = {a / b}")
5
 except ZeroDivisionError:
6
    print(f"incorrect second input {b}!")
7
The details of error and exception handling in programs will be discussed 
in Chapter 4.
WITH STATEMENT
The with statement is used to provide a context for the execution of a code 
block. The mechanism is a bit complex, but the following may provide some 
help. Remember that the with statement works only on objects that have special 
methods __enter__() and __exit__() implemented in accordance with Python 
context management protocol (PEP 343). For the mechanisms behind the with 
statement, read https://​
effbot​
.org/​
zone/​
python​
-with​
-statement​
.htm or search 
the internet for more details.
The general syntax of the with statement is as follows:
With <expression of object> as < variable referring to the object>:
<suite>
where the value of <expression of the object> will be an object on which the 
context management protocol has been implemented and the <variable refer­
ring to the resulted object> will often be used in the suite. A good and common 
example of using the with statement is dealing files, which, when opened, are 
objects with context management protocol implemented. The following is an 
example:
Code sample: with statement
1
 """
2
 This program will get an input of a big integer from 
user, and
3
 find all the prime numbers not greater than the integer 
input from the user, and
	170	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
4
 write all the prime numbers into a text file.
5
"""
6
 m = int(input("""
7
    Please tell me a big integer number and
8
    then I can find all the primes less than
9
    the prime number:"""))
10
 import math as mt
11
 with open("c:\\workbench\\myprimes.txt", 'w') as p:
12
    i = 2
13
    while i <= m:
14
      flag = True
15
      j = 2
16
      while j <= int(mt.pow(i,1/2)) + 1 and flag:
17
        if i % j == 0:
18
          flag = False
19
          j += 1
20
        if flag:
21
          p.write(str(i)+ "\n")
22
          i += 1
Chapter Summary
•	 Vocabulary is important for any language, and even more important 
for computer languages, because computers will not understand your 
programs at all if you have used the wrong vocabulary.
•	 For programming languages, including Python, vocabulary includes 
various types of data, operators, built-­
in functions, reserved words 
(including keywords), and variables identified by user-­
defined names 
(also called identifiers).
•	 Identifiers must begin with a letter or underscore in the ASCII table, 
then be followed by letters, digits, and/or an underscore.
•	 Identifiers in Python are case-­
sensitive, which means that A1 and a1 are 
two different identifiers.
•	 Within the Python community, there are conventions for how 
identifiers should be made and used for identifying different things in 
Python programs.
•	 Simple data types include integer numbers, float numbers, Boolean 
numbers, and complex numbers.
•	 Complex numbers are represented as a + bj or a − bj, where a and b are 
integers or float numbers.
•	 Compound data are made of other data that can be of two types: simple 
or compound.
	
Essential Building Blocks of Computer Programs	
171
 https://doi.org/10.15215/remix/9781998944088.01
•	 A string is a sequence of characters within a pair of single or double 
quotation marks.
•	 Some special characters in a string must be represented using 
an escape sequence, such as \n for newline, \t for tab, and \\ for a 
backslash, and so on.
•	 In a string, all characters are indexed starting from 0, so that each 
individual character can be accessed using its index.
•	 There are many functions available to manipulate strings.
•	 There are three ways of formatting strings: using placeholders, using 
the format method, and using the f prefix before a string. The last one 
is preferred.
•	 A list is a sequence of data within a pair of square brackets.
•	 Members of a list are also indexed, and each individual member can be 
accessed through its index.
•	 A tuple is a sequence of data within a pair of parentheses.
•	 Members of a tuple are also indexed, and each individual member can 
also be accessed through its index.
•	 While individual members of a list can be deleted or changed, 
individual members in a tuple cannot be deleted or changed.
•	 A set is a collection of data within a pair of curly braces.
•	 Members in a set are not indexed, so individual members in a set 
cannot be accessed through the index.
•	 A dictionary is a collection of key-­
value pairs within a pair of curly 
braces.
•	 Keys are used to access the values of a dictionary.
•	 In Python, everything can be treated as an object.
Exercises
	
1.	 Indicate which of the following are not legitimate Python identifiers to 
name variables, functions/methods, and classes, and explain why.
This
3da
My_name
for
i9
vote
$s
_sum_
cLearance
method
lists
t5#
	
2.	 Write a single statement to complete each of the following tasks:
	
a.	 Read an integer from user into variable k.
	
b.	 Print a multiple-­
line mailing label with your name and home 
address, including the postal code.
	
c.	 Print the area of a circle with a radius of 13.
	172	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
	
d.	 Assign the cube of 23 to variable x.
	
e.	 Print the square of 12, 25, and 56, respectively, on one line.
	
3.	 Evaluate the following expressions
	
a.	 23 + 16 / 2
	
b.	 round(78.3)
	
c.	 pow(2,3) + 5
	
d.	 sum([1,3,5,7,9])/13
	
e.	 bin(9)
	
f.	 divmod(13, 5)
	
g.	 int(38.6)//7
	
h.	 (3.5 + 6.7j) + (5.3 + 12.9j)
	
i.	 'Well' * 3 + '!'
	
4.	 Mentally run the following code blocks and state what each code block 
will display.
	
a.	 x = 5
	
	     y = 6
	
	     print(x + y)
	
b.	 m = 5
	
	     k = 3
	
	     print(f’{m}**{k} = {m**k}’)
	
c.	 m, k = 35, 12
	
	     m //= k
	
	     print(m)
	
d.	 m, k = 35, 12
	
	     m %= k
	
	     print(m)
Projects
	
1.	 Write a program to read a float number from the user into variable s, 
then calculate and print the area of a square with s as the length of 
its side.
	
2.	 Write a program to read two numbers and calculate the product of the 
two numbers.
	
3.	 A parking lot charges $2.50 per hour. Write a program to read the 
number of hours a vehicle has parked, then calculate and print the 
total to be paid for parking.
	
4.	 The arithmetic mean of several numbers is the sum of all these 
numbers divided by the number of these numbers. For this project, 
	
Essential Building Blocks of Computer Programs	
173
 https://doi.org/10.15215/remix/9781998944088.01
write a program that will generate three numbers from users and 
calculate and display the arithmetic mean of these three numbers.
	
5.	 A cube has 6 faces and 12 edges, all of the same length. Write a 
program that takes a number from the user as the length of an edge 
and calculate and display the total surface area of the cube.
This page intentionally left blank
 https://doi.org/10.15215/remix/9781998944088.01
Chapter 3
Flow Control of Statements
If you praise computers for their diligence when they iterate operations tirelessly 
trillions of trillions of times, you must also appreciate their intelligence when they 
do certain things only if certain conditions are met, because decision making is 
important for all intelligent beings, including modern computers. All computer 
programming languages provide constructs for decision making—­
to run a state­
ment or a block of statements only under certain conditions. Python does the same.
In Chapter 3, you will learn how to use the if, if-­
else, if-­
elif, and if-­
elif-­
else 

statements to instruct computers to do certain things only under certain 
conditions.
Learning Objectives
After completing this chapter, you should be able to
•	 use an if statement to run a code block only under a set condition.
•	 use if-­
else to run two code blocks under two different conditions.
•	 use if-­
elif to make multiple selections.
•	 use if-­
elif-­
else to make multiple selections.
•	 use for statements to make loops to run code blocks repeatedly.
•	 use while statements correctly and efficiently to put a code block in a loop.
•	 use break and continue statements correctly to change the flow of 
program within the code block.
3.1 Selective with the if Statement
In Python, all selections are done with the if statement, which can take mul­
tiple forms. The following is a code sample showing how if is used to make a 
single selection.
	176	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Code sample in Python interactive mode
1
"""
2
Code sample showing how to use an if statement to have a 
code block run under a certain condition
3
this piece of code is used to calculate the square root of 
number n only if it is a positive number.
4
"""
5
n = input('Tell me a number and I will tell you the square 
root:')
6
n = float(n) # convert n from string to float
7
if n >= 0:
8
  print(f"The square root of {n} is {n ** (1 / 2)}")
9
10
11
Note that a code block for if statements must begin on the next line after a 

colon : and be properly indented, as shown below:
n = int(input("n = ?"))
if n >= 0:
  Code block
Note: Each code block must be properly indented to indicate what the code 
block belongs to.
The conditions for an if statement can be any Boolean expression, as dis­
cussed in 2.1.
3.2 Single-branch selective with if Statement
In the above example, the program specifies only what to do when n >= 0 but 
does not say what to do otherwise. With Python, you can further specify what 
can be done if n >= 0 is not true. The following is a revised code sample—­

it simply tells the user to input a positive number.
Code sample in Python interactive mode
1
"""
2
Code sample showing how to use an if statement have a code 
block run under a certain condition
3
this piece of code is used to calculate the square root of 
number n only if it is a positive number
4
"""
	
Flow Control of Statements	
177
 https://doi.org/10.15215/remix/9781998944088.01
5
6
n = float(input('Tell me a number and I will calculate the 
square root for you:'))
7
if n >= 0:
8
  print(f"The square root of {n} is {n ** (1 / 2)}")
9
else:
10
  print ("Please give me a positive number!")
Note that no condition needs to be specified for an else clause because it implies 
that the condition is the negation of the condition for that if clause—­
that is, 
not n >= 0.
With the if and if-­
elif statements studied above, you can make single-­
 or 
two-­
branch selections, which are depicted in Figures 3-­
1 and 3-­
2.
3.3 Multiple-branch selective with if-­
elif-… and 
if-­
elif-…-­
else Statements
In decision making, there can be multiple options, each of which requires 
different actions to be taken. In Python, multiple selections can be made with 
if-­
elif and if-­
elif-­
else statements. The logic flow of these two statements is 
depicted in the following diagrams.
The flowchart in Figure 3-­
3 shows the logic flow of an if-­
elif-­
elif…elif state­
ment without else, which can be used to make multiple selections. The flowchart 
in Figure 3-­
4 illustrates the logic flow of an if-­
elif-­
elif…else statement for mul­
tiple selections.
?
Code block
Yes
No
Figure 3-­
1: Flowchart of an if statement
?
Code block A
Code block B
Yes
Figure 3-­
2: Flowchart of an if-­
else statement
	178	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Now, you are ready to tackle a real problem: to decide what letter grade 
should be assigned for a given numeric mark of a student in a course, accord­
ing to Table 3-­
1.
Table 3-­
1: Assignment of letter grade to numeric grade
Number of selections 
needed
Numeric grade (%)
Alpha/letter grade
1
90–­
100
A+
2
85–­
89
A
3
80–­
84
A−
4
76–­
79
B+
5
73–­
75
B
6
70–­
72
B−
7
67–­
69
C+
8
64–­
66
C
9
60–­
63
C−
10
55–­
59
D+
11
50–­
54
D
12
0–­
49
F
?
CB 2
No
Yes
?
CB n
No
No
Yes
?
CB 1
No
Yes
Figure 3-­
3: Flowchart of an if-­
elif-­
elif-­
elif… statement
?
CB 2
No
Yes
?
CB n
CB Else
No
No
Yes
?
CB 1
No
Yes
Figure 3-­
4: Flowchart of an if-­
elif-­
elif-­
else statement
	
Flow Control of Statements	
179
 https://doi.org/10.15215/remix/9781998944088.01
The table shows only integer numeric grades, but decimal inputs, auto­
matically rounded to the nearest integer, are also allowed. The case study is 
shown in Table 3-­
2.
Table 3-­
2: Case study: How to use if-­
elif-­
else
The problem
In this case study, design a program using an if-­
elif-­
else statement 
to convert numeric grades to alpha/letter grades.
The analysis 
and design
As the above grade-­
conversion table shows, the program needs to 
make 12 selections. For each selection, a letter grade will be printed 
out when the numeric grade falls within the corresponding interval.
The code
"""
You are required to design a program using an if-­
elif-­
else statement
to convert numeric grades to alpha letter/grades.
"""
number_grade = round(float(input("Please tell me a 
numeric grade between 0 and 100:")))
if number_grade >= 90:
  print(f"alpha/letter grade for {number_grade}% is A+")
elif number_grade >= 85:
  print(f"alpha/letter grade for {number_grade}% is A")
elif number_grade >= 80:
  print(f"alpha/letter grade for {number_grade}% is A-")
elif number_grade >= 76:
  print(f"alpha/letter grade for {number_grade}% is B+")
elif number_grade >= 73:
  print(f"alpha/letter grade for {number_grade}% is B")
elif number_grade >= 70:
  print(f"alpha/letter grade for {number_grade}% is B-")
elif number_grade >= 67:
  print(f"alpha/letter grade for {number_grade}% is C+")
elif number_grade >= 64:
  print(f"alpha/letter grade for {number_grade}% is C")
elif number_grade >= 60:
  print(f"alpha/letter grade for {number_grade}% is C-")
elif number_grade >= 55:
  print(f"alpha/letter grade for {number_grade}% is D+")
elif number_grade >= 50:
  print(f"alpha/letter grade for {number_grade}% is D")
elif number_grade >= 0:
  print(f"alpha/letter grade for {number_grade}% is F")
else:
  print("Numeric grade must be a positive integer!")
The result
Please tell me a numeric grade between 0 and 100: 88
alpha/letter grade for 88 is A
	180	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The code above didn’t explicitly specify the upper bounds of the intervals 
shown in the grade conversion table because it takes advantage of the if-­
elif-­

elif statement—­
that is, the upper bound of the current if condition has been implicitly 
satisfied when the previous if condition is not satisfied, and the program flow gets 
into the current elif selection. Taking the first elif statement as an example, since 
the previous if condition is number_grade >= 90, when the condition is not satis­
fied and the program flow goes to the elif, the number_grade must be less than 90, 
which is equal to number_grade <= 89, the upper bound of the first elif condition.
After you run the code on your computer, you may notice that for each 
conversion, you have to rerun the program to get another chance to input a 
numeric grade. How can you do as many conversions as you want until you tell 
the program to stop? You’ll be able to do that after learning how to put a code 
block in a loop in the next chapter.
CODING TRICK
How would you specify the conditions for the elif if you began from the 
lowest numeric grade to make number_grade <= 49 for the if?
3.4 Iterate with for Statement
Computers can do many amazing things. Many of these amazing things can 
only be done in thousands or even trillions of trillions of steps. Luckily, pro­
grammers don’t need to write trillions of trillions of statements in a computer 
program, because computers can be instructed to run a block of statements 
in a loop as many times as needed without complaint. As such, a programmer 
must be able to correctly put code blocks in loops when programming. In 

this and the next section of this chapter, you will learn how to use for statements 
and while statements correctly and effectively to put code blocks in loops.
In Python, the for statement is one of only two statements that can be used to 
make loops or iterations. In previous sections, you already saw some examples 
using the for statement. Formally, a for loop takes the following form:
for <iteration variable> in <sequence to be looped through>:
  <Code Block>
in which for and in are keywords, and the iteration variable is used to take items 
one by one from the sequence, which can be a list, a tuple, a string, or an iterable 
object or generator, as you will see. The code block is a block of Python code to 
	
Flow Control of Statements	
181
 https://doi.org/10.15215/remix/9781998944088.01
be executed in each iteration of the loop. The following example loops through 
a list of integers and calculates the cube of each.
In [ ]:
for i in range(1, 11):
  print(f'The cube of {i} is {i * i * i}')
Out [ ]:
The cube of 1 is 1
The cube of 2 is 8
The cube of 3 is 27
The cube of 4 is 64
The cube of 5 is 125
The cube of 6 is 216
The cube of 7 is 343
The cube of 8 is 512
The cube of 9 is 729
The cube of 10 is 1000
A flowchart describing the for loop is shown in Figure 3-­
5.
Now we are ready to solve a more complex problem, shown in Table 3-­
3.
Table 3-­
3: Case study: How to display a multiplication table
The task
Print a multiplication table from 1 * 1 to 9 * 9, and the result table 
should be a right triangle.
Analysis 
and 
design
The resulting multiplication table should be a right triangle like this:
1 x 1 = 1
1 x 2 = 2  2 x 2 = 4
1 x 4 = 3  2 x 3 = 6  3 x 3 = 9
…
so we will need two loops: the outer one is used to loop through the 
row, whereas the inner one loops through the column of each row. 
The algorithm is as follows:
Step 1: Start a row I, I = 1, 2,…, 9
Step 2: Start a column j of row I, j = 1,…i
Step 3: Print j × I = j * i on the same line until I * i
Step 4: Go back to step 1 and finish all rows
Still unused item in
the sequence?
Get next item
Code block
Yes
No item unused
Figure 3-­
5: Flowchart of the for loop
(continued on next page)
	182	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
1
"""
2
This program is used to print a multiplication table 
from 1 x 1 to 9 x 9.
3
The table will be displayed nicely as a right 
triangle. It uses two loops,
4
an outer loop for the rows and an inner loop for the 
columns.
5
"""
6
7
for i in range(1, 10):
8
  for j in range(1, i + 1):
9
    print(f"{i}x{j} = {i * j}", end = "  ")
10
    if j == i:
11
      print("\n")
12
Output in 
terminal
1 x 1 = 1
1 x 2 = 2 2 x 2 = 4
1 x 3 = 3 2 x 3 = 6 3 x 3 = 9
1 x 4 = 4 2 x 4 = 8 3 x 4 = 12 4 x 4 = 16
1 x 5 = 5 2 x 5 = 10 3 x 5 = 15 4 x 5 = 20 5 x 5 = 25
1 x 6 = 6 2 x 6 = 12 3 x 6 = 18 4 x 6 = 24 5 x 6 = 30 6 x 6 = 36
1 x 7 = 7 2 x 7 = 14 3 x 7 = 21 4 x 7 = 28 5 x 7 = 35 6 x 7 = 42 7 x 7 = 49
1 x 8 = 8 2 x 8 = 16 3 x 8 = 24 4 x 8 = 32 5 x 8 = 40 6 x 8 = 48 7 x 8 = 56 
8 x 8 = 64
1 x 9 = 9 2 x 9 = 18 3 x 9 = 27 4 x 9 = 36 5 x 9 = 45 6 x 9 = 54 7 x 9 = 63 
8 x 9 = 72 9 x 9 = 81
Our next problem, in Table 3-­
4, is to find all the Pythagorean triples of 
integers less than an integer given by the user.
Table 3-­
4: Case study: How to find Pythagorean triples
The task
Three integers—­
A, B, and C—­
are called a Pythagorean triple when C * C 
= A * A + B * B.
This program will take an integer input by the user and find all the 
Pythagorean triples of integers less than that integer.
Analysis 
and 
design
Step 1: Get input from user
Step 2: Find all the Pythagorean triples
Step 3: Print all the triples
Step 2.0: Make an empty list, say, plist =[]
Step 2.1: One loop for A = 1…user input
Step 2.2: One loop for B = 1…user input
Step 2.3: One loop for C = 1…user input
Step 2.4: If C * C = A * A + B * B, add the triple to the list plist
1
"""
2
Three integers -­
 A, B, and C -­
 are called a 
Pythagorean triple when C * C = A * A + B * B.
Table 3-­
3: Case study: How to display a multiplication table (continued)
	
Flow Control of Statements	
183
 https://doi.org/10.15215/remix/9781998944088.01
3
This program will take an integer input by the user 
and find all the Pythagorean triples of integers 
less than that integer.
4
"""
5
6
upper_bound = int(input("Give me a big integer:"))
7
plist = []
8
for i in range(1, upper_bound + 1):
9
  for j in range(i, upper_bound + 1):
10
    for k in range(j, upper_bound + 1):
11
      if k * k == j * j + i * i:
12
        plist.append((i, j, k))
13
for i in plist:
14
  print(i)
15
16
17
Output in 
terminal
Give me a big integer:39
(3, 4, 5)
(5, 12, 13)
(6, 8, 10)
(7, 24, 25)
(8, 15, 17)
(9, 12, 15)
(10, 24, 26)
(12, 16, 20)
(12, 35, 37)
(15, 20, 25)
(15, 36, 39)
A for statement can have multiple iteration variables if needed. In order to 
make it work, however, each item of the iteration sequence needs to have multiple 
values for the multiple iteration variables, as shown in the following example:
for i, j in [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]:
    print(f"{i} * {j} = {i * j}")
or
for i, j in zip(range(5), range(5)):  # zip is a special 
function
    print(f"{i + 1} * {j + 1} = {(i + 1) * (j + 1)}")
In the above, zip is a built-­
in function that takes an element from each 
iterable and forms a tuple, as shown below:
>>> list(zip(range(5), range(5), range(6)))
[(0, 0, 0), (1, 1, 1), (2, 2, 2), (3, 3, 3), (4, 4, 4)]
Table 3-­
4: Case study: How to find Pythagorean triples (continued)
	184	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The function zip will stop making tuples when the shortest iterable has 
reached the end.
Note that the following two statements are totally different:
for i in range(5):
  for j in range(5):
    print(f"{j + 1} * {i + 1} = {(i + 1)*(j + 1)}")z
versus
for i, j in zip(range(5), range(5)):
  print(f"{i + 1} * {j + 1} = {(i + 1)*(j + 1)}")
The first statement is two loops nested, whereas the second is a single loop.
You may copy and paste the code into Jupyter Notebook to find out why and how.
Using break and continue Statements and an else Clause Within 
Loops
Chapter 2 discussed what the break statement and continue statement do. 
Within a for loop, if you want to get out of the iteration immediately when some­
thing has occurred, you can use a break statement; if you want to go to the next 
item in the iteration sequence right away, you can use a continue statement.
A for statement can also have an else clause whose code block will be exe­
cuted when the iteration sequence is used up. The following code example 
taken from the Python documentation explains how the break statement and 
else clause can be used on a for loop.
In [ ]:
for n in range(2, 10):
  for x in range(2, n):
    if n % x == 0:
      print(n, 'equals', x, '*', n // x)
      break   # if break is ever executed, the else 
code block will never be reached
    else:   # the else code block is executed when 
      range(2, n) is used up without finding a factor
      print(n, 'is a prime number')
Out [ ]:
2 is a prime number
3 is a prime number
4 equals 2 * 2
5 is a prime number
6 equals 2 * 3
7 is a prime number
8 equals 2 * 4
9 equals 3 * 3
	
Flow Control of Statements	
185
 https://doi.org/10.15215/remix/9781998944088.01
In the example above, pay particular attention to the indentation of else. 
The else block is treated as a clause of the inner for statement because it 

has the same indentation as the inner for. If it were indented the same as the 
if statement, the else block would become part of the if statement.
Common Coding Mistakes with the for Loop
Because Python made the for loop to run an iteration variable or variables 
through a sequence with a finite number of items, it has essentially avoided 
some mistakes common in other languages such as C, C++, and Java. You should, 
however, remember to not change the value of any iteration variable within 
the code block of a for loop because it needs to be changed automatically by 
Python interpreter to the next item in the sequence. The iteration might be 
unexpected if the value of the iteration variable is changed in the code block.
3.5 Iterate with the while Statement
The while statement is another statement you can use to make loops. As dis­
cussed in Chapter 2, while is best used if you know when the loop should stop 
but do not know how many times the code will iterate. For the problem solved 
in the previous section, even though you also know when each loop should 
stop, it can still be coded with the while statement, as shown below:
The code
1
"""
2
This program is used to print a multiplication table from 
1 x 1 to 9 x 9.
3
The table will be displayed nicely as a right triangle. 
The two loops are coded with the while statement
4
instead of the for statement.
5
"""
6
7
  i = 1
8
  while i < 10:
9
    j = 1
10
    while j <= i:
11
      print(f"{j} x {i} = {i * j}", end ="")
12
      if j == i:   # if statement is used to decide when 
to start a new line
13
        print("\n")
14
      j += 1
15
    i += 1
16
17
	186	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
While a for loop can always be replaced with a while loop, a while loop cannot 
be replaced with a for loop in cases where the number of iterations is unknown.
Consider the problem of calculating the average of the student marks taken 
from user input. Either the total number of marks is unknown or you do not 
expect the user to count how many marks they input, so it is not possible to use 
a for loop to solve the problem. However, you do know there will be no negative 
marks, which can then be used to indicate the end of the input. Hence, you can 
use a while loop to take input from the user until you get a negative number 
from the user. The program is shown in Table 3-­
5.
Table 3-­
5: Case study: How to stop a while loop
Code sample in VS Code IDE
The task
Get student marks from user input and calculate the average mark, using 
a negative number input by the user to indicate the end of marks.
Analysis 
and 
design
You don’t know how many marks will be input from the user, but you do 
know there will be no negative marks. You can then use a negative 
number, input by the user, to end the application and use the while 
loop to iterate.
To calculate the average, you need to know the sum of all the marks 
as well as the total number of marks. For the former, you need to 
add each mark to the total, whereas for the latter, you need to use a 
counter to count every mark. Use the variable total to keep the sum 
and use the variable count to keep the number of marks. Both need to 
be initialized to 0. The algorithm is below:
Step 1: Initialize both count and total to 0
Step 2: Take an input from user and convert it to a float number
Step 3: If the number is a mark (>= 0), then do the following:
  Step 3.1: Increase count by 1
  Step 3.2: Add mark to total
  Step 3.3: Get another input from user and convert to float
  Step 3.4: Go back to Step 3
Step 4: Calculate the average using total/count and print out the result.
Step 5: End the program
Is condition to
loop met?
Code block
Met
Not met
Figure 3-­
6: Flowchart illustrating the while loop
	
Flow Control of Statements	
187
 https://doi.org/10.15215/remix/9781998944088.01
Code sample in VS Code IDE
1
"""
2
Program file name: averagemark.py
3
Application: this application takes marks from user 
input and calculates the average mark.
4
A negative number from user input is used to 
indicate the end of the program.
5
"""
6
7
count, total = 0, 0   # two variables are 
initialized in one assignment statement
8
mark = float(input("Please input a mark or a 
negative number to end:"))
9
while mark >= 0:
10
  total += mark
11
  count += 1
12
  mark = float(input("Please input next mark or a 
negative number to end:"))
13
print(f"The average of the {count} marks is {total/count}")
14
Output in 
terminal
Please input a mark or a negative number to end: 78
Please input next mark or a negative number to end: 89
Please input next mark or a negative number to end: 98
Please input next mark or a negative number to end: 88
Please input next mark or a negative number to end: 85
Please input next mark or a negative number to end: -­
1
The average of the 5 marks is 87.6
Similarly, we can also write a program that takes a list of student marks 
and identify the lowest marks, the highest marks, and the mean, as shown 

in Table 3-­
6.
Table 3-­
6: Case study: How to use a while loop statement
The problem
In this problem, you will get a list of student marks and find out the 
lowest, the highest, and the mean.
The analysis 
and design
The steps involved are
Step 1: Start with an empty list
Step 2: Get marks in a loop and build a list
Step 3: Sort the list
Step 4: Get the lowest mark, the mean, and the highest mark from 
the sorted list
Table 3-­
5: Case study: How to stop a while loop (continued)
(continued on next page)
	188	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The code
"""
Get a number of marks into a list, sort the list and
find the mean, max, and min.
"""
mark = int(input("Please input a mark or -­
1 to 
complete:"))
marks = []
while mark >= 0:
  marks.append(mark)
  mark = int(input("Please input next mark or -­
1 
to complete:"))
marks = sorted(marks)
ln = len(marks)
print(f"The lowest is {marks[0]}, mean is 
{marks[ln // 2]}, highest is {marks[ln -­
 1]}")
print(marks)
The result
The lowest is 25, mean is 65, highest is 85
[25, 32, 36, 54, 55, 58, 65, 66, 74, 77, 85, 85]
The next programming task for using a while loop is to write a program 
that can take an integer from a user and decide whether the integer is a prime 
number or not (see Table 3-­
7).
Table 3-­
7: Code sample: Prime number test
Code sample in VS Code IDE
The task
Take an integer from a user and decide whether the integer is a 
prime number or not.
Analysis and 
design
A prime number is an integer greater than 1 that cannot be divided by 
any of the integers between 1 and itself. The way to test this can be 
very simple: try to divide that number by all the numbers between 1 
and that number. If it can be divided, and the answer is a whole 
number, then that number is prime. However, since i*j = j*i, we only 
need to test integers <= square root of m to speed up the test. We 
can assume the integer is a prime at the start of the test with a flag 
initialized to True; if a number in the range discussed above is found 
to be able to divide into the integer, the flag is changed to False and 
the test is complete. If no such number is found until the end of 
the range, the flag will remain True, and the number is a prime. The 
algorithm is as follows:
Step 1: Get an integer from the user into variable n
Step 2: Initialize flag to True
Step 3: Initialize variable i to 2
Step 4: If i <= sqrt(n), do the following:
	
Flow Control of Statements	
189
 https://doi.org/10.15215/remix/9781998944088.01
Code sample in VS Code IDE
  Step 4.1: If n % m != 0, then m = m + 1; go to Step 4, else
  Step 4.2: If flag = False, break out and stop testing
Step 5: If flag = True, then number n is a prime; print it out
Step 6: End program
1
"""
2
Program file name: primetest.py
3
Application: this program takes an integer from 
user input and determines
4
whether it is a prime or not.
5
"""
6
7
m = int(input("Give me an integer that is greater 
than 1, and I will tell you if it is a prime: "))
8
flag = True
9
if m < 2:
10
  print("The number must be greater than 1")
11
  flag = False
12
else:
13
  i = 2
14
  while i< = m ** (1 / 2):   # because i * j = j * 
i, we only need to check integers < = sqrt(m)
15
    if m % i == 0:
16
      print(f"{m} is divisible by {i}, so that ", 
end=" ")
17
      flag = False
18
      break
19
    else:
20
      i += 1
21
if flag:
22
  print(f"{m} is a prime")
23
else:
24
  print(f"{m} is not a prime")
25
26
27
Output in 
terminal
Give me an integer that is greater than 1, and I will tell you if it is a 
prime: 911
911 is a prime
Please note the break statement in the example above. It is used to get out 
of the loop immediately by ignoring all the code before it without going back 
to test the looping condition. This is a way to get out of a loop in the middle of 
an iteration and is applicable to both the while loop and for loop.
Somewhat related to the break statement, the continue statement is used 
within a loop to go back directly to the beginning of the iteration—­
testing the 
Table 3-­
7: Code sample: Prime number test (continued)
	190	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
looping condition in a while loop or taking the next item of the sequence in a 
for loop.
Common Coding Mistakes with a while Loop
As mentioned, the while loop is good for iterations in which the number 
of iterations is unknown but the condition of looping is known. To ensure 

that the loop will end as expected, the looping condition must be changed 
within the code block of the while statement. Otherwise, the loop will go on 
forever. To ensure that, there must be at least one variable within the code block 

of the loop whose value needs to be changed during iterations. Such a variable 
is called an iteration variable.
There are two common mistakes when using the while statement. The first 
one is not correctly writing the looping condition, which could be coded so that 
it is always true (hence, the iteration will keep going forever) or incorrectly 
coded to become false at the wrong time. For example, if x < 0 is written in 
place of x > 0 as the looping condition, the iteration would not finish as desired 
or wouldn’t run at all.
The other common mistake people often make when using the while 
statement is not coding the code block correctly to ensure that the following 
conditions hold:
	
1.	 There will be at least one iteration variable within the code block of 
the while loop.
	
2.	 The value(s) of iteration variable(s) must change within the code 
block.
	
3.	 The logical expression of the looping condition is not correctly 
written. This mistake may occur when inequal operators are involved 
in the logical expression of the looping condition. For example, using 
> in place of >=, or using < in place <=, will cause the program to miss 
one iteration of the loop.
In the example we just mentioned above, if x is never changed within the code 
block of the while loop, the value of the looping condition will remain the same, 
and the iteration will keep going forever as well.
3.6 Iterate with for Versus while
The for loop is controlled by a variable going through a sequence with a finite 
number of items. So essentially, the for loop is good for cases when the number 
of iterations is known. Let’s take a second look at the example about finding 

	
Flow Control of Statements	
191
 https://doi.org/10.15215/remix/9781998944088.01
the average mark for a class. Assume now that we know the class has 30 students 
and we want the program to take the final marks of all students in the class and 
calculate the average mark. Because the number of students in the class is known, 
the for loop can be used to iterate, as shown below:
In [ ]:
total = 0
for i in range(30):
  mark = int(input("Please input a mark:"))
  total += mark
print(f'The average course mark is {total/30}.')
When the number of iterations is unknown, the while loop must be used, 
in which case the condition for exiting from the loop must be known. In this 
particular application, because no mark will be a negative number, we can use 
negative numbers to signify the end of input, to end the iteration, as shown in 
the following example:
In [ ]:
total, mark, count = 0, 0, 0
while mark >= 0:
  mark = int(input("Please input a mark:"))
  if (mark >= 0):
    total += mark
    count += 1
print(f'The average course mark of {count} students is 
{total/count}.')
Out [ ]:
Please input a mark: 89
Please input a mark: 96
Please input a mark: 78
Please input a mark: 97
Please input a mark: 88
Please input a mark: -­
7
The average course mark of 5 students is 89.6.
In the example above, we use mark as an iteration variable to control the 
loop. Initializing it with 0 = ensures that the looping condition (logical expres­
sion mark >= 0) is satisfied to start the iteration.
Since we know the logical expression (mark >= 0) is true when 0 is assigned 
to mark, we can also simply use constant True in place of mark >= 0 and then 
use an if statement with the break statement to get out of the loop when a 
certain condition (condition to exit the loop) is met. The revised version of the 
program is shown below:
	192	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
total, mark, count = 0, 0, 0
while True:
  mark = int(input("Please input a mark:"))
  if (mark >= 0):
    total += mark
    count += 1
  else:
    break
print(f'The average course mark of {count} students is 
{total/count}.')
Out [ ]:
Please input a mark: 88
Please input a mark: 98
Please input a mark: 97
Please input a mark: 96
Please input a mark: 78
Please input a mark: -­
3
The average course mark of 5 students is 91.4.
In the previous section we mentioned that the while loop is an entry-­
controlled iteration, which means that the code block of the loop statement 
may not be executed at all if the entry condition is not met at the beginning. In 
the example above, when we use True in place of the looping condition, it has 
guaranteed that the code block will always be run at least once, and the itera­
tion could go on forever if a break statement is not used and executed when a 
certain condition (condition to exit) is met. This has made while statement an 
exit-­
controlled iteration. The flowchart of such iteration is shown in Figure 3-­
7.
Compared to the for statement, the while statement is more powerful and 
its uses are more versatile. In fact, all code written with a for statement can 
be rewritten with a while statement, though when looping through sequences, 
coding with for statements is more elegant and more readable.
Condition to 
exit
Code block
Condition to exit
is not met
Condition to exit
is met
Figure 3-­
7: Flowchart for a while loop
	
Flow Control of Statements	
193
 https://doi.org/10.15215/remix/9781998944088.01
Since we know how to put a code block in a while loop, we can improve the 
grade conversion program written in the previous chapter so that we do not 
have to rerun the program for each conversion (see Tables 3-­
8 and 3-­
9).
Table 3-­
8: Conversion between numeric grade and letter grade in 
Alberta
Letter grade
Percentage
A+
90–­
100%
A
95–­
89%
A−
80–­
84%
B+
77–­
79%
B
73–­
76%
B−
70–­
72%
C+
67–­
69%
C
63–­
66%
C−
60–­
62%
D
55–­
59%
D
50–­
54%
F
0–­
49%
Table 3-­
9: Case study: How to make a grade converter
The problem
In this case study, you are required to design a program using an 
if-­
elif-­
else statement to convert as many numeric grades to alpha/
letter grades as needed until the user inputs -­
1 to stop.
The analysis 
and design
In Canada, different provinces may use different conversion tables 
for numeric grade to letter grade conversion. In this case study, 
we take the one used in Alberta, as shown above. Based on the 
conversion table, our program needs to make 12 selections; for 
each selection, a letter grade will be printed out when the numeric 
grade falls within the corresponding interval. Since we allow a 
user to convert as many numeric grades as needed until the user 
explicitly tells the program to stop by inputting -­
1, we will put the 
above if-­
elif-­
elif multiple selection statements inside a while loop. 
Note that for this problem, the for loop will not work because we 
do not know how many times the loop will need to run.
(continued on next page)
	194	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The code
"""
Design a program using an if-­
elif-­
else statement
to convert numeric grades to alpha/ letter grades.
"""
number_grade = 0
while number_grade >= 0:
  number_grade = input("Please input a numeric grade 
between 0 and 100 to convert; input -­
1 to exit:")
  number_grade = round(float(number_grade))
  if number_grade >= 90:
    print(f"alpha/letter grade for {number_grade} 
is A+")
  elif number_grade >= 85:
    print(f"alpha/letter grade for {number_grade} 
is A")
  elif number_grade >= 80:
    print(f"alpha/letter grade for {number_grade} 
is A-")
  elif number_grade >= 76:
    print(f"alpha/letter grade for {number_grade} 
is B+")
  elif number_grade >= 73:
    print(f"alpha/letter grade for {number_grade} 
is B")
  elif number_grade >= 70:
    print(f"alpha/letter grade for {number_grade} 
is B-")
  elif number_grade >= 67:
    print(f"alpha/letter grade for {number_grade} 
is C+")
  elif number_grade >= 64:
    print(f"alpha/letter grade for {number_grade} 
is C")
  elif number_grade >= 60:
    print(f"alpha/letter grade for {number_grade} 
is C-")
  elif number_grade >= 55:
    print(f"alpha/letter grade for {number_grade} 
is D+")
  elif number_grade >= 50:
    print(f"alpha/letter grade for {number_grade} 
is D")
  elif number_grade >= 0:
    print(f"alpha/letter grade for {number_grade} 
is F")
  else:
    print("Thank you for using this grade 
converter!")
The result
Please input a numeric grade between 0 and 100 to convert; input -­
1 
to exit:96
alpha/letter grade for 96% is A+
Please input a numeric grade between 0 and 100 to convert; input -­
1 
to exit:79
alpha/letter grade for 79% is B+
Please input a numeric grade between 0 and 100 to convert; input -­
1 
to exit:67
alpha/letter grade for 67% is C+
Please input a numeric grade between 0 and 100 to convert; input -­
1 
to exit:-­
1
Thank you for using this grade converter!
Table 3-­
9: Case study: How to make a grade converter (continued)
	
Flow Control of Statements	
195
 https://doi.org/10.15215/remix/9781998944088.01
Chapter Summary
•	 Knowing what to do at a given time and under certain conditions is 
important for any intelligent being.
•	 Conditional statements are necessary and important constructs in all 
programming languages.
•	 if, if-­
else, if-­
elif, if-­
elif-­
else are the constructs for conditional 
statements.
•	 Each if, if-­
else, if-­
elif, if-­
elif-­
else statement represents a flow of 
program execution.
•	 The if statement is for one selection. It will execute a code block if the 
condition is met.
•	 The if-­
else statement is good for two selections.
•	 The if-­
elif and if-­
elif-­
else statements are good for multiple selections.
•	 The conditions behind if and elif are logical or Boolean expressions.
•	 Python has two constructs for iteration, the for statement and the while 
statement.
•	 The for statement can be used to repeat a code block through each 
member of an iterable, such as a list, tuple, or string, or an iterable 
object such as range(…).
•	 When the iteration includes a for statement, the number of iterations 
can be determined most of the time, unless the break statement is used 
within the code block to break out from the loop.
•	 The while statement is used to iterate under certain conditions.
•	 The number of repetitions needed when using a while statement is 
often unknown. One can be used with or without a break statement 
within the code block.
•	 The continue statement can be used within the code block of a for or 
while statement to directly go to the next iteration.
•	 Any for statement can be rewritten as a while statement.
Exercises
	
1.	 Mentally run the following code blocks and write down the output of 
each code block.
a.
m, n = 10, 20
if m * n < 1000:
   print('This is not enough!')
	196	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
b.
m, n = 10, 3
if m // n == m / n:
   print(f'{m} // {n} = {m//n}')
else:
   print(f'{m} / {n} = {m/n}')
c.
m, n = 13, 5
if m * 2 > n**2:
   print(f'{m} * {2} = {m*2}')
else:
   print(f'{n} ** {2} = {n**2}')
	
2.	 Mentally run each of the code blocks below and write down the output 
of each code block:
a.
for i in range(1, 6):
 print(f'The cube of {i} is {i*i*i}')
b.
i, s = 1, 1
while i<=10:
 s *= i
 i += 1
print("the product of 1x2x3…10 is ", s)
c.
total = 0
for i in range(10):
 total += i*2 +1
print(f'1+3+5+ … +19 = {total}')
d.
number = 32
factors = []
for d in range(1, number):
 if number % d == 0:
 factors += [d]
print(f'factors of {number} are {factors}')
Projects
	
1.	 Write a program that gets three numbers from the user and displays the 
biggest number among the three.
	
2.	 Write a program that gets a number from the user then says whether 
the number is an even number or odd number.
	
3.	 Write a program that takes three numbers from the user as the lengths 
of three lines, then determines if the three lines can make a triangle.
	
4.	 Write a program that takes three numbers from the user as the 
lengths of three lines, then determines if the three lines can make a 
triangle. If the three lines can make a triangle, the program should 
further determine if the triangle is an equilateral triangle or an 
isosceles triangle.
	
Flow Control of Statements	
197
 https://doi.org/10.15215/remix/9781998944088.01
	
5.	 Write a program that takes three numbers from the user as the lengths 
of three lines, then determines if the three lines can make a triangle. 
If the three lines can make a triangle, the program should further 
determine if the triangle will be a right triangle.
	
6.	 Compound interest is a common practice in finance and banking, 
allowing you to earn interest on interest as well as on the principal. 
Assume that your bank offers a savings account with which you can 
earn compound interest. The amount you deposit into the account is 
p, and annual compound interest is r. By the end of n years after your 
initial deposit, the account balance will be a = p(1 + r)n. For this project, 
write a program that takes three numbers from the user as the initial 
deposit, the annual interest, and the number of years that the user 
wants the money to stay in the account. Calculate and display how 
much money the user will have by the end of the nth year.
	
7.	 In some countries like Canada, tax on taxable personal income for a 
year is calculated progressively according to a calculation table set for 
the year, such as the one shown below:
Income 
tax
15% on 
the first 
$48,534 
or less
20.5% on 
the next 
$48,534
26% on 
the next 
$53,404
29% on 
the next 
$63,895
33% on 
taxable 
income 
over 
$214,368
Income
$0–­
$48,535
$48,536–­
$97,069
$96,070–­
$150,473
$150,474–­
$214,368
over 
$214,368
Write a program that takes taxable income from a user and calculates 
the total income tax payable according to the table above.
	
8.	 A mortgage is the money borrowed from a lender for the purchase 
of a property. Mortgages and mortgage payments are a big thing for 
almost everyone. For a mortgage with principal of P at a fixed monthly 
interest rate of r that needs to be paid off in Y years or 12 * Y = N 
months, the monthly payment would be:
Write a program that takes the principal, fixed annual interest rate, 
and years of amortization then calculates and displays the monthly 
payment amount. Hint: You will need to work out the number of 
months from number of years, and the monthly interest rate from the 
annual interest rate.
	198	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
	
9.	 In the world of science and mathematics, the existence of some 
constants has attracted the attention of many scientists and 
mathematicians. Among those constants, pi π is the most well-­
known. 
Many great efforts have been made to get a more precise value for π. 
The following is a formula developed by Gottfried Leibniz for the 
calculation of π.
Write a program that takes an integer from the user to specify the 
number of terms used to calculate π. Calculate and display the 
approximate value.
	
10.	 Three integers—­
A, B and C—­
are called a Pythagorean when C * C = 
A * A + B * B. Write a program to take an input of integer from the 
user and find all the Pythagorean triples of integers, none of which 
are bigger than the integer taken from the user. For example, if the 
number from the user is 6, then 5, 4, and 3 are a Pythagorean triple 
because 52 = 42 + 32 = 25.
	
11.	 Compound interest is a common practice in finance and banking 
to earn interest on interest as well as on the principal. Assume that 
your bank offers you a deposit account through which you can earn 
compound interest, the amount you deposit into the account is p, and 
annual compound interest is r. By the end of n years after your initial 
deposit, the account balance will be a = p(1 + r)n. For this project, get 
p, r, and n from the user, then calculate and display a table showing 
the balance, the interest earned each year, and the total interest 
earned so far.
	
12.	 An integer is called a perfect number* if the sum of its factors, 
excluding itself, is equal to the integer itself. For example, 6 is a 
perfect number because 6 = 1 + 2 + 3, and 1, 2, and 3 are all its factors. 
Write a program to get a number from a user, then determine if the 
number is a perfect number. If yes, display all its factors.
	
13.	 For a given integer n, if another integer m can divide n, then m is 
called a factor of n. In mathematics, finding all factors of a given 
integer is an important operation, especially for cryptography. Write 
a program that takes an integer from the user and determine and 
display all the factors of the number given by the user.
* By definition, a perfect number is a positive integer that is equal to the sum of all its divisors, 
excluding itself but including 1. The smallest perfect number is 6, which is equal to the sum of 
1, 2, and 3.
	
Flow Control of Statements	
199
 https://doi.org/10.15215/remix/9781998944088.01
	
14.	 Read a series of float numbers from the user and calculate and display 
the average of all the numbers given by the user. Assume that the 
number of float numbers is unknown but that a negative number is 
used to indicate the end of the input.
	
15.	 For a mortgage with a principal of P at a fixed monthly interest rate of 
r that needs to be paid off in Y years or 12 * Y = N months, the monthly 
payment would be:
Continuing the project you did above for project 8, calculate a table 
showing the interest and principal paid each month and the principal 
balance at each month’s end.
This page intentionally left blank
 https://doi.org/10.15215/remix/9781998944088.01
Chapter 4
Handle Errors and 
Exceptions in Programs
Errors in programs are inevitable but must be handled elegantly when they 
occur. In this chapter, you will learn how to raise and handle exceptions when 
errors occur in programs.
Learning Objectives
After completing this chapter, you should be able to
•	 explain different types of errors and exceptions that may occur in a 
Python program.
•	 write down the specific codes for some common types of exceptions.
•	 use the try statement properly to handle possible exceptions raised by 
potential errors in a block of program code.
•	 understand the cause of the following messages:
◾	 TypeError
◾	 NameError
◾	 RuntimeError
◾	 OSError
◾	 ValueError
◾	 ZeroDivisionError
◾	 AssertionError
◾	 FileNotFoundError
•	 understand how to purposely throw an exception using a raise 
statement in a program.
•	 use an assert statement to prevent future exceptions in a program.
•	 list user-­
defined exceptions.
•	 define a class of exceptions.
	202	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
4.1 Errors in Your Programs
It is not unusual to have errors in your programs, especially for beginners. There 
are three types of errors in computer programs: syntax errors, runtime errors, and 
logic errors. If you program in a modern IDE such as VS Code, syntax errors can 
be easily avoided because whenever there is incorrect syntax, such as a misspelled 
keyword, you will be alerted by the IDE. Modern IDEs can even detect whether an 
identifier is used properly, such as when an undefined function is called or the 
value of a variable is used but no value has been previously assigned to the variable.
On the other hand, runtime errors only happen during the runtime of pro­
grams. Runtime errors are the most irritating to users and should be caught 
and handled gracefully in programs.
Logic errors are those caused by incorrect logic or operation in a program 
for a given problem or task. The following are some examples of logic errors:
	
1.	 An incorrect operator is used in an expression or statement, such as 
use + instead of −, > instead <, or vice versa.
	
2.	 The boundary of a sequence is miscounted.
Compared to syntax errors and runtime errors, the consequences of logic errors can 
be more costly because they often cause the program to produce incorrect results. 
It is even more concerning because logic errors often remain undetected until 
someone realizes that the result from the program is not what was expected. For 
example, syntax and runtime errors will produce no result, which will be immedi­
ately noticed by the user, whereas an incorrect result often goes unnoticed till it 
causes unexpected consequences, such as a missile being sent to the wrong target.
No programming techniques can help eliminate logic errors. It is up to the 
programmers to make the logic correct. That is why computer programmers 
should also take certain math courses.
Because Python programs are normally interpreted without compilation, 
syntax errors such as misspelled keywords are often found at runtime as well 
(unless the programs were developed in a smart IDE that can help identify the 
syntax errors while programming). However, the exception-­
handling mechan­
ism provided by Python or other programming is not intended to catch syntax 
errors. You, as a programmer, must ensure that the programs you write use 
correct syntax, with the help of an IDE whenever is available.
You may be wondering what errors can be handled by the exception-­
handling 
mechanism provided by Python. The following is a long list of exception classes, all 
of which can be caused by errors in programs. The try-­
except statement provided 
by Python to handle exceptions and errors uses the names of exception classes to 
	
Handle Errors and Exceptions in Programs	
203
 https://doi.org/10.15215/remix/9781998944088.01
identify particular exceptions caused by specific errors. Remember at least the 
names of these commonly occurring exceptions or know where to find them.
Exception
This is the superclass of all exception classes to be detailed below. In the code 
sample below, any error will be caught and treated the same because it has 
“Exception” in the list of exceptions behind the except clause.
In [ ]:
try:
  n = int(input('Give me an integer:'))
  m = int(input('Give me another integer:'))
  n /= m   # divide n by m
except Exception:
  print('Wrong: It is not an integer or m is 0')
Out [ ]:
Give me an integer: 12
Give me another integer: 0
Wrong: It is not an integer or m is 0
In this particular case, m was given 0 so that the exception was caused by 
dividing n by 0, but the except clause could not tell because “Exception” is not 
a specific exception class.
When programming, you should put a code block in a try-­
except statement if 
you know that an error or errors might occur and you may even know what kind 
of error it may be. You want to have the errors handled elegantly. In the sample 
code above, because we ask for input from users and there is no guarantee that 
the user will not input a 0 for m, which will be used as the denominator or divisor, 

we put the code in a try-­
except to handle the possible exception raised by the error. 
Otherwise, the program would stop with a report of the error, as shown below:
In [ ]:
n = int(input('Give me an integer:'))
m = int(input('Give me another integer:'))
n /= m # divide n by m
Out [ ]:
Give me an integer: 12
Give me another integer: 0
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
ZeroDivisionError  Traceback (most recent call last)
<ipython-­
input-­
2-­
d0d8abede315> in <module>
1 n = int(input('give me an integer:'))
2 m = int(input('give me another integer:'))
-­
> 3 n /= m   # divide n by m
ZeroDivisionError: division by zero
	204	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The use of the try-­
except statement will be explained in the next section. 
For now, just remember the code lines between try and except are part of the 
program to be executed for the application, while the code under the except 
header tells what to do when a given exception has occurred.
ArithmeticError
The base class of all arithmetic errors, including OverflowError, ZeroDivision­
Error, and FloatingPointError, which means except ArithmeticError would be 
the same as except (OverflowError, ZeroDivisionError, FloatingPointError). 
Note that when there are multiple error names behind the except keyword, a 
pair of parentheses is used to enclose them.
OverflowError
This subclass of ArithmeticError is raised when the result of an arithmetic 
operation is too large to be represented.
A coding example of catching arithmetic errors like this is shown below:
In [ ]:
try:
  x = pow(123567,999999)
  print(f'Big x has {len(str(x))} digits')
except OverflowError:
  print('It has overflowed because the number is too 
big')
Out [ ]:
Big x has 5091898 digits
The code in the try clause calculates the power of 123567 to 999999 or 
123567**999999. The code is put in a try-­
except statement because the result 
is expected to be very big and may overflow. Though the result has over five 
million digits, no exception is raised because the design and implementation 
of Python can handle very big numbers.
ZeroDivisionError
ZeroDivisionError is raised when the divisor of a division or module operation 
is 0. With this very specific exception/error name, the earlier example of this 
section can be rewritten as shown below:
In [ ]:
try:
  n = int(input('Give me an integer:'))
  m = int(input('Give me another integer:'))
  n /= m   # divide n by m
except ZeroDivisionError:
  print('Wrong: 0 cannot be used as a divisor!')
	
Handle Errors and Exceptions in Programs	
205
 https://doi.org/10.15215/remix/9781998944088.01
Out [ ]:
Give me an integer: 23
Give me another integer: 0
Wrong: 0 cannot be used as a divisor!
FloatingPointError
FloatingPointError is raised when a floating-­
point operation fails. However, 
Python does not raise such errors by default in its standard distribution. You 
will need a Python built with the -­
-­
 with-­
fpectl flag, and import a module called 
fpectl when you want to turn the floating-­
point error control on or off.
AssertionError
AssertionError is raised when the assert statement fails. The assert statement 

is used to make an assertion on an assumed fact, such as whether a variable is 

defined, whether a variable is holding a specific value, or whether a value 

is a member of a sequence or set. If the assumed fact is not True, an Asser­
tionError will be raised so that we know the assumed fact is untrue and we 
may need to deal with it, such as doing something else in the absence of the 
assumed fact.
In [ ]:
vs = list(range(19))   # create a list with 19 members 
indexed from 0 to 18
assert(20 in vs)   # 20 is not in the list
Out [ ]:
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
AssertionError  Traceback (most recent call last)
<ipython-­
input-­
14-­
5a912881af6c> in <module>
1 vs = list(range(19))   # create a list with 19 members indexed from 0 to 18
-­
-­
-­
-­
> 2 assert(20 in vs)   # 19 is out of the range > 18
AssertionError:
AttributeError
AttributeError is raised when an attribute assignment or reference fails. Such an 
error will occur if you use an attribute of an object but the attribute itself does 
not exist.
In [ ]:
class Student:
  pass
s0 = Student()
s0.firstname = 'John'
s0.lastname = 'Doe'
print(s0.fullname)
	206	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Out [ ]:
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
AttributeError  Traceback (most recent call last)
<ipython-­
input-­
15-­
5dc5b1212e9f> in <module>
6 s0.lastname = 'Doe'
7
-­
-­
-­
-­
> 8 print(s0.fullname)
AttributeError: 'Student' object has no attribute 'fullname'
BufferError
BufferError is raised when a buffer-­
related operation cannot be performed. 
This often happens when working directly with computer memory and making 
restricted changes to a given memory area (buffer). The following is an example:
In [ ]:
import io
data = b'Hello, Python!'   # this creates a bytearray
darray = io.BytesIO(data)   # this creates a read-­
write 
copy of the bytearray
dbuff = darray.getbuffer()   # the memory of the 
bytearray is exported
darray.write(b'Hello World!')   # raise error because 
the buffer is not changeable
Out [ ]:
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
BufferError  Traceback (most recent call last)
<ipython-­
input-­
23-­
dc2c4a5f6bbd> in <module>
3 darray = io.BytesIO(data)   # this creates a read-­
write copy of the 
bytearray.
4 dbuff = darray.getbuffer()   # the memory of the bytearray is exported
-­
-­
> 5 darray.write(b'Hello World!')   # raise error because the buffer is not 
changeable
BufferError: Existing exports of data: object cannot be re-­
sized
EOFError
EOFError is raised when the input() function hits the end-­
of-­
file condition.
GeneratorExit
GeneratorExit is raised when a generator’s close() method is called.
ImportError
ImportError is raised when the imported module is not found.
	
Handle Errors and Exceptions in Programs	
207
 https://doi.org/10.15215/remix/9781998944088.01
IndexError
IndexError is raised when the index of a sequence is out of range.
In [ ]:
vs = list(range(19))   # create a list with 19 members 
indexed from 0 to 18
vs[19] *= 3   # 19 is out of the range > 18
Out [ ]:
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
IndexError  Traceback (most recent call last)
<ipython-­
input-­
3-­
47e31ad8b75b> in <module>
1 vs = list(range(19))
-­
-­
-­
-­
> 2 vs[19] *= 3
IndexError: list index out of range
KeyError
KeyError is raised when a key is not found in a dictionary.
In [ ]:
vdict = {1:'One', 2:'Two', 3:'Three'}   # create a 
dictionary
vdict[5]   # the dictionary doesn't have key 5
Out [ ]:
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
KeyError  Traceback (most recent call last)
<ipython-­
input-­
4-­
3011ee6a346e> in <module>
1 vdict = {1:'One', 2:'Two', 3:'Three'}
-­
-­
-­
-­
> 2 vdict[5]
KeyError: 5
KeyboardInterrupt
KeyboardInterrupt is raised when the user hits the interrupt key (Ctrl+C or 
Delete).
MemoryError
MemoryError is raised when an operation runs out of memory.
ModuleNotFoundError
ModuleNotFoundError is raised by import when a module could not be located, 
or None is found in sys.modules.
In [ ]:
import fpectl   # import module fpectl for floating-­
points control
round(14.5/0, 3)
	208	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Out [ ]:
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
ModuleNotFoundError  Traceback (most recent call last)
<ipython-­
input-­
8-­
3808b892163e> in <module>
-­
-­
-­
-­
> 1 import fpectl
2 round(14.5/0, 3)
ModuleNotFoundError: No module named 'fpectl'
NameError
NameError is raised when a variable is not found in the local or global scope.
In [ ]:
print(what)   # print the value of variable named what, 
undefined
Out [ ]:
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
NameError  Traceback (most recent call last)
<ipython-­
input-­
1-­
8b57ddde6300> in <module>
-­
-­
-­
-­
> 1 print(what)
NameError: name 'what' is not defined
NotImplementedError
NotImplementedError is raised by abstract methods such as when an abstract 
method is called.
OSError
OSError is raised when a system operation causes a system-­
related error.
BlockingIOError
BlockingIOError is a subclass of OSError, raised when an operation would block 
on an object (e.g., a socket) set for a nonblocking operation.
ChildProcessError
ChildProcessError is a subclass of OSError, raised when an operation on a child 
process fails.
ConnectionError
ConnectionError is a subclass of OSError and a base class for connection-­
related issues.
	
Handle Errors and Exceptions in Programs	
209
 https://doi.org/10.15215/remix/9781998944088.01
BrokenPipeError
BrokenPipeError is a subclass of ConnectionError, raised when trying to write 
on a pipe while the other end has been closed or when trying to write on a 
socket that has been shut down for writing.
ConnectionAbortedError
ConnectionAbortedError is a subclass of ConnectionError, raised when a con­
nection attempt is aborted by the peer.
ConnectionRefusedError
ConnectionRefusedError is a subclass of ConnectionError, raised when a 

connection attempt is refused by the peer.
ConnectionResetError
ConnectionResetError is a subclass of ConnectionError, raised when a con­
nection is reset by the peer.
FileExistsError
FileExistsError is a subclass of OSError, raised when trying to create a file or 
directory that already exists.
FileNotFoundError
FileNotFoundError is a subclass of OSError, raised when a file or directory 

is requested but does not exist.
IsADirectoryError
IsADirectoryError is a subclass of OSError, raised when a file operation is 
requested on a directory.
NotADirectoryError
NotADirectoryError is a subclass of OSError, raised when a directory oper­
ation is requested on something that is not a directory.
PermissionError
PermissionError is a subclass of OSError, raised when trying to run an operation 
without adequate access rights such as filesystem permissions.
	210	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
ProcessLookupError
ProcessLookupError is a subclass of OSError, raised when a given process 
doesn’t exist.
TimeoutError
TimeoutError is a subclass of OSError, raised when a system function has timed 
out at the system level.
RecursionError
RecursionError is a subclass of Exception, raised when the maximum recursion 
depth set by the system is exceeded. The set recursion depth can be found by 
calling sys.getrecursionlimit().
ReferenceError
ReferenceError is a subclass of Exception, raised when a weak reference proxy 
is used to access a garbage collection referent.
RuntimeError
RuntimeError is raised when an error does not fall under any other category.
StopIteration
StopIteration is raised by the next() function to indicate that there is no further 
item to be returned by the iterator.
StopAsyncIteration
StopAsyncIteration is raised by the __anext__() method of an asynchronous 
iterator object to stop the iteration.
SyntaxError
SyntaxError is raised by the parser when a syntax error is encountered.
In [ ]:
s = 0
for i in range(10)   # a colon is missing which will 
cause a syntax error
  s += i
Out [ ]:
File '<ipython-­
input-­
16-­
6e54ba8cdb35>', line 2
for i in range(10)
                                 ^
SyntaxError: invalid syntax
	
Handle Errors and Exceptions in Programs	
211
 https://doi.org/10.15215/remix/9781998944088.01
IndentationError
IndentationError is raised when there is an incorrect indentation. Such errors 
may occur quite often at the beginning of your study of Python programming. 
You must pay great attention to it because indentation matters a lot in Python 
programs/scripts.
In [ ]:
s = 0
while i < 10:
  s += i
  i += 1# not indented the same
Out [ ]:
File '<tokenize>', line 4
    i += 1   # not indented the same
    ^
IndentationError: unindent does not match any outer indentation level
TabError
TabError is raised when the indentation consists of inconsistent tabs and spaces. 
Indentations can be made of spaces and tabs, but they need to be consistent 
to avoid such errors.
SystemError
SystemError is raised when the interpreter detects an internal error.
SystemExit
SystemExit is raised by the sys.exit() function.
TypeError
TypeError is raised when a function or operation is applied to an object of an 
incorrect type.
In [ ]:
sm = 10 + 'twenty'   # computer doesn't know twenty is 
20
Out [ ]:
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
TypeError  Traceback (most recent call last)
<ipython-­
input-­
19-­
a90f29de94a2> in <module>
-­
-­
-­
-­
> 1 sm = 10 + 'twenty'
TypeError: unsupported operand type(s) for +: 'int' and 'str'
	212	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
UnboundLocalError
UnboundLocalError is raised when a reference is made to a local variable in a 
function or method but no value has been bound to that variable.
UnicodeError
UnicodeError is raised when a Unicode-­
related encoding or decoding error occurs.
UnicodeEncodeError
UnicodeEncodeError is raised when a Unicode-­
related error occurs during 
encoding.
UnicodeDecodeError
UnicodeDecodeError is raised when a Unicode-­
related error occurs during decoding.
UnicodeTranslateError
UnicodeTranslateError is raised when a Unicode-­
related error occurs during 
translation.
ValueError
ValueError is raised when a function gets the correct type of argument but an 
improper value.
In [ ]:
i = int('ten')   # int doesn't convert ten into 10
Out [ ]:
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
ValueError  Traceback (most recent call last)
<ipython-­
input-­
20-­
6bbb9f319a0e> in <module>
-­
-­
-­
-­
> 1 i = int('ten')
ValueError: invalid literal for int() with base-­
10: 'ten'
The following is a sample program to show how errors should be handled 
in a Python program:
# a python program to show how errors and exceptions are 
handled
 
# ask the user to enter two numbers
num1 = input("Enter the first integer number: ")
num2 = input("Enter the second integer number: ")
	
Handle Errors and Exceptions in Programs	
213
 https://doi.org/10.15215/remix/9781998944088.01
# try to convert the inputs to floats and divide them
try:
  result = int(num1) / int(num2)
  print(f"The result of dividing {num1} by {num2} is 
{result}.")
# handle the possible errors and exceptions
except ValueError:
    print("Invalid input. Please enter numbers only.")
except ZeroDivisionError:
    print("Cannot divide by zero. Please enter a nonzero 
number.")
except Exception as e:
    print(f"An unexpected error occurred: {e}")
The following exception will be raised when you run the code but input a 
literal instead of an integer:
Invalid input. Please enter numbers only.
If you type a 0 for the second input, the following exception will be raised:
Cannot divide by zero. Please enter a nonzero number.
Note that in real applications, you may not want a user to restart the pro­
gram when an error has occurred. Instead, you may want to let the program 
continue until the user has given a valid input.
# a python program to show how errors and exceptions are 
handled
 
# initialize a flag to indicate if the division is 
successful
success = False
 
# use a while loop to keep asking for inputs until 
success is True
while not success:
    # ask the user to enter two numbers
    num1 = input("Enter the first number: ")
    num2 = input("Enter the second number: ")
	214	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
    # try to convert the inputs to floats and divide them
    try:
        result = int(num1) / int(num2)
        print(f"The result of dividing {num1} by {num2} 
is {result}.")
        # set success to True if no error occurs
        success = True
    # handle the possible errors and exceptions
    Zexcept ValueError:
        print("Invalid input. Please enter numbers 
only.")
    except ZeroDivisionError:
        print("Cannot divide by zero. Please enter a 
nonzero number.")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
This will ensure the program will continue until two integer numbers are 
received and the division is successful.
Now let us solve a real problem: write a Python program to find all perfect 
numbers in a given range set by a user. A perfect number is an integer number 
that is equal to the sum of all factors, including 1 but excluding itself. For example, 
6 is a perfect number because 6 = 1 + 2 + 3, and 1, 2, and 3 are all its factors.
So basically, the steps to take, or the algorithm, will be as follows:
	
1.	 Get two integers from user to set the range, assigned to a and b, 
respectively. If a is greater than b, then we swap their values.
	
2.	 Loop through all the numbers between a and b, including a and b, and 
test each number to see if it is a perfect number; if yes, we add it to 
a list holding perfect numbers found so far. The list should be set as 
empty at the beginning.
	
3.	 Print out all the perfect numbers in the list, and stop.
To test a number to see if it is perfect, according to the definition above, we 
need to first find out its factors and check whether the sum of all the factors is 
equal to the number itself. So there will be two additional steps:
	 2.1.	 Find out all the factors, and keep them all in a list.
	 2.2.	 Check whether the number is equal to the sum of all its factors in the 
list built up in step 2.1.
	
Handle Errors and Exceptions in Programs	
215
 https://doi.org/10.15215/remix/9781998944088.01
The following is one implementation of the algorithm in Python, taken 
from a Jupyter Notebook cell:
# a python program to find all the perfect numbers in a 
range
# set by the user
 
# first get two integers from user
# initialize a flag to indicate if the division is 
successful
success = False
 
# use a while loop to keep asking for inputs until 
success is True
while not success:
    # ask the user to enter two numbers
    num1 = input("Enter the first number: ")
    num2 = input("Enter the second number: ")
 
    # try to convert the inputs to floats and divide them
    try:
 
        a, b = int(num1), int(num2)
 
        # set success to True if no error occurs
        success = True
 
        if a>b: # then we need to swap a and b
            c = a
            a = b
            b = c
        perfect_list = [] # make an empty list ready to 
hold all perfect numbers
        for n in range(a, b+1): # we said b is included
            # start finding all factors of n
            factor_list = [1] # make a list with 1 as a 
single element
            for f in range(2,n): # start from 2, with n 
as excluded from factors
                if n%f == 0: # f is a factor of n
	216	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
                if n%f == 0: # f is a factor of n
                    if not f in factor_list:
                        factor_list.append(f)
            # now we have a list of factors for n
            if n == sum(factor_list): # n is a perfect 
number
                perfect_list.append([n, factor_list]) # 
keep factors too for checking
        # now we have found all the perfect numbers in 
the range
        print(f"Perfect numbers found between {a} and 
{b}:")
        for n in perfect_list:
            print(n, end=" ")
 
    # handle the possible errors and exceptions
    except ValueError:
        print("Invalid input. Please enter numbers 
only.")
    except ZeroDivisionError:
        print("Cannot divide by zero. Please enter a 
nonzero number.")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
When running the program with Jupyter Notebook in VS Code, by pressing 
Ctrl+Enter and inputting 3 and 1000 for the two numbers requested, the fol­
lowing output will be produced:
Perfect numbers found between 3 and 1000:
[6, [1, 2, 3]] [28, [1, 2, 4, 7, 14]] [496, [1, 2, 4, 8, 16, 31, 62, 124, 248]]
The output shows both the perfect numbers and a list of their factors.
4.2 Handling Runtime Errors and Exceptions
The runtime errors and exceptions discussed can be fatal or nonfatal. By a non­
fatal error, we mean that when the error occurs, the program can still continue 
if it is properly handled. In contrast, when a fatal error occurs, the program 
stops and has to be fixed before you can restart the program.
	
Handle Errors and Exceptions in Programs	
217
 https://doi.org/10.15215/remix/9781998944088.01
When programming, since runtime errors (or “exceptions,” to use a more 
techie term) are unavoidable, the best a programmer can do is to have all 
exceptions caught and handled properly when they occur. Otherwise, what 
renders to the users when an error has occurred could be overwhelming 
and irritating. Consider the following code example, which simply asks for 
a numeric grade.
In [ ]:
grade = int(input('Please input your grade: '))
When a letter grade is entered instead, a runtime error occurred, and Python 
interpreter or Python Virtual Machine (PVM) renders a bunch of information 
about the error, as shown below:
Out [ ]:
Please input your grade: A
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
ValueError  Traceback (most recent call last)
<ipython-­
input-­
13-­
d0126eb94acb> in <module>
-­
-­
-­
-­
> 1 grade = int(input('Please input your grade: '))
ValueError: invalid literal for int() with base-­
10: 'A'
Although the information above may be helpful for programmers to debug 
the code and correct the error, it is completely useless for ordinary users. For 
that reason, all modern programming languages provide some way to handle 
runtime errors and exceptions so that only sensible information can be seen 
by users and, in most cases, programs can continue and recover from errors 
peacefully, without crashing.
Similar to those in other modern programming languages, Python excep­
tions are handled with a try statement. The general coding structure of try 
statements is as follows:
# the try clause is for enclosing a code block of the 
program
# in which errors may occur
try:
  <code block in the normal code flow>   # things to do 
normally
 
except <exception/error 1>:   # the except clause is for 
handling errors
	218	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
  <code block for exception 1>   # things to do if 
exception 1 happens
 
except <exception/error 2>:   # except clause may have a 
list of errors
  <code block for exception 2>   # things to do if 
exception 2 happens
 
except <exception/error 3>:   # there can be more 
exceptions
  <code block for exception 3>   # things to do if 
exception 3 happens
 
else:   # do something when no error has occurred
  <code block for else>   # things to do when no 
exceptions are raised
 
finally:   # finally clause allows to do something 
regardless of the above
  <code block for finally>   # things to do regardless of 
the above
As shown, a try statement starts with a try clause, which encloses the 
code that you want to run for the application but may cause errors and raise 
exceptions.
Right after the try clause is one or more exception clauses, each of which 
starts with the keyword “except,” followed by a system-­
defined error/exception 
name. The code of each exception clause specifies what you want to do if this 
error happens.
In [ ]:
try:
  grade = int(input('Please input your grade: '))
except ValueError as e:
  print('Exception has been raised! ', e)
Out [ ]:
Please input your grade: A
Exception has been raised! invalid literal for int() with base-­
10: 'A's
Note that in the code above, ValueError is the name of a built-­
in exception 
class. We put this code in a try statement because you do not know whether 
the user will type an integer as expected. If a nonnumber is typed, an error 
will occur for function int.
	
Handle Errors and Exceptions in Programs	
219
 https://doi.org/10.15215/remix/9781998944088.01
The else clause encloses the code specifying what to do if no errors are 
caught by all the exception blocks.
The finally clause encloses the code that will run regardless of whether any 
exception has been raised within the try clause.
Now comes the question of when you need to put a code block in a try state­
ment. You cannot put every piece of code in a try statement. The rule is that 
if a statement or block of code may cause an error during runtime, especially 
when the possibility is out of your control, the statement or code should be 
enclosed in a try statement and each of the possible errors should be handled 
properly. Examples of such a possibility may include the following situations:
	
1.	 Statements involve user input, because you never know if a user will 
do what you expected.
	
2.	 Statements involve the use of files, because there is no guarantee as to 
the status of the file. It may have been deleted when you want to read 
it; it may already have existed when you want to create a new one with 
same name.
	
3.	 Statements involve the use of resources on the web or on the internet 
in general because the resources may no longer be available.
	
4.	 Statements involve the use of numbers from user input or involve 
calculation, where 0 may end up as a denominator.
	
5.	 Statements involve extensive use of computer memory, which may 
lead to the depletion of RAM.
Chapter Summary
•	 Programs can have syntax errors and logic errors.
•	 Errors that are found when running the program are runtime errors.
•	 A good IDE can often help you avoid many syntax errors, including 
undefined names, incorrect indentation, incorrect formation of 
statements, and more. If there are syntax errors in your program, look 
for marks that your IDE may have added to indicate them in your code.
•	 Logic errors are caused by incorrect problem solving or programming 
logic. Examples include values that are out of the intended range and 
the incorrect use of operators or functions.
•	 Some logic errors can raise exceptions at runtime. For example, if an 
index variable for a sequence (string, list, or tuple) is out of range, an 
exception will be raised.
•	 Some logic errors can only be discovered by programmers, system testers, 
or users who notice an unexpected result or behaviour in the system.
	220	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
•	 A Python interpreter or virtual machine will raise exceptions when a 
runtime error has occurred. If exceptions are not caught and properly 
handled, the application or system will crash and become very ugly.
•	 Python and many other modern programming languages use try-­
except 
statements to handle exceptions.
•	 In Python, a try statement may take one of five forms: try-­
except, 
try-­
except-­
else, try-­
except-­
finally, try-­
except-­
else-­
finally, and 
try-­
finally.
•	 Between try and except, there should be a code block that may have 
runtime errors (such as incorrect input from users, files, or network 
sockets). The try keyword and the code block together form a try 
clause; right behind the except keyword, there should be the name or 
names of errors, followed by a code block to be run when the named 
error or errors occurred, which together form an except clause.
•	 A try clause can be followed by multiple except clauses.
•	 An except clause can be followed by an else clause, which consists of 
the else keyword and a code block to be run when an error has occurred 
but didn’t match any of the named errors in the except clauses.
•	 The finally clause can be used as a final clause of a try statement. It 
consists of the finally keyword and a code block that is to be run in all 
circumstances, whether an error has occurred or not.
Exercises
	
1.	 Suppose that you want to get an integer from a user, but you are 
concerned that the user may type something else other than an 
integer. Write a piece of code, as concise as possible, that asks the user 
for input until an integer is entered by the user.
	
2.	 What error will occur when running the following code?
	
a.	 s = 8 + 'a'
	
b.	 students = ['John', 'May', 'Jim']
	
c.	 total = sum(12, 90, 32, 'one hundred')
	
3.	 What’s wrong with the following code?
idx = 1
product = 0
while idx>10:
 product *= idx
 idx++
print(product)
 https://doi.org/10.15215/remix/9781998944088.01
Chapter 5
Use Sequences, Sets, 
Dictionaries, and Text Files
Chapter 5 details how compound data types and files can be used in program­
ming to solve problems. Data need to be structured and organized to represent 
certain kinds of information and to make problem solving, information process­
ing, and computing possible and more efficient. In addition to integer, float, 
and complex numbers, Python provides compound data types to represent 
more complicated information. These compound data types include strings, 
lists, tuples, sets, and dictionaries, as well as files that can be used to store 

a large volume of data in the long term (after the computer is shut off).
Learning Objectives
After completing this chapter, you should be able to
•	 explain sequences.
•	 explain strings and the methods and functions that can be applied to 
them.
•	 construct and format strings with the f prefix and the format method.
•	 discuss lists and tuples and the differences between the two.
•	 properly use the methods and functions of lists and tuples.
•	 explain sets and dictionaries and discuss the methods and functions 
that can be used on them.
•	 explain files and discuss the differences between text files and binary 
files and the methods and functions available for manipulating files.
•	 use strings, lists, tuples, sets, dictionaries, and files in problem solving 
and system design and development with Python.
	222	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
5.1 Strings
The string is one of the most important data types for information representa­
tion and processing. Strings are the base of information and data, and they 
were used to structure the sequences of characters for the ASCII table in the 
early days of modern computers. They are still used the same way now in UTF-­
8 

(8-­
bit Unicode Transformation Format Unicode), which includes characters for 
all human languages in the world.
Because strings are sequences of characters, the characters are ordered 

and indexed. We can access and manipulate individual characters through these 
indexes, starting from 0, as shown in the following example:
>>> name = "John Doe"
>>> name[0]
"J"
>>> name[3]
"n"
To construct a string from another data type, you use built-­
in function str(), 
as shown in the following example:
>>> tax_rate = 0.16
>>> tax_string = str(tax_rate)
>>> tax_string
'0.16'
>>> type(tax_string)
<class 'str'>
Methods of Built-­
In Class str
As is the case with some other object-­
oriented programming languages, string 
is a built-­
in class but is named str in Python. The str class has many powerful 
methods built into it, as detailed below with coding samples.
S.CAPITALIZE()
This converts the first character of the first word of string s to upper case and 
returns the converted string. Please note that characters in string s remain 
unchanged. This is the same for all string methods: no string method will alter 
the content of the original string variable. Rather, the method will make a copy 
of the content, manipulate the copy, and return it.
	
Use Sequences, Sets, Dictionaries, and Text Files	
223
 https://doi.org/10.15215/remix/9781998944088.01
>>> s = "intro to programming with python"
>>> s_capitalized = s.capitalize()
>>> s_capitalized
'Intro to programming with python'
>>> s
'intro to programming with python'
S.CASEFOLD()
Converts all characters of string s into lower case and returns the converted 
characters.
>>> s_capitalized
'Intro to programming with python'
>>> s_capitalized.casefold()
'intro to programming with python'
S.CENTER(SPACE)
Returns a string centred within the given space. Note how the empty whitespace 
is divided when the number is not even.
>>> s="hello"
>>> s.center(10)
' hello '
S.COUNT(SUB)
Returns the number of times a specified value occurs in a string.
>>> s = "intro to programming with python"
>>> s.count('i')
3
>>> s.count('in')
2
S.ENCODE()
Returns an encoded version of characters if they are not in the standard ASCII 
table. In the example below, there are Chinese characters in the string assigned 
to variable es.
>>> es = "Python is not a big snake (蟒蛇)"
>>> print(cs.encode())
b'Python is not a big snake \xe8\x9f\x92\xe8\x9b\x87'
	224	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Please note that the b in b'Python is not a big snake \xe8\x9f\x92\xe8\x9b\
x87' indicates that all non-­
ASCII characters in the string are in byte.
S.ENDSWITH(SUB)
Returns true if the string ends with the specified value, such as a question mark.
>>> cs = "Is Python an animal?"
>>> print(cs.endswith('?'))
True
S.EXPANDTABS(TS)
Sets the size of tabs in the string to ts, which is an integer.
>>> cs = "Is\t Python\t an\t animal?"
>>> cs
'Is\t Python\t an\t animal?'
>>> print(cs)
Is Python an animal?
>>> print(cs.expandtabs(10))
Is  Python  an  animal?
S.FIND(SUB)
Searches the string for a substring and returns the position of where it was 
found.
>>> s= 'intro to programming with python'
>>> s.find("ro")
3
S.FORMAT(*ARGS, **KWARGS)
Formats specified values given in the list of position arguments *args, and/or 
the list of keyword arguments **kwargs into string s, according to the format­
ting specs given in s.
This is very useful in constructing complex strings.
>>> "Hello {0}, you are {1:5.2f} years 
old.".format("Python", 23.5)
'Hello Python, you are 23.50 years old.'
	
Use Sequences, Sets, Dictionaries, and Text Files	
225
 https://doi.org/10.15215/remix/9781998944088.01
Please note that when mapping a dictionary, s.format(**mapping) can 
be used to format a string by mapping values of the Python dictionary to 
its keys.
>>> point = {'x':9,'y':-­
10} # point is a dictionary
>>> print('{x} {y}'.format(**point))
9 -­
10
Please note that ** has converted the dictionary point into a list of key­
word arguments. This formatting can also be done by directly using keyword 
arguments:
>>> print('{x} {y}'.format(x=9,y=-­
10))
9 -­
10
S.FORMAT_MAP(MAPPING)
Similar to format(**mapping) above. The only difference is that this one takes 
a dictionary without operator **.
>>> point = {'x':9,'y':-­
10}
>>> print('{x} {y}'.format_map(point))
9 -­
10
S.INDEX(SUB)
Searches the string for a substring and returns the position of the substring. 
Generates a return error if there is no such substring.
Note that this may not be a good method to test if one string is a substring 
of another.
>>> s= 'intro to programming with python'
'intro to programming with python'
>>> s.index("ing")
17
>>> s.index('w')
21
>>> s.index('z')
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
ValueError: substring not found
	226	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
S.ISALNUM()
Returns True if all characters in the string are alphanumeric.
>>> "98765".isalnum()
True
>>> "98765abcde".isalnum()
True
>>> "98765<>abcde".isalnum()
False
S.ISALPHA()
Returns True if all characters in the string are in the alphabet, including Unicode 
characters.
>>> "abcde".isalpha()
True
>>> "abcTde".isalpha()
True
>>> "abc35Tde".isalpha()
False
>>> "abc他Tde".isalpha()
True
S.ISDECIMAL()
Returns True if all characters in the string are decimals.
>>> "1235".isdecimal()
True
>>> "1235.65".isdecimal()
False
>>> "1235.65e".isdecimal()
False
S.ISDIGIT()
Returns True if all characters in the string are digits.
>>> "123565".isdigit()
True
>>> "1235.65".isdigit()
False
	
Use Sequences, Sets, Dictionaries, and Text Files	
227
 https://doi.org/10.15215/remix/9781998944088.01
>>> "1235y65".isdigit()
False
S.ISIDENTIFIER()
Returns True if the string is an identifier by Python’s definition.
>>> "w1235y65".isidentifier()
True
>>> "9t1235y65".isidentifier()
False
>>> "w1235_y65".isidentifier()
True
S.ISLOWER()
Returns True if all characters in the string are lower case.
>>> "w1235y65".isidentifier()
True
>>> "9t1235y65".isidentifier()
False
>>> "w1235_y65".isidentifier()
True
S.ISNUMERIC()
Returns True if all characters in the string are numeric.
>>> "123565".isnumeric()
True
>>> "1235.65".isnumeric()
False
>>> "123565nine".isnumeric()
False
S.ISPRINTABLE()
Returns True if all characters in the string are printable.
>>> "123565nine".isprintable()
True
>>> "123565 all printable".isprintable()
True
	228	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> "123565 all printable<>!@#$%^&**".isprintable()
True
S.ISSPACE()
Returns True if all characters in the string are whitespace.
>>> "  ".isspace()
True
>>> " \t  ".isspace()
True
>>> " \t  \n".isspace()
True
>>> " \t  m\n".isspace())
False
S.ISTITLE()
Returns True if the string follows the rules of a title—­
that is, the first letter of 
each word is upper case, while the rest are not.
>>> "Python Is a Great Language".istitle()
False
>>> "Python Is A Great Language".istitle()
True
S.ISUPPER()
Returns True if all characters in the string are upper case.
>>> "THIS IS ALL UPPER".isupper()
True
>>> "THIS IS ALL UPPER with some lower".isupper()
False
SEP
.JOIN(ITERABLE)
Joins the elements of an iterable with the separator. The iterable can be a list, 
tuple, string, dictionary, or set. Note that each element of the iterable must be 
a string. An integer or other number will raise an error.
>>> "-­
".join([" for", " programming!"])
'for-­
 programming!'
>>> "&".join([" for", " programming!"])
	
Use Sequences, Sets, Dictionaries, and Text Files	
229
 https://doi.org/10.15215/remix/9781998944088.01
'for& programming!'
>>> "%".join([" for", " programming!"])
'for% programming!'
>>> "%".join(" for programming!")
'%f%o%r% %p%r%o%g%r%a%m%m%i%n%g%!'
>>> "%".join(('a', '2', '3'))
'a%2%3'
>>> "%".join({'a', '2', '3'})
'3%a%2'
>>> "%".join({'a':'mnmn', '2':'987', '3':'43322'})
'a%2%3'
S.LJUST(SL)
Returns a left-­
justified version of the string within the given size of space.
>>> "Python Is A Great Language".ljust(30)
'Python Is A Great Language  '
S.LOWER()
Converts a string into lower case.
>>> "Python Is A Great Language".lower()
'python is a great language'
S.LSTRIP()
Returns a left trim version of the string.
>>> "  Python Is A Great Language  ".lstrip()
'Python Is A Great Language  '
S.MAKETRANS(DICT)
S.MAKETRANS(S1, S2)
Return a translation table to be used in translations.
In s.maketrans(dict), key-­
value pairs of dict provide mapping for translation; in 
the case of s.maketrans(s1, s2), chars in s1 are mapped to chars in s2 one by one.
>>> "Python Is A Great Language".maketrans({'a':'b', 
'c':'d'})
{97: 'b', 99: 'd'}
>>> "Python Is A Great Language".maketrans('ab', 'cd')
{97: 99, 98: 100}
	230	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
S.PARTITION(SUB)
Returns a tuple where the string is divided into three parts with sub in the 
middle.
>>> "Python Is A Great Language".partition('A')
('Python Is ', 'A', ' Great Language')
S.REPLACE(S1, S2)
Returns a string where a specified value is replaced with a specified value.
>>> "Python Is A Great Language".replace('Great', 
'Powerful')
'Python Is A Powerful Language'
S.RFIND(SUB)
Searches the string from the right for a substring and returns the position 

of where it was first found.
>>> "Python Is A Great Language".rfind('g')
24
S.RINDEX(SUB)
Searches the string from the right for a substring and returns the index of 

the substring where it was first found.
>>> "Python Is A Great Language".rindex('g')
24
S.RJUST(SUB)
Returns a right-­
justified version of the string within the given size of space.
>>> "Python Is A Great Language".rjust(35)
'   Python Is A Great Language'
S.RPARTITION(SUB)
Returns a tuple where the string is divided into three parts at the substring 
found from the right.
>>> "Python Is A Great Language".rpartition('g')
('Python Is A Great Langua', 'g', 'e')
	
Use Sequences, Sets, Dictionaries, and Text Files	
231
 https://doi.org/10.15215/remix/9781998944088.01
S.RSPLIT(SEP)
Splits the string at the specified separator and returns a list.
>>> "Python Is A Great Language".rsplit('g')
['Python Is A Great Lan', 'ua', 'e']
S.RSTRIP()
Returns a right-­
trimmed version of the string.
>>> "Python Is A Great Language ".rstrip()
'Python Is A Great Language'
S.SPLIT(SEP)
Splits the string at the specified separator and returns a list.
>>> "Python Is A Great Language".split('g')
['Python Is A Great Lan', 'ua', 'e']
S.SPLITLINES()
Splits the string at line breaks and returns a list.
>>> "Python Is A Great Language.\n I love 
it.".splitlines()
['Python Is A Great Language.', ' I love it.']
S.STARTSWITH(SS)
Returns true if the string starts with the specified value.
>>> "Python Is A Great Language".startswith('g')
False
>>> "Python Is A Great Language".startswith('P')
True
S.STRIP()
Returns a trimmed version of the string.
>>> " Python Is A Great  Language ".strip()
'Python Is A Great  Language'
	232	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
S.SWAPCASE()
Swaps cases, so lower case becomes upper case, and vice versa.
>>> "Python Is A Great Language".swapcase()
'pYTHON iS a gREAT lANGUAGE'
S.TITLE()
Converts the first character of each word to upper case.
>>> 'pYTHON iS a gREAT lANGUAGE'.title()
'Python Is A Great Language'
S.TRANSLATE()
Returns a string translated from s using a translation table created with the 
maketrans() method.
>>> table = "".maketrans("ab", 'cd')
>>> print("Python Is A Great Language".translate(table))
Python Is A Grect Lcngucge
S.UPPER()
Converts a string into upper case.
>>> "Python Is A Great Language".upper()
'PYTHON IS A GREAT LANGUAGE'
S.ZFILL(SL)
Fills the string to a specific length with a specified number of 0s at the beginning.
>>> "Python Is A Great Language".zfill(39)
'0000000000000Python Is A Great Language'
Built-­
In Functions and Operators for Strings
In addition to the string methods that you can use to manipulate strings, there 
are built-­
in functions and operators. The following are some examples.
USE OPERATOR + TO JOIN STRINGS TOGETHER
>>> "Python is a good language " + "for first-­
time 
programming learners."
'Python is a good language for first-­
time programming 
learners.'
	
Use Sequences, Sets, Dictionaries, and Text Files	
233
 https://doi.org/10.15215/remix/9781998944088.01
USE OPERATOR * TO DUPLICATE A STRING
>>> "Python! "*3
'Python! Python! Python! '
USE BUILT-­
IN FUNCTION LEN(S) TO FIND OUT THE LENGTH IF A 
STRING
>>> p_string = "Python is a good language " + "for first-­
time programming learners."
>>> len(p_string)
62
USE OPERATOR [I:J] TO SLICE A STRING
>>> p_string[0:5]   # slice begins at index 0 till index 
5 but excluding 5
'Pytho'
>>> p_string[5:25]   # slice begins at index 5 till index 
25 but excluding 25
'n is a good language'
>>> p_string[:16]   # when the starting index point is 
missing, 0 is assumed
'Python is a good'
>>> p_string[6:]   # when the ending index point is 
missing, the string is copied from the start to the end
'is a good language for first-­
time programming 
learners.'
>>> p_string[:]   # when both indexes are missing, the 
entire string is copied
'Python is a good language for first-­
time programming 
learners.'
>>> p_string[:-­
1] #the result is the same as using [:]
'Python is a good language for first-­
time programming 
learners'
Table 5-­
1 summarizes the operators and built-­
in functions you can use to 
manipulate strings.
	234	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Table 5-­
1: String-­
related operators and built-­
in functions
Operators and 
built-­
in functions 
on string
Operation
Code samples in Python interactive 
mode
s[n]
Get the character at 
nth position (n is 
an integer)
>>> name = "John Doe"
>>> name[2]
'h'
s[start:end]
Get a slice of the 
string. Negative 
indexes can also 
be used to count 
from the end.
>>> name = "John Doe"
>>> name[2:6]
'hn D'
>>> name = "John Doe"
>>> name[:-­
3]
'John '
s1 + s2
Concatenate two 
strings together
>>> first_name = "John"
>>> last_name = "Doe"
>>> first_name +' '+ 
last_name
'John Doe'
s * n
Duplicate s n times
>>> (name +' ')*3
'John Doe John Doe John Doe '
s1 in s
Test if s1 is a 
substring of s
>>> first_name in name
True
len(s)
Get the length of 
string s
>>> len(name)
8
print(s)
Print string s
>>> name = "John Doe"
>>> print(name)
John Doe
In addition to the ways discussed above to construct and manipulate strings, 
Python also provides some methods for constructing and formatting strings 
nicely.
Constructing and Formatting Strings
Because text is made of strings, and text is very important in representing data, 
information, and knowledge, there is a need to convert various data objects into 
well-­
formatted strings. For this purpose, Python has provided programmers 
with a very powerful means of formatting strings that may consist of various 
types of data such as literals, integer numbers, float numbers with different 
precisions, compound data, and even user-­
defined objects.
	
Use Sequences, Sets, Dictionaries, and Text Files	
235
 https://doi.org/10.15215/remix/9781998944088.01
In 2.1, we saw how we could use f/F, r/R, u/U, and b/B to provide some dir­
ection on string formation and representation. We also saw that prefixing f or 
F to a string allows us to conveniently embed expressions into the string with 
{ } and have the expressions be automatically evaluated. In the following, you 
will see two more ways of formatting strings.
FORMATTING WITH %-­
LED PLACEHOLDERS
Let’s begin with an example to explain how %-­
led placeholders are used to 
format and construct strings:
In [ ]:
d, n = 5.689, 8   # assigning values to variable d and 
n
s0 = "n has a value of %3d, and d has a value of 
%9.5f"%(n, d)   # with %-­
led placeholders
print(s0)   # s is evaluated
Out [ ]:
n has a value of 8, and d has a value of 5.68900
In the example above, the string before the last percentage sign % is called 
a formatting string. %3d is a %-­
led placeholder for an integer that will take a 
3-­
digit spot, whereas %9.5 is a %-­
led placeholder for a float number, where 9 
specifies the total number of digits the float number will take and 5 specifies the 
total number of decimal digits. The values in the tuple behind the last percent­
age sign are to be converted and placed into their corresponding placeholders. 
In the example, the value of n will be converted to an integer and placed into the 
first placeholder, whereas the value of d will be converted into a float number 
and placed into the second placeholder.
You can also use named placeholders, as shown in the next example, where 
the course and language (in the parentheses) are the names of the placeholders.
In [ ]:
course_number = 'comp218'
language = 'Python'
s1 = '%(course)7s -­
 introduction to programming in 
%(language)s '%{'course':course_number,
'language':language}
print(s1)
Out [ ]:
comp218 -­
 introduction to programming in Python
Note that when named placeholders are used, you will need to use dictionary 
instead of a tuple behind the last percentage sign.
The general format of a %-­
led placeholder is as follows:
	236	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
%[flags][width] [.precision] type
or the following, if you like to use named placeholders:
%[(name)][flags][width] [.precision] type
The flags may use one or a combination of the characters in Table 5-­
2.
Table 5-­
2: Flags used in placeholders in formatting strings
Flag
Meaning
Code sample
#
Used with b, o, x, or X, 
this specifies that the 
formatted value is 
preceded with 0b, 0o, 0x, 
or 0X, respectively.
>>> data = ("COMP 218", 10)
>>> '%s has %#X units.' % data
'COMP 218 has 0XA units.'
0
The conversion result 
will be zero-­
padded for 
numeric values.
>>> data = {"course": "COMP 
218", "number": 10}
>>> '%(course)s has 
%(number)016d units.' % data
'COMP 218 has 0000000000000010 
units.'
-­
The converted value is 
left-­
adjusted.
>>> data = {"course": "COMP 
218", "number": 10}
>>> '%(course)s has 
%(number)-­
6d units.' % data
'COMP 218 has 10  units.'
If no sign (e.g., a minus 
sign) is going to be 
written, a blank space is 
inserted before the value.
>>> data = {"course": "COMP 
218", "number": -­
10}
>>> '%(course)s has 
%(number)16d units.' % data
'COMP 218 has  10 units.'
+
The converted value is 
right-­
adjusted, and a 
sign character (+ or -­
, 
depending on whether 
the converted value is 
positive or negative) will 
precede it.
>>> data = {"course": "COMP 
218", "number": -­
10}
>>> '%(course)s has 
%(number)+6d units.' % data
'COMP 218 has  -­
10 units.'
The width is the total width of space held for the corresponding value, and 
precision is the number of digits that the decimal portion will take if the value 
is a float number. The type can be one of the types shown in Table 5-­
3.
	
Use Sequences, Sets, Dictionaries, and Text Files	
237
 https://doi.org/10.15215/remix/9781998944088.01
Table 5-­
3: Types used in placeholders for formatting strings
Conversion
Meaning
Code sample
d, i, or u
Signed integer decimal.
Note that in the last three coding 
samples, the plus sign has 
been automatically removed in 
the printout.
>>> print("%+d"% (88))
+88
>>> print("%+i"% (88))
+88
>>> print("%+u"% (88))
+88
>>> print("%+u"% (-­
88))
-­
88
>>> print("%+i"% (-­
88))
-­
88
>>> print("%+d"% (-­
88 ))
-­
88
o
Unsigned octal.
>>> print("%10o"% (25))
31
>>> print("%10.3o"% 
(25))
031
>>> print("%10.5o"% 
(25))
00031
X or x
Unsigned hexadecimal.
>>> print("%6.5X"% (88))
00058
>>> print("%6.5x"% (88))
00058
>>> print("%#5X"% (88))
0X58
>>> print("%5X"% (88))
58
E or e
Floating-­
point exponential format 
(lower case or upper case).
>>> print("%10.3e"% 
(123456.789))
1.235e+05
>>> print("%10.3E"% 
(123456.789))
1.235E+05
F or f
Floating-­
point decimal format.
>>> print("%13.5f"% 
(123456.789))
123456.78900
>>> print("%13.5F"% 
(123456.789))
123456.78900
G or g
Same as E or e if exponent is 
greater than −4 or less than 
precision; F otherwise.
>>> print("%13.5g"% 
(123456.789))
1.2346e+05
>>> print("%13.5G"% 
(123456.789))
1.2346E+05
(continued on next page)
	238	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Conversion
Meaning
Code sample
c
Single character (accepts integer 
or single character string).
>>> s = 'Python is 
great!'
>>> 'The first character 
of string %s is %c'%(s, 
s[0])
'The first character of 
string Python is great! 
is P'
r
String (converts any python 
object using repr() or __repr__(), 
instead of str() or __str__()). In 
class definition, you need to 
implement the dunder method 
__repr__ in order for repr() or __
repr__() to work on the objects 
of the defined class.
>>> 'The complex number 
will be displayed as 
%r'%(cn)
'The complex number 
will be displayed as 
(12+35j)'
s
String (converts any python 
object using str()). We will see 
the difference between %r and 
%s when we defined __repr__ 
method for a user-­
defined 
class.
>>> 'The complex number 
will be displayed as 
%s'%(cn)
'The complex number 
will be displayed as 
(12+35j)'
%%
No argument is converted 
(results in a "%" character in 
the result). It works only if the 
formatting is complete.
>>> '%% will be displayed 
as a single percentage 
sign, and the complex 
number is %s'%(cn)
'% will be displayed as 
a single percentage 
sign, and the complex 
number is (12+35j)'
FORMATTING STRINGS WITH THE FORMAT METHOD
Compared to the two methods we have seen so far, a more formal way of string 
formatting in Python is using the format method, as shown in the following 
example:
>>> s = "{0} is the first integer; {1} is the second 
integer".format(88, 99)
>>> s
'88 is the first integer; 99 is the second integer'
Table 5-­
3: Types used in placeholders for formatting strings (continued)
	
Use Sequences, Sets, Dictionaries, and Text Files	
239
 https://doi.org/10.15215/remix/9781998944088.01
The {} in the above example is also called a placeholder or replacement 
field. You can index the placeholders with integer numbers starting from 0, 
corresponding to the positions of values. You can also name the placeholders, 
in which case dictionary or keywords arguments need to be used within the 
format method call. In the example above, if we switch the indices (0 and 1), 
99 will be placed as the first integer and 88 will be placed as the second integer, 
as shown below:
>>> s = "{1} is the first integer; {0} is the second 
integer".format(88, 99)
>>> print(s)
99 is the first integer; 88 is the second integer
The general form of the replacement field is as follows:
{[field_name] [! conversion] [: format_spec]}
As mentioned before, having the item inside [] is optional; a placeholder 
can be as simple as an empty {}, as shown in the following example:
>>> 'X: {}; Y: {}'.format(3, 5)
'X: 3; Y: 5'
In the general form of the replacement field above, field name is something 
that can be used to identify the object within the arguments of the format 
method. It can be an integer to identify the position of the object, a name if 
keyword arguments are used, or a dot notation referring to any attribute of the 
object, as shown in the following example:
>>> c = 23 -­
 35j
>>> ('The complex number {0} has a real part {0.real} and 
an imaginary part {0.imag}.').format(c)
'The complex number (23 -­
 35j) has a real part 23.0 and 
an imaginary part -­
35.0.'
In this string formatting example, the first placeholder is {0}, in which 
integer 0 indicates that the value of the first argument of the format method 
call will be placed here; the second placeholder is {0.real}, which indicates 
that the value of the attribute real of the first object pf the format method call 
will be converted and inserted in that location; and the third placeholder is 
	240	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
{0.imag}, which indicates that the value of the attribute imag of the first object 
of the format method call will be converted and inserted in that location. It 
is up to the programmer to use the right attribute names or to compose the 
right reference to a valid object or value within the arguments of the format 
method call.
Please note that conversion in the general form of the replacement field 
above is led by an exclamation mark !, which is followed by a letter: r, s, or a. 
The combination !r is used to convert the value into a raw string, !s is used to 
convert the value into a normal string, and !a is used to convert the value into 
standard ASCII, as shown in the following examples:
>>> print('{!r} is displayed as a raw string'.format('\t 
is not tab, \n is not newline'))
'\t is not tab, \n is not newline' is displayed as a raw 
string.
 
>>> print('{!s} is not displayed as a raw string'.
format('\t is a tab, \n is a new line'))
is a tab,
is a new line is not displayed as a raw string.
 
>>> print('{!s} is displayed in Chinese'.format('Python 
is not 大蟒蛇.'))
Python is not 大蟒蛇. is displayed in Chinese.
 
>>> print('{!a} is displayed as an ASCII string'.
format('Python is not 大蟒蛇.'))
'Python is not \u5927\u87d2\u86c7.' is displayed as an 
ASCII string.
Please note the difference between the two outputs using !s and !a in 
particular.
It may also have been noted that with !r, the quotation marks surrounding 
the argument remain in the output, whereas with !s, the quotation marks have 
disappeared from the output. This is true when the argument for the !r is a 
string.
When the argument for !r is not a string, especially when it is a compli­
cated object, o, the !r will cause the placeholder to be replaced with the result 
of o.repr(), which in turn calls the dunder method __repr__() defined for the 
	
Use Sequences, Sets, Dictionaries, and Text Files	
241
 https://doi.org/10.15215/remix/9781998944088.01
object’s class. You will learn how to define and use Python dunder methods 
later in Chapter 7.
In string formatting with format method, formatting specification is led by 
a colon :, which is followed by formatting instructions, including the following:
	
1.	 justification or alignment: > for right justification, < for left 
justification, ^ for centre justification
	
2.	 with/without sign for numbers: + for always showing the sign, − for 
only show the minus sign, and ' ' for showing a whitespace when the 
number is positive
	
3.	 the total number of letter spaces allocated to the data, such as in {:6d}, 
where 6 specifies that 6 letter spaces are taken by the integer number
	
4.	 the number of decimal digits for float numbers, such as in {:6.2f}, in 
which the 2 specifies the decimal, so the float number will be rounded 
to take 2 spaces
	
5.	 data type conversion indicates what data will be converted and 
inserted into the placeholder; the types of data include
	
a.	 s for string
	
b.	 d for integer
	
c.	 f for float number
	
d.	 x or X for hex number
	
e.	 o for octal number
	
f.	 b for binary number
	
g.	 #x, #X, #o, and #b to prefix the numbers 0x, 0X, 0o, and 0b, 
respectively
The following example shows how the data type conversions work:
>>> '{:+12.8f}, {:+f}, {:#b}, {:#X}'.format(2.71828182, 
-­
3.14, 78, 127)
' +2.71828182, -­
3.140000, 0b1001110, 0X7F'
If you wish the output of a placeholder to be left, right, or centre justified 
within the given space, <, >, or ^ can be used to lead the format spec, as shown 
in the following example:
>>> '{:<+22.8f}, {:+f}, {:#b}, {:#X}'.format(2.71828182, 
-­
3.14, 78, 127)
'+2.71828182  , -­
3.140000, 0b1001110, 0X7F'
	242	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
If you want the extra space to be filled with a special character, such as #, 
you can put the character between the colon and <, >, or ^, as shown below:
>>> '{:#^+22.8f}, {:+f}, {:#b}, {:#X}'.format(2.71828182, 
-­
3.14, 78, 127)
'#####+2.71828182######, -­
3.140000, 0b1001110, 0X7F'
By this point, we have learned three ways of constructing and formatting 
strings: the first one is to use the f/F prefix, the second is to use a %-­
led place­
holder, and the last is to use the format method.
Among the three, the first one is the most compact and good for simple 
string construction without any fancy formatting. The expression within each 
{} will be evaluated, and the value will be converted into a string with which 
the placeholder is replaced as is.
Both the second and the third way can be used to construct and format 
more complex strings from various objects. The difference between the two is 
that the second, using a %-­
led placeholder, is more casual, whereas the third 
is more formal and the code more readable.
Regular Expressions
Information processing and text manipulation are important uses for modern 
computers, and regular expressions, called “REs” or “regexes” for short, were 
developed as a powerful way to manipulate text. Many modern programming 
languages have special libraries for searching and manipulating text using 
regular expressions. In Python, a standard module called re was developed 
for that purpose.
To correctly use the re module, we first must understand what regular 
expressions are and how to construct a regular expression that genuinely 
defines the strings we want to find and/or manipulate within a text because 
almost all functions/methods of the re module are based on such defined 
regular expressions.
What is a regular expression? A regular expression is a pattern that describes 
certain text or literal strings. Examples of some useful patterns include tele­
phone numbers, email addresses, URLs, and many others.
To be able to correctly define a regular expression precisely describing the 
strings we want to find and manipulate, we must first understand and remem­
ber the rules of regular expressions, as well as special characters and sequences 
that have special meanings in a re module. Since regular expressions are strings 
themselves, they should be quoted with single or double quotation marks. For 
	
Use Sequences, Sets, Dictionaries, and Text Files	
243
 https://doi.org/10.15215/remix/9781998944088.01
simplicity, however, we may omit some quotation marks in our discussion when 
we know what we are talking about in the context.
Plain literals such as a, b, c,…z, A, B, C,…Z, and numeric digits such as 0, 1, 
2,…9 can be directly used in a regular expression to construct a pattern, such 
as Python, Foo, Canada. Some symbols in the ASCII table have been given 
special meanings in re. These symbols, called metacharacters, are shown 

in Table 5-­
4.
Table 5-­
4: Metacharacters and basic rules for constructing 
regular expressions
Symbols
Meaning
Example
.
Match any character except \n, a 
new line, in a string.
t..t will match test, text,…
^
Affixed to a pattern to match the 
preceding regex if it is at the 
beginning of the string being 
searched.
^Hello will only match Hello when 
it is at the start of an email
$
Affixed to a pattern to match the 
preceding regex if it is at the end 
of a string.
mpeg$ will only match mpeg 
when it is at the end of a text
|
Match either the regex on the left 
or the regex on the right.
Wang|Wong will match either 
Wang or Wong
\
Form an escape sequence such 
as \d, \s,… with special meaning. 
Table 5-­
5 lists all the escape 
sequences defined in the re 
module.
Also used to escape the 
metacharacters in this table 
back to their original meanings.
\d will match any single decimal 
digit
\D is the negation of \d, meaning 
it will not match any single 
decimal digit
[…]
Define a set/class of characters.
[xyz] will match either x, y, or z.
W[ao]ng is the same as 
Wang|Wong
[^…]
Define a set of characters 
excluded from the pattern. 
Inside and at the beginning of [], 
^ is used as negation
[^A-­
Z\s] will match everything else 
except upper case letters and 
whitespace
[…x-­
y…]
Within [], define a range of 
characters from x to y
[0-­
9], [a-­
zA-­
Z]
(continued on next page)
	244	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Symbols
Meaning
Example
(…)
Match enclosed regex and save 
as subgroup for later use.
(B|blah\s)+ will only match the 
second blah in “blah, blah and 
blah” and save it
?
This and the rest in this table 
are called quantifiers. When 
? is affixed to a preceding 
regex (character or group) it 
becomes a nongreedy qualifier, 
meaning it will match only 0 or 
1 occurrence of the preceding 
regex.
? can also be affixed to + as +?, or 
* as *?, to make + or * nongreedy.
mpe?g will match mpg or mpeg
*
Affixed to pattern meaning to 
match 0 or more (greedy) 
occurrences of preceding 
regular expression. Greedy 
means that it will match as 
many as possible.
=* will match 0 or more 
consecutive =s
+
Affixed to a pattern to match 1 
or more occurrences of the 
preceding regular expression.
=+ will match 1 or more 
consecutive =s
{n}
Affixed to a pattern to match 
exactly n occurrences of the 
preceding regex.
[0-­
9]{3} will match the first 3 
occurrences of digits, like an 
area code, for example
{m, n}
Affixed to a pattern to match 
from m to n occurrences of the 
preceding regex.
[0-­
9]{5, 11} will match all 
sequences of decimal digits that 
are 5 to 11 digits in length
Table 5-­
5: Escape sequences with special meanings in re
Escape sequence
Special meaning in re
Example
\d
Match any decimal digit 0-­
9.
Img\d+.jpg
\D
Opposite of \d, meaning do 
not match any decimal digit.
[\D] will match everything but 
decimal digits
\w
Match any alphanumeric 
character, A-Z, a-z, 0-­
9.
[_a-­
zA-­
Z]\w* will match all 
legitimate identifiers in 
Python
Table 5-­
4: Metacharacters and basic rules for constructing 
regular expressions (continued)
	
Use Sequences, Sets, Dictionaries, and Text Files	
245
 https://doi.org/10.15215/remix/9781998944088.01
Escape sequence
Special meaning in re
Example
\W
Opposite of \w, meaning 
do not match any 
alphanumeric character.
[\W] will match everything but 
alphanumeric characters
\n
Match a new line whitespace.
\.\n will match all periods that 
end a paragraph
\t
Match a tab whitespace.
re.findall(r'\t', py_scripts) 
will find all the tabs in the 
py_scripts
\r
Match a return/enter 
whitespace.
re.findall(r'\r', article) will 
find all the return/enter 
whitespaces in the article.
\v
Match a vertical feed 
whitespace.
re.findall(r'\v', article) will 
find all the vertical feed 
whitespaces in the article
\f
Match a feed whitespace.
re.findall(r'\f', article) will find 
all the feed whitespaces in 
the article
\s
Match any of the whitespaces 
above.
re.findall(r'\s', article) will find 
all the whitespaces in the 
article
\S
Opposite of \s, \S matches 
any character which is not a 
whitespace character.
re.findall(r'\S', article) will 
find everything except 
whitespaces in the article
\N
N is an integer > 0. \1 refers 
to the first subgroup saved 
with (…).
In r'\b\w*(\w)\w*\1', \1 
refers to the first found 
alphanumeric characters 
that appear more than once 
in a word
\b
Match any word boundary: the 
left boundary if \b is at the 
left of the pattern, the right 
boundary if \b is at the right 
side of the pattern
\bthe\b will match the if it is 
not part of other words
\B
Opposite of \b.
\bthe\B will match the if it is 
at the beginning of other 
words
\.
\\
\+
\*
Match a special symbol ., \, +, 
* respectively.
\d+\*\d+ will match 
multiplications of two 
integers in a text
\A
Match at the start of a string, 
same as ^.
\AHello will match Hello if 
Hello is at the beginning of 
the string
\Z
Match at the end of a string, 
same as $.
\.com\Z will match .com if it 
is at the end of the string
Table 5-­
5: Escape sequences with special meanings in re (continued)
	246	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The above are the basic rules for constructing regular expressions or regex 
patterns. Using these rules, we can write regular expressions to define most 
string patterns we are interested in.
The following are some examples of regex patterns:
780-­
\d{7}, pattern for telephone numbers in Edmonton, Alberta
\$\d+\.\d{2}, pattern for currency representations in accounting
[A-­
Z]{3}-­
\d{3}, pattern for licence plate numbers
The re module is also empowered with the following extension rules, which 
all begin with a question mark ? within a pair of parentheses. Although sur­
rounded by a pair of parentheses, an extension rule, except (?P<name>…), does 
not create a new group.
(?AILMSUX)
Here, ? is followed by one or more letters from set a, i, L, m, s, u, and x, 
setting the corresponding flags for the re engine. (?a) sets re.A, meaning 
ASCII-­
only matching; (?i) sets re.I, meaning ignore case when matching; 
(?L) sets re.L, meaning local dependent; (?m) sets re.M, meaning multiple 
lines; (?s) sets re.S, meaning dot matches all characters including newline; 
(?u) sets re.U, meaning Unicode matching; (?x) sets re.X, meaning verbose 
matching. These flags are defined in the re module. The details can be found 
by running help(re).
The flags can be used at the beginning of a regular expression in place of 
passing the optional flag arguments to re functions or methods of pattern object.
(?AILMSUX-­
IMSX:…)
Sets or removes the corresponding flags. (?a-­
u…) will remove Unicode matching.
(?:…)
Is a noncapturing version of regular parentheses, meaning the match cannot 
be retrieved or referenced later.
(?P<NAME>…)
Makes the substring matched by the group accessible by name.
(?P=NAME)
Matches the text matched earlier by given name.
	
Use Sequences, Sets, Dictionaries, and Text Files	
247
 https://doi.org/10.15215/remix/9781998944088.01
(?#…)
Is a comment; ignored.
(?=…)
Matches if… matches next but does not consume the string being searched, 
which means that the current position in string remains unchanged. This is 
called a lookahead assertion.
John (?=Doe) will match John only if it is followed by Doe.
(?!…)
Matches if… does not match next.
Jon (?!Doe) will match Jon only if it is not followed by Doe.
(?<=…)
Matches if preceded by… (must be fixed length).
(?<=John) Doe will find a match in John Doe because there is John before Doe.
(?<!…)
Matches if not preceded by… (must be fixed length).
(?<!John) Doe will find a match in Joe Doe because there is not Joe before Doe.
(?(ID)YES PATTERN | NO PATTERN)
(?(NAME)YES PATTERN | NO PATTERN)
Match yes pattern if the group with id or name is matched; match no pattern 
otherwise.
To do text manipulation and information processing using regular expressions 
in Python, we will need to use a module in the standard Python library called Re. 
Similarly, we will need to import the module before using it, as shown below:
>>> import re
Using the dir(re) statement, you can find out what names are defined in the 
module, as shown below, but you will need to use help(re) to find out the core 
functions and methods you can use from the re module.
The following are functions defined in the re module:
re.compile(pattern, flags=0)
Compile a pattern into a pattern object and return the compiled pattern 
object for more effective uses later.
	248	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> import re
>>> pobj=re.compile('780-­
?\d{3}-­
?\d{4}')
>>> pobj.findall('780-­
9381396, 7804311508, 
18663016227')   # findall method of pattern object
['780-­
9381396', '7804311508']
>>> b = re.compile(r'\d+\.\d*')
>>> b.match('32.23')   # match method of pattern object
<re.Match object; span=(0, 5), match='32.23'>
RE.MATCH(PATTERN, STRING, FLAGS=0)
Match a regular expression pattern to the beginning of a string. Return None 
if no match is found.
>>> r = re.match(r'\d+\.\d*', '123.89float')
>>> r
<re.Match object; span=(0, 6), match='123.89'>
RE.FULLMATCH(PATTERN, STRING, FLAGS=0)
Match a regular expression pattern to all of a string. Return None if no match 
is found.
>>> r = re.fullmatch(r'\d+\.\d*', '123.89')
# this will match
>>> r = re.fullmatch(r'\d+\.\d*', '123.89float')
# this will not match
RE.SEARCH(PATTERN, STRING, FLAGS=0)
Search a string for the presence of a pattern; return the first match object. 
Return None if no match is found.
>>> r = re.search(r'\d+\.\d+', 'real 123.89')
>>> r
<re.Match object; span=(5, 11), match='123.89'>
RE.SUB(PATTERN, REPLACING, STRING, COUNT=0, FLAGS=0)
Substitute occurrences of a pattern found in a string by replacing and return 
the resulted string.
>>> re.sub('t', 'T', 'Python is great.')
'PyThon is greaT.'
	
Use Sequences, Sets, Dictionaries, and Text Files	
249
 https://doi.org/10.15215/remix/9781998944088.01
RE.SUBN(PATTERN, REPLACING, STRING, COUNT=0, FLAGS=0)
Same as sub, but also return the number of substitutions made.
>>> re.subn('t', 'T', 'Python is great.')
('PyThon is greaT.', 2)
RE.SPLIT(PATTERN, STRING, MAXSPLIT=0, FLAGS=0)
Split a string by the occurrences of a pattern and return a list of substrings cut 
by the pattern.
>>> re.split(r'\W+', 'Python is great.')   # \W is 
nonalphanumeric so it will get a list of words
['Python', 'is', 'great', '']
RE.FINDALL(PATTERN, STRING, FLAGS=0)
Find all occurrences of a pattern in a string and return a list of matches.
>>> re.findall('t', 'Python is great.')
['t', 't']
RE.FINDITER(PATTERN, STRING, FLAGS=0)
Return an iterator yielding a match object for each match.
>>> re.finditer('t', 'Python is great.')
<callable_iterator object at 0x00000198FE0F5FC8>
RE.PURGE()
Clear the regular expression cache.
>>> re.purge()
>>>
RE.ESCAPE(PATTERN)
Backslash all nonalphanumerics in a string.
>>> print(re.escape('1800.941.7896'))
1800\.941\.7896
Suppose we want to write a program to check if a name given by a user is a 
legitimate Python identifier. We can define a regex pattern for a Python iden­
tifier as shown below:
	250	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
idPatt = '\b_{0,2}[A-­
Za-­
z](_?[A-­
Za-­
z0-­
9])*_{0,2}\b\'
Before using the re module, we need to import it, as shown below:
import re
The next step will be to get an input from the user and test it:
name = input('Give me a name and I will tell you if it is 
a Python identifier: ')
Trim the whitespace at the beginning and the end of the name just in case:
name = name.strip()  # this will strip the whitespaces
Then, we do the real test:
if re.match(idPatt, name) is not None:
print('Congratulations! It is!') else:
print('Sorry, it is not.')
The complete code of the program is shown in the code section of Table 5-­
6.
Table 5-­
6: Case study: How to check Python identifiers
The problem
In this case study, we will write a program to check if a name given 
by a user is legitimate Python identifier.
The analysis 
and design
Steps:
Step 1: Import re module before using it
Step 2: Define a regex pattern for Python identifiers
Step 3: Get an input from the user, and
Step 4: Test it with an if-­
else statement
The code
import re
idPatt = '(^[A-­
Za-­
z]\w+)$|(^_[A-­
Za-­
z]\
w+_$)|(^__[A-­
Za-­
z]\w+__$)'
name = input('Give me a name and I will tell you 
if it is a Python identifier:')
name = name.strip()
if re.match(idPatt, name) is not None:
  print('Congratulations! It is!')
else:
  print('Sorry, it is not.')
The result
Give me a name and I will tell you if it is a Python identifier:A2
Congratulations! It is!
	
Use Sequences, Sets, Dictionaries, and Text Files	
251
 https://doi.org/10.15215/remix/9781998944088.01
5.2 Lists
The list is an important compound data type in Python and in almost all pro­
gramming languages, though not many programming languages have list as 
a built-­
in data type.
In previous sections, you saw a few program examples with a list involved. 
In the following, we explain the operators and functions that can be used 
on lists.
LIST(ITERABLE)
To construct a list from an iterable such as a sequence or call to range().
>>> l1 = list("test")
>>> l1
['t', 'e', 's', 't']
>>> l2 = list((1,2,3,4))
>>> l2
[1, 2, 3, 4]
>>> l5 = list(range(13, 26))
>>> l5
[13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]
In addition, you can also create a list by directly putting items in a pair of 
square brackets, as shown below:
>>> l6 = ['Jon', 'John', 'Jonathan', 'Jim', 'James']
>>> l6
['Jon', 'John', 'Jonathan', 'Jim', 'James']
L[NTH]
To get the nth element of list l.
>>> students = ['John', 'Mary', 'Terry', 'Smith', 'Chris']
>>> students[3]
'Smith'
L[START:END]
To get a slice/sublist of l, including the members from a start position till right 
before the end position.
	252	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> students = ['John', 'Mary', 'Terry', 'Smith', 
'Chris']
>>> students[1:3]
['Mary', 'Terry']
L[START:END:STEP]
To get a slice/sublist of l, including members from a start position to right before 
an end position with set step.
>>> l6 = ['Jon', 'John', 'Jonathan', 'Jim', 'James']
>>> l6[:5:3]   # start from 0 till 5 with step set as 3.
['Jon', 'Jim']
L[N] = E
To replace element at n with e.
>>> print(students)
['John', 'Mary', 'Terry', 'Smith', 'Chris']
>>> students[2] = 'Cindy'
>>> print(students)
['John', 'Mary', 'Cindy', 'Smith', 'Chris']
L1 + L2
To concatenate list l2 to l1, but without changing l1. As such, if you want to keep 
the result of concatenation, you will need to assign the result to a new variable.
>>> teachers = ['Jeffery', 'Clover', 'David']
>>> students + teachers
['John', 'Mary', 'Terry', 'Smith', 'Chris', 'Jeffery', 
'Clover', 'David']
>>> teachers
['Jeffery', 'Clover', 'David']
>>> class_members = students + teachers
>>> class_members
['John', 'Mary', 'Terry', 'Smith', 'Chris', 'Jeffery', 
'Clover', 'David']
L * N
N * L
To duplicate list l n times but without changing l.
	
Use Sequences, Sets, Dictionaries, and Text Files	
253
 https://doi.org/10.15215/remix/9781998944088.01
>>> students[1:3]
['Mary', 'Terry']
>>> students[1:3] * 2
['Mary', 'Terry', 'Mary', 'Terry']
>>> 2*students[1:3]
['Mary', 'Terry', 'Mary', 'Terry']
E IN L
To test if e is in list l. If l has compound data such as lists, tuples, or instances 
of a class, e is only part of a compound data or object and is not considered 
in the list.
>>> teachers
['David', 'Jeffery', 'Clover']
>>> 'Clover' in teachers
True
>>> l0 = [1, 2, 3, [4, 5], 6]   # 4 and 5 are members of 
a sublist of l0
>>> 5 in l0   # so that 5 is not considered as part of 
list l0
False
LEN(L)
To get the number of elements in the list l.
>>> students
['John', 'Mary', 'Terry', 'Smith', 'Chris']
>>> len(students)
5
PRINT(L)
To print list l. Note that the list will be recursively printed, but complex objects 
such as instances of a user-­
defined class may not be printed the way you 
expected unless you have defined the __str__() method for the class.
>>> print(teachers)
['Jeffery', 'Clover', 'David']
In addition, there are also built-­
in methods for list objects, as detailed below.
	254	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
L.APPEND(E)
To append element e to list l.
>>> l = ['T', 'h']
>>> l.append('e')
>>> l
['T', 'h', 'e']
L.CLEAR()
To remove all items from list l.
>>> l1 = list("test")
>>> l1
['t', 'e', 's', 't']
>>> l1.clear()
>>> l1   # l1 became an empty list
[]
L.COPY()
To return a shallow copy of list l—­
that is, it only copies simple objects of the list 
such as numbers and strings; for compound data, it does not copy the actual 
objects but only makes references to the objects.
>>> l7 = l6.copy()   # from above we know that items in 
l6 are all simple strings
>>> l7
['Jon', 'John', 'Jonathan', 'Jim', 'James']
>>> l7[3] = 'Joe'   # change the value of l7[3]
>>> l7   # it shows l7 has been changed
['Jon', 'John', 'Jonathan', 'Joe', 'James']
>>> l6   # it shows l6 remains the same
['Jon', 'John', 'Jonathan', 'Jim', 'James']
Now suppose we have
>>> l8 = [[13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 
24, 25], ['Jon', 'John', 'Jonathan', 'Joe', 'James'], 
100]
>>> l9 = l8.copy()
>>> l9   # l9 has the same items as l8
	
Use Sequences, Sets, Dictionaries, and Text Files	
255
 https://doi.org/10.15215/remix/9781998944088.01
[[13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25], 
['Jon', 'John', 'Jonathan', 'Joe', 'James'], 100]
>>> l9[0][0] = 1000   # make change to the internal value 
of list l9[0], that is, l9[0][0] to 1000
>>> l9   # l9 has been changed
[[1000, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25], 
['Jon', 'John', 'Jonathan', 'Joe', 'James'], 100]
>>> l8   # l8 has been changed as well
[[1000, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25], 
['Jon', 'John', 'Jonathan', 'Joe', 'James'], 100]
As can be seen, if you make changes to a piece of compound data (a list as 
the first item of l9 copied from l8), the change also occurs in the original list, 
and vice versa.
L.INDEX(E, START = 0, STOP = 9223372036854775807)
To return the first index of element e, from a start position till a stop position. 
The default range is from 0 to 9223372036854775807.
>>> l6.index('Jim')
3
L.POP()
To remove and return an item from the end of list l.
>>> l.pop()
'e'
L.POP(2)
To remove and return an item from the middle of list l. When there are an even 
number of elements in the list, there will be two elements in the middle, but 
only the first one pops out.
>>> l = [1, 3, 2, 6, 5, 7]
>>> l.pop(2)
2
>>> l
[1, 3, 6, 5, 7]
>>> l.pop(2)
6
	256	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
L.REVERSE()
To reverse the list.
>>> l.reverse()
>>> l
[7, 5, 3, 1]
L.SORT()
To sort the list in ascending order by default. To sort in descending order, use 
l.sort(reverse = True).
>>> l.sort()
>>> l
[1, 3, 5, 7]
L.EXTEND(L0)
To extend list l by appending list l0 to the end of list l. It is different from l + l0 
but it is same as l += l0.
>>> l = list(range(5))
>>> l
[0, 1, 2, 3, 4]
>>> l0 = list(range(6, 11))
>>> l0
[5, 6, 7, 8, 9, 10]
>>> l.extend(l0)
>>> l
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
L.INSERT(I, E)
To insert e before index i of existing list l.
>>> l = list(range(10))
>>> l
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> l.insert(5, 13)
>>> l
[0, 1, 2, 3, 4, 13, 5, 6, 7, 8, 9]
	
Use Sequences, Sets, Dictionaries, and Text Files	
257
 https://doi.org/10.15215/remix/9781998944088.01
L.REMOVE(E)
To remove first occurrence of e in the list.
>>> l
[0, 1, 2, 3, 4, 13, 5, 6, 7, 8, 9]
>>> l.remove(5)
>>> l   # 5 has been removed from l
[0, 1, 2, 3, 4, 13, 6, 7, 8, 9]
L.COUNT(E)
To search the list and return the number of occurrences of e.
>>> l
[0, 1, 2, 3, 4, 13, 6, 7, 8, 9]
>>> l.count(6)
1
As you can see, elements in lists can be changed or mutated. You can insert, 
delete, replace, expand, and reorder all the elements in a list.
Lists are a very important data model in programming and problem solving. 
First, lists can be used as collections of data. Each member of the collection 
can be as simple as a number or a string and as complex as another list or any 
other compound data type, or even an object. Many functions and methods, 
as discussed above, have been made available for accessing and manipulating 
lists and their members.
Suppose we want to develop a management system for a company, for example. 
Within the system, we need to represent information on its employees. We can 
use a list containing the name, birthdate, department, start date at the company, 
and level of employment to represent information on each employee, then use 
another list to represent a collection of employees. This is illustrated as follows:
# this defines an embedded list or two-­
dimensional array
employees = [['Kevin Smith', 19560323, 'Sale', 20100621, 3],
['Paul Davina', 19860323, 'HR', 20120621, 5],
['Jim Carri', 1969323, 'Design', 20120625, 2],
['John Wong', 19580323, 'Customer Service', 20110323, 3],
['Keri Lam', 19760323, 'Sale', 20130522, 5]]
Moreover, lists can be used to represent trees, which is an important data 
structure in programming and problem solving.
	258	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
5.3 Tuples
Unlike a list, a tuple is an immutable object, which means that once created, 
the internal structure of a tuple cannot be changed. Hence, most methods you 
have seen for lists are not available for tuples, except for the following two.
T.COUNT(E)
To count and return the number of occurrences of a specified value in a tuple.
>>> t = (3, 6, 5, 7, 5, 9)
>>> t.count(5)
2
T.INDEX(E, START = 0, STOP = 9223372036854775807)
To search the tuple for a specified value e and return the index of the first 
occurrence of the value. Remember that just like a list, a tuple can have dupli­
cate values as well.
>>> t.index(6)
1
>>> t.index(7)
3
>>> t0 = tuple("same as list, tuple")
>>> t0
('s', 'a', 'm', 'e', ' ', 'a', 's', ' ', 'l', 'i', 's', 
't', ',', ' ', 't', 'u', 'p', 'l', 'e')
>>> t0.index('l')   # it only returns the index of the 
first l
8
>>> t.index('l', 9)   # to get the index of the next 
occurrence
17
As well, compared to list, fewer number of operators and built-­
in functions 
can be used on tuples, as shown below.
TUPLE(ITERABLE)
To construct a tuple from an iterable such as another sequence or a call to 
range(), a built-­
in function.
	
Use Sequences, Sets, Dictionaries, and Text Files	
259
 https://doi.org/10.15215/remix/9781998944088.01
>>> l1 = [1, 2, 3]
>>> t0 = tuple(l1)
>>> t0
(1, 2, 3)
This would be the same as the following:
>>> t0 = (1, 2, 3)
 
>>> t1 = tuple('tuple')
>>> t1
('t', 'u', 'p', 'l', 'e')
 
>>> tuple(range(7))
(0, 1, 2, 3, 4, 5, 6)
T[N]
To get nth element of a tuple.
>>> teachers = ('Jeffery', 'Clover', 'David')
>>> teachers[2]
'David'
Please note that because a tuple is an immutable sequence, making changes 
to its members will generate an error, as shown below:
>>> teachers[1] = 'Chris'
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item 
assignment
T[I:J]
To get a slice of tuple t including elements from point i to the one right before 
point j.
>>> teachers[0:2]
('Jeffery', 'Clover')
>>> print(teachers)
('Jeffery', 'Clover', 'David')
	260	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
T1 + T2
To concatenate tuple t2 to t1.
>>> students = tuple(students)
>>> print(students)
('John', 'Mary', 'Terry', 'Smith', 'Chris')
>>> students + teachers
('John', 'Mary', 'Terry', 'Smith', 'Chris', 'Jeffery', 
'Clover', 'David')
T * N
To duplicate tuple t n times.
>>> teachers * 2
('Jeffery', 'Clover', 'David', 'Jeffery', 'Clover', 
'David')
E IN T
To test if e is an element of tuple t.
>>> teachers
('David', 'Jeffery', 'Clover')
>>> 'David' in teachers
True
LEN(T)
To get the number of elements in the tuple t.
>>> len(teachers * 2)
6
PRINT(T)
To print tuple t. Again, print may print the tuple recursively, but the expected result 
can only be achieved if __str__() has been defined for every object at all levels.
>>> print(students)
('John', 'Mary', 'Terry', 'Smith', 'Chris')
Again, although we can extend the tuple by concatenating and duplicating, 
we cannot make any change to the existing element of a tuple as we did to 
	
Use Sequences, Sets, Dictionaries, and Text Files	
261
 https://doi.org/10.15215/remix/9781998944088.01
lists, because tuples are immutable. As a result, the tuple is not a suitable data 
structure for representing the group of employees in the example presented at 
the end of the previous section because employees may come and go.
5.4 Sets
As in mathematics, a set is a collection of unindexed and unordered elements. 
For sets, Python has very few operators and built-­
in functions that we can use.
SET(S)
To construct a set from s, which can be a list, tuple, or string.
>>> students = ['Cindy', 'Smith', 'John', 'Chris', 
'Mary']
>>> students = set(students)
>>> students
{'Cindy', 'Smith', 'John', 'Chris', 'Mary'}
>>> numbers = set(range(10))
>>> numbers
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
E IN S
To test if e is a member of set s.
>>> students
{'Cindy', 'Smith', 'John', 'Chris', 'Mary'}
>>> 'Chris' in students
True
LEN(S)
To get the total number of elements in the set.
>>> numbers
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
>>> len(numbers)
10
However, there are good number of methods defined for sets.
	262	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
S.ADD(M)
To add an element to the set s.
>>> s = set([3])
>>> s
{3}
>>> s.add(5)
>>> s
{3, 5}
S.CLEAR()
To remove all the elements from the set s.
>>> s.clear()
>>> s
set()
S.COPY()
To make and return a copy of the set s.
>>> s
{3, 5}
>>> s1 = s.copy()
>>> s1
{3, 5}
S.DIFFERENCE(S1,…)
To make and return a set containing only members of s that other sets in the 
arguments don’t have—­
that is, the difference between two or more sets.
>>> s1
{3, 5}
>>> s2 = {5, 7}
>>> s1.difference(s2)
{3}
>>> s3={3,7}
>>> s1.difference(s2,s3)   # returns an empty set
set()
	
Use Sequences, Sets, Dictionaries, and Text Files	
263
 https://doi.org/10.15215/remix/9781998944088.01
S.DIFFERENCE_UPDATE(*SX)
To remove the items in set s that are also included in another, specified set.
>>> s1 = {2 * i for i in range(15)}
>>> s2 = {3 * i for i in range(15)}
>>> s1
{0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28}
>>> s2
{0, 33, 3, 36, 6, 39, 9, 42, 12, 15, 18, 21, 24, 27, 30}
>>> s1.difference_update(s2)
>>> s1
{2, 4, 8, 10, 14, 16, 20, 22, 26, 28}
>>> s2
{0, 33, 3, 36, 6, 39, 9, 42, 12, 15, 18, 21, 24, 27, 30}
S.DISCARD(M)
To remove the specified item.
>>> s2
{0, 33, 3, 36, 6, 39, 9, 42, 12, 15, 18, 21, 24, 27, 30}
>>> s2.discard(18)
>>> s2
{0, 33, 3, 36, 6, 39, 9, 42, 12, 15, 21, 24, 27, 30}
S.INTERSECTION(*SX)
To return a set that is the intersection of two other sets.
>>> s1 = {2 * i for i in range(15)}
>>> s2 = {3 * i for i in range(15)}
>>> s1
{0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28}
>>> s2
{0, 33, 3, 36, 6, 39, 9, 42, 12, 15, 18, 21, 24, 27, 30}
>>> s1.intersection(s2)
{0, 6, 12, 18, 24}
S.INTERSECTION_UPDATE(*SX)
To remove the items in this set that are not present in another, specified set 
or sets.
	264	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> s1
{0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28}
>>> s2
{0, 33, 3, 36, 6, 39, 9, 42, 12, 15, 18, 21, 24, 27, 30}
>>> s1.intersection_update(s2)
>>> s1
{0, 6, 12, 18, 24}
S.ISDISJOINT(SX)
To check and return whether two sets have an intersection (common member) 
or not.
>>> s1
{0, 6, 12, 18, 24}
>>> s2
{0, 33, 3, 36, 6, 39, 9, 42, 12, 15, 18, 21, 24, 27, 30}
>>> s1.isdisjoint(s2)
False
S.ISSUBSET(SX)
To check and return whether another set contains this set or not.
>>> s1 = {2 * i for i in range(15)}
>>> s2 = {3 * i for i in range(15)}
>>> s1
{0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28}
>>> s2
{0, 33, 3, 36, 6, 39, 9, 42, 12, 15, 18, 21, 24, 27, 30}
>>> s1.issubset(s2)
False
S.ISSUPERSET(SX)
To check and return whether this set contains another set or not.
>>> s1.issuperset(s2)
False
S.POP()
To remove an element from the set.
	
Use Sequences, Sets, Dictionaries, and Text Files	
265
 https://doi.org/10.15215/remix/9781998944088.01
>>> s2
{0, 33, 3, 36, 6, 39, 9, 42, 12, 15, 18, 21, 24, 27, 30}
>>> s2.pop()
0
>>> s2
{33, 3, 36, 6, 39, 9, 42, 12, 15, 18, 21, 24, 27, 30}
S.REMOVE(M)
To remove the specified element.
>>> s2
{33, 3, 36, 6, 39, 9, 42, 12, 15, 18, 21, 24, 27, 30}
>>> s2.remove(18)
>>> s2
{33, 3, 36, 6, 39, 9, 42, 12, 15, 21, 24, 27, 30}
S.SYMMETRIC_DIFFERENCE(SX)
To construct and return a set with elements in either set s or another set but 
not both. These are called set symmetric differences (“I have you do not; you 
have I do not”).
>>> s1 = {2 * i for i in range(15)}
>>> s2 = {3 * i for i in range(15)}
>>> s1
{0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28}
>>> s2
{0, 33, 3, 36, 6, 39, 9, 42, 12, 15, 18, 21, 24, 27, 30}
>>> s1.symmetric_difference(s2)
{2, 3, 4, 8, 9, 10, 14, 15, 16, 20, 21, 22, 26, 27, 28, 
30, 33, 36, 39, 42}
S.SYMMETRIC_DIFFERENCE_UPDATE(SX)
To insert the symmetric differences from this set and another.
>>> s1.symmetric_difference_update(s2)
>>> s1
{2, 3, 4, 8, 9, 10, 14, 15, 16, 20, 21, 22, 26, 27, 28, 
30, 33, 36, 39, 42}
	266	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
S.UNION(SX)
To return a set containing the union of sets.
>>> s2 = {3 * i for i in range(5)}
>>> s1 = {2 * i for i in range(5)}
>>> s1
{0, 2, 4, 6, 8}
>>> s2
{0, 3, 6, 9, 12}
>>> s1.union(s2)
{0, 2, 3, 4, 6, 8, 9, 12}
S.UPDATE(SX)
To update the set by adding members from other sets.
>>> s1
{0, 2, 4, 6, 8}
>>> s2
{0, 3, 6, 9, 12}
>>> s1.update(s2)
>>> s1
{0, 2, 3, 4, 6, 8, 9, 12}
5.5 Dictionaries
A dictionary is a collection of key and value pairs enclosed in curly brackets. As 
with a set, the dictionary is also immutable. There are very few operators and 
built-­
in functions that can be used on dictionaries, as shown below.
DICT(**KWARG)
To construct a dictionary from a series of keyword arguments.
>>> dt = dict(one = 1, two = 2, three = 3)
>>> dt
{'one': 1, 'two': 2, 'three': 3}
DICT(MAPPING, **KWARG)
To construct a dictionary from mapping. If keyword arguments are present, 
they will be added to the dictionary constructed from the mapping.
	
Use Sequences, Sets, Dictionaries, and Text Files	
267
 https://doi.org/10.15215/remix/9781998944088.01
>>> d1 = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
>>> d2 = dict(zip([1, 2, 3], ['one', 'two', 'three']))
>>> d1
{'one': 1, 'two': 2, 'three': 3}
>>> d2
{1:'one', 2:'two', 3:'three'}
DICT(ITERABLE, **KWARG)
To construct a dictionary from an iterable. If keyword arguments are present, 
they will be added to the dictionary constructed from the mapping.
>>> d3 = dict([('two', 2), ('one', 1), ('three', 3)])
>>> d3
{'two': 2, 'one': 1, 'three': 3}
LIST(DT)
To return a list of all the keys used in the dictionary dt.
>>> d3
{'two': 2, 'one': 1, 'three': 3}
>>> list(d3)
['two', 'one', 'three']
DT[K]
To get the value of key k from dictionary dt.
>>> dt = {1:'One', 2:'Two', 3:'Three'}
>>> dt[1]
'One'
DT[K] = V
To set d[key] to value V.
>>> d3
{'two': 2, 'one': 1, 'three': 3}
>>> d3['two']
2
>>> d3['two'] = bin(2)
>>> d3['two']
'0b10'
	268	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
DEL DT[K]
To remove dt[key] from dt.
>>> d3
{'two':'0b10', 'one': 1, 'three': 3}
>>> del d3['two']
>>> d3
{'one': 1, 'three': 3}
K IN DT
To test if dt has a key k.
>>> d3
{'one': 1, 'three': 3}
>>> 'two' in d3
False
K NOT IN DT
Same as not k in dt, or k not in dt.
>>> 'two' not in d3
True
>>> not 'two' in d3
True
ITER(DT)
To return an iterator over the keys of dt. Same as iter(dt.keys()).
>>> iter(d3)
<dict_keyiterator object at 0x00000198FE0EFEF8>
>>> list(iter(d3))
['one', 'three']
LEN(DT)
To get the total number of elements in the dictionary.
>>> dt
{1:'One', 2:'Two', 3:'Three'}
>>> len(dt)
3
	
Use Sequences, Sets, Dictionaries, and Text Files	
269
 https://doi.org/10.15215/remix/9781998944088.01
REVERSED(DT)
To return a reverse iterator over the keys of the dictionary. Same effect as 
reversed(dt.keys()). This is new in Python 3.8.
>>> dt = {1:'One', 2:'Two', 3:'Three'}   # keys: 1, 2, 3
>>> rk = reversed(dt)   # reversed iterator over the keys 
in rk
>>> for k in rk:
print(k)
…
3
2
1
Note that in the output above, the keys in rk are 3, 2, 1.
The following built-­
in methods of the dictionary class can be used to manipu­
late dictionaries.
D.CLEAR()
To remove all the elements from the dictionary.
>>> dt = {1:'One', 2:'Two', 3:'Three'}
>>> dt
{1:'One', 2:'Two', 3:'Three'}
>>> dt.clear()
>>> dt
D.COPY()
To make and return a copy of the dictionary.
>>> dt = {1:'One', 2:'Two', 3:'Three'}
>>> dx = dt.copy()
>>> dx
{1:'One', 2:'Two', 3:'Three'}
DICT.FROMKEYS()
To make a dictionary from a list of keys.
	270	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> keys = ['Edmonton','Calgary','Toronto']
>>> weather = dict.fromkeys(keys, 'Sunny')
>>> print(weather)
{'Edmonton': 'Sunny', 'Calgary': 'Sunny', 'Toronto': 'Sunny'}
D.GET(K)
To return the value of the specified key.
>>> d3 =dict([('two', 2), ('one', 1), ('three', 3)])
>>> d3.get('two')
2
D.ITEMS()
To return a list containing a tuple for each key-­
value pair.
>>> d3.items()
dict_items([('two', 2), ('one', 1), ('three', 3)])
D.KEYS()
To return a list containing the dictionary’s keys.
>>> d3.keys()
dict_keys(['two', 'one', 'three'])
D.VALUES()
To return a list of all the values in the dictionary.
>>> d3.values()
dict_values([2, 1, 3])
D.POP(K)
To remove the element with the specified key. Note that the removed item will 
no longer exist in the dictionary.
>>> d3
{'two': 2, 'one': 1, 'three': 3}
>>> d3.pop('two')
2
>>> d3
{'one': 1, 'three': 3}
	
Use Sequences, Sets, Dictionaries, and Text Files	
271
 https://doi.org/10.15215/remix/9781998944088.01
D.POPITEM()
To remove an item from the end of the dictionary, as a key and value pair.
>>> d3
{'two': 2, 'one': 1, 'three': 3}
>>> d3.popitem()
('three', 3)
D.SETDEFAULT(KEY, VALUE)
To insert a key-­
value pair into the dictionary if the key is not in the dictionary; 
return the value of the key if the key exists in the dictionary.
>>> d3
{'two': 2, 'one': 1}
>>> d3.setdefault('three', 3)
3
>>> d3.setdefault('two', 'II')
2
>>> d3
{'two': 2, 'one': 1, 'three': 3}
D.UPDATE(DX)
To update the dictionary with the specified key-­
value pairs in dx.
>>> d3
{'two': 2, 'one': 1, 'three': 3}
>>> d2
{1:'one', 2:'two', 3:'three'}
>>> d3.update(d2)
>>> d3
{'two': 2, 'one': 1, 'three': 3, 1:'one', 2:'two', 
3:'three'}
5.6 List, Set, and Dictionary Comprehension
Lists, sets, and dictionaries are important data models for programmers to 
structure and organize data with. Before using lists, tuples, sets, and dictio­
naries, it is important to create them in a nice way. List, set, and dictionary 
comprehension is provided by Python to construct lists, sets, and dictionaries 
	272	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
in a concise but efficient language. The essential idea for list, set, and dictionary 
comprehension is the use of a for loop with or without conditions.
List Comprehension
The following is an example that constructs a list of odd numbers from 1 to 100:
In [ ]:
l0 = [i * 2 + 1 for i in range(50)]
print(l0)
Out [ ]:
[1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 
45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 
85, 87, 89, 91, 93, 95, 97, 99]
In the example, the expression before for represents the items of the list; 
the for loop will run through the item expression in each iteration. This list 
can also be generated using the for loop with an if clause, as shown below:
In [ ]:
l1 = [i for i in range(100) if i % 2 != 0]
print(l1)
Out [ ]:
[1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 
45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 
85, 87, 89, 91, 93, 95, 97, 99]
In the example above, the list item expression will be evaluated in every 
iteration of the for loop only if the condition of the if clause is met. In fact, we 
can put any condition on the iteration variable i. For example, assume we have 
a Boolean function isPrime(N) that can test if number N is prime or not; then 
the following statement will produce a list of prime numbers in the given range:
primes = [i for i in range(1000) if isPrime(i)]
Please note that the list item expression before for can be anything whose 
value is a legitimate list item, as shown in the example below:
In [ ]:
detailed = [f"{i} is odd" if i % 2 !=0 else f"{i} is 
even" for i in range(10)]
print(detailed)
Out [ ]:
['0 is even', '1 is odd', '2 is even', '3 is odd', '4 is even', '5 is odd', '6 is even', '7 
is odd', '8 is even', '9 is odd']
For item expressions involving two variables or more, nested for statements 
can be used. For example, the following statement will generate a list of com­
binations of some years and months:
	
Use Sequences, Sets, Dictionaries, and Text Files	
273
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
years = ['2015', '2016', '2017', ' 2018', '2019']
combo = [year + str(month).rjust(2, '0') for year in 
years for month in range(1, 13)]
print(combo)
Out [ ]:
['201501', '201502', '201503', '201504', '201505', '201506', '201507', '201508', 
'201509', '201510', '201511', '201512', '201601', '201602', '201603', '201604', 
'201605', '201606', '201607', '201608', '201609', '201610', '201611', '201612', 
'201701', '201702', '201703', '201704', '201705', '201706', '201707', '201708', 
'201709', '201710', '201711', '201712', ' 201801', ' 201802', ' 201803', ' 
201804', ' 201805', ' 201806', ' 201807', ' 201808', ' 201809', ' 201810', ' 
201811', ' 201812', '201901', '201902', '201903', '201904', '201905', '201906', 
'201907', '201908', '201909', '201910', '201911', '201912']
Set Comprehension
A set is a collection of unique unordered items. With that in mind, set compre­
hension is similar to list comprehension, except that the items are enclosed in 
curly brackets, as shown in the example below:
In [ ]:
asc = {chr(c) for c in range(ord('A'), ord('Z') + 1)}
print(asc)
Out [ ]:
{'K', 'M', 'G', 'T', 'C', 'O', 'L
', 'D', 'S', 'I', 'B', 'N', 'A', 'F', 'W', 'H', 'P', 'X', 'J', 'Z', 'E', 'R', 'U', 
'Y', 'Q', 'V'}
What would happen if items generated from the iteration were duplicated? 

No worries! The implementation of set comprehension can take care of that. 
If we want to find out all the unique words contained in a web document, we 
can simply use set comprehension to get them, as shown below:
In [ ]:
import requests   # import requests module to handle 
requests for web resources
content = requests.get("https://scis.athabascau.ca/").
text
separators = [',', '.', '"', "'", '>', '<', '-­
-­
', '!', 
'|', ']', '[', '?', ';', '/']   # separators used to 
separate words
separators += [')', '(', '$', '&', ':', '}', '{']
operators = ['=', '+']
for sp in separators:
  content = content.replace(sp, ' ')   # replace each 
of the separators with a space
for op in operators:
  content = content.replace(op, f' {op} ')   # add a 
space before and after each operator
unique_words = {w for w in content.split()}
print(len(unique_words), unique_words)
Out [ ]:
969
	274	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The example above took a web document at https://​
scis​
.athabascau​
.ca, 
pulled all the unique words used in the document into a set, and printed the 
number of unique words used, which is 969.
As you can see, we could get the unique words in a document very easily 
by using set comprehension. How would we find out the ratio between the 
number of unique words and the total number of words used?
Dictionary Comprehension
Dictionary comprehension is very similar to set comprehension, except that 
we need to add a key and colon before each item to make a dictionary item, as 
shown in the following:
In [ ]:
months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
m_dict = {i + 1: months[i] for i in range(12)}
print(m_dict)
Out [ ]:
{1: 'Jan', 2: 'Feb', 3: 'Mar', 4: 'Apr', 5: 'May', 6: 'Jun', 7: 'Jul', 8: 'Aug', 9: 'Sep', 10: 
'Oct', 11: 'Nov', 12: 'Dec'}
This can also be written in nested for clauses, as shown below:
In [ ]:
months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
m_dict = {i + 1: m for i in range(12) for m in 
months}
print(m_dict)
Out [ ]:
{1: 'Dec', 2: 'Dec', 3: 'Dec', 4: 'Dec', 5: 'Dec', 6: 'Dec', 7: 'Dec', 8: 'Dec', 9: 'Dec', 
10: 'Dec', 11: 'Dec', 12: 'Dec'}
5.7 Text Files
For people and smart beings in general, part of intelligence is being able to 
remember things. Memory is an important part of that.
Computers have two types of memory. The first is RAM, which is volatile, 
expensive, and of relatively lower capacity but provides high-­
speed access. 
The variables we have been talking about so far are using RAM to hold data 
and running programs that are also inside RAM. If the computer is turned off, 
both data and programs will disappear from RAM. RAM is also called internal 
memory.
	
Use Sequences, Sets, Dictionaries, and Text Files	
275
 https://doi.org/10.15215/remix/9781998944088.01
The second type of memory that modern computers have is persistent 
memory, such as a hard drive, flash memory card, or solid-­
state hard disk. This 
type of memory is also called external memory. For this type of memory to be 
useful, it must be part of a file system managed by an OS such as Windows, iOS, 
or Linux. Within a file system, files are used for saving data and programs to 
external memory, and the files are organized into hierarchical directories or 
folders. In a file system, a file can be located through a path from the root to 
the file within a tree-­
like structure.
Opening and Closing a File
To use a file, the first step is to open the file using the built-­
in function open. 
The following will open a file for writing:
f = open("./mypoem.txt", 'w')   # open file mypoem.txt in 
the current working directory for writing
The statement above opened the file mypoem.txt in the current working 
directory and returned a stream, which was then assigned to variable f, often 
called a file handle.
The general syntax of the open statement is as follows:
open(file, mode = 'r', buffering = -­
1, encoding = None, 
errors = None, newline = None, closefd = True, opener = 
None)
The statement opens a file and returns a stream or file object; it will raise 
OSError upon failure. In the statement, file is a text or byte string referring to 
the file to be opened. It may include the path to the actual file if the file is not 
in the current working directory.
Apart from the first argument for the name of the file to be opened, all 
other arguments have default values, which means that these arguments are 
optional. If no value is supplied, the default value will be used.
The second argument is called mode. It is optional with a default value r, 

which means “open a text file for reading.” This argument is used to tell 
the program what to do with the file after opening. Because reading from 
a text file is not always what you want it to do with a file, the argument 
is not optional. All available values for the mode argument are shown in 

Table 5-­
7.
	276	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Table 5-­
7: List of mode arguments for the open function
Mode argument
Access or accesses
r
Open for reading only; file must already exist.
r+
Open for both reading and writing; file must already exist.
w
Open for writing only; file may or may not exist. If not, a new 
file will be created and ready for writing; if file already exists, 
content will be overwritten.
w+
Open for writing and reading; file may or may not exist.
a
Open for appending, same as w, but will not overwrite the 
existing content.
a+
Open for both appending and reading.
x
Create a new file for writing. File Exists Error will occur if the 
file already exists. This would help prevent accidentally 
overwriting an existing file.
The file to be opened or created can be either a text file, referred to as t, or 
a binary file containing raw bytes, referred as b. To explicitly specify whether 
the file is a text or binary file, t or b can be used in combination with each 

of the values in Table 5-­
7. The default file type is text, so you do not have to 

use t if the file is a text file. So in the example above, the statement is equivalent 
to the following, in which t is used to explicitly indicate that it is a text file:
f = open("./mypoem.txt", 'wt')   # open text file mypoem.
txt in the current working directory
In both examples, we assigned the file stream returned from the open state­
ment to a variable f, which is called the file handle. After the file is opened, 
all operations on the file—­
such as read, write, append, or even close—­
must 
be appended to the file handle. Every file must be closed using the f.close() 
method after open and use unless the file is opened within a with statement, 
in which case a context manager will take over access to the file and close it 
when the job is done, as in the sample code below:
In [ ]:
with open("./mypoem.txt", 'r') as f:   # f is still a 
file handle
  for ln in f:   # a file stream referred by f is an 
iterator
    print(ln)
Out [ ]:
Yet it was plain she struggled, and that salt
	
Use Sequences, Sets, Dictionaries, and Text Files	
277
 https://doi.org/10.15215/remix/9781998944088.01
When not using the with statement, you will need to use the following 
instead:
In [ ]:
f = open("./mypoem.txt", 'r')   # f is still a file 
handle
for ln in f:   # a file stream referred by f is an 
iterator
  print(ln)
f.close()
Out [ ]:
Yet it was plain she struggled, and that salt
The third argument is called buffering. It takes an optional integer used to 
specify the buffering policy of the file operation. Passing 0 turns off buffering, 
but it is only allowed for binary files. Passing 1 selects line buffering, which is 
only allowed for text files. Passing an integer greater than 1 specifies the actual 
size of a fixed-­
size chunk buffer. When no buffering argument is provided, the 
default value −1 is used, which means that if the file is a binary file, the file will 
be buffered in a fixed-­
size chunk; if the file is a text file, line buffering policy 
is used, which means that the data will be flush to the actual file (on a disk 
such as a hard drive) from the buffer (a portion of internal memory to buffer 

the data) after each line was written.
The fourth argument is encoding, which specifies how the data in the file 
are encoded. This argument only makes sense for text files. The default value 
is platform dependent. If you believe that the encoding of data on a file is not 
the default, you can specify whatever encoding in which the data are encoded. 
However, the encoding must be supported by Python. In most cases, UTF-­
8 is 
the default encoding.
The next optional argument is errors, which takes a string if provided. The 
string specifies how encoding errors should be handled. Again, this argument 
only makes sense if the file is a text file. The same is true for the optional new­
line argument, which controls how universal newlines work in a text file. The 
optional newline argument can take the following:
•	 None
•	 ,
•	 \n
•	 \r
•	 \rn
Once a file is opened, a list of methods can be used to operate on the file object, 
as detailed below.
	278	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Write or Append to a File
New data can be added to a file in two different manners. The first one is to 
overwrite everything already in the file and place the new data at the beginning 
of the file, and the second one is to keep the data already in the file and append 
the new data to the end of the existing data. The write methods are the same 
for both, but the file must be opened with a different mode depending on the 
operation. That is, mode w or x must be used to open a file for writing the data 
from the beginning of the file, and mode a must be used to append new data, 
as you will see shortly in the examples.
There are two methods for writing to a file. The first one is f.write(string), 
which writes string to the file referred by f. The second method is f.writelines(se­
quence), in which the sequence is any iterable object, such as a list or tuple, 
but often a list of strings. The following is an example of opening or creating 
a file (if the file does not exist yet) for writing data from the beginning of the 
file using the write(string) method:
>>> f = open("./mypoem.txt", "w")   # open file in the 
current working directory for writing
>>> f.write("\nYou may write me down in history")   # add 
\n to write on a new line
>>> f.flush()   # to flush the data out to the actual file
The resulting file will read,
You may write me down in history
If you could write only this one line of your poem and had to close the 
file and shut down the computer, you would be more likely to continue from 
where you had stopped the next time you came back to the poem. So you need 
to append the new lines to the file. This is done by opening the file in a mode, 
as shown below:
>>> f = open("./mypoem.txt", "a")   # open file in the 
current working directory for writing
>>> f.write("\nWith your bitter, twisted lies")   # add 
\n to write on a new line
>>> f.flush()   # to flush the data out to the actual 
file
The file is extended with one more line of poem:
	
Use Sequences, Sets, Dictionaries, and Text Files	
279
 https://doi.org/10.15215/remix/9781998944088.01
You may write me down in history
With your bitter, twisted lies
Note that the write method will only write a string to the file. As such, any­
thing that is not a string must be converted into a string before being written 
to the file, as shown in the following example:
>>> f.write(f'\n{3.1415926}')
Also, because of buffering, the data you write to a file will not immediately 
show up in the actual file until you close the file or use the flush() method 

to flush the data in the buffer out to the file, as shown below:
>>> f.flush()
The write(string) method can only write one string to a file each time. To 
write multiple strings to a file, the writelines(sequence) method is used. How­
ever, keep in mind that writelines() does not automatically write one string on 
each line. You will still need to add \n at the beginning of the string if you want 
it to be on the next line or at the end of the string if you don’t want anything 
behind the string on the same line.
Recall the example of printing a 9 × 9 multiplication table. Now we can write 
the table to a text file so that you can print it out whenever you want. This is 
shown in the two examples below:
"""This first code sample is using the write method."""
 
f = open('./my9x9table.txt', 'w')
for i in range(1, 10):
  for j in range(1, i + 1):
    f.write('{:1d} x {:1d} = {:2d} '.format(j, i, i * j))
  f.write('\n')
f.close()
The output of the program is in the file my9x9table.txt:
1 x 1 = 1
1 x 2 = 2     2 x 2 = 4
1 x 3 = 3     2 x 3 = 6      3 x 3 = 9
1 x 4 = 4     2 x 4 = 8      3 x 4 = 12     4 x 4 = 16
1 x 5 = 5     2 x 5 = 10     3 x 5 = 15     4 x 5 = 20     5 x 5 = 25
	280	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
To use the writelines(sequence) method, we need to store the results in a 
list first; each item of the list will be printed on one line. The code is shown 
as follows:
"""This code sample is using the writelines method."""
 
table = []
for i in range(1, 10):
  newline = ''
  for j in range(1, i + 1):
    newline += '{:1d} x {:1d} = {:2d} '.format(j, i, i * j)
  newline += '\n'
  table.append(newline)
 
f = open('./my9x9table0.txt', 'w')
f.writelines(table)
f.close()
The result is the same as in the my9x9table.txt text shown above.
Reading from a File
To read from a file, three methods can be used. These methods are read([size]), 
readline([size]), and readlines([sizehint]).
Use the read([size]) method to read the entire file and return the entire 
contents as a single string or, if the optional size argument is given, to read 
the specified number of bytes and return the contents as a single string. The 
following example shows how the 9 × 9 multiplication table is read using 

the read([size]) method:
In [ ]:
f = open('./my9x9table0.txt', 'r')
ln = f.read()
print(ln)
f.close()
Out [ ]:
1 x 1 = 1
1 x 2 = 2 2 x 2 = 4
1 x 3 = 3 2 x 3 = 6 3 x 3 = 9
1 x 4 = 4 2 x 4 = 8 3 x 4 = 12 4 x 4 = 16
1 x 5 = 5 2 x 5 = 10 3 x 5 = 15 4 x 5 = 20 5 x 5 = 25
1 x 6 = 6 2 x 6 = 12 3 x 6 = 18 4 x 6 = 24 5 x 6 = 30 6 x 6 = 36
1 x 7 = 7 2 x 7 = 14 3 x 7 = 21 4 x 7 = 28 5 x 7 = 35 6 x 7 = 42 7 x 7 = 49
1 x 8 = 8 2 x 8 = 16 3 x 8 = 24 4 x 8 = 32 5 x 8 = 40 6 x 8 = 48 7 x 8 = 56 8 x 
8 = 64
1 x 9 = 9 2 x 9 = 18 3 x 9 = 27 4 x 9 = 36 5 x 9 = 45 6 x 9 = 54 7 x 9 = 63 8 x 
9 = 72 9 x 9 = 81
	
Use Sequences, Sets, Dictionaries, and Text Files	
281
 https://doi.org/10.15215/remix/9781998944088.01
If size is given, only that number of bytes will be read, as shown in the next 
example:
In [ ]:
f = open('./my9x9table0.txt', 'r')
ln = f.read(135)   # only read 135 bytes
print(ln)
f.close()
Out [ ]:
1 x 1 = 1
1 x 2 = 2 2 x 2 = 4
1 x 3 = 3 2 x 3 = 6 3 x 3 = 9
1 x 4 = 4 2 x 4 = 8 3 x 4 = 12 4 x 4 = 16
1
Because the given size is so small, only a small portion of the multiplication 
table has been read from the file.
Our next method for reading data from a file is readline([size]). This method 
will read and return one entire line from the file if the optional size argument 
is not provided or if the integer value is equal to or greater than the size of the 
line. If the provided size is smaller than the actual size of the line being read, 
then only part of that line, equal to the size in bytes, will be read and returned, 
as shown in the following example:
In [ ]:
f = open('./my9x9table0.txt', 'r')
ln = f.readline(3)
print(ln, end='')
f.close()
Out [ ]:
1 x
Using this method to read all the lines of the 9 × 9 multiplication table in the 
file shown in the previous examples, we will need to put it in a loop and read 
line by line until the end of the file. In Python, however, there is no effective 
way to test if it has reached the end of the file. For this particular file, since 
we know there is no blank line before the end of the file, we will use an empty 
string to signify the end of the file. The revised code is shown below:
In [ ]:
f = open('./my9x9table0.txt', 'r')
while True:
  ln = f.readline()
  print(ln, end='')
  if ln == '':   # test if it has reached the end of 
the table
    break
f.close()
	282	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Out [ ]:
1 x 1 = 1
1 x 2 = 2 2 x 2 = 4
1 x 3 = 3 2 x 3 = 6 3 x 3 = 9
1 x 4 = 4 2 x 4 = 8 3 x 4 = 12 4 x 4 = 16
1 x 5 = 5 2 x 5 = 10 3 x 5 = 15 4 x 5 = 20 5 x 5 = 25
1 x 6 = 6 2 x 6 = 12 3 x 6 = 18 4 x 6 = 24 5 x 6 = 30 6 x 6 = 36
1 x 7 = 7 2 x 7 = 14 3 x 7 = 21 4 x 7 = 28 5 x 7 = 35 6 x 7 = 42 7 x 7 = 49
1 x 8 = 8 2 x 8 = 16 3 x 8 = 24 4 x 8 = 32 5 x 8 = 40 6 x 8 = 48 7 x 8 = 56 8 x 
8 = 64
1 x 9 = 9 2 x 9 = 18 3 x 9 = 27 4 x 9 = 36 5 x 9 = 45 6 x 9 = 54 7 x 9 = 63 8 x 
9 = 72 9 x 9 = 81
The code above does not look so neat. In fact, since the text file is treated 
as an iterator in Python, with one item for each line, the above code can be 
simply written as follows:
f = open('./my9x9table0.txt', 'r')
for ln in f:
  print(ln, end = '')
f.close()
The output is the same as above.
Using a context manager with the code can be further simplified as follows:
with open('./my9x9table0.txt', 'r') as f:
for ln in f:
  print(ln, end='')   # keyword argument end is set empty 
because ln already has newline in it
Considering the fact that a text file is an iterator, the built-­
in function 
next(iterator) can be used to iterate the file line by line. However, it would raise 
a StopIteration error if it reached the end of the file. The following example 
shows how to use next(iterator) to read and print the entire multiplication table:
In [ ]:
f = open('./my9x9table0.txt', 'r')
try:
  while True:
    line = next(f)   # treat f as an iterator
    print(line, end='')
except (StopIteration):
  f.close()   # if it reached the end of the file, 
close the file
	
Use Sequences, Sets, Dictionaries, and Text Files	
283
 https://doi.org/10.15215/remix/9781998944088.01
Out [ ]:
1 x 1 = 1
1 x 2 = 2 2 x 2 = 4
1 x 3 = 3 2 x 3 = 6 3 x 3 = 9
1 x 4 = 4 2 x 4 = 8 3 x 4 = 12 4 x 4 = 16
1 x 5 = 5 2 x 5 = 10 3 x 5 = 15 4 x 5 = 20 5 x 5 = 25
1 x 6 = 6 2 x 6 = 12 3 x 6 = 18 4 x 6 = 24 5 x 6 = 30 6 x 6 = 36
1 x 7 = 7 2 x 7 = 14 3 x 7 = 21 4 x 7 = 28 5 x 7 = 35 6 x 7 = 42 7 x 7 = 49
1 x 8 = 8 2 x 8 = 16 3 x 8 = 24 4 x 8 = 32 5 x 8 = 40 6 x 8 = 48 7 x 8 = 56 8 x 
8 = 64
1 x 9 = 9 2 x 9 = 18 3 x 9 = 27 4 x 9 = 36 5 x 9 = 45 6 x 9 = 54 7 x 9 = 63 8 x 
9 = 72 9 x 9 = 81
The third method for reading data from a file is readlines([sizehint]), where 
optional sizehint, if provided, should be an integer hinting at the amount of 
data to be read. Again, it is only available for text files. As the name implies, 
it reads multiple lines into a Python list until the end of the file, or as much 
as defined by sizehint, if the argument is provided. For example, if the total 
amount of data of the first n lines is less than sizehint, but the first n + 1 lines 
is greater than sizehint, then the method will read (n + 1) lines. So it will read 
whole lines rather than partial, in contrast to the readline([size]) method.
Sometimes, we might like to read from a particular portion of a file, just like we 
want to start reading a book from a specific page. How can we do that in Python?
Imagine there is a pointer indicating where the reading will start in a file. 
In Python, several methods can be used to adjust the pointer.
The first method is f.tell(), which determines where the pointer is in terms 
of how many bytes ahead it is, as shown in the following example:
In [ ]:
f = open('./my9x9table0.txt', 'r')
while True:
  pt = f.tell()
  line = f.readline()
  print('{:3d}: {:s}'.format(pt, line), end = '')
  if line == '':   # test if it has reached the end of 
the table
    break
f.close()
Out [ ]:
0:   1 x 1 = 1
15:  1 x 2 = 2 2 x 2 = 4
43:  1 x 3 = 3 2 x 3 = 6 3 x 3 = 9
84:  1 x 4 = 4 2 x 4 = 8 3 x 4 = 12 4 x 4 = 16
138: 1 x 5 = 5 2 x 5 = 10 3 x 5 = 15 4 x 5 = 20 5 x 5 = 25
205: 1 x 6 = 6 2 x 6 = 12 3 x 6 = 18 4 x 6 = 24 5 x 6 = 30 6 x 6 = 36
285: 1 x 7 = 7 2 x 7 = 14 3 x 7 = 21 4 x 7 = 28 5 x 7 = 35 6 x 7 = 42 7 x 7 = 49
378: 1 x 8 = 8 2 x 8 = 16 3 x 8 = 24 4 x 8 = 32 5 x 8 = 40 6 x 8 = 48 7 x 8 = 56 
8 x 8 = 64
484: 1 x 9 = 9 2 x 9 = 18 3 x 9 = 27 4 x 9 = 36 5 x 9 = 45 6 x 9 = 54 7 x 9 = 63 
8 x 9 = 72 9 x 9 = 81
603:
	284	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The output above shows where each line starts. For example, the end of 
the file is at 603. So with this information, the code using the readline([size]) 
method to read the multiplication table previously given can be easily revised 
to the following:
f = open('./my9x9table0.txt', 'r')
while f.tell() != 603:   # we use the read location to 
identify if it has reached the end of the file
  line = f.readline()
  print(line, end = '')
f.close()
What if we want to read from a specific point in the file? To do that, we 
need to move the pointer to that point. That brings us to the second method 
of adjusting the pointer, which is f.seek(offset, start), in which the offset is 
how much to move it from the start. The default value for start is the cur­
rent position of the pointer in the file. It would have been 0 when the file 

opened.
So suppose we want to read the line of the multiplication table 138 bytes from 
the beginning of the file. We would have to move the pointer to 138 first. From 0 
at the beginning, the offset would be 138 as well. The code is shown below:
In [ ]:
f = open('./my9x9table0.txt', 'r')
f.seek(138)
pt = f.tell()
line = f.readline()
print('{:3d}: {:s}'.format(pt, line), end = '')
f.close()
Out [ ]:
138: 1 x 5 = 5 2 x 5 = 10 3 x 5 = 15 4 x 5 = 20 5 x 5 = 25
Update Existing Content of a Text File
In a text file, how do we replace an existing line with something else? To achieve 
this, we need to take the following steps:
	
1.	 Open the file in r+ mode
	
2.	 Find out the position of the line
	
3.	 Move the file pointer to that position using f.seek(offset, start)
	
4.	 Write whatever you want to the file, which will replace the original 
content on that line
	
Use Sequences, Sets, Dictionaries, and Text Files	
285
 https://doi.org/10.15215/remix/9781998944088.01
An example of such an update is shown below:
In [ ]:
f = open('./my9x9table0.txt', 'r+')
f.seek(138)
pt = f.tell()
line = f.readline()
f.seek(138, 0)
f.write("update this line\n")
print('{:3d}: {:s}'.format(pt, line), end = '')
f.close()
Out [ ]:
138: 1 x 5 = 5 2 x 5 = 10 3 x 5 = 15 4 x 5 = 20 5 x 5 = 25
The updated content of the file is shown below:
1 x 1 = 1
1 x 2 = 2     2 x 2 = 4
1 x 3 = 3     2 x 3 = 6      3 x 3 = 9
1 x 4 = 4     2 x 4 = 8      3 x 4 = 12     4 x 4 = 16
1 x 5 = 5 2 x 5 = 1update this line
= 20     5 x 5 = 25
Note that if there is less new content than the original, only part of the 
original is replaced.
We can also replace a single original line with multiple lines, as shown 
below:
In [ ]:
f = open('./my9x9table0.txt', 'r+')
f.seek(138)
pt = f.tell()
line = f.readline()
f.seek(138, 0)
f.write("we write a line at the current position\n")
f.write("we write another line below\n")
f.write("we add third line below the two lines already 
written\n")
print('{:3d}: {:s}'.format(pt, line), end = '')
f.close()
Out [ ]:
138: 1 x 5 = 5 2 x 5 = 10 3 x 5 = 15 4 x 5 = 20 5 x 5 = 25
The updated file is shown below:
	286	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
1 x 1 = 1
1 x 2 = 2     2 x 2 = 4
1 x 3 = 3     2 x 3 = 6      3 x 3 = 9
1 x 4 = 4     2 x 4 = 8      3 x 4 = 12     4 x 4 = 16
1 x 5 = 5 2 x 5 = 1we write a line at the current position
we write another line below
we add third line below the two lines already written
4 3 x 7 = 21 4 x 7 = 28 5 x 7 = 35 6 x 7 = 42 7 x 7 = 49
1 x 8 = 8 2 x 8 = 16 3 x 8 = 24 4 x 8 = 32 5 x 8 = 40 6 x 8 = 48 7 x 8 = 
56 8 x 8 = 64
1 x 9 = 9 2 x 9 = 18 3 x 9 = 27 4 x 9 = 36 5 x 9 = 45 6 x 9 = 54 7 x 9 = 
63 8 x 9 = 72 9 x 9 = 81
However, if the total size of the new written data is longer than the line 
being replaced, part of the line or lines under will be overwritten. Therefore, 
if you want to replace a specific line of the text file exactly, you will need to 
write just enough to cover the existing data—­
no more, no less.
Deleting Portion of a Text File
To delete a portion of existing data from a file, you will need to use the f.trun­
cate([size]). If the optional size argument is given, the file will be truncated to 
that size or the size of the file. Otherwise, the file will be truncated to the current 
file position. So if a file is freshly opened in w, w+, a, or a+ mode, f.truncate() 
will remove all data from the beginning to the end of the file. Please note that if 
the optional size argument is given and greater than 0, the file must be opened 
in a or a+ mode in order to truncate the file to the expected size.
f = open('./my9x9table0.txt', 'a')
f.truncate(399)
 
f.close()
The resulting content of the file is shown below:
1 x 1 = 1
1 x 2 = 2 2 x 2 = 4
1 x 3 = 3 2 x 3 = 6 3 x 3 = 9
1 x 4 = 4 2 x 4 = 8 3 x 4 = 12 4 x 4 = 16
1 x 5 = 5 2 x 5 = 1we write a line at the current position
we write another line below
we add third line below the two lines already written
4 3 x 7 = 21 4 x 7 = 28 5 x 7 = 35 6 x 7 = 42 7 x 7 = 49
1 x 8 = 8 2 x 8 = 16 3 x 8 = 24 4 x 8 = 32 5 x 8 = 40 6 x 8 = 48 7 x 8 
= 56
	
Use Sequences, Sets, Dictionaries, and Text Files	
287
 https://doi.org/10.15215/remix/9781998944088.01
Please note that only part of the content in the file is left.
If the file is opened in w or w+ mode, the file will be truncated to a size of 
0 regardless.
With all we have learned so far, we are ready to design and code a program 
to analyze an article stored in a text file. The program is shown in Table 5-­
8.
Table 5-­
8: Case study: How to create a word list
The problem
Different people have different styles when writing articles. These 
styles may include the words, phrases, and even sentences used 
most often in their writing. In this case study, we will develop a 
program that analyzes an article stored as a text file to create a list 
of the words used most often in the article.
The analysis 
and design
To analyze the article, we need to read the file into memory, build a 
list of words used in the article, then count how many times each 
word appears in the article. Because the file needs to be read line 
by line, we will read, analyze, and count the words in each line. 
How can we store the result containing the unique words and the 
number of times each word appeared in the article? Recall what 
we learned about dictionaries: each unique word can be used as a 
key, and the number of times the word appears can be the value. 
We then just need to determine the words used most often in the 
article. The best way to do that would be to sort the items of the 
dictionary based on the values (instead of keys), then take the 
first 10 items as the result. The algorithm is as follows:
 
1. Prepare by creating a list of punctuation marks and a list of 
nonessential words that can be ignored.
 
2. Initialize by setting the counter to 0, w_dict = {}.
 
3. Read the first line from the article into the memory.
 
4. Build a list of all words within the line:
   a.  replace all the punctuation marks with whitespace
   b.  split the entire article at whitespace to build a list of words
   c.  remove all nonessential words from the list
 
5. Add the length of the list to the word counter:
   a.  get a word from the list
   b.  
if the word is already in w_dict, increase the value by 1; 
otherwise, add dictionary item (word:1) to w_dict
   c.  repeat step 5
 
6. Repeat steps 3–­
5 on the next line until there are no remaining lines 
in the file.
 
7. Sort w_dict based on the values.
 
8. Print out the first 10 items to show the words used most often by 
the article’s author.
Please note that this is just an example of programming with text 
files and Python dictionaries. The underlying theory about writing 
style may not be sound. The words that appear most often in an 
article may also be relevant to the topics covered by the article.
(continued on next page)
	288	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The code
"""
This program finds out the frequencies of all words 
used in a news article stored in a text file.
"""
def news_analysis(article="WritingProposal.txt"):
  f = open(article, 'r')
  w_dict = {}   # we use dictionary to store the 
result, the key is the word, the value is times 
used
  punctuations = ['//', '-­
', ',', '.', ':', '"', 
'[', ']', '(', ')', ';', '!', '?', '\n']
  less_meaningful = ['the', 'a', 'an', 'to', 'of', 
'and', 'was', 'is', 'are', 'in', 'on']
  space, words_total, unique_count = ' ', 0, 0
  for m in f:   # this will lead the PVM to read the 
file line by line
    for c in punctuations:
      m = m.replace(c, ' ')
    words = m.split(f"{space}")
    for w in words:
      if w == '':
        continue
      else:
        words_total += 1   # count total number of 
all words
    for w in less_meaningful:
      m = m.replace(f' {w} ', ' ')
      m = m.replace(f' {w.capitalize()} ', ' ')
    words = m.split(f"{space}")
    for w in words:
      if w == '':
        continue
      else:
        if w not in w_dict.keys():
          unique_count += 1
          w_dict.update({w: 1})
        else:
          w_dict[w] += 1
  f.close()
  return words_total, [(k, v) for k, v in sorted(w_
dict.items(), reverse=True, key=lambda item: 
item[1])]
result = news_analysis()
print(f"The article has {result[0]} words in total")
print(f"The number of unique words used is 
{len(result[1])}")
for i in range(20):
  print(f'word "{result[1][i][0]}" used 
{result[1][i][1]} times.')
Table 5-­
8: Case study: How to create a word list (continued)
	
Use Sequences, Sets, Dictionaries, and Text Files	
289
 https://doi.org/10.15215/remix/9781998944088.01
The result
The article has 926 words in total
The number of unique words used is 467
word "will" used 20 times.
word "be" used 13 times.
word "NATO" used 13 times.
word "https" used 13 times.
word "research" used 10 times.
word "interoperability" used 9 times.
word "as" used 9 times.
word "Information" used 8 times.
word "standards" used 7 times.
word "military" used 7 times.
word "Interoperability" used 7 times.
word "for" used 7 times.
word "www" used 7 times.
word "such" used 6 times.
word "This" used 5 times.
word "this" used 4 times.
word "Canada" used 4 times.
word "essay" used 4 times.
word "exchange" used 4 times.
word "MIP" used 4 times.
Chapter Summary
•	 Computer intelligence is achieved by computing and information 
processing.
•	 Both computing and information processing involve the manipulation 
of data.
•	 Simple types of data such as integers, floats, characters, and bools are 
the fundamental elements for complex data types.
•	 Unlike other languages, such as C, Python doesn’t have a separate data 
type for single characters. In Python, a single character is a string 
whose length is 1.
•	 Python has two constants, True and False, defined as values of type 
bool. However, Python also treats 0, None, and empty string, empty 
list, empty tuple, empty set, and empty dictionary as False and treats all 
other values/objects as True.
•	 Python has some special data values/constants that don’t belong to 
any ordinary data type. These special values/constants include None, 
NotImplemented, Ellipsis, and __debug__.
•	 Strings, lists, tuples, sets, and dictionaries are the compound data types 
in Python.
Table 5-­
8: Case study: How to create a word list (continued)
	290	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
•	 A string is a sequence of characters (ASCII, Unicode, or another 
encoding standard).
•	 A list is a sequence of data in a pair of square brackets [], such as [1, 2, 
3, 4, 5].
•	 A tuple is a sequence of data in a pair of parentheses (), such as (1, 2, 3, 
4, 5).
•	 The difference between a list and a tuple is that a list is mutable 
whereas a tuple is immutable, which means that once created, the data 
member of a tuple cannot be changed.
•	 Characters in a string and members of a list or a tuple are indexed from 
0 to n − 1, where n is the length of the string, list, or tuple.
•	 The character at place j of string s can be accessed using s[j].
•	 Similarly, a data member at place j of a list or tuple x can be accessed 
using x[j].
•	 Strings, lists, and tuples are collectively called sequences.
•	 A slice of sequence (string/list/tuple) x can be taken using x[i:j], in 
which i specifies where the slice starts and j specifies that the slice 
should end right before location j.
•	 A number of operators and functions are available for constructing and 
manipulating strings, lists, or tuples.
•	 String, list, and tuple objects also have a number of methods available 
for constructing and manipulating strings, lists, or tuples.
•	 Some operators, functions, and methods are common for strings, lists, 
and tuples.
•	 A set is a collection of unique data enclosed by a pair of curly brackets 
{}, such as {1, 2, 3, 5}.
•	 Members of a set s are unordered, which means that they cannot be 
accessed using notion S[j], for example.
•	 A set has some very special functions and methods from other 
compound data types in Python.
•	 A dictionary is a collection of keys: value pairs enclosed by a pair of 
curly brackets {}, such as {'one':1, 'two':2, 'three':3, 'five':5}.
•	 Members of a set s are unordered, which means that in a dictionary, 
there is no such thing as a member at location j, for example.
•	 However, the value of a dictionary d can be accessed using the key 
associated with the value with the notion of d[k], which refers to the 
value whose associated key is k.
•	 Some special methods are defined for the operations of dictionaries.
•	 Files are important for storing data and information permanently.
•	 Files include text files and binary files.
	
Use Sequences, Sets, Dictionaries, and Text Files	
291
 https://doi.org/10.15215/remix/9781998944088.01
•	 The basic operations of files include create, read, write, append, and 
expand.
•	 A new file can be created when open with the w or x flag, when the file 
doesn’t already exist. Opening a file with the w flag will overwrite the 
existing content of the file.
•	 To prevent data already in a file from being overwritten, open a file 
with the a flag or x flag. The a flag will open the file for appending new 
data to the end of the existing content of the file, while the x flag will 
not open the file if it already exists.
•	 Open a file with the t flag to indicate that the file is a text file.
•	 Open a file with the b flag to indicate that the file is a binary file.
•	 After reading or writing a file, use the close() file object method to close 
the file.
Exercises
	
1.	 Mentally run the following code blocks and write down the output of 
each code block.
	
a.	 course = 'comp218 -­
 introduction to programming in 
Python'
print(f'The length of \'{course}\' is 
{len(course)}')
	
b.	 course = 'comp218 -­
 introduction to programming in 
Python'
print(f'The length of \'{course[10:22]}\' is 
{len(course[10:22])}')
	
c.	 ls = list(range(9))
print(ls[2:5])
	
d.	 asc = {chr(c) for c in range(ord('A'), 
ord('Z')+1)}
print(asc)
	
e.	 l0 = [i*2+1 for i in range(10)]
print(l0[2])
	
f.	 combo = [year + str(month+1) for year in ['2015', 
'2016'] for month in range(6)]
print(combo)
	
g.	 s0 = 'Python '
s1 = 'is my language!'
print(s0+s1)
	292	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Projects
	
1.	 Write a program that reads a text from a user, then counts and displays 
how many words and how many alphanumeric letters are in the text.
	
2.	 Write a program that
	
a.	 reads a series of numbers that are separated by whitespace and 
uses a new line to end the input, then converts the numbers in the 
input string and puts them into a list.
	
b.	 sorts the numbers in the list in descending order, using the sort() 
list object method.
	
c.	 sorts the numbers in the list in descending order, using the Python 
built-­
in function sorted().
Write your own code to sort the numbers in the list in ascending order 
without using the sort() method or sorted() function.
	
3.	 Sorting is a very important operation in computing and information 
processing because it is much easier to find a particular item (a 
number or a word) from a large collection of items if the items 
have been sorted in some manner. In computer science, many 
algorithms have been developed, among which selection sort, bubble 
sort, insertion sort, merge sort, quick sort, and heap sort are the 
fundamental ones. For this project, search the internet for articles 
about these sorting algorithms. Choose one to sort a list of integers.
	
4.	 Every course offered at universities has a course number and a title. 
For this project, write an application that uses a dictionary to save 
course information, allows users to add a course into the dictionary, 
and allows a user to get the title of a course for a given course 
number. The application should perform the following functions:
	
a.	 Get a course number and name from a user and add an item, with 
the course number as key and the name as value, to the dictionary 
if the course doesn’t already exist in the dictionary.
	
b.	 Get a course number from a user, then find out the name of the 
course.
	
c.	 Display a list of all the courses in the dictionary showing the course 
numbers as well as names.
	
d.	 Quit the application.
Hint: You will need a top-­
level while loop, which displays a menu 
showing the four options then acts accordingly.
	
5.	 This project is about text analysis. Find a news article on the internet, 
analyze the content, and generate and display some statistical data 
from the article. The detailed requirements are as follows:
	
Use Sequences, Sets, Dictionaries, and Text Files	
293
 https://doi.org/10.15215/remix/9781998944088.01
	
a.	 Find a news article on the internet and save it as a text file on your 
computer.
	
b.	 Have your program build a list of words in the article while reading 
the news content from the file.
	
c.	 Generate and display the following statistics of the article:
	
i.	 the total number of words in the article
	
ii.	 a list of unique words
	
iii.	 the frequency of each unique word in the article
	
iv.	 a short list of words that represent the essence of the article
	
v.	 a table with the above data nicely presented
	
6.	 Cryptography is the study of theory and technology for the protection 
of confidential documents in transmission or storage. It involves both 
encryption and decryption. In any cryptographic scheme, encryption 
is the process of converting plaintext to ciphertext according to a 
given algorithm using an encryption key, whereas decryption is the 
process of converting encrypted text (ciphertext) back to plaintext 
according to a given algorithm using a decryption key. If the 
encryption key and decryption key are the same in a cryptographic 
scheme, the scheme is a symmetric cryptographic scheme; if the 
two keys are different, the scheme is an asymmetrical cryptographic 
scheme.
Among the many cryptographic schemes, substitution is a classic 
one, though the scheme is prone to frequency analysis attack. Write a 
program that can
	
a.	 automatically generate a substitution key and add it to a key list 
stored in a file.
	
b.	 display the substitution keys in the file.
	
c.	 allow the user to choose a key in the list and encrypt some text 
taken from the user.
	
d.	 allow the user to choose a key to decrypt an encrypted text taken 
from the user.
	
e.	 allow the user to choose a key, encrypt the content of a text file, 
and save the encrypted content into a different file.
	
f.	 allow a user to choose a key, decrypt the encrypted content in a 
file, and display the plaintext decrypted content.
This page intentionally left blank
 https://doi.org/10.15215/remix/9781998944088.01
Chapter 6
Define and Use Functions
In programming or software development, program codes must be well 
structured to be manageable. Some program codes can be reused to make pro­
gramming and software development more efficient. Functions and modules 
serve these two goals. Chapter 6 shows you how to define and use functions in 
Python and how to make and use modules in programming.
Learning Objectives
After completing this chapter, you should be able to
•	 explain what functions are in Python.
•	 define new functions correctly.
•	 use functions, including both built-­
in and programmer-­
defined 
functions.
•	 use return statements properly to return various values from a 
function.
•	 use positional arguments in defining and using functions.
•	 use variable-­
length lists of arguments in defining and using functions.
•	 use keyed arguments in defining and using functions.
•	 use positional arguments, keyed arguments, and variable-­
length lists of 
arguments.
•	 explain what recursive functions are and how they work.
•	 define and use recursive functions.
•	 explain what anonymous/lambda functions are.
•	 define and use anonymous/lambda functions.
•	 use special functions such as mapping, filtering, and reducing.
•	 explain what generators are and what advantages they have.
•	 define a function as a generator.
	296	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
•	 explain what closures and decorators are and how they are used.
•	 define and use closures and decorators.
•	 describe the properties of functions and use them properly.
6.1 Defining and Using Functions in Python
You have already seen and used some built-­
in functions in the previous chap­
ters. These built-­
in functions are built into Python Virtual Machine (PVM) 
in its standard distribution so that you can use them without importing any 
Python modules. For example, the built-­
in function sum can be used directly 
to calculate the sum of a sequence of numbers, as shown in the following 
code sample:
>>> sum([12, 23, 25, 65, 52])
177
As you will see, many Python modules, available via either Python distribu­
tion or a third party, have also defined functions ready for you to use in your 
programs.
For functions defined in a standard or third-­
party module, you must 
import the module before you can call the function by using the dot notation 
or operator, such as m.f(…), where m is a name referring to the module, 
and f is the name of the function to be used. Within the pair of parentheses 
are data as arguments of the function call, to be passed to the function for 
processing. The following is an example calling the pow() function from 
the math module:
>>> import math
>>> math.pow(35,12)
3.3792205080566405e+18
Note that when calling a function, a pair of parentheses must be attached to 
the name of the function, even if there is no argument to pass. Otherwise, the 
name of the function will be evaluated as a first-­
class object, and the type of 
the object and the name will be returned, as shown in the following example:
>>> print(sum)
<built-­
in function sum>
>>> print(id)
<built-­
in function id>
	
Define and Use Functions	
297
 https://doi.org/10.15215/remix/9781998944088.01
Although many modules have been developed by others and many func­
tions have been made available, programmers do need to define their own 
functions for their specific purposes.
To define a function in Python, the def compound statement is used. The 
general syntax is as follows:
def <function name>(parameters):
  <code block>
Where function name is a legitimate identifier in the local scope, parameters 
are legitimate variable names that can be used to pass values (arguments) to 
the function, and a code block (function body, in this compound statement) 
is the real program code that does the computing or information processing. 
What makes a code block in a function definition different from code blocks 
in other compound statements such as for, while, and if is that it will always 
return a value with the return statement. Even if you do not have anything 

to return from a function definition and do not have a return statement, special 
value None will still be automatically returned from the function.
The following is a real example showing how a function is defined in Python:
In [ ]:
def factorial(n):
"""This function calculates and returns n!, the 
factorial of an integer n > 0."""
  if (not isinstance (n, int)) or (n < 1):
    return None
  r = 1
  for i in range(n):
    r *= (i + 1)
    return r
As documented in the docstring, the function is to calculate and return the 
factorial of an integer if the number is greater than 0; otherwise, it returns 
None.
The function you defined can be used in the same way as built-­
in functions. 
The following example shows how to call the factorial function defined above:
In [ ]:
N = 16
fn = factorial(N)
print(f'factorial of {N} is {fn}.')
Out [ ]:
factorial of 16 is 20922789888000.
	298	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Sometimes you need to return more than one value from a function. To 
do that, you can either put the values in a compound data type such as a 
list, tuple, set, or dictionary, or just put the value all behind return. In the 
latter case, the values will be automatically packed in a tuple by the return 
statement.
The following example calculates and returns both the quotient and remain­
der of two integers at the same time.
In [ ]:
def idivmod(n, m):
  if (not isinstance(n, int)) or (not isinstance(n, 
int)) or (m == 0):
    return None
  return n // m, n % m
n, m = 23, 5
print(f'The value returned from idivmod({n}, {m}) is 
{idivmod(n, m)}.')
Out [ ]:
The value returned from idivmod(23, 5) is (4, 3).
In the remainder of this section, we show how to program to solve slightly 
more complicated problems with Python.
A perfect number is an integer that equals the sum of all its factors excluding 
the number itself. For example, 6 is a perfect number because 6 = 1 + 2 + 3. So 
is 28. It sounds simple, but the next perfect number is very far from 28: 496. A 
program for finding perfect numbers is shown in Table 6-­
1.
Table 6-­
1: Case study: How to find perfect numbers
The problem
In this case study, we are going to write a program to ask for a big 
integer from the user, then find all the perfect numbers smaller 
than the big integer.
The analysis 
and design
Step 1.	 Take an input from user, and convert it into an integer
Step 2.	 Loop from 2 to the big integer
   a. Test each integer to see if it is a perfect number
   b. If yes, print the number and all its factors
Step 3.	 Finish
Steps to check if a number is a perfect number:
Step 4.	 Find all its factors, including 1 but excluding the number 
itself, and put them into a list
Step 5.	 Sum up the factors with sum(factors)
Step 6. If the number == sum(factors), then return True.
	
Define and Use Functions	
299
 https://doi.org/10.15215/remix/9781998944088.01
The code
"""
This program is used to find all the perfect 
numbers that are less than N given by a user.
"""
def perfect(n):
  factor = [1]   # create a list with 1 as the 
first factor
  for j in range(2, (n // 2) + 1):   # only need 
loop to n // 2 + 1
    if n % j == 0:   # if j is a factor
      factor.append(j)   # add j to the list
    if n == sum(factor):   # if the sum of the 
factors = n
      return [True, factor] # return True as well 
as factors
    else:
      return [False, []]
upper_bound = int(input("Tell me the upper 
bound:"))
for i in range(2, upper_bound):
  test = perfect(i)
  if test[0]:
    print(f"{i} = {test[1]}")
The result
Tell me the upper bound:32198765
6 = [1, 2, 3]
28 = [1, 2, 4, 7, 14]
496 = [1, 2, 4, 8, 16, 31, 62, 124, 248]
8128 = [1, 2, 4, 8, 16, 32, 64, 127, 254, 508, 1016, 2032, 4064]
6.2 Parameters and Arguments in Functions
When you define a function, you can use variables within the parentheses 
right next to the function name to specify what values can be taken when 
the function is called. These variables within the parentheses are called par­
ameters, and the values to be passed to the parameters in a function call are 
called arguments.
In Python, a function call may take positional arguments, keyword argu­
ments, variable-­
length lists of nonkeyword arguments, variable-­
length lists 
of keyword arguments, and default arguments. These are determined in the 
definition of the function.
In a function definition, a simple variable name can be used for a parameter 
expecting a positional argument or keyword argument, to give a parameter, such 
as x, a default V using assignment x = V. When a parameter is given a default 
Table 6-­
1: Case study: How to find perfect numbers (continued)
	300	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
value, the default value will be used when no value is given to the parameter 
in a function call.
To indicate that parameter y will hold a variable-­
length list of nonkeyword 
arguments, use *y; to indicate that parameter z will take variable-­
length 
of keyword arguments, use **z. Keyword arguments will be explained 

shortly.
When calling a function, positional arguments are the arguments passed to 
their respective parameters in accordance with their positions. That is, the first 
parameter in a function call is passed to the first argument in the definition of 
the function, the second parameter is passed to the second argument, and so 
on. This is illustrated in the example below:
In [ ]:
def func_demo1(a, b, c):
  print(f'a = {a}, b = {b}, c = {c}')
func_demo1(1, 2, 3)
Out [ ]:
a = 1, b = 2, c = 3
This shows that the first argument was passed to the first parameter a, the 
second argument was passed to the second parameter b, and the third argument 
was passed to the third parameter c.
When calling a function, its parameter name, such as x, can be used as a 
keyword to explicitly indicate that a specific value, such as v, will be passed to 
x. This is done using x = v syntax, called a keyword argument in a function call. 
The following example shows how keyword arguments are used.
In [ ]:
def func_demo1(a, b, c):
  print(f'a = {a}, b = {b}, c = {c}')
func_demo1(b =1, a = 2, c = 3)
Out [ ]:
a = 2, b = 1, c = 3
In this case, the order of the arguments does not matter because the code 
explicitly indicates which argument is given to which parameter. Please note 
that in a function call when keyword argument is used, no more positional 
arguments, except variable-­
length nonkeyword arguments, may follow. An 
error will occur otherwise, as shown below:
	
Define and Use Functions	
301
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
def func_demo1(a, b, c):
  print(f'a = {a}, b = {b}, c = {c}')
func_demo1(b=1, 2, 3)
Out [ ]:
File "<ipython-­
input-­
51-­
6539f4d878e5>", line4
func_demo1(b = 1, 2, 3)
    ^
SyntaxError: positional argument follows keyword argument
Also, in a function definition, parameters expected to be used as keywords 
must be placed behind those expecting positional arguments. An error will 
occur otherwise, as shown in the following example:
In [ ]:
def func_demo1(a, b, c):
  print(f'a = {a}, b = {b}, c = {c}')
func_demo1(3, 1, a = 2)
Out [ ]:
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
TypeError   Traceback (most recent call last)
<ipython-­
input-­
185-­
f540d2127799> in <module>
  2 print(f'a = {a}, b = {b}, c = {c}')
  3 -­
-­
-­
-­
>
  4 func_demo1(3, 1, a = 2)
TypeError : func_demo1() got multiple values for argument 'a'
When a parameter in a function definition has a default value, the argu­
ment for the parameter can be omitted if the default value is to be used. The 
function defined in the following example will calculate the square of num­
ber x by default, but it can also calculate x power of y by passing a particular 
value to y:
In [ ]:
def powerof(x, y = 2):
  return f'{x} ** {y} = {x ** y}'
print(powerof(12))
print(powerof(23, 5))
print(powerof(13, y = 6))
print(powerof(y = 21, x = 3))   # with keyword 
arguments, the order doesn't matter
Out [ ]:
12 ** 2 = 144 23 ** 5 = 6436343 13 ** 6 = 4826809 3 ** 21 = 10460353203
	302	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The following example demonstrates how to define a function that can 
take variable-­
length nonkeyword arguments. The function is to calculate the 
product of a series of numbers:
In [ ]:
def product(*n):
  s = 1
  for i in n:
    s *= i
  return f'Product of all numbers in {n} is {s}'
print(product(1,2,5,32,67))
print(product(11,32,25,3,7))
print(product(19,12,15,322,6))
Out [ ]:
Product of all numbers in (1, 2, 5, 32, 67) is 21440
Product of all numbers in (11, 32, 25, 3, 7) is 184800
Product of all numbers in (19, 12, 15, 322, 6) is 6607440
As can be seen, using variable-­
length nonkeyword positional arguments 
has made the function more powerful.
Sometimes in a function call, you may also want to use variable-­
length 
keyword arguments. The following example shows how this can be done:
In [ ]:
def reporting(**kwargs):
  for k, v in kwargs.items():
    print(f'{k}:{v}')
reporting(First_name ='John', Last_name ='Doe', Sex 
='Male')
reporting()
Out [ ]:
First_name:John
Last_name:Doe
Sex:Male
When calling a function with variable-­
length keyword arguments, the key­
words look like parameter names to which the values are passed. However, 
in the case of variable-­
length keyword arguments, these keywords cannot be 
used as variables inside the function definition because they are not in the 
parameter list when the function is defined.
While variable-­
length nonkeyword arguments are passed to a function as 
a tuple, variable-­
length keyword arguments are passed to the function as a 
dictionary. As such, what can be achieved by using variable-­
length keyword 
	
Define and Use Functions	
303
 https://doi.org/10.15215/remix/9781998944088.01
arguments can also be achieved by passing a dictionary instead. For example, 
the above example can be easily rewritten as follows:
In [ ]:
def dict_reporting(ps):   # kw is a dictionary
  for k, v in ps.items():
    print(f'{k}:{v}')
pdict = {'First_name':'John', 'Last_name':'Doe', 
'Sex':'Male'}
dict_reporting(pdict)
Out [ ]:
First_name:John
Last_name:Doe
Sex:Male
Similarly, functions taking variable-­
length nonkeyword arguments can be 

easily rewritten to take a tuple. So the example of list_product function can 

be rewritten as follows:
In [ ]:
def product_tuple(nt):
  s = 1
  for i in nt:
    s *= i
  return f'Product of all numbers in {nt} is {s}'
print(product_tuple((1,2,5,32,67)))
print(product_tuple((11,32,25,3,7)))
print(product_tuple((19,12,15,322,6)))
Out [ ]:
Product of all numbers in (1, 2, 5, 32, 67) is 21440
Product of all numbers in (11, 32, 25, 3, 7) is 184800
Product of all numbers in (19, 12, 15, 322, 6) is 6607440
The difference between using variable-­
length arguments and passing a 
tuple or dictionary is that, because the length of variable-­
length arguments can 
be 0, you do not have to pass any argument at all if you don’t have one. With 
a tuple or dictionary, on the other hand, you would have to have a legitimate 
argument for the corresponding parameter in the function definition unless 
you have set a default value to it. Also, as can be seen from the two examples 
above, in some applications, using variable-­
length arguments is more natural 
and elegant.
	304	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
CODING PRACTICE
We know that given a, b, and c for equation ax2 + bx + c = 0, x is (−b + 
sqrt(b2 − 4ac)) / 2a, or (−b − sqrt(b2 − 4ac)) / 2a.
Design a program that will take three numbers with the input 
statement, and then solve quadratic equation ax2 + bx + c = 0 by calling 
a function solve quadratic(a, b, c) which you need to design. The two 
solutions x1, x2 should be returned in a tuple as (x1, x2).
6.3 Recursive Functions
A function is recursive if it calls itself either directly or indirectly. Recursion 

is a powerful concept in computing and computational theory. In computational 
theory, it has been proven that any problem computable by modern computers 
can be represented as a recursive function.
In programming, recursive functions do not make your programs run fast. 
However, they do provide a powerful means of algorithm design to solve a 
problem and make neater program code.
Take the factorial function n! as an example. You know that n! is defined as 
1 * 2 * 3 * … * n. If you use fac(n) to refer to the factorial function, you cannot 
simply define the function in Python as
def fac(n):
  return 1 * 2 * 3 * … * n   # this does not work in 
Python
because the dots (…) do not make sense to computers in this context. With what 
you have learned so far, the function can be defined as
def fac(n):
  if n == 0:
    return 1
  product = 1
  for i in range(n):   # using loop
    product *= (i + 1)
  return product
The function above has seven lines of code.
	
Define and Use Functions	
305
 https://doi.org/10.15215/remix/9781998944088.01
Since you know that 0! = 1, and n! can be computed as n * (n − 1)! if n > 0, 
you can program a recursive function in Python to solve the factorial problem, 
as shown in the case study in Table 6-­
2.
Table 6-­
2: Case study: How to use a recursive function for 
calculating factorial n
The problem
Define a recursive function to calculate factorial n as n!
The analysis 
and design
We know that 0! = 1, and n! can be computed as n * (n − 1)! when 
n > 0. So if we use fac(n) to denote n!, this will be translated as 
fac(n) = 1 if n = 0 and as fac(n)= n * fac(n − 1) if n > 0. Accordingly, 
we can define a recursive factorial function in Python as follows:
The code
def fac(n):
  if n == 0:
    return 1
  else:
    return n * fac(n -­
 1)
n = 9
print(f"{n}! = {fac(n)}")
The result
9! = 362880
As you can see, the function has become shorter and neater, although it 
often takes more memory and more time to run.
The next case study, in Table 6-­
3, shows how a recursive function can be 
used to find the greatest common divisor of two integers.
CODING ALERT
What will happen if fac(n) is called with n < 0? For example, as fac(−9)?
Table 6-­
3: Case study: How to use a recursive function
The problem
This simple problem aims to find the greatest common divisor 
(GCD) for two given integers. A common divisor of two integers 
is an integer that can divide both integers, and the GCD is the 
biggest one among the common divisors. For example, 1 and 2 are 
common divisors of 4 and 6, and 2 is the GCD of 4 and 6.
The analysis 
and design
At first glance, a straightforward approach is to find all the divisors 
for each integer,
(continued on next page)
	306	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The code
"""
Ask for two integers and find the GCD of the two 
using the improved Euclidean algorithm.
"""
def my_gcd(a, b):
  global depth
  if b == 0:   # condition to finish
    return b
  else:
    b, a = sorted((abs(a -­
 b), b))   # sort and 
reassign
    depth += 1   # recursion depth increased by 1
    print(f"recursion #{depth} for{(a, b)}")
    return my_gcd(a, b)
i = int(input("Tell me the first integer:"))
j = int(input("Tell me the second integer:"))
if i < j:
  i, j = j, i
depth = 0
print(f"The greatest common divisor of {i} and {j} 
is {my_gcd(i, j)} after {depth} recursions.")
The result
Tell me the first integer:3238
Tell me the second integer:326
recursion #1 for (2912, 326)
recursion #2 for (2586, 326)
recursion #3 for (2260, 326)
recursion #4 for (1934, 326)
recursion #5 for (1608, 326)
recursion #6 for (1282, 326)
recursion #7 for (956, 326)
recursion #8 for (630, 326)
recursion #9 for (326, 304)
recursion #10 for (304, 22)
recursion #11 for (282, 22)
recursion #12 for (260, 22)
recursion #13 for (238, 22)
recursion #14 for (216, 22)
recursion #15 for (194, 22)
recursion #16 for (172, 22)
recursion #17 for (150, 22)
recursion #18 for (128, 22)
recursion #19 for (106, 22)
recursion #20 for (84, 22)
recursion #21 for (62, 22)
recursion #22 for (40, 22)
recursion #23 for (22, 18)
recursion #24 for (18, 4)
recursion #25 for (14, 4)
recursion #26 for (10, 4)
recursion #27 for (6, 4)
recursion #28 for (4, 2)
recursion #29 for (2, 2)
recursion #30 for (2, 0)
The greatest common divisor of 3238 and 326 is 2 after 30 
recursions.
Table 6-­
3: Case study: How to use a recursive function (continued)
	
Define and Use Functions	
307
 https://doi.org/10.15215/remix/9781998944088.01
As noted, the program took 30 recursions to find the GCD of 3238 and 326. 
Can we make it more efficient? The answer is yes, and it is fun to design and 
code a better and faster program to solve a problem, as shown in the case study 
of this same problem in Table 6-­
4.
Table 6-­
4: Case study: How to use a recursive function—­
revised
The problem
This simple problem aims to find the greatest common divisor 
(GCD) for two given integers. A common divisor of two integers 
is an integer that can divide both integers, and the GCD is the 
biggest one among the common divisors. For example, 1 and 2 are 
common divisors of 4 and 6, and 2 is the GCD of 4 and 6.
The analysis 
and design
The original Euclidean algorithm is great because it only needs 
subtraction to find out the greatest common divisor, but sometimes 
it will involve too many steps, especially if we do the calculation 
manually. For example, to find the greatest common divisor of 4 
and 40000, one needs to complete 10000 subtractions to find out 
that 4 is the GCD. An obvious and straightforward improvement to 
the algorithm is to use modular operation in place of subtraction.
The code
"""
Ask for two integers and find the GCD of the two 
using the improved Euclidean algorithm.
"""
def my_gcd(a, b):
  global depth
  if b == 0:   # condition to exit from recursion
    return a
  else:
    b, a = sorted(((a % b), b))   # sort and 
reassign
    depth += 1   # recursion depth increased by 1
    print(f"recursion # {depth} for {(a, b)}")
    return my_gcd(a, b)
i = int(input("Tell me the first integer:"))
j = int(input("Tell me the second integer:"))
if i < j:
  i, j = j, i
depth = 0
print(f"The greatest common divisor of {i} and {j} 
is {my_gcd(i, j)} after {depth} recursions.")
The result
Tell me the first integer:3238
Tell me the second integer:326
recursion #1 for (326, 304)
recursion #2 for (304, 22)
recursion #3 for (22, 18)
recursion #4 for (18, 4)
recursion #5 for (4, 2)
recursion #6 for (2, 0)
The greatest common divisor of 3238 and 326 is 2 after 6 
recursions.
	308	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
As you can see, for the same numbers, the improved algorithm took only six 
recursions, whereas the original took 30. Another benefit of using the improved 
algorithm is that because Python Virtual Machine (PVM) has a limit on the 
maximum depth of recursions due to the limitations of computer memory, 
the improved algorithm will be able to handle much bigger numbers than the 
original algorithm. You may run the two programs on 24230336504090 and 
356879542 to see the difference between the two algorithms.
6.4 Anonymous Functions: lambda Expressions
In previous sections, you saw functions with names, which make it possible to 
call a function by its name. Sometimes, especially when the operations of the 
function are simple and used only once, it is more convenient to simply use a 
small code block as a function without defining a function with a name. This 
is where anonymous functions or lambda expressions come to play.
The word lambda originates from lambda calculus, which has played an 
important role in the development of modern computational theory and func­
tional programming. You are encouraged to search for lambda calculus on the 
internet for more details.
In Python, an anonymous function can be defined using the following 
syntax:
lambda <formal argument list> : <expression whose value is to be 
returned>
In the above syntax, a formal argument list is a list of variables separated 
by commas but without surrounding parentheses, and everything behind the 
colon takes the role of the code block in the regular function definition. But 
it must be a single expression whose value is to be returned by the lambda 
function without a keyword return.
The following is an example of a lambda function in Python that is used to 
construct an odd number from a given integer:
>>> lambda n: 2 * n + 1
<function <lambda> at 0x012CBD20>
>>>
Because an anonymous function is meant to have no name, the common use 
of such a function is to have it called directly when it is defined, as shown below:
	
Define and Use Functions	
309
 https://doi.org/10.15215/remix/9781998944088.01
>>> (lambda n: 2 * n + 1)(4)
9
Note that a pair of parentheses encloses the entire lambda expression to 
signify the end of the lambda expression.
A lambda expression can also have two or more formal arguments, as shown 
below:
>>> (lambda x, y: x + y)(3, 5)
8
In the example above, we first defined a lambda function within a pair of paren­
theses, then applied it to a list of two actual arguments within a pair of parentheses.
An anonymous function can even be defined to take a variable-­
length list 
of arguments, as shown in the following example:
>>> (lambda& * x: sum(x) * 3)(1, 2, 3, 4, 5)
15
Although an anonymous function is meant to have no name, that does not 
stop you from giving it a name, as shown in the next example:
>>> double = lambda x: 2 * x
We can then call the function with the name, as shown below:
>>> double(23)
46
Our next anonymous function takes two arguments and checks if one is a 
multiple of the other:
>>> is_multiple = lambda m, n: m % n == 0
>>> is_multiple(32, 4)
True
>>> is_multiple(32, 5)
False
The next section will show how lambda expressions can be used to program 
more effectively.
	310	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
6.5 Special Functions: Mapping, Filtering, and 
Reducing
As mentioned, Python treats everything as objects, including functions, which 
can be accessed in the same way as ordinary objects. The following is an example:
>>> f_objects = [abs, len, open]   # the list has three 
functions as its members
>>> f_objects[0](-­
2)   # f_objects[0] refers to the first 
item in the list, which is built-­
in function abs
12
>>> f_objects[1](f_objects)   # f_objects[1] refers to the 
second item in the list, which is built-­
in function len
3
This has provided programmers with great possibilities. For example, 
Python has three special built-­
in functions that can take other functions as 
arguments and apply them to a list. These special functions include mapping, 
filtering, and reducing.
Mapping
It is easier to explain what mapping does with a code example:
>>> integers = [-­
12, 32, -­
67, -­
78, -­
90, 88]   # this list 
has negative numbers
>>> list(map(abs, integers))   # this maps the function 
abs to each integer in the list
[12, 32, 67, 78, 90, 88]
Note that abs() has been applied to every member of the list.
Basically, the map function can apply any function to as many lists as 
required for its arguments. The following is an example:
>>> def sum(a, b):   # this function requires two 
arguments
… return a + b
…
>>> list(map(sum, [1, 2, 3], [5,8,9]))   # this maps the 
sum function to two lists for the two arguments
[6, 10, 12]
	
Define and Use Functions	
311
 https://doi.org/10.15215/remix/9781998944088.01
Given what you have already learned about anonymous functions, you can 
generate a list of odd numbers neatly, as follows:
>>> list(map(lambda n: 2 * n + 1, range(10)))
[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
Similarly, we can generate all multiples of a number k, such as 3 in the 
example below:
>>> list(map(lambda n: 3 * n, range(10)))
[0, 3, 6, 9, 12, 15, 18, 21, 24, 27]
Filtering
The filtering function takes the same form as the mapping function but is used 
to extract items from the iterable that satisfy the Boolean filtering condition at 
hand. The following sample code keeps only even numbers in the generated list:
>>> def even(n):
… return n % 2 == 0   # if it can be divided by 2, then 
return true; return false otherwise
…
>>> list(filter(even, range(10)))   # filter applies to 
each even number and keeps only some
[0, 2, 4, 6, 8]
The code above can be neatly rewritten by using a lambda expression, as 
follows:
>>> list(filter(lambda n: n % 2 == 0, range(10)))
[0, 2, 4, 6, 8]
The filter function may play an important role in selecting items from a 
given list based on certain criteria, as shown in the following example:
>>> st = "The filter function may play an important role 
in selecting words from a given text. In the following 
example, only words that contain the letter o are selected"
>>> list(filter(lambda s: 'o' in s, st.split()))
['function', 'important', 'role', 'words', 'from', 
'following', 'only', 'words', 'contains', 'o']
Note that only the words that include the letter o are selected.
	312	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Reducing
The reduce function is not a built-­
in function but defined in the functools mod­
ule. It takes the same form as the mapping and filtering functions but applies 
the function to items in the iterable progressively until the list is exhausted 
and reduced to a single value or object, as shown in the following example in 
JupyterLab:
In [ ]:
def pow(m, n):
  return m ** n
from functools import reduce
reduce(pow, range(2, 6))   # equal to pow(pow(pow(2, 
3), 4), 5)
Out [ ]:
1152921504606846976
We can recode the above operation with the lambda expression (anonymous 
function) we learned in the previous section, as shown below:
In [ ]:
reduce(lambda n, m: n ** m, range(2, 6))
Out [ ]:
1152921504606846976
As seen from the examples above, a lambda expression becomes handy 
when you use a function only once and the function is simple enough to be 
written with an expression.
6.6 Generators: Turning a Function into a Generator 
of Iterables
As you have seen, sequences (including lists, tuples, and strings) are an import­
ant way of organizing data. In addition to having a relatively static list accessible 
through a variable, Python also provides a means to make a generator that can 
generate members of a sequence dynamically.
Assume we want to find out a sequence of perfect numbers within a 
given range. Instead of finding all perfect numbers within the range and 
returning them in a list, we can define a generator of perfect numbers 
using the yield statement in place of the return statement, as shown in the 
following example:
	
Define and Use Functions	
313
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
def isPerfect(n):
  factor = [1]
  for j in range(2, (n // 2) + 1):
    if n % j == 0:
      factor.append(j)
    if n == sum(factor):
      return [True, factor]
    else:
      return [False, []]
def perfectGenerator(m = 100):
  for i in range(m):
    testResult = isPerfect(i)
    if testResult[0]:
      yield [i, testResult[1]]
myPerfects = perfectGenerator(10000)
print(myPerfects)
Out [ ]:
<generator object perfectGenerator at 0x00000191402373C8>
As we can see, instead of returning a list of all the perfect numbers and 
factors within the given range, the function actually returned a generator.
To get the next perfect number in the generator, we use the built-­
in function 
next, as shown below:
In [ ]:
print(next(myPerfects))
print(next(myPerfects))
print(next(myPerfects))
print(next(myPerfects))
print(next(myPerfects))
Out [ ]:
[1, [1]]
[6, [1, 2, 3]]
[28, [1, 2, 4, 7, 14]]
[496, [1, 2, 4, 8, 16, 31, 62, 124, 248]]
[8128, [1, 2, 4, 8, 16, 32, 64, 127, 254, 508, 1016, 2032, 4064]]
Note that in the output above, we found five perfect numbers between 1 and 
10000. Output on each line is a list, and the first member is a perfect number, 
whereas the second member contains a list of its factors (whose sum is equal 
to the first number).
Recall that we have used the built-­
in function range() with for loops. We can 
use user-­
defined generators with for loops as well, as shown below:
	314	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
myPerfects = perfectGenerator(10000)
for p in myPerfects:
  print(p)
Out [ ]:
[1, [1]]
[6, [1, 2, 3]]
[28, [1, 2, 4, 7, 14]]
[496, [1, 2, 4, 8, 16, 31, 62, 124, 248]]
[8128, [1, 2, 4, 8, 16, 32, 64, 127, 254, 508, 1016, 2032, 4064]]
You may wonder why we need generators instead of returning a list of 
objects. The reason is for performance in terms of both speed and memory 
usage. The next two examples show the difference in speed between a generator 
and a normal function returning a list of perfect numbers.
In [ ]:
import time   # time module for time and timing 
related functions
from memory_profiler import profile   # a module 
for profiling memory usage
def isPerfect(n):
  factor = [1]
  for j in range(2, (n // 2) + 1):
    if n % j == 0:
      factor.append(j)
    if n == sum(factor):
      return [True, factor]
    else:
      return [False, []]
def getAllPerfects(n = 10):
  perfects=[]
  for i in range(1, n + 1):
    testResult = isPerfect(i)
    if testResult[0]:
      perfects.append((i, testResult[1]))
  return perfects
t0 = time.process_time()
perfectNumbers = getAllPerfects(10000)
t1 = time.process_time()
print(f"{t1 -­
 t0} seconds are used to get a list 
of perfect numbers")
Out [ ]:
1.1875 seconds are used to get a list of perfect numbers
	
Define and Use Functions	
315
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
import time   # time module for time and timing related 
functions
from memory_profiler import profile   # a module for 
profiling memory usage
def isPerfect(n):
  factor = [1]
  for j in range(2, (n // 2) + 1):
    if n % j == 0:
      factor.append(j)
    if n == sum(factor):
      return [True, factor]
    else:
      return [False, []]
def perfectGenerator(m = 100):
  for i in range(m):
    testResult = isPerfect(i)
    if testResult[0]:
      yield [i, testResult[1]]
t0 = time.process_time()
myPerfects = perfectGenerator(10000)
t1 = time.process_time()
print(f"{t1 -­
 t0} seconds are used to get a generator 
of perfect numbers")
Out [ ]:
0.0 seconds are used to get a generator of perfect numbers
The first code sample is to find a list of perfect numbers within a given 
range using a normal function to return a list of perfect numbers, whereas the 
second code sample uses a generator instead. As you can see, to get a generator 
of perfect numbers took no time (0.0 seconds), whereas using a function to 
return a list of perfect numbers took 1.1875 seconds.
The gain from returning a generator instead of a complete list from a func­
tion is even more obvious in terms of memory usage, because a list would 
usually take a bigger chunk of computer memory, which increases drastically 
along with the growth of the list, whereas for a list generator, the memory 
usage is determined by the coding of the function and will not change. In our 
examples above, the generator that generates perfect numbers from 1 to 100000 
has almost the same number of lines of code as the function that produces a list 
of perfect numbers in the same range, but the function consumes much more 
memory than the generator because of the use of list. To get a sense of how 
much memory would be consumed by a bigger list, see the following example:
	316	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
import sys
print(f"The size of a list containing numbers from 0 to 
100 is {sys.getsizeof(list(range(100)))}Bytes")
print(f"The size of list containing numbers from 0 to 
1000 is {sys.getsizeof(list(range(1000)))}Bytes")
print(f"The size of list containing numbers from 0 to 
10000 is {sys.getsizeof(list(range(10000)))}Bytes")
Out [ ]:
The size of a list containing numbers from 0 to 100 is 1008Bytes
The size of a list containing numbers from 0 to 1000 is 9112Bytes
The size of a list containing numbers from 0 to 10000 is 90112Bytes
As you can see, a simple list containing integer numbers from 0 to 10000 
takes up almost 90KB of memory.
6.7 Closures: Turning a Function into a Closure
In Python and some other programming languages such as JavaScript, closures 
are the result of a nested function—­
that is, one function that is defined inside 
another—­
as shown in the following example:
In [ ]:
def outer(greeting):
    print('Good morning!')
    def inner(msg):
        print(msg)
    inner(greeting)
outer('Good day!')
Out [ ]:
Good morning!
Good day!
In the example above, the outer function can also return the inner function 
with the parameter list as a first-­
order object, as shown below:
In [ ]:
def outer():
    greeting = 'Good morning,'
    def greet(who):
        print(greeting, who)
    return greet
cl = outer() # cl will hold function greet
name = input('What is your name?')
cl(name) # local greeting in outer still attached
Out [ ]:
Good morning, Joe
The output was produced when you input Joe for the name.
	
Define and Use Functions	
317
 https://doi.org/10.15215/remix/9781998944088.01
What has been returned from call of outer() is a function object. However, 
because of the way the function is defined and returned, the value of the vari­
able greeting, defined locally within the outer function, has been attached to 

the inner function object. This is called closure—­
the binding of certain data 

to a function without actually executing the function.
6.8 Decorators: Using Function as a Decorator 
in Python
Python has many powerful means and program constructs that you can use to 
solve problems and get the jobs done. Decorators are one of them.
In Python, a decorator can be a function, but it is used to modify the func­
tionality of other functions. Suppose we want to keep a log of the time a function 
is called, the parameters passed, and the time the call took to run. A decorator 
function can be defined as follows:
In [ ]:
import time # import the time module
# define a function as a decorator
def calllog(function_logged):   # calllog function will 
be used as a high order function and decorator
    def wrapper_function(*args, **kwargs):
        t0 = time.asctime()
        t1 = time.time()   # time started in seconds as 
a float number
    func_handle = function_logged(*args, **kwargs)
        t2 = time.time()   # time ended in seconds as a 
float number
        call_args = ''
        if args:
            call_args += str(args)
    if kwargs:
            call_args += str(kwargs)
        with open("calllog.txt", "w") as logs:
            log_str = f"Call to {function_logged.__
name__}{call_args}\n"
            log_str += f"was made at {t0}, taking {t2 
-­
 t1} \n"
            logs.write(log_str)
            print(f"Logging string written to file 
is:\n {log_str}")
    return func_handle
  return wrapper_function
@calllog   # calllog is used as decorator
def real_function(message = "Operation",m=2, n=3):
  print(message,'\n', f'{m}**{n}=\n', m**n)
real_function(message="Operation m to the power of n", 
m=123456789, n=199)
	318	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Out [ ]:
Operation m to the power of n
123456789**199=
16273480830928460132417950594596569558877352891957597527186
5178655668529042309237619989258306106107470796567847777669
4979578642000466712019740418952547246055989565285203342320
1635987631993944618743752213013724549514037908343831333069
3339877194631448240511529289603414404095019761182651422306
3215694559633025394947655131573832171589906384161873332226
4922481325525627831284047397626329561279283208434591744868
1553425787599413514884427065211671134509510806599010879043
4049581161589934723326683225949480983457824265493831766741
8414495414087226417784891667194654738380143539652423296727
8397336246191565592631874430342301391129941032341482155018
4853648462203555248458520671193824561733068153104155547783
9087024586408999843855597754908302821728495386842518994478
2520828778542782626615331157474809673798175226065273267575
2489133426820060935499575223584065751090015735421676999145
0814755577140900813045111393260168223478200641944154844292
6373709258668550718362777098506123158504564363626666999333
4013946685549557175420965888062340558027537152951783153293
2230219978406047270164537039827469092224210875077720641113
1334391598657540208216549131267004257438048558678889138741
5395857275045805521942026082836745137076008067859592825225
6417990024617027365928579573806527191486578290433390603117
7020338769884454165407411399431838155103129975186500016431
8853234471269192633863320874318241295949565851371992467870
9745114665575426890554943460193024792121207815114065877782
2152688458823924816621267882515972976339888586466699424919
8618153756380986737526890055365847162354423404796566823762
41467062062297627346560365999071034663278109
Logging string written to file is:
Call to real_function{'message': 'Operation m to the power of n', 'm': 
123456789, 'n': 199}
was made at Mon Mar 13 12:07:27 2023, taking 0.0
As shown above, the log written to the calllog.txt file is as follows:
Call to real_function{'message': 'Operation m to the power of n', 'm': 
123456789, 'n': 199}
was made at Mon Mar 13 12:07:27 2023, taking 0.0
Our next example is to use the calllog function as a decorator, as defined 
above, to record the time it takes to find all perfect numbers in a given range, 
the example we have worked on in Chapter 4.
This time, since we have learned how to define and use functions, we will 
define functions for factorization and perfect number testing, respectively, so 
that we can log the time on calls to the function. The code is as follows:
	
Define and Use Functions	
319
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
def factors(n): # function for finding factors of a given 
number
    # the function will return a list of factors for n
    factor_list = [1] # make a list with 1 as a single element
    for f in range(2,n): # start from 2, with n as excluded 
from factors
        if n%f == 0: # f is a factor of n
            if not f in factor_list:
                factor_list.append(f)
    # now we have a list of factors for n
    return factor_list
# function to find all perfect numbers in a given range
def perfect_numbers(a, b):
    if a>b: # then we need to swap a and b
        c = a; a = b; b = c
    perfect_list = [] # make an empty list ready to hold all 
perfect numbers
    for n in range(a, b+1): # b is included
        factor_list = factors(n)
        if n == sum(factor_list):
            perfect_list.append([n, factor_list]) # keep 
factors too for checking
    return perfect_list
# now the main
@calllog   # calllog is used as a decorator
def do_perfect():
    success = False
    # use a while loop to keep asking for inputs until success 
is True
    while not success:
        num1 = input("Enter the first number: ")
        num2 = input("Enter the second number: ")
        # try to convert the inputs to floats and divide them
            try:
            a, b = int(num1), int(num2)
            # set success to True if no error has occurred by 
now
            success = True
            perfect_list = perfect_numbers(a, b)
        # now we have found all the perfect numbers in the 
range
            print(f"Perfect numbers found between {a} and 
{b}:")
            for n in perfect_list:
                print(n, end=" ")
        # handle the possible errors and exceptions
        except ValueError:
            print("Invalid input. Please enter numbers only.")
        except ZeroDivisionError:
            print("Cannot divide by zero. Please enter a 
nonzero number.")
        except Exception as e:
            print(f"An unexpected error occurred: {e}")
    # end of do_perfect
do_perfect()
	320	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Out [ ]:
Perfect numbers found between 3 and 10000:
[6, [1, 2, 3]]
[28, [1, 2, 4, 7, 14]]
[496, [1, 2, 4, 8, 16, 31, 62, 124, 248]]
[8128, [1, 2, 4, 8, 16, 32, 64, 127, 254, 508, 1016, 
2032, 4064]] Logging string written to file is:
Call to do_perfect
was made at Mon Mar 13 13:18:15 2023, taking 
5.2627036571502686
As shown above, the log written to the calllog.txt is
Call to do_perfect
was made at Mon Mar 13 13:18:15 2023, taking 5.2627036571502686
As you can see, although a decorated function is called in the same way as other 
functions, a lot of other things can be done through a decorator during the call.
It is also worth noting that perfect numbers are very rare. Between 3 and 
10000, there are only four perfect numbers, and it took a little over 5 seconds to 
find them. Tested on the same machine, it took more than 100 second to look 
for all the perfect numbers between 3 and 100000, and there are no perfect 
numbers between 10000 and 100000.
6.9 Properties of Functions
Functions are important building blocks of programs in all programming lan­
guages. In Python, a function will have the following properties, and most of 
them can be written by the programmer of the function.
__DOC__
This holds the function’s docstring, written by the programmer, or None if no 
docstring is written by the coder. The docstring will show up when the help() 
function is called on a function, though help() will also show some standard 
information even if no docstring is available.
__NAME__
This contains the name of the function.
__QUALNAME__
This contains the qualified name of the function and is new to Python 3.3 and 
later versions. By qualified name, we mean the name that includes the path 
	
Define and Use Functions	
321
 https://doi.org/10.15215/remix/9781998944088.01
leading to the location where the function is defined. For example, a function F 

can be a method defined in a class C, which is defined in a module M, in which 
case the qualified name will be M.C.F.
__MODULE__
This stores the name of the module in which the function was defined. It con­
tains None if module info is unavailable.
__DEFAULTS__
This stores a tuple containing default argument values for those arguments that 
have defaults or stores None if no arguments have a default value.
__CODE__
This contains the actual code object representing the compiled function body.
__GLOBALS__
This contains a reference to the dictionary that holds the function’s global 
variables, the global namespace of the module in which the function was 
defined. It is a read-­
only function automatically generated by Python Virtual 
Machine (PVM).
__DICT__
This stores a dictionary describing names of attributes and their values in the 
namespace of the function. In Python, a namespace is a mapping from names 
to objects and is implemented as a Python dictionary.
__CLOSURE__
This stores a tuple of cells that contain bindings for the function’s free variables. 
Each cell has an attribute called cell_contents from which a cell’s value can be 
retrieved. It is automatically generated by PVM.
__ANNOTATIONS__
This stores a dictionary containing annotations of parameters. The keys of the 
dictionary are the parameter names, and return as key for the return annota­
tion, if provided, and the values of the dictionary are the expected data type of 
the parameters as well as the expected data type of the object to be returned 
by the function.
__KWDEFAULTS__
This stores a dictionary containing default values for keyword-­
only parameters.
	322	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Chapter Summary
•	 Functions are important building blocks of programs in almost all 
programming languages.
•	 Different languages use different keywords to signify the definition of 
a function. Python uses def to start the definition of a function (and 
method within a class definition).
•	 In Python, the definition of one function can contain the definition of 
other function or functions.
•	 A function can have positional arguments, variable-­
length lists of 
arguments, and keyword arguments.
•	 When calling a function, the parameters for positional arguments must 
come first, followed by variable-­
length lists of arguments. Keyword 
arguments come last.
•	 A recursive function is a function that calls itself within its definition.
•	 Anonymous functions are functions without a name. They begin 
with the keyword lambda. Anonymous functions are useful when the 
function is only used once.
•	 Mapping, filtering, and reducing are special functions that can used 
to apply a function, including an anonymous function, to a list of 
parameters.
•	 Mapping applies a function to each item of a list.
•	 Filtering applies some criteria specified in a Boolean function to a list 
to filter out the items that do not meet the criteria.
•	 Reducing sequentially applies a function to the members of a list and 
reduces the list to a single member.
•	 Functions are often used to process and return the results of 
information processing using the return statement.
•	 In a function definition, the return statement can be replaced with the 
yield statement to turn the function into a generator of a sequence.
Note that a function cannot be turned into a generator by simply 
replacing the return statement with a yield statement.
Exercises
	
1.	 Python has a built-­
in input function for taking input from users. 
However, it treats everything from the user as a string. For this 
exercise, define a function named getInteger, which takes one 
optional argument as a prompt and gets and returns an integer from 
the user.
	
Define and Use Functions	
323
 https://doi.org/10.15215/remix/9781998944088.01
	
2.	 Define a function that has one argument, n, that will take a natural 
number and return the product of all the odd numbers between 1 and n.
	
3.	 Define a function that has one argument, n, that will take an integer 
and return the product of all the odd numbers between 1 and n, or 
between n and −1 if n is a negative integer, or that will return None if n 
is not an integer.
	
4.	 The Fibonacci sequence (Fn) is well-­
known in mathematics, and is 
defined as follows:
F0 = 1, F1 = 1, Fn = Fn−1 + Fn−2
Define a recursive function that takes one argument, n, and 
calculates and returns the nth item (Fn) of the Fibonacci sequence.
	
5.	 Define a recursive function that takes one argument, n, and calculates 
and returns the entire list of all items from F0 to Fn, of the Fibonacci 
sequence.
	
6.	 Define a function that takes a variable-­
length list of numbers and 
returns the product of all these numbers.
Projects
	
1.	 Study the federal personal income tax rates for the current tax 
year and define a function that takes one argument as net taxable 
income and calculates and returns the total federal income tax due.
	
2.	 Study both the federal personal income tax rates and the provincial 
tax rates for your province for the current tax year. Define a function 
that takes one argument as net taxable income and calculate and 
return both total federal income tax due and total provincial tax due.
	
3.	 Modify the function defined for 6.6 by adding a keyword argument 
with the default value f or F to tell the function to calculate and return 
the federal tax due. If the argument passed to the keyword parameter 
is p or P, then provincial tax due should be calculated and returned. 
Test the modified function with different values passed to the keyword 
argument to make sure it works as expected.
	
4.	 The Tower of Hanoi is a mental game. It consists of three rods and N 
disks of different sizes that can move onto any rod one by one, but 
at no time is a bigger disk allowed to be on top of a smaller disk. The 
three rods are labelled A, B, and C. The game begins with all disks 
stack on rod A, and the goal is to move all the disks onto rod C. Write 
a recursive function that takes one argument as the number of disks 
initially on rod A and print out the moves to be taken in order to move 
	324	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
all the disks from A to C. Each move can be represented as i: Rs Rd, 
where i is 0, 1, 2…, Rs and Rd is A, B or C, but Rs and Rd cannot be the 
same. It means that at step i, take one disk from source rod Rs and 
slide it onto destination rod Rd. For example, if there are three disks 
on rod A, the moves will be as follows:
1: A  C, 2 : A  B, 3 : C  B, 4 : A  C, 5 : B  A, 6 : B  C, 7 : A  C
 https://doi.org/10.15215/remix/9781998944088.01
Chapter 7
Object-­
Oriented 
Programming with Python
This chapter introduces you to object-­
oriented programming, including how to 
define classes and how to use classes as a new data type to create new objects, 
and will show you how to use objects in programming. Programming for com­
puters essentially means modelling the world, or parts of it, for computers. 
In modern computing and programming, object-­
oriented programming is a 
very powerful means of thinking and modelling. In Python, everything can be 
treated as an object.
Learning Objectives
After completing this chapter, you should be able to
•	 explain object-­
oriented programming and list its advantages.
•	 define a new class to model objects in programming and software 
development.
•	 create and use objects and instances of classes in programming and 
system development.
•	 use subclasses and superclasses properly when defining and using 
classes.
•	 properly define and use public, private, and protected members of 
a class.
•	 correctly define and use class attributes.
•	 effectively define and use class methods and static methods when doing 
object-­
oriented programming.
•	 properly define and use dunder methods.
•	 use class as a decorator.
	326	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
•	 explain the built-­
in property function and use it to add an attribute 
or property to a class with or without explicit setter, getter, or deleter 
functions.
•	 use the property function as a decorator to turn a method into an attribute 
of a class, and declare explicitly the setter, getter, or deleter of the attribute.
7.1 Introduction to Object-­
Oriented Programming 
(OOP)
Object-­
oriented programming, including analysis and design, is a powerful 
methodology of thinking of how things are composed and work. The world 
is made of objects, each of which has certain attributes and contains smaller 
objects. What is specially offered by object-­
oriented analysis, design, and 
programming in a systematic and even scientific manner are abstraction, 
information hiding, and inheritance.
Abstraction
Abstraction is a very fundamental concept of object-­
oriented programming. The 
concept is rather simple. Because an object in the real word can be very com­
plicated, containing many parts and with many attributes, it would be practical 

to consider only those parts and attributes that are relevant to the programming 
tasks at hand. This simplified model of a real-­
world object is an abstraction of it.
Information Hiding or Data Encapsulation
The concept of information hiding is very simple and straightforward. There are 
two reasons for hiding certain kinds of information: one is to protect the infor­
mation, and the other is to make things easier and safer by hiding the details. 
An example of information hiding that you have already seen is defining and 
using functions. The code block of a function can be very lengthy and hard to 
understand. After a function is defined, however, a programmer only needs to 
know what the function does and how to use it, without considering the lengthy 
code block of how the function works.
In OOP, information hiding is further down within classes. Some OOP lan­
guages strictly limit direct access to class members (variables declared within 
a class), and all access must be done through the setter and getter methods. 
Python, however, has no such restriction, but you still need to remember the 
benefit of information hiding: avoiding direct access to the internal members 
of objects. Python also provides a way to hide, if you want to, by using double 
underscored names, such as __init__, __str__, and __repr__.
	
Object-­
Oriented Programming with Python	
327
 https://doi.org/10.15215/remix/9781998944088.01
Inheritance
Inheritance is a very important concept of object-­
oriented programming, 
and inheriting is an important mechanism in problem solving and system 
development with the object-­
oriented approach. The underlying philosophy 
of inheritance is how programmers describe and understand the world. Most 
often, things are categorized and put in a tree-­
like hierarchy with the root on 
the top, as shown in Figure 7-­
1 below. In such a tree-­
like hierarchy, the root 
of the tree is the most generic class or concept, and the leaves are the most 
specific and often refer to specific objects. From the root down to the leaves, 
nodes on a lower level will inherit the properties of all the connected nodes 
at higher levels.
Within such a hierarchy, it is more convenient to have a model that captures 
general attributes shared by desktop, laptop, and tablet computers than to 
have models capturing the specifics of desktop, laptop, and tablet computers, 
respectively, with these specific models inheriting the common attributes cap­
tured by the generic model for computers. In such a hierarchy, the computer is 
the superclass of the desktop, laptop, and tablet, whereas the desktop, laptop, 
and tablet are a subclass of the computer.
7.2 Defining and Using Classes in Python
Normally in OOP, a class would include some attributes and methods, as well 
as a constructor or initiator for creating instances of the class. However, com­
pared to other object-­
oriented programming languages, especially the earlier 
generations such as C++ and Java, Python provides some less-­
restricted ways 
of defining classes and instantiating objects.
In Python, a class can be easily created with only two lines of code, as 
shown below:
>>> class Computer:
…   pass
Computer
Figure 7-­
1: Illustration of class inheritance
	328	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
This defines a class named Computer containing no attribute and no 
method, though it automatically inherits all the attributes and methods of the 
generic object class in the built-­
in module of Python. As mentioned before, 
the pass statement is simply a placeholder for everything needed to com­
plete the class definition. We can use the help statement to see that the class 

has been created, as shown below:
>>> help(Computer)
Help on class Computer in module __main__:
 
class Computer(builtins.object)
| Data descriptors defined here:
|
| __dict__
|   dictionary for instance variables (if defined)
|
| __weakref__
|   list of weak references to the object (if defined)
The builtins.object is a built-­
in class of Python from which all classes auto­
matically inherit by default. In OOP term, the class that inherits from another 
class is called a subclass of the other class, while the class being inherited 

from is called a superclass.
Formally in Python, if you are defining a class that needs to inherit from 
another class, you can put the superclass(es) in a pair of parentheses, as shown 
in the following example:
>>> class PC(Computer):
…   pass   # the pass statement does nothing, but it 
completes the class definition
We can check the result using the help statement, as shown below:
>>> help(PC)
Help on class PC in module __main__:
 
class PC(Computer)
| Method resolution order:
|   PC
|   Computer
	
Object-­
Oriented Programming with Python	
329
 https://doi.org/10.15215/remix/9781998944088.01
|   builtins.object
|
| Data descriptors inherited from Computer:
|
| __dict__
|   dictionary for instance variables (if defined)
|
| __weakref__
|   list of weak references to the object (if defined)
This shows that the class PC has been created, which is a subclass of Computer.
Although the Computer class contains nothing in its original definition, we 
can create an instance of the class, add attributes to the instance, and manipu­
late the attributes using some built-­
in functions. For example, we can use the 
setattr function to add an attribute called CPU to an instance of the Computer 
class, as shown below:
>>> c = Computer()   # to create an instance of the 
Computer class
>>> setattr(c, 'CPU', 'Intel i6800')
>>> c.CPU
'Intel i6800'
In the above example, Computer() is the constructor of class Computer. In 
Python, X() will be automatically the constructor of class X, but it calls a special 
method named __init__, which can be defined within the class to instantiate 
instances of the class. In our simplest definition of class Computer, we did not 
define the __init__ method, but it has been automatically inherited from class 
builtins.object.
Now we can use special attribute __dict__ of instance c of class Computer 
to check the attribute and value of object c, as shown below:
>>> print(c.__dict__)
{'CPU': 'intel i6800'}
As you can see, the c object has an attribute called CPU and its value intel 
i6800.
In addition to setattr, Python has a number of built-­
in functions available 
for class and object manipulation. These built-­
in functions are summarized 
in Table 7-­
1.
	330	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Table 7-­
1: Built-­
in functions for class and object manipulation
Built-­
in function
Operation
Coding example
getattr(o, attr)
Return the value of 
object o's attribute 
attr, same as o.attr
>>> getattr(math, 'sqrt')
<built-­
in function sqrt>
>>> getattr(math, 'e')
2.718281828459045
hasattr(o, attr)
Test if object o has 
attribute attr; return 
True if it does
>>> hasattr(math, 'e')
True
>>> hasattr(math, 'sqrt')
True
setattr(o, a, v)
Set/add an attribute 
a to object o, and 
assign value v to the 
attribute
>>> class student:
…   pass
…
>>> s1 = student()
>>> setattr(s1, 'name', 
'John')
>>> s1.name
'John'
delattr(o, a)
Delete attribute a 
from object o
>>> delattr(s1, 'name')
>>> hasattr(s1, 'name')
False
isinstance(o, c)
Return true if o is an 
instance of class c 
or a subclass of c
>>> class student:
…   pass
…
>>> s1 = student()
>>> isinstance(s1, student)
True
issubclass()
Return true if class c 
is a subclass of C
>>> class 
graduate(student):
…   pass
…
>>> issubclass(graduate, 
student)
True
repr(o)
Return string 
representation of 
object o
>>> repr(graduate)
"<class '__main__.
graduate'>"
The rest of this section describes in detail how to define classes in Python—­
in 
particular, how to define attributes and methods in a class definition. Your jour­
ney to learn OOP begins with modelling a small world, shapes, which include 
the circle, rectangle, and triangle.
	
Object-­
Oriented Programming with Python	
331
 https://doi.org/10.15215/remix/9781998944088.01
First, define an abstract class called shape, as shown in Table 7-­
2.
Table 7-­
2: Example of class definition with overriding
Code sample in Python interactive mode
1
"""
2
Modelling the world of shapes. First Python app with 
OOP.
3
"""
4
5
class Shape:
6
  """We design an abstract class for shape."""
7
  def circumference(self):
8
    """Method to be overridden."""
9
    pass
10
11
def area(self):
12
"""Method to be overridden."""
13
pass
14
15
class Circle(Shape):
16
  def __init__(self, radius):   # two underscores on 
each side
17
    self.radius = radius
18
19
  def circumference(self):   # this overrides the 
method defined in Shape
20
    return self.radius * 2 * 3.14
21
22
  def area(self):   # this overrides that defined in 
Shape
23
    return self.radius ** 2 * 3.14
24
25
c1 = Circle(35)
26
print(f"A circle with a radius of {c1.radius} has an 
area of {c1.area()},")
27
print(f"and the circumference of the circle is {c1.
circumference()}")
Output
A circle with a radius of 35 has an area of 3846.5,
and the circumference of the circle is 219.8
In the example above, __init__ is a reserved name for a special method in 
a class definition. It is called when creating new objects of the class. Please 
remember, however, that you need to use the name of the class when creating 
new instances of the class, as shown on line 25 of the example above.
It may have been noted that “self” appears in the list of arguments when 
defining the __init__ method and other methods of the class, but it is ignored in 

	332	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
the calls of all these methods. There is no explanation as to why it is ignored. 
In the definitions of all these methods, “self” is used to refer to the instance of 
the class. It is the same as “this” in other OOP languages such as C++ and Java, 
though “this” doesn’t appear in the list of formal arguments of any method 
definition.
Another detail worth noting when defining classes in Python is that there 
can be no explicit definition of any of the attributes, as is the case in C++ or 
Java. Instead, attributes are introduced within the definition of the __init__ 
method by assignment statements or by using the built-­
in function setattr(o, 
a, v), which are all the attributes of the particular instance created by the 
constructor of the class. Function setattr(o, a, v) sets the value of attribute a 
of object o to n, if o has attribute a; if not, it will add attribute a to o, then set 
its value to v.
Next, we define a class for a rectangle, as shown in Table 7-­
3.
Table 7-­
3: Example of subclass definition
Code sample in Python interactive mode
1
"""
2
Modelling the world of shapes. First Python app 
with OOP.
3
"""
4
5
class Shape:
6
  """We design an abstract class for shape."""
7
  def circumference(self):
8
    """Method to be overridden"""
9
    pass
10
11
  def area(self):
12
    """Method to be overridden"""
13
    pass
14
15
class Rectangular(Shape):
16
  def __init__(self, length, width):
17
    self._length = length
18
    self._width = width
19
20
  def circumference(self):
21
    return (self._length + self._width) * 2
22
23
  def area(self):
24
    return self._length * self._width
25
26
  def is_square(self):
	
Object-­
Oriented Programming with Python	
333
 https://doi.org/10.15215/remix/9781998944088.01
27
    return self._width == self._length
28
29
rt1 = Rectangular(35, 56)
30
31
print(f"The circumference of the rectangle is 
{rt1.circumference()}, and")
32
print(f"the area is {rt1.area()}")
33
print(f"Is the rectangle a square? {rt1.
is_square()}")
Output of the 
program
The circumference of the rectangle is 182, and
the area is 1960
Is the rectangle a square? False
Note that class Rectangular not only has overridden two methods of 
Shape but has also defined a new method named is_square() to test if the 
rectangular is a square.
Inheritance: Subclass and Superclass
If you want to inherit from other base classes when defining a new class in 
Python, you need to add all the base classes to the list of inheritances enclosed 
in a pair of parentheses, as shown below:
class myClass(base_1, base_2, base_3):
  pass
The new class will inherit all the attributes and methods from base_1, 
base_2, and base_3 and override the methods defined in the base classes.
In Python, all classes are a subclass of the built-­
in base object class and 
inherit all the properties and methods of object, even if object is not explicitly 
included in the inheritance list. So the following two statements will have the 
same effects:
In [ ]:
class myClassA:
  pass
dir(myClassA)
Out [ ]:
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', 
'__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', 
'__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_
ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 
'__weakref__']
Table 7-­
3: Example of subclass definition (continued)
	334	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
class myClassB(object):
  pass
dir(myClassB)
Out [ ]:
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', 
'__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', 
'__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_
ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 
'__weakref__']
As you can see, myClassA and myClassB both inherit from the base class 
object. However, in the list, some of the dunder names such as __le__ and __ge__ 
inherited from base class object are merely wrapper descriptors. If you want to 
make real use of these wrapper descriptors in your class, you will need to over­
ride them. Some inherited dunder methods can be used, but the values returned 
are not so useful. In particular, you will need to override the dunder methods 
__init__ __str__, and __repr__. The method __init__ is a dunder method used 

as constructor called internally by PVM whenever a new instance of a class needs 
to be created. The method __str__ is a dunder method called internally when­
ever an object of a class needs to be converted to a string, such as for printout. 
Finally, __repr__ is a dunder method called internally when an object needs to be 
converted to a representation for serialization—­
a process that converts a Python 
object into a byte stream that can be stored or transmitted.
Public, Private, and Protected Members of a Class
People familiar with other OO programming languages such as C++ and Java 
may be wondering how to declare and use public, private, and protected attrib­
utes in Python, as they are used to doing in other OO programming languages. 
Python, however, doesn’t differentiate attributes between public, private, and 
protected members. Instead, Python treats all attributes of a class as public. 
It is up to the programmers to decide whether a member should be public, 
private, or protected. To ensure that everyone reading the code understands 
the intention of the original coder/programmer, Python has a convention for 
naming protected members, private members, and public members: a name 
with a leading underscore _ is a protected member of the class in which it is 
defined, a name with a double underscore __ is a private member of the class 
in which it is defined, and all other names will be public.
According to the common principles of object-­
oriented programming, 
public members of a class can be seen and accessed from outside of the class 
or the instance of the class; protected members of a class can only be seen 
	
Object-­
Oriented Programming with Python	
335
 https://doi.org/10.15215/remix/9781998944088.01
and accessible within the class or a subclass of the class; private members can 
only be accessed within the class. In Python, however, the rule for protected 
members is not strictly enforced. As such, the following code will not raise 
any error or exception.
In [ ]:
class Student:
  def __init__(self, firstname, lastname):
    self._firstname = firstname
    self._lastname = lastname
s0 = Student('Jim', 'Carte')
print(s0._firstname, s0._lastname)
Out [ ]:
Jim Carte
In our example about shapes, _width and _length are protected attributes 
of the class, which should only be accessible within the class or its subclasses 
and should be hidden from the outside.
In contrast, the rule on private members, those with names prefixed with 
a double underscore __, is strictly enforced in Python. So if we change first­
name and lastname to private members, it will raise exceptions, as shown in 
the following example:
In [ ]:
class Student:
  def __init__(self, firstname, lastname):
    self.__firstname = firstname
    self.__lastname = lastname
s0 = Student('Jim', 'Carte')
setattr(Student, '_firstname', 'Richard')
print(s0.__firstname, s0.__lastname)
Out [ ]:
AttributeError Traceback (most recent call last)
<ipython-­
input-­
5-­
87cd9bc7801e> in <module>
  6 s0 = Student('Jim', 'Carte')
  7 setattr(Student, '_firstname', 'Richard')
-­
-­
-­
-­
> 8 print(s0.__firstname, s0.__lastname)
AttributeError: 'Student' object has no attribute '__firstname'
If you want to access the private members of a class from outside, the built-­
in 
functions setattr and getattr can be used to access both private and protected 
members of a class or its instance, as shown below:
	336	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
class Student:
  def __init__(self, firstname, lastname):
    self.__firstname = firstname
    self.__lastname = lastname
s0 = Student('Jim', 'Carte')
setattr(s0, '__firstname', 'Richard')
setattr(s0, '__lastname', 'Selot')
print(getattr(s0, '__firstname'), getattr(s0, '__lastname'))
Out [ ]:
Richard Selot
Class Methods
As we have seen, in Python, special method __init__ is used as a constructor 
of the class. People familiar with C++ or Java might be wondering if __init__ 
can be overloaded or defined multiple times in Python to make multiple con­
structors, because a class in C++ and Java can have two or more constructors 
with different signature. In Python, however, a class cannot have more than 
one __init__ effectively defined. If you define two or more __init__ within a 
class definition, only the last one will take effect.
So how can you create an instance of a class differently in Python if there 
can be only one constructor, the special __init__ method, in a class definition? 
The solution is to use the class method, as shown in the next example:
In [ ]:
class Graduate:
  def __init__(self, fullname):
    firstname, lastname = fullname.split(' ')
    self.firstname = firstname
    self.lastname = lastname
@classmethod # this decorator declaires a class method
def newGraduate(cls, firstname, lastname): # cls as 1st
    return cls(f'{firstname} {lastname}') # return an 
object
def __str__(self): # normal method
    return f'{self.firstname} {self.lastname}'
g0 = Graduate('James Gord') # __init__ is called to 
construct a new object
g1 = Graduate.newGraduate('John', 'Doe')
# newGraduate() is called to create a new object
print(g0) # __str__ is called to convert the object to 
a string
print(g1) # __str__ is called to convert the object to 
a string
Out [ ]:
James Gord
John Doe
	
Object-­
Oriented Programming with Python	
337
 https://doi.org/10.15215/remix/9781998944088.01
In the example above, decorator @classmethod is used to declare that 
method newGraduate() is a class method, which means that the first param­
eter refers to the class instead of an instance of the class, and the method is 
bound to the class and can be called through the class. A class method can be 

used to directly modify the structure of the class. For example, we can have a 

class method for Graduate class that sets the value of the class attribute 
at the beginning of a new year, say, 20210101. In this particular example 
above, however, class method newGraduate() is used as an alternate con­
structor of class Graduate, which takes first name and last name separately to 

instantiate an instance of Graduate.
When defining a class method, it is a convention to use cls as the name 
of the first parameter to refer to the class. Technically, however, it can be 
anything unique in the scope of a class definition, as long as you know it 
refers to the class. This is similar to “self” in definitions of regular methods, 
which is only the conventional name referring to the instance itself being 
instantiated.
Static Methods
Similar to the class method of a class, a static method can be called directly 
through the class. The difference is that in the definition of a static method, no 
parameter refers to the class nor to the instance itself. Its usefulness may be 
demonstrated by the example below, where we define a class called Convertor, 
and within the class definition, we define a number of static methods, each of 
which convert values from one unit to another:
In [ ]:
class Convertor:
  @staticmethod
  def kg2lb(w):
    return w * 2.20462
  @staticmethod
  def lb2kb(w):
    return w/2.20462
  @staticmethod
  def metre2feet(l):
    return l * 3.28084
  @staticmethod
  def feet2metre(l):
    return l / 3.28084
	338	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
  @staticmethod
  def C2F(d):
    return (d * 9 / 5) + 32
  @staticmethod
  def F2C(d):
    return (d -­
 32) * 5 / 9
  @staticmethod
  def acr2hec(a):
    return a * 0.404686
  @staticmethod
  def hec2arc(a):
    return a / 0.404686
print(Convertor.kg2lb(123))
print(Convertor.C2F(21))
Out [ ]:
271.16826
69.8
As you can see from the above example, the static methods can be called dir­
ectly through the class Convertor, without an instance. Defining a static method 
within a class is a way to add utility functions to the class so that it can be used 
without instantiating an object.
Class Attributes
As previously mentioned, in Python, you can define a class without explicitly 
declaring attributes of the class. However, Python does allow the explicit dec­
laration of attributes within a class definition. These attributes are called class 
attributes. Explicit declaration of an attribute within a class definition means 
that the attribute is declared outside of the __init__ method. In the following 
example, student_id is declared as a class attribute.
In [ ]:
class Graduate:
  student_id = 20201195 # student_id is a class 
attribute
  def __init__(self, fullname):
# self refers to the instance in normal method
    firstname, lastname = fullname.split(' ')
    self.f_name = firstname
    self.l_name = lastname
    self.__class__.student_id += 1
# self.__class__.student_id must be used to
# refer class attribute
	
Object-­
Oriented Programming with Python	
339
 https://doi.org/10.15215/remix/9781998944088.01
  @classmethod   # decorator
  def newGraduate(cls, firstname, lastname):
# cls refers to the class
    return cls(f'{firstname} {lastname}')
  def __str__(self):
    return f'{self.f_name} {self.l_name}, {self.
student_id}'
g0 = Graduate('James Gord')
print(g0)
# newGraduate() is called from class Graduate
g1 = Graduate.newGraduate('John', 'Doodle')
print(g1)
Out [ ]:
James Gord, 20201196
John Doodle, 20201197
From this example, you can see how a class attribute is used and shared 
among all the instances of the class. You can create student_id as a class attrib­
ute to dynamically track the student IDs allocated to new students—­
a new 
instance of the class Graduate. It starts from 20201195 and increases by one 
every time a new student is enrolled.
Note the dunder name __class__ used in the example. In Python, __class__ 
refers to the class of an object. So in the example above, self.__class__ refers to 
the class of object self—­
that is, Graduate. If you do not have __class__ between 
self and student_id but simply use self.student_id, student_id would become 
an attribute of each instance of the class, different from the class attribute, as 
demonstrated in the following example:
In [ ]:
class Graduate:
  student_id = 20201195
  def __init__(self, fullname):
    firstname, lastname = fullname.split(' ')
    self.f_name = firstname
    self.l_name = lastname
    self.student_id += 1
# self.student_id is an attribute of an individual object
  def __str__(self):   # self refers to the instance/
object
    return f'{self.f_name} {self.l_name}, {self.
student_id}'
g0 = Graduate('James Gord')
print(g0)
print(f'class attr student_id = {g0.__class__.student_id}')
g1 = Graduate('John Doodle')
print(g1)
Out [ ]:
James Gord, 20201196
class attribute student_id = 20201195
John Doodle, 20201196
	340	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
As you can see from the example above, although value 20201195 of 
class attribute student_id is used to calculate the student_id (20201195 
+ 1) when instantiating each instance of the class, the result 20201196 has 
no effect on the class attribute whose value remains to be 20201195. How 
did that work? Remember that assignment self.student_id += 1 is short for 

self.student_id = self.student_id. In this example, self.student_id on the right 
side of the assignment statement is resolved to be the class attribute according 
to the rule, whereas self.student_id on the left side of the assignment statement 
is an attribute of the object being instantiated. That is, the two self.student_id 
are two different variables.
Class attributes have different behaviours from static attributes in C++ or 
Java, although they do have certain things in common. In Python, class attrib­
utes are shared among all the objects of the class and can also be accessed 
directly from the class, without an instance of the class, as shown above.
7.3 Advanced Topics in OOP with Python
The previous section showed how classes can be defined and used in prob­
lem solving and system development. With what you learned in the previous 
section, you can certainly solve some problems in an object-­
oriented fashion. 
To be a good OOP programmer and system developer, it is necessary to learn 
at least some of the advanced features offered in Python for object-­
oriented 
programming.
Dunder Methods in Class Definition
Python has a list of names reserved for some special methods called dunder 
methods or magic methods. These special names have two prefix and suffix 
underscores in the name. The word dunder is short for “double under (under­
scores).” Most of these dunder methods are used for operator overloading. 
Examples of the dunder/magic methods that can be used for overloading 
operators are __add__ for addition, __sub__ for subtraction, __mul__ for multi­
plication, and __div__ for division.
Some dunder methods have specific meanings and effects when overloaded 
(defined in a user-­
defined class). These dunder methods include __init__, 
__new__, __call__, __len__, __repr__, __str__, and __getitem__.
In the previous section you saw how __init__ method is used as a constructor 
of class. The following sheds some light on the others.
	
Object-­
Oriented Programming with Python	
341
 https://doi.org/10.15215/remix/9781998944088.01
__CALL__
Dunder method __call__ can be used to make an object, an instance of class, 
callable, like a function. In the following example, a class is defined as Home, 
which has two attributes: size and value. In addition to __init__ as a con­
structor, a dunder function __call__ is defined, which turns object h1, an 
instance of class Home, into a callable function.
In [ ]:
class Home():
  def __init__(self, size, value):
    self.size = size
    self.value = value
  def __call__(self, check='average'):   # return the 
size, or value, or average
    if check == 'size':
      return self.size
    elif check == 'value':
      return self.value
    else:
      return self.value/self.size
h1 = Home(3270, 986500)
print(h1())   # using default value for the keyword 
argument
print(h1(check='size'))   # check the size of the home
print(h1(check='value'))   # check the value of the 
home
Out [ ]:
301.68195718654437
3270
986500
What can be done through dunder method __call__ can also be done through a 
normal method, say checking. The obvious benefit of using the dunder method 
__call__ is cleaner and neater code.
__NEW__
Dunder method __new__ is a method already defined in the object base class. It 
can be overridden to do something extra before the creation of a new instance 
of a class. Dunder method __ new__ itself doesn’t create or initialize an object 
for a class. Instead, it can check, for example, if a new object can be created. 
If the answer is yes, then it will call __init__ to do the actual work of creation 
and initialization, as shown in the following example:
	342	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
class TravelPlan():
  _places = dict()
  _step = 0
  def __new__(cls, newPlace):
    if newPlace in TravelPlan._places.values():
      print(f"{newPlace} is already in the plan!")
      return newPlace
    else:
      return super(TravelPlan, cls).__new__(cls)
  def __init__(self, newPlace):
    TravelPlan._places[TravelPlan._step] = newPlace
    print(f'{TravelPlan._places[TravelPlan._step]} is 
added.')
    TravelPlan._step += 1
  @staticmethod
  def printPlan():
    for pl in TravelPlan._places:
      print(f'Stop {pl + 1}: {TravelPlan._places[pl]}')
TravelPlan('Calgary')
TravelPlan('Toronto')
TravelPlan('Calgary')
TravelPlan.printPlan()
Out [ ]:
Calgary is added.
Toronto is added.
Calgary is already in the plan!
Stop 1: Calgary
Stop 2: Toronto
The example above makes a travel planning system by making a list of 
places to be visited. The __new__ method is defined to control the addition 

of a new city to the list. It checks whether the city has already been added to 
the plan and will not add the city if it is already on the list.
Note that we also defined and used two protected class attributes in the def­
inition of class TravelPlan. One is a dictionary storing the places in the plan and 
their order. We also used a static method so we can print out the entire plan when 
it is needed. Because the class attributes are shared among the instances of the 
class, changes to the class attributes will be retained, and at any time before 

the application is stopped, one can use the static method to print out the plan.
__STR__
Dunder method __str__can be used to implement the string representation of 
objects for a class so that it can be printed out by using the print statement. 
The method will be invoked when str() function is called to convert an object 

	
Object-­
Oriented Programming with Python	
343
 https://doi.org/10.15215/remix/9781998944088.01
of the class to a string. In our definition of class Graduate in our earlier example, 
the __str__ has been implemented to just return the full name of a student. 
You may, of course, choose to return whatever string you think would better 
represent the object for a given purpose.
__LEN__
Dunder method __len__ can be used to return the length of an object for a class. 
It is invoked when function len(o) is called on object o of the class. It is up to the 
programmer to decide how to measure the length, though. In our definition of 
class Graduate, we simply use the sum of the first name, last name, and id length.
__REPR__
Dunder method __repr__ can be used to return the object representation of a 
class instance so that, for example, the object can be saved to and retrieved from 
a file or database. An object representation can be in the form of a list, tuple, or 
dictionary, but it has to be returned as a string in order to be written to and read 
from a file or database. The __repr__ method will be invoked when function 
repr() is called on an object of the class. The following example extended from 
the definition of class Graduate shows how dunder methods __str__, __len__, 
and __repr__ can be defined and used.
In [ ]:
class Graduate:
  student_id = 20201195
  def __init__(self, fullname):
    firstname, lastname = fullname.split(' ')
    self.firstname = firstname
    self.lastname = lastname
    self.__class__.student_id += 1
  @classmethod
  def newGraduate(cl, firstname, lastname):
    return cl(f'{firstname} {lastname}')
  def __str__(self):
    return f'{self.firstname} {self.lastname}'
  def __len__(self):
    return len(self.firstname) + len(self.lastname) + 
len(str(self.student_id))
  def __repr__(self):
    return "{'firstname':" + self.firstname +", 
'lastname':" + self.lastname + ", 'student_id':" + 
str(self.student_id) + "}"
g0 = Graduate('James Gord'); print(g0, g0.student_id)
g1 = Graduate.newGraduate('John', 'Doodle')   # 
newGraduate() is called from class Graduate
print(g1, g1.student_id); print(len(g0)); 
print(str(repr(g1)))
	344	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Out [ ]:
James Gord 20201196
John Doodle 20201197
17
{'firstname':John, 'lastname':Doodle, 'student_id':20201197}
__GETITEM__ AND __SETITEM__
These two methods are used to turn a class into an indexable container object. 
__getitem__ is called to implement the evaluation of self[key] whereas __
setitem__ is called to implement the assignment to self[key].
__DELITEM__
This is called to implement the deletion of self[key].
__MISSING__
This is called by dict.__getitem__() to implement self[key] for dict subclasses 
when the key is not in the dictionary.
__ITER__
This is called when an iterator is required for a container.
__REVERSED__
This can be implemented and called by the reversed() built-­
in function to 
implement a reverse iteration.
__CONTAIN__
This is called to implement membership test operators. It should return True 
if the item is in self and False if it is not.
__DELETE__
This is called to delete the attribute on an instance of the owner class.
Tables 7-­
4, 7-­
5, 7-­
6, and 7-­
7 show a comprehensive list of dunder methods 
and their respective operators that can be overridden by programmers when 
defining new classes.
Table 7-­
4: Binary operators
Overridden operator
Dunder method
+
object.__add__(self, other)
-­
object.__sub__(self, other)
*
object.__mul__(self, other)
	
Object-­
Oriented Programming with Python	
345
 https://doi.org/10.15215/remix/9781998944088.01
Overridden operator
Dunder method
//
object.__floordiv__(self, other)
/
object.__truediv__(self, other)
%
object.__mod__(self, other)
**
object.__pow__(self, other[, modulo])
<<
object.__lshift__(self, other)
>>
object.__rshift__(self, other)
&
object.__and__(self, other)
^
object.__xor__(self, other)
|
object.__or__(self, other)
Table 7-­
5: Augmented assignment operators
Overridden operator
Dunder method
+=
object.__iadd__(self, other)
-­
=
object.__isub__(self, other)
*=
object.__imul__(self, other)
/=
object.__idiv__(self, other)
//=
object.__ifloordiv__(self, other)
%=
object.__imod__(self, other)
**=
object.__ipow__(self, other[, modulo])
<<=
object.__ilshift__(self, other)
>>=
object.__irshift__(self, other)
&=
object.__iand__(self, other)
^=
object.__ixor__(self, other)
|=
object.__ior__(self, other)
Table 7-­
4: Binary operators (continued)
	346	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Table 7-­
6: Unary operators
Overridden operator
Dunder method
-­
object.__neg__(self)
+
object.__pos__(self)
abs()
object.__abs__(self)
~
object.__invert__(self)
complex()
object.__complex__(self)
int()
object.__int__(self)
long()
object.__long__(self)
float()
object.__float__(self)
oct()
object.__oct__(self)
hex()
object.__hex__(self)
Table 7-­
7: Comparison operators
Operator
Dunder method
<
object.__lt__(self, other)
<=
object.__le__(self, other)
==
object.__eq__(self, other)
!=
object.__ne__(self, other)
>=
object.__ge__(self, other)
>
object.__gt__(self, other)
Using Class as Decorator
In Chapter 6, we saw how decorators can be used as powerful and useful tools 
that wrap one function with another to change the behaviour of the wrapped 
function without modifying the wrapped function. In this section, we show how 
to use classes as decorators to modify the behaviour of an existing function.
As we know, a class has two types of members. One is attributes and the 
other is methods. Our first example uses the methods of a class as a decorator, 
as shown below:
	
Object-­
Oriented Programming with Python	
347
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
class MyClass:
  def __init__(self, decorated):
    self.func = decorated
  def __call__(self, *args, **kwargs):   # variable-­
length arguments
    print("More code can be added before calling the 
decorated function")
    self.func(*args, **kwargs)   # call the decorated 
function
    print("More code can be added after calling the 
decorated function")
# use MyClass as a decorator
@MyClass
def myFunc(name, message ='Welcome to COMP218'):
  print(f"Hello {name}, {message}")
myFunc("Joe", "Welcome to the world of Python")
Out [ ]:
More code can be added before calling the decorated function
Hello Joe, Welcome to the world of Python
More code can be added after calling the decorated function
As shown in the example above, the __init__ method is used to pass a func­
tion to be decorated or wrapped to the class, and the __call__ method is used 
to actually wrap the real function passed to the class.
We learned in Chapter 6 how to calculate the actual execution time of a 
program using a function as a decorator. The same can be done with a class 
as a decorator when we time finding all the primes within a given range using 
an algorithm called “sieve of Eratosthenes.”
In [ ]:
from time import time
class ProgramTimer:
     def __init__(self, func):
          self.function = func
     def __call__(self, *args, **kwargs):
          program_start_time = time()
          result = self.function(*args, **kwargs)
          program_end_time = time()
          print(f"Execution of {self.function} took
            {program_end_time- program_start_time} seconds"
          return result
	348	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
# add a decorator to the class
def sieving(n, l):
  """Remove all n's multiples from list l."""
  return list(filter(lambda m: m == n or m%n != 0, l))
def i_list(max_l_int):
  """Create initial list."""
  l0 = [2] + list(range(3, max_l_int, 2))
  return l0
@ProgramTimer
def primesBySieving(upper_bound):
  nl = i_list(upper_bound)
  sl = nl[1: len(nl) // 2 + 1]   # initial sieve
  flag = True
  while flag:
    d = sl[0]
    nl = sieving(d, nl)
    sl = sl[1:]
    if d**2 > nl[-­
1]:
      flag = False
      return nl
ub = 2**19
pl = primesBySieving(ub)
print(f"{len(pl)} prime numbers have been found between 
2 and {ub}")
Out [ ]:
Execution of <function primesBySieving at 0x0000014363F8AEE8> took 
3.1760756969451904 seconds
43390 prime numbers have been found between 2 and 524288
In the above examples, we used class to decorate a function. Within the class, 
a special dunder function __call__ is used to execute the decorated function 
and calculate the time spent on the execution of the function that finds all the 
prime numbers between 2 and 32768 (2 ** 15).
Built-­
In Property() Function and Property Decorator
Python has a special built-­
in function named property, as mentioned in Chap­
ter 2. It can be called directly to create an attribute of a class with potentially 

added setter, getter, and deleter methods and documentation. In this case, the 
function can either be called within a class definition or outside a class defin­
ition while adding the created property to a class or object of a class.
A call of the property function may take none or any combination of the 
four optional keyword arguments, as shown below:
	
Object-­
Oriented Programming with Python	
349
 https://doi.org/10.15215/remix/9781998944088.01
Property_name = property(fget=None, fset=None, fdel=None, 
doc=None)
# fget, fset, and fdel take functions only
firstname = property()   # call of the property function 
with default
lastname = property(set_lastname, get_lastname, 
delete_lastname)
# call with three function names
firstname.setter(set_firstname)   # add a set function to 
property firstname. set_firstname must be a function
firstname.getter(get_firstname)
# add a get function to property firstname. get_firstname 
must be a function
If property() function is called with no argument, you can add a setter 
function, getter function, and/or deleter function later by calling the setter, 
getter. and deleter methods.
The following example demonstrates how the built-­
in property function is 
used to add a property/attribute to a class:
In [ ]:
class Employee:
  def __init__(self, firstname, lastname):
    self.firstname = firstname
    self.lastname = lastname
  def setFullname(self, fullname):
    names = fullname.split()
    self.firstname = names[0]
    self.lastname = names[1]
  def getFullname(self):
    return f'{self.firstname} {self.lastname}'
  fullname = property(getFullname, setFullname)
e1 = Employee('Jack', 'Smith')
print(e1.fullname)
e1.fullname = 'John Doe'
print(e1.fullname)
print(f'{e1.lastname}, {e1.firstname}')
Out [ ]:
Jack Smith
John Doe
Doe, John
	350	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
A built-­
in property function can also be used as a decorator within a class def­
inition to make a method name to be used as an attribute/property of the class.
Similar to the example above, suppose we want to define a class named Stu­
dent for a management system at a university. The attributes should include the 
first name, last name, full name, email address, and some other information. 
We know that a full name is made of a first name and a last name and that the 
university often has a rule of assigning an email address based on the first name 
and last name. If we define full name and email address as ordinary attributes, 
the dependencies would not be reflected because a change to the first name 
or last name of a student will not automatically result in the change to the full 
name and email address. Using property() function as a decorator can nicely 
solve the problem, as shown in the following example:
In [ ]:
class Student:
  def __init__(self, firstname, lastname):
    self.firstname = firstname
    self.lastname = lastname
  @property
  def fullname(self):
    return f"{self.firstname} {self.lastname}"
  @property
  def emailaddress(self):
    return f"{self.firstname}.{self.lastname}@
globalemail.com"
s0 = Student('John', 'Doe')
print(f'First name: {s0.firstname}')
print(f'Last name: {s0.lastname}')
print(f'Full name: {s0.fullname}')
print(f'Email address: {s0.emailaddress}')
s0.lastname = 'Smith'
print(f'First name: {s0.firstname}')
print(f'Last name: {s0.lastname}')
print(f'Full name: {s0.fullname}')
print(f'Email address: {s0.emailaddress}')
Out [ ]:
First name: John
Last name: Doe
Full name: John Doe
Email address:​
John​
.Doe​
@globalemail​
.com
First name: John
Last name: Smith
Full name: John Smith
Email address:​
John​
.Smith​
@globalemail​
.com
	
Object-­
Oriented Programming with Python	
351
 https://doi.org/10.15215/remix/9781998944088.01
In the example above, we use built-­
in property() function as a decorator to 
decorate method fullname() and emailaddress(). By doing that, the function 
name can be used as a property or attribute of the object, but access to the 
attribute invokes a call to the function so that an updated full name or email 
address is retrieved. In the example, when the last name is changed to Smith, 
the full name is automatically changed to John Smith, and the email address 
is automatically changed to John​
.Smith​
@globalemail​
.com.
Using decorator, we can also further add setter, getter, and deleter methods 
to the property fullname, as shown below:
In [ ]:
class Student:
  def __init__(self, firstname, lastname):
    self.firstname = firstname
    self.lastname = lastname
  @property
  def fullname(self):
    return f"{self.firstname} {self.lastname}"
  @fullname.setter
  def fullname(self, fullname):
    """
    Set the value of fullname. However,
    you cannot do self.fullname = fullname
    because fullname is not true attribute.
    """
    names = fullname.split()
    self.firstname = names[0]
    self.lastname = names[1]
s0 = Student('John', 'Doe')
print(s0.fullname)
s0.fullname = 'Kevin Smith'
print(s0.fullname)
Out [ ]:
John Doe
Kevin Smith
Note that using a property decorator can make a method to be used like an 
attribute/property without the need to allocate memory space to keep the value 
of the attribute. As such, you cannot assign a value directly to such an attribute.
	352	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Creating a New Class Dynamically and Modify a Defined Class or 
Instance
In Python, you have the freedom to make changes to an already defined class 
or an instance of the class, and you can even create a new class dynamically.
To create a new class dynamically in your Python program, a built-­
in func­
tion type is used, as shown below:
In [ ]:
Shape = type('Shape', (object,), dict(points=[(1,1)]))
s0=Shape()
s1=Shape()
print(f's0.points = {s0.points}')
print(f's1.points = {s1.points}')
s0.points += [(12, 23)]   # add a new point to s0
print(f's0.points = {s0.points}')
print(f's1.points = {s1.points}')
s1.points = [(35, 67)]   # this adds an attribute point 
to s1
print(f's0.points = {s0.points}')
print(f's1.points = {s1.points}')
Out [ ]:
s0.points = [(1, 1)]
s1.points = [(1, 1)]
s0.points = [(1, 1), (12, 23)]
s1.points = [(1, 1), (12, 23)]
s0.points = [(1, 1), (12, 23)]
s1.points = [(35, 67)]
In the example above, we dynamically create a new class called Shape and set 
one attribute called points, which is a list of points initially assigned one point 
(1, 1). We then create two instances of the Shape class, s0 and s1, in the same 
way that we do with other classes defined with the class statement. We then even 
added one more point to s0. Because attributes added to the class with built-­
in 
function type() are automatically treated as class attributes and shared by all 
instances of the class, changes to points of s0 are also reflected in the value of 
points of s1. However, the third-­
to-­
last statement above adds an attribute with 
the same name as the class attribute to object s1, which only belongs to s1. As 
a result, a change to this attribute of s1 has no effect on s0.
As we have already seen above, with a defined class or an instance of a 
defined class, you can modify the class or instance by adding or deleting attrib­
utes to/from the class or instance. Moreover, you can even add or delete a new 
method dynamically to or from a class or instance of a class.
One way to add an attribute to an object, either a class or an instance of a class, 
is to directly name a new attribute and assign a value in the same way that we 
	
Object-­
Oriented Programming with Python	
353
 https://doi.org/10.15215/remix/9781998944088.01
introduce a new variable to a program. For example, we can add a new attribute 
called shape_type to s0 instantiated above with the first statement of code below:
In [ ]:
s0.shape_type = 'line'
print(f'The shape is a {s0.shape_type}, with points 
{s0.points}')
Out [ ]:
The shape is a line, with points [(1, 1), (12, 23)]
The second statement has proved that a new attribute shape_type has been 
added to object s0, and now this particular instance of Shape is called line.
A new attribute can also be added by using the built-­
in function setattr(). 

To add the shape_type attribute to s0 with setattr(), run the following statement:
In [ ]:
setattr(s0, 'shape_type', 'rectangle')
# this will only add attribute shape_type to object s0
s0.shape_type
Out [ ]:
'rectangle'
An attribute can also be deleted from an object using the built-­
in function 
delattr(). When you want to add or delete an attribute, but you are not sure if the 
attribute exits, you can use built-­
in function hasattr() to check, as shown below:
In [ ]:
print(hasattr(s0, 'shape_type'))
delattr(s0, 'shape_type')
print(hasattr(s0, 'shape_type'))
Out [ ]:
True
False
Remember, attributes added to an instance of a class will not be seen by 
other instances of the same class. If we want to make the shape_type attribute 
visible to all instances of the Shape class because every shape should have a 

shape type, we need to add the shape_type attribute to the class to make it 

a class attribute. This is done with the following statement:
Shape.shape_type = 'point'
From now on, all instances of the Shape class will have an attribute called 
shape_type, as shown in the examples below:
	354	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
Shape.shape_type = 'point'
print(f's0.shape_type = {s0.shape_type}')
print(f's1.shape_type = {s1.shape_type}')
Out [ ]:
s0.shape_type = point
s1.shape_type = point
As you may have noted, the attribute shape_type and its value, added to the 
Shape class, have been propagated to both s0 and s1 because the shape_type 
attribute was added as a class attribute. By comparison, the attribute later added 
to an individual instance of the class is the attribute of that instance only. This 
is shown in the following code sample:
In [ ]:
print(s0.points, s1.points)
s0.weight = 1
print(s0.weight)
hasattr(s1, 'weight')
Out [ ]:
[(1, 1), (12, 23), (2, 3), (2, 3)] [(1, 1), (12, 23), (2, 3), (2, 3)]
1
False
The example shows that the new attribute weight was only added to object 
s0, and s1 does not have the attribute. Again, if you want the weight attribute 
and its value to be shared by all instances of the class, you have to add the 
attribute to the class directly, as shown below:
In [ ]:
Shape.weight = 1
print('s0 weight = ', s0.weight)
print('s1 weight = ', s1.weight)
Out [ ]:
s0 weight = 1
s1 weight = 1
How can you add a new method to an already defined class? You can do this 
in almost the same way as you would add new attributes to a class or instance 
of a class, as shown in the following example:
In [ ]:
def print_points(self):   # we define a function with a 
parameter
  for i, p in enumerate(self.points):
    print(f'point {i} at {p}')
Shape.print_points = print_points   # we now attach the 
function
s0.print_points()   # the method is called on s0
	
Object-­
Oriented Programming with Python	
355
 https://doi.org/10.15215/remix/9781998944088.01
Out [ ]:
Point 1 at (1, 1)
Point 2 at (12, 23)
This provides programmers with so much power, as they can create new 
classes and modify all aspects of classes dynamically. For example, we know 
we can only define one __init__() in a class definition, so we only have one 
constructor to use when creating new instances of the class. By attaching a 
different properly defined method to the __init__ attribute, we are now able 
to construct a new instance of a class in whatever way we want, as shown in 
the following example:
In [ ]:
def print_shape(self):
  print(f'A {self.shape_type} has {len(self.points)} 
point(s):')
  for i, p in enumerate(self.points, 1):
    print(f'Point {i} at {p}')
Shape.print_shape = print_shape
def c1(self, *points):   # a point
  self.points = list(points)
  self.shape_type = 'point'
def c2(self, *points):   # a line, a shape made of two 
points
  self.points = list(points)
  self.shape_type = 'line'
def c3(self, *points):   # a triangle, a shape made of 
three points
  self.points = list(points)
  self.shape_type = 'triangle'
Shape.__init__= c1   # constructor for one point
p1 = Shape((3,5))
Shape.__init__= c2 # constructor for a line
l1 = Shape((3,5), (12, 35))
Shape.__init__= c3   # constructor for a triangle
t1 = Shape((3,5), (12, 35), (26, 87))
print(p1.print_shape())
print(l1.print_shape())
print(t1.print_shape())
	356	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Out [ ]:
A point has 1 point(s):
Point 1 at (3, 5)
None
A line has 2 point(s):
Point 1 at (3, 5)
Point 2 at (12, 35)
None
A triangle has 3 point(s):
Point 1 at (3, 5)
Point 2 at (12, 35)
Point 3 at (26, 87)
None
In this example, we defined three methods to use as constructors or 
initiators for the shape class we previously defined. Constructor c1 is for 
creating point objects, c2 is for creating line objects, and c3 is for creating 
triangle objects. We then attach each method to the __init__ attribute of the 
shape class to create the shape object we want. We also defined a method 
called print_shape() for the class, just to show the results of the three different 
constructors.
As you may imagine, however, the consequence of modifying instances of 
a class is that different instances of the same class may have totally different 
attributes. In an extreme case, two instances of the same class can have totally 
different attributes. This is something you need to keep in mind when enjoying 
the freedom offered by Python.
Keeping Objects in Permanent Storage
As mentioned previously, classes and objects are a very powerful way to model 
the world. Hence, in a program, classes and objects can be used to represent 
information and knowledge for real-­
world application. You do not want to 
lose that information and knowledge whenever you shut down the computer. 
Instead, you want to keep this information and knowledge in permanent stor­
age and reuse it when you need it. For example, you may have developed a 
management system using the Student class, defined earlier in this section, 
and created a number of objects of the Student class containing information 
about these students. You need to reuse the information about these students 
contained in those student objects next time you turn on the computer and run 
the system. How can you do that?
Previously, we discussed defining the __repr__ dunder method, which 
returns a string representation of an object that can be in the form of list, tuple, 
or dictionary, as shown in the following example:
	
Object-­
Oriented Programming with Python	
357
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
class Employee:
  age : int = 20
  salary : float = 30000
  def __init__(self, firstname, lastname):
    self.firstname = firstname
    self.lastname = lastname
  def __str__(self):
    return f'{self.firstname} {self.lastname}, {self.
age}, {self.salary}'
  def __repr__(self):
    rdict = {'firstname':self.
firstname,'lastname':self.lastname, 'age':self.age, 
'salary':self.salary}
    return f"{rdict}"
e1 = Employee('Jack', 'Smith')
e1.age =37
e1.salary = 56900
e2 = Employee('Jone', 'Doe')
print(e1)   # this will call the __str__ method
e2 # this will call the __repr__ method
Out [ ]:
Jack Smith, 37, 56900
{'firstname': 'Jone', 'lastname': 'Doe', 'age': 20, 'salary': 30000}
With the __repr__() method for a class, you can save the representation of 
these objects into a file. To use the object representations stored in a file, you 
will need to write another function/method to pick up the information from 
each object representation and add it to its respective object. The two processes 
must work together to ensure that objects can be correctly restored from files. 
Neither process is easy. Fortunately, there is a Python module called pickle 
already developed just for this purpose.
In formal terms, saving data, especially complex data such as objects in OOP, 
in permanent storage is called serialization, whereas restoring data from perma­
nent storage back to its original form in programs is called deserialization. 
The pickle module is a library implemented for serializing and deserializing 
objects in Python. The pickling/serializing process converts objects with hier­
archical structure into a byte stream ready to save on a binary file, send across 
a network such as the internet, or store in a database, whereas the unpickling/
deserializing process does the reverse: it converts a byte stream from a binary 
file or database, or received from a network, back into the object hierarchy.
	358	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
There are some good sections and documents on the internet that explain 
how to use the pickle module for your Python programming needs. When you 
do need to use it, be aware of the following:
	
1.	 Unpickling with the pickle module is not secure. Unpickling objects from 
unknown and untrusted sources can be dangerous because harmful 
executable code may be deserialized into your computer memory.
	
2.	 Not all objects can be pickled. You need to know what data types 
and objects can be pickled before you pickle them. Pickling 
unpicklable objects will raise exception.
Chapter Summary
•	 Object-­
oriented programming is an important approach to object 
modelling and programming.
•	 Abstraction, information hiding, and inheritance are important 
concepts and principles in OOP.
•	 New classes can be defined with the class statement.
•	 A class contains attributes/properties and methods.
•	 In Python, there are attributes called class attributes, which can have 
default values.
•	 The __init__ method is called upon when instantiating new instances of 
classes.
•	 Except for class attributes, attributes of individual objects of a class 
don’t need to be explicitly declared in a class definition.
•	 Instead, attributes of a class are introduced in the definition of 
the __init__ method.
•	 In Python, each class can only have one constructor for the initializing 
instance of the class. That means that you can define only one __init__ 
method within a class.
•	 Methods of a class are defined the same way as functions, except that the 
first parameter of a method definition needs to be self, which refers to 
the object, an instance of the class on which the method is being called.
•	 There are methods called class methods in Python.
•	 There are also methods called static methods in Python class definition.
•	 A number of dunder methods can be defined in a class to achieve neat 
and powerful programming effects.
•	 Some dunder methods can be redefined in a class to mimic arithmetic 
operators.
	
Object-­
Oriented Programming with Python	
359
 https://doi.org/10.15215/remix/9781998944088.01
•	 Some important and interesting dunder methods include __repr__, 
__init__, __call__, __new__, and __len__.
•	 Class can also be used as a decorator of a function/method.
•	 The built-­
in function property() has two interesting uses: one is to 
attach specific getter, setter, and deleter functions to a property/
attribute of an object, and the other is to use it as a decorator—­
to create 
the name of a method to be used as a property/attribute name.
Exercises
	
1.	 Run the following code in a cell of one of the Jupyter Notebooks 
created for the chapter and answer the questions below:
class myClassB(object):
    pass
 
print(myClassB.__dict__)
dir(myClassB)
	
a.	 What does each statement do?
	
b.	 What is the output from print(myClassB.__dict__) statement?
	
c.	 What does dir(myClassB) return?
	
d.	 Python dir() function returns a list of the attributes and methods of 
any object. In the code above, no attribute or method is defined in 
the definition of class myClassB. Why does the list returned from 
dir(myClassB) have so many items in it? Find out and explain what 
each item is.
	
2.	 Mentally run the code below and write down the output of the program:
class Employee:
    def __init__(self, firstname, lastname):
         self.firstname = firstname
         self.lastname = lastname
 
    def setFullname(self, fullname):
         names = fullname.split()
         self.firstname = names[0]
         self.lastname = names[1]
 
    def getFullname(self):
	360	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
         return f'{self.firstname} {self.lastname}'
 
 fullname = property(getFullname, setFullname)
 
e1 = Employee('Jack', 'Smith')
print(e1.fullname)
e2 = e1
e2.fullname = 'John Doe'
print(e2.fullname)
	
3.	 For the Employee class defined in Exercise 2, define method __str__() 
so that the statement print(e1) will display the full name of the 
employee.
	
4.	 For the Employee class defined below, define setter and getter 
methods for attribute age and salary, respectively.
class Employee:
    age : int = 20
    salary : float = 30000
    def __init__(self, firstname, lastname):
         self.firstname = firstname
         self.lastname = lastname
	
5.	 For the Employee class defined in Exercise 4, define method 
__repr__() to return a dictionary whose item is a pair of that includes 
the attribute name and its value, such as 'firstname': 'John'.
	
6.	 Define a class named Quiz_question that models multiple-­
choice 
questions, including the correct answers. In addition to a constructor—­

the __init__ method to construct the objects of the class—­
there should 
be other methods allowing the user to change the description of 
the question, the individual choices, and the correct answers.
	
7.	 If we allow the number of choices to vary for the multiple-­
choice 
questions modelled by the Quiz_question class defined for Exercise 6, 
what changes need to be made to the Quiz_question class?
	
8.	 Define a class named Quiz that uses the Quiz_question class defined 
above to model a quiz that contains a number of quiz questions. It 
should have methods for a user to create a quiz, to add quiz questions 
to the quiz, to display a list of all quiz questions in a quiz for review, 
and to execute a quiz on a user and calculate the score.
	
Object-­
Oriented Programming with Python	
361
 https://doi.org/10.15215/remix/9781998944088.01
Project
	
1.	 Using the Quiz_question and Quiz classes you developed in Exercises 7 
and 8 above, develop a terminal-­
based quiz system that will allow the 
user to do the following:
•	 Create a quiz.
•	 Select a quiz and add new quiz questions.
•	 Select a quiz and preview all the quiz questions.
•	 Select a quiz and execute the quiz by presenting the quiz 
questions one by one.
•	 At the end of the quiz, calculate the user’s score as a percentage 
and show the correct answers to incorrectly answered questions. 
The quiz questions should be displayed to the user one by one 
during the quiz.
This page intentionally left blank
 https://doi.org/10.15215/remix/9781998944088.01
Chapter 8
Modules and Packages
Divide-­
and-­
conquer is a fundamental but effective strategy in problem solv­
ing as well as system design and development. This is because big problems 
can often be divided into smaller problems that can be easily solved or have 
already been solved, and large systems can often be made of smaller ones that 
can be easily created or are already readily available. Not only that, but the 
divide-­
and-­
conquer method also results in easier system maintenance, better 
quality insurance, quicker error detection and correction, and better reusability.
In Chapter 6, we learned how functions can be used in problem solving, 
and in Chapter 7, we studied object-­
oriented programming and learned how 
classes and objects can be used in system development and to solve problems. 
In computing, both functions and objects are common programming technol­
ogies that implement divide-­
and-­
conquer strategies.
In this chapter, we will study modules and packages that can also be used 
to implement the divide-­
and-­
conquer strategy in programming. In this way, 
we will learn how to create and use modules in programming and software 
development. We will also study some Python modules and packages that are 
readily available and often needed to solve problems and develop computer 
applications.
Learning Objectives
After completing this chapter, you should be able to
•	 describe modules.
•	 explain what packages are, what files are required, and how they are 
structured in a file system.
•	 import and use modules already in the Python programming/
development environment.
	364	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
•	 import and use specific parts from a module or specific modules from 
a package.
•	 explain the functionalities of some standard and widely used modules, 
and use them comfortably in programming.
•	 write and use your own modules and packages.
8.1 Creating Modules and Packages
As mentioned in previous sections, a module can be just a Python script file 
defining functions, classes, and other program constructs such as variables 
and constants. The following is an example of a Python module:
Code sample in VS Code IDE
1
"""
2
The module in this file defines some functions often used 
in calculations related to circles
3
4
Author: John Doe
5
Date: March 30, 2019
6
Version: 1.0
7
"""
8
9
10
PAI = 3.1415926
11
12
13
def area(r):
14
  """Calculate the area of a circle with radius r."""
15
  return PAI * r ** 2   # calculate the area
16
17
18
def circumference(r):
19
  """Calculate the circumference of a circle with radius 
r."""
20
  return 2 * PAI * r
21
22
The file can then be imported into a Python program and used as a module, 
as shown below:
In [ ]:
import circle
print(f'The area of a circle with a radius of 12 is 
{circle.area(12)}')
Out [ ]:
The area of a circle with a radius of 12 is 452.3893344
	
Modules and Packages	
365
 https://doi.org/10.15215/remix/9781998944088.01
How do you create a module or package and publish it at https://​
pypi​
.org/ 
for the Python community at large so that it can be found and installed with 
the pip command?
Suppose you want to create a package for developing e-learning applications. 
You would need to take the following steps to develop the package to make it 
available for the others in the Python community:
	
1.	 First, create a directory called mypackages, which will contain all the 
packages and modules that you will develop for yourself or the Python 
community at large.
	
2.	 Suppose you would like the package to be called elearn. You first need 
to check to see if the name has been used by others to name any top-­
level module or package published at http://​
pypi​
.python​
.org.
	
3.	 Under the mypackages directory, create a directory named elearn, 
which will contain everything for your elearn package or module.
	
4.	 Under this elearn directory, you can create Python script files (.py) 
and other subdirectories under which you may have other packages or 
modules.
	
5.	 To distinguish this elearn directory from other ordinary directories of 
the file system so that it can be searchable through a Python interpreter, 
create a special file called ​
_​
_init​
_​
_​
.py right under the elearn directory. 
The ​
_​
_init​
_​
_​
.py file should contain all the names and objects defined 
in the package or module, either directly or indirectly (by importing 
individual names and objects from each of the other files). The must-­
have ​
_​
_init​
_​
_​
.py file is the entry point of each package or module.
	
6.	 Under the mypackages directory, write a special Python script file 
called setup​
.py, which imports a special module called setuptools 
and calls the setup function to prepare the package to be sent to the 
repository. The following is an example of the setup​
.py file.
import setuptools
 
setup(name = 'elearn',
version = '1.0beta',
description = 'A package for developing elearn 
applications',
url = 'http://​
github​
.com/​
AU​
.CA/​
elearn',
author = 'SCIS Athabasca',
author_email = 'scis​
@athabascau​
.ca',
license = 'FSF free software foundation',
	366	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
packages = ['elearn'],
zip_safe = False)
	
7.	 If you are not really ready to submit the package to the repository but 
would rather test it or just want to use it by yourself, you can install the 
package locally so that it can be found with the import statement. The 
following is the command to be used to install the package when your 
current working directory is mypackages:
$ pip install .
	
8.	 To publish your elearn package, you need to
	
a.	 Register the package with PyPi so that the online repository will 
know about your package and create an entry-­
point link to the 
elearn package at GitHub, as specified in the setup​
.py file.
	
b.	 Create a single zip file that contains all Python script files.
	
c.	 Upload the zip file to PYPI repository.
By running the following command also under mypackages directory:
$ python setup​
.py register sdist upload
Upon completing the above steps, anyone on the internet will be able to install 
and use your elearn library to develop elearn applications using the following 
command:
$ pip install elearn
Please note that for your package to be available in a GitHub repository so 
that the link used in your entry at PYPI is valid, you will need to create or sign 
into an account with GitHub and do the following:
	
1.	 Create the project within your account at GitHub
	
2.	 Install Git on your computer and use the commands to manually 
synchronize your work on your computer with GitHub
VS Code IDE can work with Git and GitHub through respective GitHub exten­
sions that can be downloaded and installed in VS Code so that your project in 
VS can be easily synchronized with GitHub.
	
Modules and Packages	
367
 https://doi.org/10.15215/remix/9781998944088.01
8.2 Using Modules and Packages
To use a module, we first import it, as shown in the following example:
Code sample in Python interactive mode
1
2
import circle
3
4
radius = float(input("Tell me the radius:"))
5
6
print(f"The area of a circle with the radius 
{radius} is {circle.area(radius)}")
7
print(f"The circumference of a circle with the 
radius {radius} is {circle.circumference(radius)}")
The result
Tell me the radius: 12.3
The area of a circle with the radius 12.3 is 475.2915444540001
The circumference of a circle with the radius 12.3 is 77.28317796
When importing a module, you can also give the module an alias to use, 
especially if the original name is too long or hard to remember. In the above 
code sample, the import statement import circle can be changed to ci, as in 
the following:
>>> import circle as ci
Then in the program file, you can use ci in place of circle, as shown below:
>>> print(f"The area of a circle with the radius {radius} 
is {ci.area(radius)}")
When designing and coding a system, you may create and use as many 
modules as needed, but do so wisely and do not make a simple system too 
complicated. Managing too many unnecessary modules and files will consume 
time and resources as well, especially since many Python modules have already 
been developed by the great Python community for almost every application 
domain you can think of. In most cases, all you need is to know is what modules 
are available out there and what each module does, even if you do not want to 
learn about the details now.
In general, the import statement may take one of the following forms.
	368	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
IMPORT <THE NAME OF THE MODULE>
This is the simplest form, although you do need to know what the module has 
defined and know exactly what the name is, which is just the file name without 
the extension py.
IMPORT <THE NAME OF THE MODULE> AS <SIMPLER ALIAS FOR 
THE MODULE NAME>
Sometimes, the name of a module can be long and hard to remember, and giving 
the module an alias would make programming more efficient. For example, 
there is a module for mathematical plotting called matplotlib if you give an 
alias to the module when importing it as follows:
import matplotlib as mpl
A name such as o defined in the module can then be referred to using mpl.o, 
which is much simpler than matplotlib.o.
FROM <MODULE/PACKAGE NAME> IMPORT <NAME OF OBJECT 
OR MODULE>
When importing from a module, you can import a specific name you want to use 
instead of the entire module. For example, a mathematical module may have 
defined a number of mathematical constants such as PI and E. You may import 
only the one you want to use in your program.
As previously mentioned, a package usually contains other packages 

and modules, which can often be depicted as a tree. You can import just the 
package, module or even the name you want to use by using the import state­
ment above. Again, the important thing is that you need to know where the 
thing you want to import is located within the tree. Assume from the root r 

the module m is located at r.n.m; then the import statement can be written 
as follows:
from r.n import m
This dot notation can also be used to import a module from a package 
without using from, as shown in the following example:
import matplotlib.pyplot as ppl
which imports the pyplot module from the matplotlib package and assigns an 
alias to the module.
	
Modules and Packages	
369
 https://doi.org/10.15215/remix/9781998944088.01
FROM <MODULE/PACKAGE NAME> IMPORT <NAME OF OBJECT 
OR MODULE> AS <ALIAS>
This is the last form an import statement can take. It gives an alias to the module/
name imported from a package or module.
8.3 Install and Learn About Modules Developed by 
Others
To learn about modules already developed by others, your starting point can 
be a website called Python Package Index (PyPi) at https://​
pypi​
.org, where you 
can find, install, and publish Python packages and modules. By browsing this 
site, you will quickly get an idea what packages and modules have been already 
developed and published and are ready for use.
To see what modules and packages have already been installed on your 
computer, you can simply run pip list on a shell terminal such as PowerShell, 
as shown below:
PS C:\> pip list
Package             Version
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
  -­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
appdirs             1.4.4
argon2-­
cffi         20.1.0
asgiref             3.3.1
async-­
generator     1.10
attrs               20.3.0
backcall            0.2.0
bleach              3.2.1
certifi             2020.11.8
cffi                1.14.3
chardet             3.0.4
colorama            0.4.4
decorator           4.4.2
defusedxml          0.6.0
distlib             0.3.1
Django              3.1.5
entrypoints         0.3
filelock            3.0.12
idna                2.10
ipykernel           5.3.4
ipython             7.19.0
	370	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
ipython-­
genutils    0.2.0
ipywidgets          7.5.1
jedi                0.17.2
Jinja2              2.11.2
json5               0.9.5
jsonschema          3.2.0
jupyter             1.0.0
jupyter-­
client      6.1.7
jupyter-­
console     6.2.0
jupyter-­
core        4.6.3
jupyterlab          2.2.9
jupyterlab-­
pygments 0.1.2
jupyterlab-­
server   1.2.0
MarkupSafe          1.1.1
mistune             0.8.4
nbclient            0.5.1
nbconvert           6.0.7
nbformat            5.0.8
nest-­
asyncio        1.4.2
notebook            6.1.5
packaging           20.4
pandocfilters       1.4.3
parso               0.7.1
pickleshare         0.7.5
Pip                 21.1.3
pipenv              2020.11.15
prometheus-­
client   0.8.0
To find out what a particular installed module or package does, you can 
import the package or module into a Python interactive shell or a Jupyter Note­
book cell, then run the dir command/statement to find out the names defined 
in the module or package and use the help command/statement to see more 
detailed information for a particular name.
PS C:\> python
Python 3.9.0 (tags/v3.9.0:9cf6752, Oct 5 2020, 15:34:40) 
[MSC v.1927 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more 
information.
>>> import math
	
Modules and Packages	
371
 https://doi.org/10.15215/remix/9781998944088.01
>>> dir(math)
['__doc__', '__loader__', '__name__', '__package__', 
'__spec__', 'acos', 'acosh', 'asin , asinh , atan', 
'atan2', 'ata
nh', 'ceil', 'comb', 'copysign', 'cos', 'cosh', 'degrees', 
'dist', 'e', 'erf', 'erfc', 'exp', 'expmr, 'fabs', 'factoria
l', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 
'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'isqrt',
'1cm', 'Idexp', 'lgamma', 'log', 'log10', 'Ioglp', 
'log2', 'modf', 'nan', 'nextafter', 'perm', 'pi', 'pow', 
'prod', 'rad
ians', 'remainder', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 
'tau', 'trunc', 'ulp']
>>> help(math)
Help on built-­
in module math:
 
NAME
    math
 
DESCRIPTION
    This module provides access to the mathematical functions
    defined by the C standard.
 
FUNCTIONS
    acos(x, /)
        Return the arc cosine (measured in radians) of x.
 
        The result is between 0 and pi.
 
    acosh(x, /)
        Return the inverse hyperbolic cosine of x.
 
    asin(x, /)
        Return the arc sine (measured in radians) of x.
 
        The result is between -­
pi/2 and pi/2.
 
    asinh(x, /)
        Return the inverse hyperbolic sine of x.
 
	372	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
    atan(x, /)
        Return the arc tangent (measured in radians) of x.
 
        The result is between -­
pi/2 and pi/2.
 
    atan2(y, x, /)
        Return the arc tangent (measured in radians) of y/x.
 
        Unlike atan(y/x), the signs of both x and y are 
considered.
 
    atanh(x, /)
        Return the inverse hyperbolic tangent of x.
Another way to learn about and navigate through the available modules and 
packages is to use a module called pydoc. However, this module is usually run 
from a command shell or PowerShell terminal as shown below:
(base) PS C:\Users\james> python pydoc
pydoc -­
 the Python documentation tool
 
pydoc <name> …
    Show text documentation on something. <name> may be 
the name of a
    Python keyword, topic, function, module, or package, 
or a dotted
    reference to a class or function within a module or 
module in a
    package. If <name> contains a '\', it is used as the 
path to a
    Python source file to document. If name is 
'keywords', 'topics',
    or 'modules', a listing of these things is displayed.
 
pydoc -­
k <keyword>
    Search for a keyword in the synopsis lines of all 
available modules.
 
pydoc -­
n <hostname>
	
Modules and Packages	
373
 https://doi.org/10.15215/remix/9781998944088.01
    Start an HTTP server with the given hostname 
(default: localhost).
 
pydoc -­
p <port>
    Start an HTTP server on the given port on the local 
machine. Port
    number 0 can be used to get an arbitrary unused port.
 
pydoc -­
b
    Start an HTTP server on an arbitrary unused port and 
open a Web browser
    to interactively browse documentation. This option 
can be used in
    combination with -­
n and/or -­
p.
 
pydoc -­
w <name> …
    Write out the HTML documentation for a module to a 
file in the current
    directory. If <name> contains a '\', it is treated as 
a filename; if
    it names a directory, documentation is written for 
all the contents.
 
(base) PS C:\Users\james>
Note that when you want to run a Python module as a normal script, run 
Python with the -­
m switch before the module name.
As shown above, if you want to get documentation on something, just add 
the something behind pydoc. For example, if you want to see the documenta­
tion on the math module, run the following command in the command shell:
python -­
m pydoc math
The resulting documentation is shown below:
Help on built-­
in module math:
 
NAME
  math
 
	374	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
DESCRIPTION
  This module provides access to the mathematical 
functions
  defined by the C standard.
 
FUNCTIONS
  acos(x, /)
   Return the arc cosine (measured in radians) of x.
 
  acosh(x, /)
   Return the inverse hyperbolic cosine of x.
 
  asin(x, /)
   Return the arc sine (measured in radians) of x.
 
  asinh(x, /)
   Return the inverse hyperbolic sine of x.
 
  atan(x, /)
   Return the arc tangent (measured in radians) of x.
 
  atan2(y, x, /)
   Return the arc tangent (measured in radians) of y/x.
 
   Unlike atan(y/x), the signs of both x and y are 
considered.
 
  atanh(x, /)
   Return the inverse hyperbolic tangent of x.
With some installations of Python, such as those installed with Anaconda, 
pydoc has been made available as executable directly from command shell, 
as shown here:
(base) PS C:\Users\james> pydoc math
Help on built-­
in module math:
 
NAME
  math
 
	
Modules and Packages	
375
 https://doi.org/10.15215/remix/9781998944088.01
DESCRIPTION
  This module provides access to the mathematical functions
  defined by the C standard.
 
FUNCTIONS
  acos(x, /)
   Return the arc cosine (measured in radians) of x.
 
  acosh(x, /)
   Return the inverse hyperbolic cosine of x.
 
  asin(x, /)
   Return the arc sine (measured in radians) of x.
 
  asinh(x, /)
   Return the inverse hyperbolic sine of x.
 
  atan(x, /)
   Return the arc tangent (measured in radians) of x.
 
  atan2(y, x, /)
   Return the arc tangent (measured in radians) of y/x.
 
   Unlike atan(y/x), the signs of both x and y are considered.
 
  atanh(x, /)
   Return the inverse hyperbolic tangent of x.
pydoc has some switches that can be used when running it as a Python 
module or an executable directly from the command shell. These switches 
include the following.
-­
K <KEYWORD>
Used to search for a keyword in the synopsis lines of all available modules 
installed. The following example searches for all modules that has the word 
“hash” in the synopsis.
PS C:\Users\james> python -­
m pydoc -­
k hash
-­
N <HOSTNAME>
Used to start an HTTP server with the given <hostname>. When no hostname 
is given, localhost is default.
	376	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
-­
P <PORT>
Used to start an HTTP server on the given <port> on the local machine. Port 
number 0 can be used to get an arbitrary unused port.
-­
B
Used to start an HTTP server on an arbitrary unused port and open a web 
browser to interactively browse documentation. This option can be used in 
combination with -­
n and/or -­
p.
The following example starts a server on the local machine at an available 
port and launches a web browser to browse all available modules and packages.
(base) PS S:\Dev\learn-­
python> pydoc -­
b
Server ready at http://localhost:30128/
Server commands: [b]rowser, [q]uit
server>
Please note that if you type q to quit from the program, the server will be 
down and no longer available.
The browser opened by the example above will look like this:
Index of Modules
Built-­
In Modules
_abc	
_imp	
_stat
_ast	
_io	
_statistics	
builtins
_bisect	
_json	
_string	
cmath
_blake2	
_locale	
_struct	
errno
_codecs	
_lsprof	
_symtable	
faulthandler
_codecs_cn	
_md5	
_thread	
gc
_codecs_hk	
_multibvtecodec	 _tokenize	
itertools
_codecs_iso2022	 _opcode	
_tracemalloc	
marshal
_codecs_jp	
_operator	
_typing	
math
_codecs_kr	
_pickle	
_warnings	
mmap
_codecs_tw	
_random	
_weakref	
msvcrt
_collections	
_shal	
_winapi	
nt
_contextvars	
_sha256	
_xxsubinterpreters	 sys
_csv	
_sha3	
array	
time
_datetime	
_sha512	
atexit	
winreg
_functools	
_signal	
audioop	
xxsubtype
_heapq	
_sre	
binascii	
zlib
	
Modules and Packages	
377
 https://doi.org/10.15215/remix/9781998944088.01
Please note that the above only shows the built-­
in modules. There is more 
about nonbuilt-­
in modules if you scroll down to read further.
-­
W <NAME>…
Used to write out the HTML documentation for a module to a file in the current 
directory. If the name contains a backslash \, it is treated as a filename; if it 
names a directory, documentation is written for all the contents. The following 
example generates documentation in HTML for a module called timeit:
(base) PS S:\Dev\learn-­
python > pydoc -­
w timeit
wrote timeit.html
As can be seen, using the pydoc -­
b in command shell can easily access a 
server and start to browse documentation for all the available modules and 
packages installed on your computer. For example, if we want to learn more 
about the timeit module, we can browse or search for timeit within the first 
page of the browser window launched by the pydoc -­
b command, then click 
the link to see the details of the documentation.
The remainder of this chapter introduces some Python modules that you 
may need to use in the development of different computer applications.
8.4 Module for Generating Random Numbers
In certain computer applications, you often need to generate random numbers. 
For example, you need random numbers to automatically generate quizzes. In 
computer security, big random numbers play very important roles.
The random module comes with the standard Python distribution library. 
It provides functions and class definitions related to generating pseudor­
andom numbers, though they are not good enough to be used for security 
purposes. To see what names are defined at the top level of the module, run 
the dir(random) statement after importing the module to get a list of the 
names, as shown below:
>>> import random
>>> dir(random)
['BPF', 'LOG4', 'NV_MAGICCONST', 'RECIP_BPF', 
'Random', 'SG_MAGICCONST', 'SystemRandom', 'TWOPI', '_
BuiltinMethodType', '_MethodType', '_Sequence', '_Set', 
'__all__', '__builtins__', '__cached__', '__doc__', 
'__file__', '__loader__', '__name__', '__package__', 
	378	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
'__spec__', '_acos', '_bisect', '_ceil', '_cos', '_e', 
'_exp', '_inst', '_itertools', '_log', '_os', '_pi', 
'_random', '_sha512', '_sin', '_sqrt', '_test', '_
test_generator', '_urandom', '_warn', 'betavariate', 
'choice', 'choices', 'expovariate', 'gammavariate', 
'gauss', 'getrandbits', 'getstate', 'lognormvariate', 
'normalvariate', 'paretovariate', 'randint', 
'random', 'randrange', 'sample', 'seed', 'setstate', 
'shuffle', 'triangular', 'uniform', 'vonmisesvariate', 
'weibullvariate']
In the list, names with leading underscores are often intended to be hid­
den. It’s important to know only what those without leading underscores are 
and what they do. You can use the help statement to find out what randint is, 
for example:
>>> help(random.randint)
Running help on method randint in the random module outputs the 
following:
randint(a, b) method of random.Random instance
This returns a random integer within the range [a, b], including both end 
points.
As you can see with the help statement, all these names defined in the ran­
dom module are functions and methods. These functions and methods can be 
categorized as bookkeeping methods, random integer generating methods, ran­
dom real/float number generating methods, random item generating methods, 
or items from a sequence. The module also provides alternate random number 
generators such as the one provided by the operating system.
In the following, you will run through the functions provided in the ran­
dom module. These functions are categorized into four groups: bookkeeping 
functions, functions randomly generating integers, functions randomly gen­
erating float/real numbers, and functions randomly selecting items from a 
sequence.
	
Modules and Packages	
379
 https://doi.org/10.15215/remix/9781998944088.01
Functions for Bookkeeping
SEED(A = NONE, VERSION = 2)
This initializes the random number generator by seeding the generator. If there 

is no argument for a, the current time is used to seed the generator. Version 2 is 

the default version of the algorithm.
>>> import random
>>> random.seed(a = 3)
GETSTATE()
This gets and returns the current internal state of the random number generator.
>>> s1 = random.getstate()
SETSTATE(STATE)
This sets the internal state of the random number generator to state.
>>> random.setstate(s1)
GETRANDBITS(K)
This generates and returns an integer with k random bits.
>>> bin(random.getrandbits(9))
'0b100101111'
>>> bin(random.getrandbits(9))   # will get a different 
number
'0b10111101'
Functions for Generating Random Integers
RANDRANGE(START, STOP=NONE, STEP = 1)
This generates and returns a random number within the given range.
>>> random.randrange(99)
69
>>> random.randrange(99)
	380	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
RANDINT(A, B)
This generates and returns a random integer within the given range.
>>> random.randint(1, 100)
42
>>> random.randint(1, 100)
85
Functions for Randomly Generating Float Numbers
RANDOM()
This randomly generates and returns a random float number between 0 and 
1, including 0 but excluding 1.
>>> random.random()
0.4084252811341471
UNIFORM(A, B)
This randomly generates and returns a float number between a and b.
>>> random.uniform(2, 99)
73.1658416986511
>>> random.uniform(2, 99)
92.92610150048253
TRIANGULAR(LOW = 0.0, HIGH = 1.0, MODE = NONE)
This randomly generates and returns a random float number between low 
and high. The third argument for mode parameter can be used to indicate the 
preference for the outcome. If it is closer to low, it is more likely to get a ran­
dom float number on the low end, for example. Internally, the default value 
for mode is the midpoint between low and high.
>>> random.triangular(2, 99)
84.02716580051677
>>> random.triangular(2,99,35)
50.303535641546
BETAVARIATE(ALPHA, BETA)
This randomly generates and returns a random float number between 0 
and 1 based on the beta distribution of statistics. Parameters alpha and beta 

	
Modules and Packages	
381
 https://doi.org/10.15215/remix/9781998944088.01
(both > 0) are used to set the conditions of the distribution, as used in the beta 
distribution function.
>>> random.betavariate(2, 99)
0.011368344795580798
>>> random.betavariate(2, 99)
0.019428131869773747
EXPOVARIATE(LAMBDA)
This randomly generates and returns a random float number between 0 and 
1, or between 0 and −1 if lambda is negative, based on the exponential distri­
bution of statistics.
>>> random.expovariate(2)
0.379317249922913
GAMMAVARIATE(ALPHA, BETA)
This randomly generates and returns a random float number between 0 and 1 
based on the gamma distribution of statistics. Parameters alpha and beta (both 
> 0) are used to set the conditions of the distribution, as used in the gamma 
distribution function.
>>> random.gammavariate(2,99)
43.06391063895096
GAUSS(MU, SIGMA)
This randomly generates and returns a random float number between 0 and 1 
based on the Gaussian distribution of probability theories. Parameter mu is the 
mean, and sigma is the standard deviation, as used in the distribution function.
>>> random.gauss(2, 99)
38.05513497609059
LOGNORMVARIATE(MU, SIGMA)
This generates and returns a random float number between 0 and 1 based on a 
log-­
normal distribution of probability theories. Parameter mu is the mean, and 
sigma is the standard deviation, as used in the log normal distribution function.
>>> random.lognormvariate(2, 99)
9.252497191266324e-­
41
	382	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
NORMALVARIATE(MU, SIGMA)
This generates and returns a random float number between 0 and 1 based on 
the normal distribution of probability theories. Parameter mu is the mean, and 
sigma is the standard deviation, as used in the normal distribution function.
>>> random.normalvariate(2, 99)
155.45854862650918
VONMISESVARIATE(MU, KAPPA)
This generates and returns a random float number between 0 and 1 based 
on the von Mises distribution of directional statistics. Parameter mu is the 
mean angle, expressed in radians between 0 and 2 * pi, whereas kappa is 
the concentration.
>>> random.vonmisesvariate(2, 99)
1.9289474404869416
PARETOVARIATE(ALPHA)
This generates and returns a random float number between 0 and 1 based 
on the Pareto distribution of probability theories. Parameter alpha is used to 
indicate the shape.
>>> random.paretovariate(2)
1.7794461337233882
WEIBULLVARIATE(ALPHA,BETA)
This generates and returns a random float number between 0 and 1 based on 
the Weibull distribution of statistics. Parameter alpha is the scale, and beta 

is the shape, as in its mathematical function.
>>> random.weibullvariate(2, 99)
2.0164248554211417
Functions for Randomly Selected Item(s) from Sequences
Functions in this group are often used in statistics.
CHOICE(POPULATION)
This generates and returns a random element from the given population (in 
the form of a Python sequence).
	
Modules and Packages	
383
 https://doi.org/10.15215/remix/9781998944088.01
>>> random.choice(range(1, 1000))
536
>>> random.choice(list("The message will look like this 
but"))
'l'
>>> random.choice(list("The message will look like this 
but"))
't'
CHOICES(POPULATION, WEIGHTS = NONE, *, CUM_WEIGHTS = 
NONE, K = 1)
This generates and returns a list with k randomly selected items from the given 
sequence, with weights or cumulative weights considered if they are given. An 
optional argument for weights should be a list of integers specifying how likely 
the corresponding items are to be selected. The number of integers in weights 
must match the number of items in the population; optional argument for 
cum_weights is also a list. A value in the list is shown as cumulation of weights so 
far. Argument weights and cum_weights are just different ways of representing 
the same preferences.
>>> random.choices(range(1, 1000), k = 5)
[456, 79, 57, 51, 110]
>>> random.choices(range(1, 10), weights = [2, 3, 5, 8, 
2, 3, 3, 2, 10], k = 5)
[9, 4, 6, 3, 8]
This function can be very useful when you want to generate a quiz by ran­
domly selecting questions from a question bank. Assume the question bank is 
called q_bank, and each quiz will have 10 questions. The random choices can 
be easily made by calling the function as follows:
>>> random.choices(q_bank, k = 10)
SHUFFLE(POPULATION, RANDOM = NONE)
This takes a sequence, shuffles the members, then returns the sequence with 
the members randomly shuffled.
>>> l = list(range(10))
>>> l
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
	384	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> random.shuffle(l)
>>> l
[2, 9, 0, 4, 1, 6, 5, 3, 7, 8]
SAMPLE(POPULATION, K)
This generates and returns a sample for a given population. It seems similar 
to choices(), but internally the algorithm should check whether the choices 
would make a sample of the population according to some sampling criteria 
in statistics.
>>> random.sample(range(1, 1000), k = 5)
[251, 337, 822, 499, 853]
In the following programming problem in Table 8-­
1, you will study how well 
the random generator works. You will randomly generate 1000 integer numbers 
within the range of 0 to 999 and visualize the randomness of these numbers.
Table 8-­
1: Case study: Random number generator quality
The problem
This case study will find out how good the random number 
generator is.
The analysis 
and design
Random numbers generated by computers are not completely 
random. Rather, they are pseudorandom sequences. To study 
how good a generator is, you need to see if the numbers 
generated by the generator look random. We will show that in a 
two-­
dimensional chart to visualize it.
The code
import random
import matplotlib.pyplot as pyp
data = [random.randint(0,100) for i in 
range(1000)]
pyp.plot(list(range(1000)), data)
pyp.xlabel('Run #')
pyp.ylabel('Random Integer')
pyp.title('Visualization of Randomness')
pyp.show()
The result
Figure 8-­
1 below is plotted by the program. It seems the random 
generator works very well.
	
Modules and Packages	
385
 https://doi.org/10.15215/remix/9781998944088.01
8.5 Module for Mathematical Operations
The math module also comes with the standard Python distribution library 
and provides many useful mathematical functions that you may need. To learn 
what the module has for you, type the following statement in a Jupyter Note­
book cell and click run or press Shift+Enter at the same time. You will see 
the documentation for all these functions as well as the constants defined 

in the math module.
To learn what is defined in the module, run the dir statement on math after 
import, as we did before with the random module:
>>> import math
>>> dir(math)
['__doc__', '__loader__', '__name__', '__package__', 
'__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 
'atan2', 'atanh', 'ceil', 'copysign', 'cos', 'cosh', 
'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 
'factorial', 'floor', 'fmod', 'frexp', 'fsum', 
'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 
'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 
0
200
400
600
800
1000
Run #
0
20
40
60
80
100
Random Integer
Visualization of Randomness
Figure 8-­
1: Visualization of randomness
	386	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
'log1p', 'log2', 'modf', 'nan', 'pi', 'pow', 'radians', 
'remainder', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 
'trunc']
Then run help on a particular name to find out what that name, such as 
ceil, does:
>>> help(math.ceil)
Running help on the built-­
in function ceil in the math module outputs the 
following:
ceil(x, /)
    Return the ceiling of x as an Integral.
This returns the smallest integer >= x.
In the following, we run through the functions available in the math module.
ACOS(X)
This calculates and returns the arc cosine (measured in radians) of x, where 
0 <= x < = 1.
>>> import math
>>> math.acos(0.5)
1.0471975511965979
ACOSH(X)
This calculates and returns the inverse hyperbolic cosine of x. (Google “hyper­
bolic functions” to learn more.)
>>> math.acosh(1000)
7.600902209541989
ASIN(X)
This calculates and returns the arc sine (measured in radians) of x.
>>> math.asin(0.5)
0.5235987755982989
	
Modules and Packages	
387
 https://doi.org/10.15215/remix/9781998944088.01
MATH.ASINH(X)
This calculates and returns the inverse hyperbolic sine of x.
>>> math.asinh(5)
2.3124383412727525
MATH.ATAN(X)
This calculates and returns the arc tangent (measured in radians) of x.
>>> math.atan(0.5)
0.4636476090008061
MATH.ATAN2(Y, X)
This calculates and returns the arc tangent (measured in radians) of y/x. Unlike 
atan(y/x), the signs of both x and y are considered.
>>> math.atan2(3, -­
5)
2.601173153319209
MATH.ATANH(X)
This calculates and returns the inverse hyperbolic tangent of x.
>>> math.atanh(0.5)
0.5493061443340549
MATH.CEIL(X)
This calculates and returns the ceiling of x as an Integral—­
the smallest integer 
>= x.
>>> math.ceil(0.5)
1
MATH.COPYSIGN(X, Y)
This calculates and returns a float with the magnitude (absolute value) of x 
but the sign of y. On platforms that support signed zeros, copysign(1.0, −0.0) 
returns −1.0.
>>> math.copysign(0.5, -­
1.2)
-­
0.5
	388	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
MATH.COS(X)
This calculates and returns the cosine of x (measured in radians).
>>> math.cos(0.5)
0.8775825618903728
MATH.COSH(X)
This calculates and returns the hyperbolic cosine of x.
>>> math.cosh(50)
2.592352764293536e+21
MATH.DEGREES(X)
This converts angle x from radians to degrees and returns the result.
>>> math.degrees(0.5)
28.64788975654116
MATH.ERF(X)
This is the error function at x, as defined in statistics.
>>> math.erf(0.5)
0.5204998778130465
MATH.ERFC(X)
This is the complementary error function at x, so that erf(x) + erfc(x) = 1.
>>> math.erfc(0.5)
0.4795001221869534
MATH.EXP(X)
This calculates and returns e raised to the power of x. This is the same as 
math.e**x, or math.pow(math.e, x).
>>> math.exp(5)
148.4131591025766
MATH.EXPM1(X)
This calculates and returns exp(x)−1. This function avoids the loss of precision 
involved in the direct evaluation of exp(x)−1 for small x.
	
Modules and Packages	
389
 https://doi.org/10.15215/remix/9781998944088.01
>>> math.expm1(5)
147.4131591025766
MATH.FABS(X)
This calculates and returns the absolute value of the float x.
>>> math.fabs(-­
23.6)
23.6
MATH.FACTORIAL(X)
This calculates and returns x!. It will raise a ValueError if x is negative or 
nonintegral.
>>> math.factorial(23)
25852016738884976640000
MATH.FLOOR(X)
This calculates and returns the floor of x as an integer—­
that is, the return value 
is the largest integer < = x.
>>> math.floor(2.3)
2
MATH.FMOD(X, Y)
This calculates and returns fmod(x, y), according to platform C. x % y may differ.
>>> math.fmod(2.3, 1.5)
0.7999999999999998
MATH.FREXP(X)
This calculates the mantissa and exponent of x and returns a pair (m, e). m is 
a float, and e is an integer, such that x = m * 2** e. If x is 0, m and e are both 0. 
Otherwise, 0.5 <= abs(m) < 1.0.
>>> math.frexp(2.3)
(0.575, 2)
MATH.FSUM(SEQ)
This calculates and returns an accurate floating-­
point sum of values in the 
iterable seq. It assumes IEEE-­
754 floating-­
point arithmetic. It is a lossless sum.
	390	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> math.fsum([2.3, 2, 53454, 6.71232])
53465.01232
MATH.GAMMA(X)
This returns the value of the gamma function at x.
>>> math.gamma(2.3)
1.16671190519816
MATH.GCD(X, Y)
This calculates and returns the greatest common divisor of x and y.
>>> math.gcd(222, 780)
6
MATH.HYPOT(X, Y)
This calculates and returns the Euclidean distance—­
that is, the value of sqrt(x 
* x + y * y).
>>> math.hypot(3, 4)
5.0
MATH.ISCLOSE(A, B, *, REL_TOL = 1E-­
09, ABS_TOL = 0.0)
Determine whether two floating-­
point numbers are close in value. The rel_tol 
argument sets the maximum difference for being considered “close” relative 
to the magnitude of the input values, whereas abs_tol argument sets the max­
imum difference for being considered “close” regardless of the magnitude of 
the input values. Return True if a is close in value to b, and False otherwise. 
For the values to be considered close, the difference between them must be 
smaller than at least one of the tolerances set by rel_tol and abs_tol. -­
inf, inf, 
and NaN behave similarly to the IEEE 754 Standard. That is, NaN is not close to 
anything, even itself, and inf and -­
inf are only close to themselves.
>>> math.isclose(3.5, 3.51)
False
>>> math.isclose(3.5, 3.500000001)
True
>>> math.isclose(3.5, 3.50000001)
False
	
Modules and Packages	
391
 https://doi.org/10.15215/remix/9781998944088.01
MATH.ISFINITE(X)
This returns True if x is neither an infinity nor a NaN, and False otherwise.
>>> math.isfinite(3.5)
True
MATH.ISINF(X)
This returns True if x is a positive or negative infinity, and False otherwise.
>>> math.isinf(3.5)
False
MATH.ISNAN(X)
This returns True if x is a NaN (not a number), and False otherwise.
>>> math.isnan(3.5)
False
MATH.ISQRT(N)
This returns the integer square root of the nonnegative integer n, which is the 
floor of the exact square root of n, or equivalently the greatest integer is such 
that a2 ≤ n. This function is only available in Python 3.8.0 or later.
>>> math.isqrt(43)
6
MATH.LDEXP(X, I)
This calculates and returns x* (2 ** i). The function is essentially the inverse 
of frexp().
>>> math.ldexp(3, 12)
12288.0
MATH.LGAMMA(X)
This calculates and returns the natural logarithm of the absolute value of the 
gamma function at x.
>>> math.lgamma(3)
0.693147180559945
	392	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
MATH.LOG(X, BASE = MATH.E)
This calculates and returns the logarithm of x to the given base. If the base is 
not specified, it returns the natural logarithm (base-­
e) of x.
>>> math.log(3)
1.0986122886681098
>>> math.log(3,3)
1.0
>>> math.log(3,5)
0.6826061944859854
MATH.LOG10(X)
This calculates and returns the base-­
10 logarithm of x.
>>> math.log10(3)
0.47712125471966244
MATH.LOG1P(X)
This calculates and returns the natural logarithm of 1 + x (base-­
e). The result 
is computed in a way that is accurate for x near 0.
>>> math.log1p(3)
1.3862943611198906
MATH.LOG2(X)
This calculates and returns the base-­
2 logarithm of x.
>>> math.log2(3)
1.584962500721156
MATH.MODF(X)
This calculates and returns the fractional and integer parts of x. Both results 
carry the sign of x and are floats.
>>> math.modf(32.6)
(0.6000000000000014, 32.0)
MATH.POW(X, Y)
This calculates and returns x ** y (x to the power of y).
	
Modules and Packages	
393
 https://doi.org/10.15215/remix/9781998944088.01
>>> math.pow(32,6)
1073741824.0
MATH.RADIANS(X)
This converts angle x from degrees to radians and returns the result.
>>> math.radians(32)
0.5585053606381855
MATH.REMAINDER(X, Y)
This calculates and returns the difference between x and the closest integer 
multiple of y, which is x − n * y, where n * y is the closest integer multiple of y. 
In the case where x is exactly halfway between two multiples of y, the nearest 
even value of n is used. The result is always exact.
>>> math.remainder(32,7)
-­
3.0
>>> math.remainder(30,7)
2.0
>>> math.remainder(31,7)
3.0
MATH.SIN(X)
This calculates and returns the sine of x (measured in radians).
>>> math.sin(0.31)
0.3050586364434435
MATH.SINH(X)
This calculates and returns the hyperbolic sine of x.
>>> math.sinh(31)
14524424832623.713
MATH.SQRT(X)
This calculates and returns the square root of x.
>>> math.sqrt(31)
5.5677643628300215
	394	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
MATH.TAN(X)
This calculates and returns the tangent of x (measured in radians).
>>> math.tan(31)
-­
0.441695568020698
MATH.TANH(X)
This calculates and returns the hyperbolic tangent of x.
>>> math.tanh(31)
1.0
MATH.TRUNC(X)
This truncates the float number x to the nearest Integral toward 0. It uses the 
__trunc__ magic method.
>>> math.trunc(3.561)
3
In addition, the module also defines the following constants used in math:
math.e = 2.718281828459045
math.inf = inf
math.nan = nan
math.pi = 3.141592653589793
math.tau = 6.283185307179586
Note that to use these functions and constants, you will have to use the dot nota­
tion shown in the sample code above to indicate that it is from the math module.
If you only need to use one or some functions from the math module, you 
may import the particular functions from it to save computer memory and 
use the functions without using the dot notation. The following is an example, 
generating a table of square roots for numbers from 1 to 100, in which only the 
sqrt function has been imported from the math module:
In [ ]:
from math import sqrt
for i in range(100):
  print('{:<5.3}'.format(sqrt(i + 1)), end = ' ')
  if (i + 1) % 10 == 0:
    print('\n')
	
Modules and Packages	
395
 https://doi.org/10.15215/remix/9781998944088.01
Out [ ]:
1.0 1.41 1.73 2.0 2.24 2.45 2.65 2.83 3.0 3.16
3.32 3.46 3.61 3.74 3.87 4.0 4.12 4.24 4.36 4.47
4.58 4.69 4.8 4.9 5.0 5.1 5.2 5.29 5.39 5.48
5.57 5.66 5.74 5.83 5.92 6.0 6.08 6.16 6.24 6.32
6.4 6.48 6.56 6.63 6.71 6.78 6.86 6.93 7.0 7.07
7.14 7.21 7.28 7.35 7.42 7.48 7.55 7.62 7.68 7.75
7.81 7.87 7.94 8.0 8.06 8.12 8.19 8.25 8.31 8.37
8.43 8.49 8.54 8.6 8.66 8.72 8.77 8.83 8.89 8.94
9.0 9.06 9.11 9.17 9.22 9.27 9.33 9.38 9.43 9.49
9.54 9.59 9.64 9.7 9.75 9.8 9.85 9.9 9.95 10.0
8.6 Modules for Time, Date, and Calendar
Date and time are often used and referred to in many applications. You may 
also want to include a calendar in an application. Python has modules in its 
standard distribution that allow you to import these modules right away.
The Datetime Module
The first of these modules is the datetime module that comes in the standard 
Python library. To use the module, simply import it as shown below:
>>> import datetime
To find out what is defined and available in the module, run the following 
dir statement:
>>> dir(datetime)
 
['MAXYEAR', 'MINYEAR', '__builtins__', '__cached__', 
'__doc__', '__file__', '__loader__', '__name__', 
'__package__', '__spec__', 'date', 'datetime', 'datetime_
CAPI', 'sys', 'time', 'timedelta', 'timezone', 'tzinfo']
To further find out what each name is defined for, use the help statement 
on each. As usual, we will go through some of the important names defined in 
the module, with examples.
DATETIME.DATE(<YEAR, MONTH, DAY>)
This is the constructor of the date class defined in the datetime module and 
used to construct and return a date object for the day of the month of the year.
	396	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> d1 = datetime.date(2020, 7, 1)   # create a date 
object
>>> d1.year   # get the year attribute of the date object
2020
>>> d1.month   # get the month attribute of the date 
object
7
>>> d1.day   # get the day attribute of the date object
1
A date object has the following methods defined.
DATETIME.DATE.CTIME()
This returns a ctime()-­
style string.
>>> d1.ctime()
'Wed Jul 1 00:00:00 2020'
DATETIME.DATE.ISOCALENDAR()
This returns a three-­
tuple containing an ISO year, week number of the year, 
and day number of the week. In the datetime module, Monday is 1, Tuesday 
is 2,…, Sunday is 7.
>>> d1.isocalendar()
(2020, 27, 3)
DATETIME.DATE.ISOFORMAT()
This returns a date string in ISO 8601 format, YYYY-­
MM-­
DD.
>>> d1.isoformat()
'2020-­
07-­
01'
DATETIME.DATE.ISOWEEKDAY()
This returns an integer from 1 to 7 as the day of the week represented by the 
date.
>>> d1.isoweekday()
3
	
Modules and Packages	
397
 https://doi.org/10.15215/remix/9781998944088.01
DATETIME.DATE.REPLACE(…)
This returns the date with new specified fields.
DATETIME.DATE.STRFTIME(…)
This changes the date format and returns a strftime()-­
style string.
DATETIME.DATE.TIMETUPLE(…)
This returns a time-­
tuple that is compatible with time.localtime().
DATETIME.DATE.TOORDINAL(…)
This returns a proleptic Gregorian ordinal. January 1 of year 1 is day 1.
DATETIME.DATE.WEEKDAY(…)
This returns the day of the week represented by the date: Monday is 0…Sunday 
is 6.
The following are all class methods of the date class defined in the datetime 
module, which means they can be called from the class name date.
DATETIME.DATE.FROMISOFORMAT(<ISO_DATE_FORMAT 
STRING>)
This will construct a date object from an ISO date format string, which is 
YYYY-­
MM-­
DD.
>>> d2 = datetime.date.fromisoformat('2020-­
07-­
01')
>>> d2.ctime()
'Wed Jul 1 00:00:00 2020'
DATETIME.DATE.FROMORDINAL(<DAYS IN RELATION TO A 
PROLEPTIC GREGORIAN ORDINAL>)
This constructs a date object from an integer >= 1 representing the days after 
the proleptic Gregorian ordinal, which is January 1 of year 1, with ordinal 1.
>>> from datetime import date   # after this, you don't 
need to have datetime in the reference to date class
>>> d3 = date.fromordinal(1235)
>>> d3.ctime()
'Wed May 19 00:00:00 0004'
	398	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
DATETIME.DATE.FROMTIMESTAMP(<TIMESTAMP>)
This constructs a local date object from a POSIX timestamp (a big positive float 
number), such as returned time.time(), which will be explained shortly.
>>> import time
>>> time.time()   # it returns a timestamp for now
1593745988.6121984
>>> date.fromtimestamp(1593745988.6121984)
datetime.date(2020, 7, 2)
DATETIME.DATE.TODAY()
This returns a date object of for the current date.
>>> from datetime import date
>>> print(date.today())
2020-­
07-­
05
The datetime module also has a class called time. The following is the con­
structor of the time class.
DATETIME.TIME(HOUR = 0, MINUTE = 0, SECOND = 0, 
MICROSECOND = 0, TZINFO = NONE)
This returns a time object. All arguments with 0 as their default value must be in 
their reasonable range or the program will raise a value error. If no argument is 
provided, they are all 0, except tzinfo (for time zone information, which needs 
to be an instance of tzinfo class if given). The default value of tzinfo is None.
>>> from datetime import time
>>> print(time(hour = 23))
23:00:00
>>> t1 = time(11, 25, 5)
time is 11:25:05
>>> print(f'time is {t1}')
>>> print(f'hour is {t1.hour}')   # this is to get the 
hour of a time
hour is 11
>>> print(f'minute is {t1.minute}')   # this is to get 
the minute
minute is 25
	
Modules and Packages	
399
 https://doi.org/10.15215/remix/9781998944088.01
>>> print(f'second is {t1.second}')   # this is to get 
second
second is 5
The following is the only class method of the date class in the datetime module.
TIME.FROMISOFORMAT(…)
This class method will construct a date object from a string passed in the 
parameter.
>> import datetime
>> canada_day_str = "2022-­
07-­
01"
>> canada_day_object = datetime.date.
fromisoformat(canada_day_str)
>> print(f"{canada_day_object} as 
{type(canada_day_object)}")
2022-­
07-­
01 as <class 'datetime.date'>
The datetime module also has a class called datetime, which is a combination 
of date and time. The following is the constructor of the datetime objects.
DATETIME.DATETIME(YEAR, MONTH, DAY, HOUR = 0, MINUTE = 0, 
SECOND = 0, MICROSECOND = 0, TZINFO = NONE, *, FOLD = 0)
This returns a datetime object for the date and time given in the arguments. 
If no time is given, the default is the beginning of the day of the month 

of the year.
The following are the methods defined in the datetime class.
DATETIME.CTIME(…)
This returns a ctime()-­
style time string.
>>> from datetime import datetime
>>> dt1 = datetime.now()
>>> print(f'now it is {dt1.ctime()}')
now it is Mon Jul 6 14:07:01 2020
	400	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
DATETIME.ASTIMEZONE(TZ)
This converts to the local time with the time zone set to <tz> or local.
>>> from datetime import datetime
>>> dt1 = datetime.now()
>>> print(dt1)
2020-­
07-­
06 14:07:01.046202
>>> print(dt1.astimezone())
2020-­
07-­
06 14:07:01.046202-­
06:00
>>> import pytz
>>> asiachina=pytz.timezone('Asia/Chongqing')
>>> print(dt1)
2020-­
07-­
06 14:07:01.046202
>>> print(dt1.astimezone(asiachina)) # print time in 
China
2020-­
07-­
07 04:07:01.046202+08:00
A complete list of time zone names can be found at https://​
en​
.wikipedia​
.org/​
wiki/​
List​
_of​
_tz​
_database​
_time​
_zones.
DATETIME.DATE()
This returns a date object of the date portion of the datetime object with the 
same year, month, and day.
>>> from datetime import datetime
>>> tm1 = datetime.now()
>>> print(f'now is {dtm1.ctime()}')
now is Tue Jul 7 08:50:25 2020
>>> dt1 = dtm1.date()
>>> print(f'the date is {dt1}')
the date is 2020-­
07-­
07
DATETIME.DST()
This returns the DST (daylight saving time) status of a given tzinfo.
>>> print(f'the date is {dt1}')
the date is 2020-­
07-­
07
>>> print(f'the dst status is {dtm1.dst()}')
None
	
Modules and Packages	
401
 https://doi.org/10.15215/remix/9781998944088.01
DATETIME.ISOFORMAT(SEP = 'T')
This returns a date and time string in ISO 8601 format, YYYY-­
MM-­
DDT[HH[:MM[:SS[.mmm[uuu]]]]][+HH:MM]. sep is a single character used 
to separate the year from the time, and defaults to T. timespec specifies what 
components of the time to include. The allowed values include the following: 
auto, hours, minutes, seconds, milliseconds, and microseconds.
>>> from datetime import datetime
>>> dt1 = datetime.now()
>>> print(dt1.isoformat(sep='@'))
2023-­
03-­
13@18:51:29.324588
DATETIME.REPLACE(<FIELD>=<VALUE>)
This returns a datetime object with the named field(s) replaced.
>>> dt2 = dt1.replace(year=2025)
>>> print(f'new datetime becomes {dt}')
new datetime becomes 2021-­
07-­
07 09:00:37.138388
DATETIME.TIME()
This returns a time object for the time portion of the datetime object but with 
tzinfo = None.
>>> dt1 = dtm1.date()
>>> tm1=dtm1.time()
>>> print(f'the date is {dt1}')
the date is 2020-­
07-­
07
>>> print(f'the time is {tm1}')
the time is 09:17:06.055195
DATETIME.TIMESTAMP()
This returns POSIX timestamp as a float number.
>>> tmstamp = dtm1.timestamp()
>>> print(f'The timestamp of {dtm1} is {tmstamp}')
DATETIME.TIMETUPLE()
This returns a time-­
tuple compatible with time.localtime().
>>> tmtuple = dtm1.timetuple()
>>> print(f'The time-­
tuple of {dtm1} is {tmtuple}')
	402	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
DATETIME.TIMETZ()
This returns a time object with the same time and tzinfo. Note the difference 
between timetz() and time().
>>> tminfo = dtm1.timetz()
>>> print(f'The time of {dtm1} is {tminfo}')
The timezone info of 2020-­
07-­
07 09:24:39.517213 is 
09:24:39.517213
DATETIME.TZNAME(…)
This returns the tzname of tzinfo.
>>> import pytz
>>> tz = pytz.timezone('Canada/Mountain')
>>> dtm = datetime.fromisoformat('2020-­
07-­
05T21:05:33')
>>> ndtm = dtm.replace(tzinfo = tz)
>>> tmzname = ndtm.tzname()
>>> print(f'The timezone for {ndtm} is {tmzname}')
The timezone for 2020-­
07-­
05 21:05:33-­
07:34 is LMT
DATETIME.UTCOFFSET(…)
This returns utcoffset of tzinfo.
>>> tmzutcoffset = ndtm.utcoffset()
>>> print(f'The timezone utc offset of {ndtm} is 
{tmzutcoffset}')
The timezone utc offset of 2020-­
07-­
05 21:05:33-­
07:34 is 
-­
1 day, 16:26:00
The following are some class methods defined in the datetime class.
DATETIME.COMBINE(DT, TM)
This combines the date dt and time tm into a datetime object and returns the 
datetime object.
>>> dt = datetime.date.today()
>>> tm = datetime.time(20,59,12)
>>> dtm = datetime.datetime.combine(dt, tm)
>>> print(f'date is {dt}, time is {tm}, datetime is {dtm}')
	
Modules and Packages	
403
 https://doi.org/10.15215/remix/9781998944088.01
date is 2020-­
07-­
05, time is 20:59:12, datetime is 
2020-­
07-­
05 20:59:12
DATETIME.FROMISOFORMAT(DTMSTR)
This constructs the datetime object from a date and time string in ISO format 
and returns the converted datetimeobject. Remember that the ISO time string 
format is YYYY-­
MM-­
DDTHH:MM:SS:mmm:uuu.
>>> dtm = datetime.datetime.fromisoformat('2020-­
07
-­
05T21:05:33')
>>> print(dtm)
2020-­
07-­
05 21:05:33
DATETIME.FROMTIMESTAMP(…)
This constructs a datetime object from a POSIX timestamp.
>>> tmstamp1 = ndtm.timestamp()
>>> print(f'The time stamp of {ndtm} is {tmstamp1}')
The time stamp of 2020-­
07-­
05 21:05:33-­
07:34 is 
1594010373.0
>>> redtmobj = datetime.fromtimestamp(tmstamp1)
>>> print(f'It is a different object and the time value 
has changed to {redtmobj}')
It is a different object, and the time value has changed 
to 2020-­
07-­
05 22:39:33.
DATETIME.NOW(TZ = NONE)
This returns a datetime object representing the current time local to tz, which 
should be a Timezone object if given. If no tz is specified, the local timezone 
is used.
>>> from datetime import datetime   # import the datetime 
class from the datetime module
>>> dt1 = datetime.now()
>>> print(f'it is {dt1}')
it is 2020-­
07-­
05 11:22:48.876825
DATETIME.STRPTIME(<DATE_STRING, FORMAT>)
This returns a datetime object by parsing a date_string, based on a given format.
	404	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> dtstring = "7 July, 2020"
>>> dtobj = datetime.strptime(dtstring, "%d %B, %Y")   # 
note the date formatting string
>>> print("date object = ", dtobj)
 
date object = 2020-­
07-­
07 00:00:00
DATETIME.TODAY()
This returns a datetime object for today.
>>> dt2 = datetime.today()
>>> print(f'Today is {dt2}')
Today is 11:34:09.228618
DATETIME.UTCFROMTIMESTAMP()
This constructs a naive UTC datetime from a POSIX timestamp.
>>> redtmobj = datetime.utcfromtimestamp(tmstamp1)
>>> print(f'{redtmobj} is a UTC datetime from a POSIX 
timestamp {redtmobj}')
2020-­
07-­
06 04:39:33 is a UTC datetime from a POSIX 
timestamp 1594010373.0
DATETIME.UTCNOW()
This returns a new datetime representing the UTC day and time.
>>> dt2 = datetime.today()
>>> dt3 = datetime.utcnow()
>>> print(f'Today is {dt2}, and the UTC time is {dt3}')
Today is 2020-­
07-­
07 11:37:02.862356, and the UTC time is 
2020-­
07-­
07 17:37:02.862356
Sometimes, you need to deal with time intervals such as how long has passed 
since the last time you saw your best friend. That is what the timedelta class is 
defined for in the datetime module. The following is the constructor of the class.
DATETIME.TIMEDELTA(DAYS = 0, SECONDS = 0, MICROSECONDS 
= 0, MILLISECONDS = 0, MINUTES = 0, HOURS = 0, WEEKS = 0)
This constructs and returns a timedelta object. Note that all arguments are 
optional, and all default to 0 if not provided.
	
Modules and Packages	
405
 https://doi.org/10.15215/remix/9781998944088.01
>>> from datetime import timedelta
>>> ndlt = timedelta(days = 31)
TIMEDELTA.TOTAL_SECONDS(…)
This returns the total number of seconds in the duration.
>>> print(f'the total number of seconds in 31 days is 
{ndlt.total_seconds()}')
the total number of seconds in 31 days is 2678400.0
>>> ndlt = timedelta(31, 25, hours = -­
3)
>>> print(f'the total number of seconds in 31 days is 
{ndlt.total_seconds()}')
the total number of seconds in 31 days and 25 seconds 
minus 3 hours is 2667625.0
The Time Module
The second of these modules is the time module. It comes with the standard 
Python distribution, so there is no need for you to install anything in par­
ticular. This module can be imported and used directly within your program 
when needed. The following statements get us a list of the names defined in 
the module:
>>> import time
>>> dir(time)
['_STRUCT_TM_ITEMS', '__doc__', '__loader__', '__
name__', '__package__', '__spec__', 'altzone', 
'asctime', 'clock', 'ctime', 'daylight', 'get_clock_
info', 'gmtime', 'localtime', 'mktime', 'monotonic', 
'monotonic_ns', 'perf_counter', 'perf_counter_ns', 
'process_time', 'process_time_ns', 'sleep', 
'strftime', 'strptime', 'struct_time', 'thread_time', 
'thread_time_ns', 'time', 'time_ns', 'timezone', 
'tzname']
In the following, we explain the names, including attributes and functions, 
available in the time module on a Windows platform. The code samples are all 
shown as they would appear in a Python interactive shell. If you wish to see 

all functions defined in the time module, please read the documentation at 
https://​
docs​
.python​
.org/​
3/​
library/​
time​
.html.
	406	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
TIME.ALTZONE
This is an attribute that contains the offset of the local DST timezone in seconds 
west of UTC, if one is defined. The value is negative if the local DST timezone is 
east of UTC (as in Western Europe, including the UK). Only use this if daylight 
is nonzero.
>>> import time
>>> print("local time zone is %d " % (time.altzone/3600))
local time zone is 6
TIME.ASCTIME(TUPLETIME)
This accepts a time-­
tuple and returns a readable 24-­
character string such as Tue 
Dec 11 18:07:14 2008. A time-­
tuple has nine elements, as returned by gmtime() 
or localtime().
>>> import time   # you only need to import a module 
once, so this is just in case
>>> print("local time is %s " % (time.asctime()))
local time is Tue Nov 12 15:10:50 2019
>>> time.asctime(tuple(time.localtime()))
'Tue Nov 12 15:24:05 2019'
TIME.CLOCK()
This returns a floating-­
point number for the CPU time or real time since the 
start of the process or since the first call to clock(). It is very useful, especially 
when measuring the computational cost of a code block.
>>> time.clock()
428446.1717301
TIME.CTIME([SECS])
This returns a time in seconds since the epoch to a string in the local time. 
Remember that the argument in [] is optional.
This has the same result as asctime(localtime(secs)), and simply a call of 
asctime(), which will use the current local time in seconds.
>>> time.asctime()
'Tue Nov 12 15:24:49 2019'
>>> time.ctime()
'Tue Nov 12 15:24:55 2019'
	
Modules and Packages	
407
 https://doi.org/10.15215/remix/9781998944088.01
TIME.GET_CLOCK_INFO(NAME)
This returns information on the specified clock as a namespace object. Sup­
ported clock names and the corresponding functions to read their value are 
the following: monotonic, perf_counter, process_time, thread_time, and time.
>>> time.get_clock_info('monotonic')
namespace(adjustable = False, 
implementation='GetTickCount64()', monotonic=True, 
resolution = 0.015625)
>>> time.get_clock_info('time')
namespace(adjustable = True, implementation = 
'GetSystemTimeAsFileTime()', monotonic=False, 
resolution=0.015625)
TIME.GMTIME([SECS])
This accepts an instant expressed in seconds since the epoch and returns 

a time-­
tuple t with the UTC time. Note: t.tm_isdst is always 0.
>>> time.gmtime()
time.struct_time(tm_year = 2019, tm_mon = 11, tm_mday = 
12, tm_hour = 22, tm_min = 21, tm_sec = 31, tm_wday = 1, 
tm_yday = 316, tm_isdst = 0)
>>> tuple(time.gmtime())
(2019, 11, 12, 22, 22, 2, 1, 316, 0)
TIME.LOCALTIME([SECS])
This accepts an instant expressed in seconds since the epoch and returns 

a time-­
tuple t with the local time (t.tm_isdst is 0 or 1, depending on whether 
DST applies to instant secs by local rules).
>>> time.localtime()
time.struct_time(tm_year = 2019, tm_mon = 11, tm_mday = 
12, tm_hour = 15, tm_min = 19, tm_sec = 0, tm_wday = 1, 
tm_yday = 316, tm_isdst = 0)
>>> tuple(time.localtime())
(2019, 11, 12, 15, 22, 32, 1, 316, 0)
TIME.MKTIME(TUPLETIME)
This accepts a time instant expressed as a time-­
tuple in the local time and returns 
a floating-­
point value, with the instant expressed in seconds since the epoch.
	408	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> time.mktime((2019, 11, 12, 22, 22, 2, 1, 316, 0))
1573622522.0
TIME.MONOTONIC()
This returns the value of a monotonic clock as a float number, the number 
of seconds since the previous call. The clock is not affected by system clock 
updates. The reference point of the returned value is undefined, so that only 
the difference between the results of consecutive calls is valid.
>>> time.monotonic()
1557979.093
TIME.MONOTONIC_NS()
This is similar to monotonic() but returns time as nanoseconds.
>>> time.monotonic_ns()
1557954406000000
TIME.PERF_COUNTER()
This returns the value of a performance counter as a float number since the 
previous call. A performance counter is a clock with the highest available 
resolution to measure a short duration. It includes time elapsed during 
sleep and is system-­
wide. The reference point of the returned value is 
undefined, so that only the difference between the results of consecutive calls 

is valid.
>>> time.perf_counter()
429437.6389873
TIME.PERF_COUNTER_NS()
This is similar to perf_counter() but returns time as nanoseconds.
>>> time.perf_counter_ns()
429556266018100
TIME.PROCESS_TIME()
This returns the value (in fractional seconds) of the sum of the system and the 
user CPU time of the current process. It does not include time elapsed during 
sleep. It is process-­
wide by definition. The reference point of the returned value 
	
Modules and Packages	
409
 https://doi.org/10.15215/remix/9781998944088.01
is undefined so that only the difference between the results of consecutive 
calls is valid.
>>> time.process_time()
6.71875
TIME.PROCESS_TIME_NS()
This is similar to process_time() but returns time as nanoseconds.
>>> time.process_time_ns()
6687500000
TIME.SLEEP(SECS)
This suspends the calling thread for secs (seconds). It can be used to delay 
programs.
>>> time.sleep(6)   # sleep 6 seconds
TIME.STRFTIME(FMT[,TUPLETIME])
This accepts an instant expressed as a time-­
tuple in the local time and returns 
a string representing the instant as specified by string fmt.
>>> t = (2019, 11, 17, 17, 3, 38, 1, 48, 0)
>>> t = time.mktime(t)
>>> print(time.strftime("%b %d %Y %H:%M:%S", time.
gmtime(t)))
Nov 18 2019 00:03:38
TIME.STRPTIME(STRINGTIME[, FMT])
This parses str according to format string fmt and returns the instant in 
time-­
tuple format.
>>> time.strptime('Tue Nov 12 15:24:05 2019','%a %b %d 
%H:%M:%S %Y')
time.struct_time(tm_year = 2019, tm_mon = 11, tm_mday = 
12, tm_hour = 15, tm_min = 24, tm_sec = 5, tm_wday = 1, 
tm_yday = 316, tm_isdst = -­
1)
>>> tuple(time.strptime('Tue Nov 12 15:24:05 2019','%a %b 
%d %H:%M:%S %Y'))
(2019, 11, 12, 15, 24, 5, 1, 316, -­
1)
	410	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
TIME.TIME()
This returns the current time instant, a floating-­
point number of seconds 

since the epoch.
>>> time.time()
1573607220.4043384
>>> time.asctime(time.localtime(time.time()))   # it is 
the same as time.asctime()
'Mon Jun 8 13:59:35 2020'
>>> time.asctime()
'Mon Jun 8 13:59:45 2020'
The Calendar Module
If you prefer a simple and more direct module to handle time and date, you 
can use the calendar module, as detailed below.
CALENDAR.CALENDAR(YEAR, W = 2, L = 1, C = 6)
This returns a formatted calendar for year—­
a multiline string formatted into 
three columns separated by c spaces. w is the width in characters of each date; 
each line has length 21 * w + 18 + 2 * c. l is the number of lines for each week.
>>> import calendar as cl
>>> print(cl.calendar(2021))
                                2021
       January                 February                 March
Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su
             1  2  3     1  2  3  4  5  6  7     1  2  3  4  5  6  7
 4  5  6  7  8  9 10     8  9 10 11 12 13 14     8  9 10 11 12 13 14
11 12 13 14 15 16 17    15 16 17 18 19 20 21    15 16 17 18 19 20 21
18 19 20 21 22 23 24    22 23 24 25 26 27 28    22 23 24 25 26 27 28
25 26 27 28 29 30 31                            29 30 31
       April                    May                     June
Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su
          1  2  3  4                    1  2        1  2  3  4  5  6
 5  6  7  8  9 10 11     3  4  5  6  7  8  9     7  8  9 10 11 12 13
12 13 14 15 16 17 18    10 11 12 13 14 15 16    14 15 16 17 18 19 20
19 20 21 22 23 24 25    17 18 19 20 21 22 23    21 22 23 24 25 26 27
26 27 28 29 30          24 25 26 27 28 29 30    28 29 30
                        31
	
Modules and Packages	
411
 https://doi.org/10.15215/remix/9781998944088.01
       July                    August                September
Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su
          1  2  3  4                       1           1  2  3  4  5
 5  6  7  8  9 10 11     2  3  4  5  6  7  8     6  7  8  9 10 11 12
12 13 14 15 16 17 18     9 10 11 12 13 14 15    13 14 15 16 17 18 19
19 20 21 22 23 24 25    16 17 18 19 20 21 22    20 21 22 23 24 25 26
26 27 28 29 30 31       23 24 25 26 27 28 29    27 28 29 30
                        30 31
       October                November                December
Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su
             1  2  3     1  2  3  4  5  6  7           1  2  3  4  5
 4  5  6  7  8  9 10     8  9 10 11 12 13 14     6  7  8  9 10 11 12
11 12 13 14 15 16 17    15 16 17 18 19 20 21    13 14 15 16 17 18 19
18 19 20 21 22 23 24    22 23 24 25 26 27 28    20 21 22 23 24 25 26
25 26 27 28 29 30 31    29 30                   27 28 29 30 31
CALENDAR.FIRSTWEEKDAY()
This returns an integer that is the current setting for the weekday that starts each 
week. By default, when the calendar module is first imported, it is 0 for Monday.
>>> import calendar as cl
>>> cl.firstweekday()
0
CALENDAR.ISLEAP(YEAR)
This tests if a year is a leap year. It returns True if it is; it returns False otherwise.
>>> cl.isleap(2022)
False
CALENDAR.LEAPDAYS(Y1, Y2)
This returns the total number of leap days in the years within range(y1, y2).
>>> cl.leapdays(2020, 2030)
3
CALENDAR.MONTH(YEAR, MONTH, W = 2, L = 1)
This returns a multiline string with a calendar for month of year, one line per 
week plus two header lines. w is the width in characters of each date; each line 
has length 7 * w + 6. l is the number of lines for each week.
	412	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> print(cl.month(2021, 3))
     March 2021
Mo Tu We Th Fr Sa Su
 1  2  3  4  5  6  7
 8  9 10 11 12 13 14
15 16 17 18 19 20 21
22 23 24 25 26 27 28
29 30 31
CALENDAR.MONTHCALENDAR(YEAR, MONTH)
This returns a list of sublists of integers. Each sublist denotes a week starting 
from Monday. Days outside month of year are set to 0; days within the month 
are set to their day-­
of-­
month, 1 and up. The result as a list of sublists can be 
conveniently used in applications. For example, you can easily tell what date 
it is for Monday of the third week of a month.
>>> print(cl.monthcalendar(2020, 6))
[[1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12, 13, 14], [15, 16, 17, 18, 
19, 20, 21], [22, 23, 24, 25, 26, 27, 28], [29, 30, 0, 0, 0, 0, 0]]
CALENDAR.MONTHRANGE(YEAR, MONTH)
This returns two integers. The first one is the code of the weekday for the first 
day of the month in year; the second one is the number of days in the month. 
Weekday codes are 0 (Monday) to 6 (Sunday); month numbers are 1 (January) 
to 12 (December). This is useful if you want to print a calendar that begins on 
a specific day of the week.
>>> print(cl.monthrange(2020, 6))
(0, 30)
CALENDAR.PRCAL(YEAR, W = 2, L = 1, C = 6)
This prints a well-­
formatted calendar of a given year. It is the same as calendar.
calendar(year, w, l, c). Remember that w is the width of each date in number 
of characters and l is the number of lines for each week.
>>> cl.prcal(2020, w = 2, l = 1, c = 6)
                                 2020
       
January                 
February                  
March
Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su
       1  2  3  4  5                   1  2                       1
 6  7  8  9 10 11 12     3  4  5  6  7  8  9     2  3  4  5  6  7  8
13 14 15 16 17 18 19    10 11 12 13 14 15 16     9 10 11 12 13 14 15
20 21 22 23 24 25 26    17 18 19 20 21 22 23    16 17 18 19 20 21 22
27 28 29 30 31          24 25 26 27 28 29       23 24 25 26 27 28 29
                                                30 31
	
Modules and Packages	
413
 https://doi.org/10.15215/remix/9781998944088.01
 
        
April                    May                     June
Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su
       1  2  3  4  5                 1  2  3     1  2  3  4  5  6  7
 6  7  8  9 10 11 12     4  5  6  7  8  9 10     8  9 10 11 12 13 14
13 14 15 16 17 18 19    11 12 13 14 15 16 17    15 16 17 18 19 20 21
20 21 22 23 24 25 26    18 19 20 21 22 23 24    22 23 24 25 26 27 28
27 28 29 30             25 26 27 28 29 30 31    29 30
 
        July                   August                 
September
Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su
       1  2  3  4  5                    1  2        1  2  3  4  5  6
 6  7  8  9 10 11 12     3  4  5  6  7  8  9     7  8  9 10 11 12 13
13 14 15 16 17 18 19    10 11 12 13 14 15 16    14 15 16 17 18 19 20
20 21 22 23 24 25 26    17 18 19 20 21 22 23    21 22 23 24 25 26 27
27 28 29 30 31          24 25 26 27 28 29 30    28 29 30
                        31
 
       
October                 November                December
Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su
          1  2  3  4                       1        1  2  3  4  5  6
 5  6  7  8  9 10 11     2  3  4  5  6  7  8     7  8  9 10 11 12 13
12 13 14 15 16 17 18     9 10 11 12 13 14 15    14 15 16 17 18 19 20
19 20 21 22 23 24 25    16 17 18 19 20 21 22    21 22 23 24 25 26 27
26 27 28 29 30 31       23 24 25 26 27 28 29    28 29 30 31
                        30
CALENDAR.PRMONTH(YEAR, MONTH, W = 2, L = 1)
This prints a well-­
formatted calendar month, the same as the one created by 
calendar.month(year, month, w, l).
>>> cl.prmonth(2020, 6, w = 2, l = 1)
      June 2020
  Mo Tu We Th Fr Sa Su
   1  2  3  4  5  6  7
   8  9 10 11 12 13 14
  15 16 17 18 19 20 21
  22 23 24 25 26 27 28
  29 30
	414	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
CALENDAR.SETFIRSTWEEKDAY(WEEKDAY)
This sets the first day of each week. Weekday codes are 0 (Monday by default) 
to 6 (Sunday by default), so if you change this, you will see the days in the 
calendar shift.
>>> cl.setfirstweekday(6)   # set to start from Sunday
>>> cl.prmonth(2020, 6, w = 2, l = 1)
       June 2020
  Su Mo Tu We Th Fr Sa
      1  2  3  4  5  6
   7  8  9 10 11 12 13
  14 15 16 17 18 19 20
  21 22 23 24 25 26 27
  28 29 30
CALENDAR.TIMEGM(TUPLETIME)
This is the inverse of time.gmtime. It accepts a time instant in time-­
tuple form and 
returns the same instant as a floating-­
point number of seconds since the epoch.
>>> cl.timegm((2020, 6, 19, 11, 35, 56))
1592566556
CALENDAR.WEEKDAY(YEAR, MONTH, DAY)
This returns the weekday code for the given date. Weekday codes are 0 (Monday) 
to 6 (Sunday); month numbers are 1 (January) to 12 (December).
>>> import calendar as cl
>>> cl.weekday(2020, 6, 19)   # it is a Friday
4
Our last example in Jupyter Lab is to display a calendar for March of 1961.
import calendar
cld = calendar.month(1961, 3)
print(cld)
       March 1961
  Mo Tu We Th Fr Sa Su
         1  2  3  4  5
   6  7  8  9 10 11 12
  13 14 15 16 17 18 19
  20 21 22 23 24 25 26
  27 28 29 30 31
	
Modules and Packages	
415
 https://doi.org/10.15215/remix/9781998944088.01
With the calendar module, you will be able to produce a calendar of any 
year you want.
8.7 Modules for Data Representation and Exchange
JavaScript Object Notation (JSON) is a lightweight data interchange format widely 
used today. JSON can be used to represent different types of data, though the 
most used are objects or associate arrays made of key-­
value pairs. When used for 
data interchanges between applications, JSON data are represented in a string 
so that they can be stored, transmitted, and parsed by different applications.
Python has a built-­
in module called json to handle JSON data. The following 
two statements will get us a list of the few names defined in the json module:
>>> import json
>>> dir(json)
['JSONDecodeError', 'JSONDecoder', 'JSONEncoder', '__all__', 
'__author__', '__builtins__', '__cached__', '__doc__', 
'__file__', '__loader__', '__name__', '__package__', 
'__path__', '__spec__', '__version__', '_default_decoder', 
'_default_encoder', 'codecs', 'decoder', 'detect_encoding', 
'dump', 'dumps', 'encoder', 'load', 'loads', 'scanner']
In the following, we explain two pairs of important functions provided in 
the json module. The first pair of functions is used to convert JSON data to 
Python data, which is called deserialization or decoding. The other is used 

to convert Python data to JSON data, which is called serialization.
JSON.LOADS(S, *, ENCODING=NONE, CLS=NONE, OBJECT_
HOOK=NONE, PARSE_FLOAT=NONE, PARSE_INT=NONE, 
PARSE_CONSTANT=NONE, OBJECT_PAIRS_HOOK=NONE, **KW)
This deserializes json data in s, which can be a str, byte, or bytearray instance 
containing a JSON document and returns a Python object of s. Or, in plainer 
terms, it converts a string of JSON data into a Python object and returns the 
converted Python object.
>>> import json
>>> sj = '{"firstname": "Jone", "lastname": "Doe"}'
>>> pdict = json.loads(sj)
>>> print(pdict)
 
{'firstname': 'Jone', 'lastname': 'Doe'}
	416	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
JSON.LOAD(FP
, *, CLS = NONE, OBJECT_HOOK = NONE, PARSE_
FLOAT=NONE, PARSE_INT = NONE, PARSE_CONSTANT = NONE, 
OBJECT_PAIRS_HOOK = NONE, **KW)
This deserializes data in a file object or file-­
like object, such as a socket, referred 
to as fp that contains a JSON document, making it a Python object. Note the 
difference between loads and load function: loads convert JSON data in a string, 
whereas load converts JSON data in a file.
>>> import json
>>> from io import StringIO
>>> sio = StringIO('{"firstname": "Jone", "lastname": 
"Doe"}')
>>> json.load(sio)
{'firstname': 'Jone', 'lastname': 'Doe'}
The next pair of functions are used to convert Python objects into JSON data. 
This process is called serialization or encoding.
JSON.DUMPS(OBJ, *, SKIPKEYS=FALSE, ENSURE_ASCII=TRUE, 
CHECK_CIRCULAR=TRUE, ALLOW_NAN = TRUE, CLS = NONE, 
INDENT = NONE, SEPARATORS = NONE, DEFAULT = NONE, SORT_
KEYS=FALSE, **KW)
This serializes a Python object obj and returns a JSON-­
formatted string of the 
object.
>>> print(pdict)
{'firstname': 'Jone', 'lastname': 'Doe'}
>>> js = json.dumps(pdict)
>>> print(js)   # please note the double quotation marks 
used in JSON-­
formatted data
{"firstname": "Jone", "lastname": "Doe"}
JSON.DUMP(OBJ, FP
, *, SKIPKEYS = FALSE, ENSURE_ASCII = 
TRUE, CHECK_CIRCULAR = TRUE, ALLOW_NAN = TRUE, CLS = 
NONE, INDENT = NONE, SEPARATORS = NONE, DEFAULT = NONE, 
SORT_KEYS = FALSE, **KW)
This serializes the Python object obj and writes it as a JSON-­
formatted stream 
to a writable file or file-­
like object, such as a socket, referred to as fp.
	
Modules and Packages	
417
 https://doi.org/10.15215/remix/9781998944088.01
>>> from io import StringIO
>>> io = StringIO()
>>> json.dump({'firstname': 'Jone', 'lastname': 'Doe'}, io)
>>> io.getvalue()
'{"firstname": "Jone", "lastname": "Doe"}'
Conversions can be made between JSON and Python on different types of 

data. Table 8-­
2 shows those conversions.
Table 8-­
2: Conversion between JSON and Python data
Python
Sample Python 
data
JSON
Sample JSON 
data
dict
{'firstname': 
'Jone', 
'lastname': 
'Doe'}
Object
{"firstname": 
"Jone", 
"lastname": 
"Doe"}
list
['James', 
'Jone', 
'Smith', 
'Doe']
Array
["James", 
"Jone", 
"Smith", 
"Doe"]
tuple
('James', 
'Jone', 
'Smith', 
'Doe')
Array
["James", 
"Jone", 
"Smith", 
"Doe"]
str
"James, Jone, 
Smith, Doe"
String
"James, Jone, 
Smith, Doe"
int
98765321
Number
98765321
float
98765.321
Number
98765.321
True
True
true
true
False
False
false
false
None
None
null
null
As you can see, all basic Python data can be converted/serialized into JSON 
data, and vice versa. However, trying to serialize multiple Python objects by 
repeatedly calling dump() using the same file handle will result in an invalid 
JSON file because when doing deserialization with load() from the file, load has 
no way to find out the boundary between different JSON data. As such, there 
will be only one serialized Python object per file.
	418	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
8.8 Modules for Interfacing Operating Systems and 
Python Interpreter
On a computer, all applications run on top of an operating system (OS) such as 
Windows, MacOS, or Linux. Therefore, quite often when developing applica­
tions, you will need to interact with an OS, file paths, and the Python interpreter. 
In Python, the built-­
in os module, path submodule of os, and sys module provide 
powerful and convenient ways to interact with the OS, the file path, the Python 
interpreter, and the runtime environment.
OS Module for Interacting with the Operating System
Since it is a built-­
in module, all you need to do to use the os module is import it, 
as shown below:
import os
If you use the dir(os) statement, you can get a rather big list of names defined in 
the module. Note that because the os module is operating-­
system dependent, 
you may get a different list of names available depending on your platform (e.g., 
Windows or Linux).
The following are some functions provided in the os module. You are encour­
aged to test these functions with your own examples on your own machine.
OS.ACCESS(PATH, MODE)
This tests if access to path is in mode, which is an integer such as 777 (111111111) 
representing the global, group, and user’s executable, write, and read rights.
>>> import os
>>> p = os.path.abspath(".")
>>> p
'd:\\workshop'
>>> os.access(p,763)
True
OS.CHDIR(PATH)
This changes the current working directory to path.
>>> os.chdir('c:\\workbench')
>>> os.getcwd()
' c:\\workbench'
>>> os.listdir()
['myprimes.txt', ' news_01.txt', ' personal']
	
Modules and Packages	
419
 https://doi.org/10.15215/remix/9781998944088.01
OS.CHMOD(PATH, MODE)
This changes the mode of path to the numeric mode.
>>> os.chmod('c:\\workbench', 477)
OS.CHOWN(PATH, UID, GID)
This changes the owner and group id of path to the numeric uid and gid. Please 
note that these operations are more similar to what you would do on a Unix/
Linux system, all subject to permission by the operating system.
OS.CLOSE(FD)
This closes the file descriptor fd. A file descriptor is returned by the os.open() 
function.
>>> fd = os.open('/home/james/testing.txt')
>>> os.close(fd)
OS.CPU_COUNT()
This returns the number of CPUs in the system; it will return None if the num­
ber is indeterminable.
>>> os.cpu_count()
8
OS.GET_EXEC_PATH(ENV=NONE)
This returns the sequence of directories that will be searched for by the named 
executable.
>>> import os
>>> print(os.get_exec_path())
['/opt/tljh/user/bin', '/usr/local/sbin', '/usr/local/
bin', '/usr/sbin', '/usr/bin', '/sbin', '/bin', '/snap/
bin']
OS.GETCWD()
This returns a Unicode string representing the current working directory.
>>> import os
>>> print(os.getcwd())
/home/jupyter-­
kevin
	420	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
OS.GETCWDB()
This returns a byte string representing the current working directory.
>>> import os
>>> print(os.getcwdb())
b'/home/jupyter-­
kevin'
OS.GETENV(KEY, DEFAULT=NONE)
This returns an environment variable and returns None if it does not exist. The 
optional second argument can specify an alternate default.
OS.GETLOGIN()
This returns the actual login name.
>>> os.getlogin()
kevin
OS.LINK(SRC, DST)
This creates a hard link pointing to src named dst.
OS.LISTDIR(PATH)
This returns a list containing the names of the entries in the directory given 
by path.
>>> os.listdir('.')
['backups', 'Pipfile', 'snap']
OS.MKDIR(PATH, MODE=511, DIR_FD=NONE)
This function is used to create a directory, the mode argument only used on 
Unix-­
like systems, and will be ignored on Windows. The path argument is 
required; the mode argument is optional and takes an integer representing 
permission for the path to be created. Argument _dir_fd is a file descriptor 
referring to a directory that the new directory will be under; the path is not an 
absolute path. The default value is None.
>>> import os
>>> os.mkdir('/home/james/learn_python')
>>> os.listdir('.')
['backups', 'learn_python', 'Pipfile', 'snap']
	
Modules and Packages	
421
 https://doi.org/10.15215/remix/9781998944088.01
OS.MAKEDIRS(PATH, MODE = 511, EXIST_OK = FALSE)
This recursively makes directories. For example, if the path is ./comp218/
assignment1, it will first make a directory named comp218 under the current 
working directory, if it doesn’t exist, then make assignment1 under comp218. 
The optional mode argument is the same as the one in os.mkdir(). The optional 
exist_ok argument tells if the operation will continue if the leaf directory already 
exists. The default is False, meaning that a FileExistsError will be raised if the 
leaf directory already exists.
OS.OPEN(PATH, FLAGS, MODE = 511, *, DIR_FD = NONE)
This opens the file path and sets various flags for low-­
level IO and returns a 
file descriptor to be used by other functions in the os module. Argument dir_fd 
should be a file descriptor open to a directory (if not default None) and can be 
used to provide a directory that the file path is relative to. The flags argument 
tells what the path is opened for. It can take one or some of the following values 
joined with or |: os.O_RDONLY, os.O_WRONLY, os.O_RDWR, os.O_APPEND, 
os.O_CREAT, os.O_EXCL¶, os.O_TRUNC. These values are available on both 
Windows and Unix platforms.
OS.PUTENV(NAME, VALUE)
This changes or adds an environment variable if name doesn’t exist yet.
>>> os.times()
nt.times_result(user = 4.125, system = 1.890625, children_
user = 0.0, children_system = 0.0, elapsed = 0.0)
OS.READ(FD, N)
This reads at most n bytes from file descriptor fd and returns a string containing 
the bytes read. If the end of the file referred to by fd has been reached, an 
empty string is returned.
OS.UMASK(MASK)
This sets the current numeric umask to mask and returns the previous umask. 
umask is used by operating systems to determine the default permission for 
newly created files.
>>> import os
>>> os.umask(666)   # from now on all new files created 
will have umask 666 till next change
256
	422	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
OS.URANDOM(SIZE)
This returns a bytes object containing random bytes suitable for cryptographic use.
>>> os.urandom(5)
b'-­
\x8e\xeb\xf1\x7f'
OS.UTIME(PATH, TIMES = NONE)
This sets the access and modified times of path, such as on a file.
OS.WALK(TOP)
This is a directory-­
tree generator and returns a walk object. For each directory 
in the directory tree rooted at top, it will yield a three-­
tuple (dirpath, dirnames, 
filenames), in which dirpath is a string, the path to the directory; dirnames is 
a list of the names of the subdirectories in dirpath; and filenames is a list of 
the names of the nondirectory files in dirpath.
Note that the names in the lists are just names, with no path components. 
To get a full path (which begins with top) to a file or directory in dirpath, use 
os.path.join(dirpath, name).
In [ ]:
import os
# loop through all the directories and files
for dirName, subdirList, fileList in os.walk('.'):
    print('Found directory: %s' % dirName)
    for fname in fileList:
        print('\t%s' % fname)
Out [ ]:
Found directory: ./samples
        average marks​
.py
        brutal attack on cipher​
.py
        circle​
-­
­
v2​
.py
Found directory: ./samples/chapter3
    randomness​
.py
    regex1​
.py
    scratch​
-­
­
v3​
.py
    sieve prime​
.py
OS.WALK(TOP
, TOPDOWN = TRUE, ONERROR = NONE, 
FOLLOWLINKS = FALSE)
This generates the file names in a directory tree by walking the tree either from 
the top down or from the bottom up. The os.walk function will be very useful 
in completing one of the projects in the textbook.
	
Modules and Packages	
423
 https://doi.org/10.15215/remix/9781998944088.01
OS.WRITE(FD, STR)
This writes the string str to the file descriptor fd and returns the number of 
bytes actually written.
The path Submodule from os for Manipulating File Paths
When dealing with files and file systems, we quite often need to manipulate 
file paths. For that reason, the os module has a submodule called path. To use 
the path module, run the following statement:
>>> from os import path
The path module provides functions for joining and splitting paths, getting 
information about a path or file such as its size and timestamp, and testing 
whether a path is a file, a directory, a real path, or just a link.
PATH.ABSPATH(P)
This returns the absolute version of p.
>>> path.abspath('.')
'd:\\workshop\\comp218'
PATH.BASENAME(P)
This returns the final component of a pathname.
>>> os.path.basename(p)
'comp218'
PATH.COMMONPATH(PATHS)
This returns the longest common subpath for a given sequence of pathnames.
>>> os.path.commonpath(['d:/workshop/comp218','d:/
workshop/comp369'])
'd:\\workshop'
PATH.COMMONPREFIX(PATHS)
This returns the longest common leading component of a given list of pathnames.
>>> os.path.commonprefix(['d:/workshop/comp218','d:/
workshop/comp369'])
'd:/workshop/comp'
	424	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
PATH.DIRNAME(P)
This returns the directory component of a pathname.
>>> os​
.path​
.dirname​
(​
'd:​
/​
workshop/​
comp218/​
test​
.py')
'd:/workshop/comp218'
PATH.EXISTS(P)
This tests whether a path exists. It returns False for broken symbolic links.
>>> os​
.path​
.exists​
(​
'd:​
/​
workshop/​
comp218/​
test​
.py')
False
PATH.EXPANDUSER(P)
This expands ~ and ~user constructs, mostly for Unix/Linux systems. If user 
or $HOME is unknown, it does nothing.
>>> os​
.path​
.expanduser​
('​
~/​
workshop/​
comp218/​
test​
.py')
'C:\\Users\\kevin/​
workshop/​
comp218/​
test​
.py'
PATH.EXPANDVARS(P)
This expands shell variables of the forms $var, ${var}, and %var%. Unknown 
variables will be left unchanged.
PATH.GETATIME(FILENAME)
This returns the time a file was last accessed, as reported by os.stat().
PATH.GETCTIME(FILENAME)
This returns the time a file’s metadata was last changed, as reported by 
os.stat().
PATH.GETMTIME(FILENAME)
This returns the time a file was last modified, as reported by os.stat().
PATH.GETSIZE(FILENAME)
This returns the size of a file, as reported by os.stat().
PATH.ISABS(S)
This tests whether a path is absolute.
	
Modules and Packages	
425
 https://doi.org/10.15215/remix/9781998944088.01
PATH.ISDIR(P)
PATH._ISDIR(P)
These return True if the pathname refers to an existing directory.
>>> from os import path
>>> path.isdir('.')
True
PATH.ISFILE(P)
This tests whether a path is a regular file.
>>> from os import path
>>> path.isfile('.')
False
PATH.ISLINK(P)
This tests whether a path is a symbolic link. It will always return False for 
Windows prior to 6.0.
PATH.ISMOUNT(P)
This tests whether a path is a mount point (a drive root, the root of a share, or 
a mounted volume).
PATH.JOIN(P1, P2)
This is used to join two paths or a path with a file.
>>> from os import path
>>> fullpath = path.join('/comp218/', 'testfile')
>>> print(fullpath)
/comp218/testfile
PATH.LEXISTS(P)
This tests whether a path exists. It will return True for broken symbolic links.
PATH.NORMCASE(S)
This normalizes the case of a pathname. That is, it makes all characters lower 
case and all slashes backslashes.
PATH.NORMPATH(P)
This normalizes the path, eliminating double slashes, etc.
	426	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
PATH.ABSPATH(P)
This returns the absolute version of a path.
PATH.RELPATH(P
, START=NONE)
This returns a relative version of a path.
PATH.SAMEFILE(F1, F2)
This tests whether two pathnames reference the same actual file or directory.
PATH.SAMEOPENFILE(FP1, FP2)
This tests whether two open file objects reference the same file.
PATH.SAMESTAT(S1, S2)
This tests whether two stat buffers reference the same file.
PATH.SPLIT(P)
This splits a pathname and returns tuple (head, tail), where tail is everything 
after the final slash.
PATH.SPLITDRIVE(P)
This splits a pathname into a drive/UNC sharepoint and relative path specifiers 
and returns a two-­
tuple (drive_or_unc, path); either part may be empty.
PATH.SPLITEXT(P)
This splits the extension from a pathname. An extension is everything from 
the last dot to the end, ignoring leading dots. For some paths without a dot, the 
extension part will be empty.
The sys Module for Interaction Between the Python and Python 
Interpreter or Python Virtual Machine (PVM)
The os and path modules we studied above provide programmers with ways 
to interact with the operating system and to access the underlying interface 
of the operating system. The sys module we are going to study below allows 
programs to interact with Python interpreter.
The following are the objects defined in the sys module and maintained 
by Python interpreter. These objects are put into two groups: dynamic objects 
and static objects.
The following are the dynamic objects defined in the sys module. Dynamic 
means the values can be changed.
	
Modules and Packages	
427
 https://doi.org/10.15215/remix/9781998944088.01
SYS.ARGV
This holds command-­
line arguments; argv[0] is the script pathname if known. 
The following example shows what happens when we test it in Jupyter Lab:
# factorial.py
def fac(n):
    if n == 0:
        return 1
    else:
        return n * fac(n-­
1)
 
n = 9
 
print(f"{n}! = {fac(n)}")
 
import sys
print(f'argv = {sys.argv}')
 
python -­
u "d:\workshop\research\books\COMP218\samples\
factorial​
.py"
9! = 362880
argv = ['d:\\workshop\\research\\books\\COMP218\\
samples\\factorial​
.py']
SYS.PATH
This holds the module search path; path[0] is the script directory. The sys.path 
for the above Python program/script will be
sys.path = ['d:\\workshop\\research\\books\\COMP218\\
samples', 's:\\python\\python311\\python311.zip', 's:\\
python\\python311\\Lib', 's:\\python\\python311\\
DLLs', 'C:\\Users\\james\\AppData\\Roaming\\Python\\
Python311\\site-­
packages', 'C:\\Users\\james\\AppData\\
Roaming\\Python\\Python311\\site-­
packages\\win32', 'C:\\
Users\\james\\AppData\\Roaming\\Python\\Python311\\
site-­
packages\\win32\\lib', 'C:\\Users\\james\\AppData\\
Roaming\\Python\\Python311\\site-­
packages\\Pythonwin', 
's:\\python\\python311', 's:\\python\\python311\\Lib\\
site-­
packages']
	428	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
SYS.MODULES
This is a dictionary of all loaded modules. It will provide a long list of modules 
it is using.
SYS.DISPLAYHOOK
This contains an executable object and can be called to show the results in an 
interactive session.
>>> sys.displayhook
<ipykernel.displayhook.ZMQShellDisplayHook at 
0x15a70b56b48>
SYS.EXCEPTHOOK
This contains an executable object and can be called to handle any uncaught 
exception other than SystemExit.
SYS.STDIN
This contains the standard input file object; it is used by input().
SYS.STDOUT
It contains the standard output file object; it is used by print().
SYS.STDERR
This contains the standard error object; it is used for error messages.
SYS.LAST_TYPE
This contains the type of the last uncaught exception.
>>> sys.last_type
AttributeError
SYS.LAST_VALUE
This contains the value of the last uncaught exception.
>>> sys.last_value
AttributeError("module 'os' has no attribute 'chroot'")
SYS.LAST_TRACEBACK
This contains the traceback of the last uncaught exception.
	
Modules and Packages	
429
 https://doi.org/10.15215/remix/9781998944088.01
>>> sys.last_traceback
<traceback at 0x15a70ca9388>
The above three objects are only available in an interactive session after a 
traceback has been printed.
The next group of objects available from the sys module are called static objects, 
which means the values do not change for the given Python interpreter being 
used.
SYS.BUILTIN_MODULE_NAMES
This contains a tuple of built-­
in module names.
SYS.COPYRIGHT
This contains the copyright notice pertaining to the interpreter in use. sys.copy­
right in our case will produce the following, as an example:
Copyright (c) 2001–­
2022 Python Software Foundation.
All Rights Reserved.
 
Copyright (c) 2000 BeOpen​
.com.
All Rights Reserved.
 
Copyright (c) 1995–­
2001 Corporation for National Research 
Initiatives.
All Rights Reserved.
 
Copyright (c) 1991–­
1995 Stichting Mathematisch Centrum, 
Amsterdam.
All Rights Reserved.
SYS.EXEC_PREFIX
This contains the prefix used to find the machine-­
specific Python library.
SYS.EXECUTABLE
This contains the absolute path of the executable binary of the Python 
interpreter.
	430	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
SYS.FLOAT_INFO
This contains a named tuple with information about the float implementation.
SYS.FLOAT_REPR_STYLE
This contains a string indicating the style of repr() output for floats.
SYS.HASH_INFO
This contains a named tuple with information about the hash algorithm.
>>> print(sys.hash_info)
sys.hash_info(width = 64, modulus = 2305843009213693951, 
inf = 314159, nan = 0, imag = 1000003, algorithm = 
'siphash24', hash_bits = 64, seed_bits = 128, cutoff = 0)
SYS.HEXVERSION
This contains version information encoded as a single integer.
SYS.IMPLEMENTATION
This contains Python implementation information.
>>> print(sys.implementation)
namespace(cache_tag = 'cpython-­
37', hexversion = 
50792432, name = 'cpython', version =s ys.version_
info(major = 3, minor = 7, micro = 7, releaselevel = 
'final', serial = 0))
SYS.INT_INFO
This contains a named tuple with information about the int implementation.
>>> print(sys.int_info)
sys.int_info(bits_per_digit = 30, sizeof_digit = 4)
SYS.MAXSIZE
This contains the largest supported length of containers.
>>> print(sys.maxsize)
9223372036854775807
SYS.MAXUNICODE
This contains the value of the largest Unicode code point.
	
Modules and Packages	
431
 https://doi.org/10.15215/remix/9781998944088.01
>>> print(sys.maxunicode)
1114111
>>> print(chr(1114111))
􏿿
>>> print(chr(1114112))   # this is out of range and will 
cause an error
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
ValueError   Traceback (most recent call last)
<ipython-­
input-­
81-­
1965bd6642f9> in <module>
-­
-­
-­
-­
> 1< print(chr<(1114112))
ValueError: chr() arg not in range(0x110000)
SYS.PLATFORM
This contains the platform identifier.
>>> print(sys.platform)
win32
SYS.PREFIX
This contains the prefix used to find the Python library.
>>> print(sys.prefix)
C:\ProgramData\Anaconda3
SYS.THREAD_INFO
This contains a named tuple with information about the thread implementation.
>>> print(sys.thread_info)
sys.thread_info(name = 'nt', lock = None, version = 
None)
SYS.VERSION
This contains the version of this interpreter as a string.
SYS.VERSION_INFO
This contains the version information as a named tuple.
SYS.DLLHANDLE
This is the integer handle of the Python DLL (Windows only).
	432	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
SYS.WINVER
This contains the version number of the Python DLL (Windows only).
SYS.__STDIN__
This is the original stdin.
SYS.__STDOUT__
This is the original stdout.
SYS.__STDERR__
This is the original stderr.
SYS.__DISPLAYHOOK__
This is the original displayhook.
SYS.__EXCEPTHOOK__
This is the original excepthook.
The following are functions also defined in the sys module.
SYS.DISPLAYHOOK()
This function prints an object to the screen and saves it in builtins.
SYS.EXCEPTHOOK()
This function prints an exception and its traceback to sys.stderr.
SYS.EXC_INFO()
This function returns thread-­
safe information about the current exception.
SYS.EXIT()
This function exits the interpreter by raising SystemExit.
SYS.GETDLOPENFLAGS()
This function returns flags to be used for dlopen() calls.
SYS.GETPROFILE()
This function returns the global profiling function.
	
Modules and Packages	
433
 https://doi.org/10.15215/remix/9781998944088.01
SYS.GETREFCOUNT()
This function returns the reference count for an object.
SYS.GETRECURSIONLIMIT()
This function returns the max recursion depth for the interpreter.
SYS.GETSIZEOF()
This function returns the size of an object in bytes.
>>> from datetime import datetime
>>> import sys
>>> dt1 = datetime.now()
>>> print(sys.getsizeof(dt1))
48
SYS.GETTRACE()
This function gets the global debug tracing function.
SYS.SETCHECKINTERVAL()
This function controls how often the interpreter checks for events.
SYS.SETDLOPENFLAGS()
This function sets the flags to be used for dlopen() calls.
SYS.SETPROFILE()
This function sets the global profiling function.
SYS.SETRECURSIONLIMIT()
This function sets the max recursion depth for the interpreter.
SYS.SETTRACE()
This function sets the global debug tracing function.
As can be seen, the sys module gives programmers a way to find out informa­
tion about the Python interpreter and the runtime environment in particular.
	434	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
8.9 Module for Logging Events During Program 
Runtime
In some applications, sometimes it’s necessary or desirable to keep a rec­
ord of what happened with the program for performance improvement, 
error debugging, security, and audit purposes. Examples of such events/
data include, but are not limited to, how many times a function/method has 
been called, how long a function call takes, how much memory it used, and 
so on. In Python, a package called logging is available for logging within its 
standard distribution.
Due to the variety of purposes stated above, logged events can be classified 
into the following five categories based on the nature or severity of the events, 
in the view of the users of the application, as shown in Table 8-­
3.
Table 8-­
3: Levels of logging
Category of logs
Description
Numeric value of 
the level
NOTSET
The level hasn't been set.
0
DEBUG
Events are useful for error 
debugging. This is the lowest 
level of severity.
10
INFO
Information can be useful for 
improving the performance 
of the application/program or 
for assurance of security and 
auditing.
20
WARNING
Something needs checking.
30
ERROR
These errors are often logical and 
should be checked.
40
CRITICAL
The event is critical for the program 
to perform correctly and should 
be checked and resolved. This is 
highest level of severity.
50
The logging library defines several classes and module-­
level functions, and it 
is the latter that you would be using directly in your programs and applications. 
The basicConfig() function is used to set up the logging file and other param­
eters for the logger. The logging() function is for logging messages describing 
events in each category, as shown in the following code sample:
	
Modules and Packages	
435
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
import logging
logging.debug('Everything logged with logging.debug is 
labelled as debug')
logging.info('Everything logged with logging.info is 
labelled as info')
logging.warning('Everything logged with logging.warning 
is labelled as warning')
logging.error('Everything logged with logging.error is 
labelled as error')
logging.critical('Everything logged with logging.
critical is labelled as critical')
The output of the code above is shown below:
Out [ ]:
WARNING:root:Everything logged with logging.warning is labelled as warning 
ERROR:root:Everything logged with logging.error is labelled as error 
CRITICAL:root:Everything logged with logging.critical is labelled as critical
You may have noted that output from the debug and info logging functions are 
missing from the output. This is because the default configuration of the logging 
module only logs events at warning level or higher. To change the default log-
ging level, you can call a function of the logging module named basicConfig(), as 

shown in the following example:
1
import logging
2
3
logging.basicConfig(level=logging.DEBUG,
4
filename='c:\\users\\james\\myapp.log',
5
filemode='w', format='%(name)s -­
 %(levelname)s -­
 %(message)
s')   # this line belongs to the basicConfig call as well
6
logging.debug('Everything logged with logging.debug is 
labelled as debug')
7
logging.info('Everything logged with logging.info is 
labelled as info')
8
logging.warning('Everything logged with logging.warning is 
labelled as warning')
9
logging.error('Everything logged with logging.error is 
labelled as error')
10
logging.critical('Everything logged with logging.critical 
is labelled as critical')
Instead of directly printing out to the terminal, this code writes the logs to a 
file named myapp.log, and the content of the generated logging file myapp.
log is as follows:
	436	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
root -­
 DEBUG -­
 Everything logged with logging.debug is labelled as debug
root -­
 INFO -­
 Everything logged with logging​
.info is labelled as info
root -­
 WARNING -­
 Everything logged with logging.warning is labelled as 
warning
root -­
 ERROR -­
 Everything logged with logging.error is labelled as error
root -­
 CRITICAL -­
 Everything logged with logging.critical is labelled 
as critical
Now as can be seen, DEBUG and INFO are recorded in the logging file 
because we changed the logging level to DEBUG.
Please note that for logging configuration to take full effect, all should be 
configured in a single basicConfig() method call. If the statement becomes too 
long to fit in a single line, the statement can take two or more lines, as long as 
newline is not within the string or word, as shown above.
In the basicConfig() function call shown above, keyword arguments are used 
to set the level of logging to DEBUG, the logging file name to c:\users\james\
myapp.log, and the log file mode to w for write, which means that everything 
in the log file will be overwritten by new logging messages. If you want to keep 
the old logs and add the new logs to the end of the old logs, you need to set the 
file mode to a for append, which is the default set by the logging mode.
It has been noted that the basicConfig() function for logging is not fully 
functional within Jupyter Notebook. To change the logging level within Jupyter 
Notebook, you can use the logging.getLogger().setLevel() method. However, you 
cannot set the logging file name and logging file mode within Jupyter Notebook.
8.10 Modules for Playing and Manipulating Audio 
and Video Files
This section covers how to develop sound-­
 and music-­
related applications with 
Python.
winsound
To play WAV files in your Windows applications, you can use the winsound 
module included in the standard Python distribution. You can import the mod­
ule and use the functions defined in it without installing the module. Using 
the following statements, you can get a list of names defined in the module:
>>> import winsound
>>> dir(winsound)
['Beep', 'MB_ICONASTERISK', 'MB_ICONEXCLAMATION', 'MB_
ICONHAND', 'MB_ICONQUESTION', 'MB_OK', 'MessageBeep', 
	
Modules and Packages	
437
 https://doi.org/10.15215/remix/9781998944088.01
'PlaySound', 'SND_ALIAS', 'SND_APPLICATION', 'SND_
ASYNC', 'SND_FILENAME', 'SND_LOOP', 'SND_MEMORY', 
'SND_NODEFAULT', 'SND_NOSTOP', 'SND_NOWAIT', 'SND_PURGE', 
'__doc__', '__file__', '__loader__', '__name__', '__
package__', '__spec__']
For more details about the module and functionalities provided, run 
help(winsound) in Python interactive mode, as shown below:
>>> import winsound
>>> help(winsound)
 Help on module winsound:
NAME
winsound
DESCRIPTION
PlaySound(sound, flags)—­
play a sound
SND_FILENAME—­
sound is a wav file name
SND_ALIAS—­
sound is a registry sound association name
SND_LOOP—­
play the sound repeatedly; must also specify 
SND_ASYNC
SND_MEMORY—­
sound is a memory image of a wav file
SND_PURGE—­
stop all instances of the specified sound
SND_ASYNC—­
PlaySound returns immediately
SND_NODEFAULT—­
Do not play a default beep if the sound 
cannot be found
SND_NOSTOP—­
Do not interrupt any sounds currently 
playing
SND_NOWAIT—­
Return immediately if the sound driver is 
busy
Beep(frequency, duration)—­
Make a beep through the PC 
speaker.
MessageBeep(type)—­
Call Windows MessageBeep.
FUNCTIONS
eep(frequency, duration)
A wrapper around the Windows Beep API.
frequency
Frequency of the sound in hertz.
Must be in the range 37 through 32,767.
duration
How long the sound should play, in milliseconds.
	438	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
MessageBeep(type = 0)
Call Windows MessageBeep(x).
x defaults to MB_OK.
PlaySound(sound, flags)
A wrapper around the Windows PlaySound API.
sound
The sound to play; a filename, data, or None.
flags
Flag values, ORed together. See module 
documentation.
DATA
MB_ICONASTERISK = 64
MB_ICONEXCLAMATION = 48
MB_ICONHAND = 16
MB_ICONQUESTION = 32
MB_OK = 0
SND_ALIAS = 65536
SND_APPLICATION = 128
SND_ASYNC = 1
SND_FILENAME = 131072
SND_LOOP = 8
SND_MEMORY = 4
SND_NODEFAULT = 2
SND_NOSTOP = 16
SND_NOWAIT = 8192
SND_PURGE = 64
FILE
s:\python\python311\dlls\winsound.pyd
Among the functions defined in the module, PlaySound is an important 
one for playing sound or music files. The following statement will play a WAV 
file named dj.wav.
>>> import winsound
>>> winsound.PlaySound("c:/users/comp218/
dj.wav",winsound.SND_FILENAME)
When using the PlaySound function to a play sound file, you must make 
sure the WAV file exists in the default or specified path. In the example above, 
an absolute path has been given. You can also use a relative path that makes 
	
Modules and Packages	
439
 https://doi.org/10.15215/remix/9781998944088.01
use of two special notations, a single dot (.) representing the current directory 
and a double dot (..) representing the parent directory; or you don’t need to 
specify the path at all if the WAV file is in the current directory. In any case, 
the rule is that you must be clearly aware of where the file is located. This rule 
is applicable whenever the file is used.
PyGame
The PlaySound function in the standard winsound module can play only WAV 
files. To play the popular MP3 music files in your Python applications, use the 
module called mixer in the PyGame package. Because the package is usually 
included in the standard Python distribution, you can install the package into 
your Python programming environment using the pip command, as shown 
below:
pip install pygame
Then you can import and use the mixer module to load and play MP3 files, as 
shown below:
>>> from pygame import mixer # load the required library
Hello from the pygame community. https://​
www​
.pygame​
.org/​
contribute​
.html
>>> mixer.init()
>>> mixer.music.load("../I_Will_Remember_You.mp3")
>>> mixer.music.play()
To learn more about how to use the mixer and mixer.music module, you 
can run the following commands in Python interactive mode as shown below, 
after the module has been imported:
>>> help(mixer)
You can then see the functions defined within the module, as further 
detailed below.
CHANNEL(ID)
This is used to create and return a Channel object for controlling playback.
FADEOUT(TIME)
This sets the time to fade out the volume on all sounds before stopping.
	440	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
FIND_CHANNEL(FORCE = FALSE)
This finds and returns an unused channel.
GET_BUSY()
This tests if any sound is being mixed and returns a Boolean value.
GET_INIT()
This tests if the mixer is initialized and returns a tuple (frequency, format, 
channels) representing the channel.
GET_NUM_CHANNELS()
This can be used to check and return the total number of playback channels.
INIT(FREQUENCY = 22050, SIZE = −16, CHANNELS = 2, BUFFER = 
4096, DEVICENAME = NONE, ALLOWEDCHANGES = AUDIO_ALLOW_
FREQUENCY_CHANGE | AUDIO_ALLOW_CHANNELS_CHANGE)
This can be used to initialize the mixer module.
PAUSE() -­
> NONE, TEMPORARILY STOP PLAYBACK OF ALL 
SOUND CHANNELS
PRE_INIT(FREQUENCY=22050, SIZE = −16, CHANNELS = 2, 
BUFFERSIZE = 4096, DEVICENAME = NONE)
These can be used to preset the mixer init arguments.
QUIT()
This can be used to uninitialize the mixer.
SET_NUM_CHANNELS(COUNT)
This can be used to set the total number of playback channels.
SET_RESERVED(COUNT)
This can be used to keep channels from being automatically used.
STOP()
This can be used to stop playback on all sound channels.
UNPAUSE()
This can be used to resume playback on sound channels after it has been 
paused.
	
Modules and Packages	
441
 https://doi.org/10.15215/remix/9781998944088.01
The mixer module has a submodule named music. To learn what func­
tions are available in the mixer.music submodule module, run the following 
statement:
>>> help(mixer.music)
You will then see the following information about the related functions.
FADEOUT(TIME)
This can be used to stop music playback after fading out.
GET_BUSY()
This can be used to check if the music stream is playing. It will return True 
or False.
GET_ENDEVENT()
This can be used to get the event a channel sends when playback stops.
GET_POS()
This can be used to get the music playtime.
GET_VOLUME() -­
> VALUE
This can be used to get the music volume.
LOAD(FILENAME) -­
> NONE, OR LOAD(OBJECT) -­
> NONE,
This can be used to load a music file/object for playback.
PAUSE() -­
> NONE
This can be used to temporarily stop music playback.
PLAY(LOOPS = 0, START = 0.0) -­
> NONE
This can be used to start the music stream playback.
QUEUE(FILENAME) -­
> NONE
This can be used to queue a music file to follow the currently playing file.
REWIND() -­
> NONE
This can be used to restart the music.
	442	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
SET_ENDEVENT() -­
> NONE
SET_ENDEVENT(TYPE) -­
> NONE
These can be used to have the mixer send events when playback stops.
SET_POS(POS) -­
> NONE
This can be used to set the position in the music file when starting playback.
SET_VOLUME(VALUE) -­
> NONE
This can be used to set the music volume.
STOP() -­
> NONE
This can be used to stop the music playback.
UNPAUSE() -­
> NONE
This can be used to resume paused music.
These functions in mixer.music are the ones used directly to handle music files. 
These functions are sufficient for you to develop a high-­
quality music player with 
what you will learn in Chapter 9 on developing GUI-­
based applications in Python.
Please note that the mixer module from the PyGame package can also play 
other types of music files including WAV, as shown below:
>>> from pygame import mixer   # import mixer module from 
PyGame
>>> mixer.init()   # initialize the mixer
>>> mixer.music.load("../I_will_Remember_you.mp3")   # 
load the mp3 file
>>> mixer.music.play(loops = 2)   # play the most recent 
loaded file twice
The functions listed above are needed if you are developing a music player 
with PyGame. For details on these functions, please refer to the official documen­
tation on the PyGame mixer at https://​
www​
.pygame​
.org/​
docs/​
ref/​
mixer​
.html.
8.11 Modules for Creating and Manipulating 
Graphics and Images
In computing and information processing, graphics are an important part of 
data and information. In this section, we learn how to create and manipulate 
graphics and images with Python.
	
Modules and Packages	
443
 https://doi.org/10.15215/remix/9781998944088.01
Create Graphics with Tkinter
The module built into the standard Python distribution for creating graphics 
is the Tkinter module, which is commonly used to develop graphical user 
interface (GUI) applications. However, Tkinter also provides a widget called 
Canvas for graphics and images. The following statements in Python interactive 
mode will produce a window containing a Canvas ready for drawing graphic 
objects—­
Canvas items:
>>> from tkinter import *
>>> d_board = Canvas()
Table 8-­
4 is a list of Canvas items we can draw on a Canvas.
Table 8-­
4: A list of functions that can be used to draw on a Canvas
Graphic object
Canvas method to 
create
Code sample
arc or arc-­
shaped 
region (such as a 
chord or pie slice)
create_arc(bbox, 
**options)
>>> d_board = Canvas()
>>> d_board.pack()
>>> d_board.create_arc(30, 
50, 100, 200)
1
bitmap (built-­
in or read 
from an XBM file)
create_bitmap(position, 
**options)
>>> d_board.create_
bitmap(30, 50)
image (a BitmapImage 
or PhotoImage 
instance)
create_image(position, 
**options)
>>> d_board.create_
image(30, 50)
line
create_line(coords, 
**options)
>>> d_board.create_
line(30, 50, 100, 200)
2
Figure 8-­
2: An example of TK Canvas
(continued on next page)
	444	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Graphic object
Canvas method to 
create
Code sample
oval (a circle or an 
ellipse)
create_oval(bbox, 
**options)
>>> d_board.create_
oval(30, 50, 80, 80, 
fill = "RED")
polygon
create_polygon(coords, 
**options)
>>> d_board.create_
polygon(30, 50, 80, 80, 
70, 90, fill = "RED")
rectangle
create_rectangle(bbox, 
**options)
>>> d_board.create_
rectangle(30, 50, 80, 
80, fill = "RED")
text
create_text(position, 
**options)
>>> d_board.create_
text(130, 150, text = 
"Hello!")
window
create_
window(position, 
**options)
Every method listed in Table 8-­
4 returns a unique ID for the created graphic 
object, which can be used later to manipulate the object.
Note that graphic objects created by the above methods will be stacked 

on the Canvas and will remain until being moved, lifted, lowered, or deleted, 
with the methods in Table 8-­
5.
Table 8-­
5: Other methods of Canvas within Tkinter
Method
Operation
Code sample
dchars(item, from, to 
= None)
Deletes text from an 
editable graphic 
item such as text: 
from is where to 
start deleting text, 
to is where to stop 
deleting text. If to is 
omitted, only a single 
character is deleted.
>>> d_board.create_
text(130, 150, text = 
"Hello Python!")
>>> d_board.dchars('text', 
1,2)
delete(item)
Deletes all matching 
items.
>>> h3 = d_board.
create_text(230, 150, 
text="Hello!")
>>> d_board.delete(h3)
>>> d_board.delete(3)
>>> d_board.delete(10)
>>> d_board.delete(11)
>>> d_board.delete(9)
Table 8-­
4: A list of functions that can be used to draw on a Canvas 
(continued)
	
Modules and Packages	
445
 https://doi.org/10.15215/remix/9781998944088.01
Method
Operation
Code sample
coords(item, *coords)
Returns or sets the 
coordinates of 
matching items.
>>> d_board.coords(o1, 30, 
150, 80, 250)
move(item, dx, dy)
Moves matching 
items by an offset.
>>> d_board.move(o1, 10, 
15)
Canvas has many other methods for accessing and manipulating graphic 
objects. Running the following statements in Python interactive mode will give 
you a list of names defined within the Canvas class.
>>> from tkinter import *
>>> dir(Canvas)
['_Misc__winfo_getint', '_Misc__winfo_parseitem', '__
class__', '__delattr__', '__dict__', '__dir__', '__doc__', 
'__eq__', '__format__', '__ge__', '__getattribute__', 
'__getitem__', '__gt__', '__hash__', '__init__', '__init_
subclass__', '__le__', '__lt__', '__module__', '__ne__', 
'__new__', '__reduce__', '__reduce_ex__', '__repr__', 
'__setattr__', '__setitem__', '__sizeof__', '__str__', 
'__subclasshook__', '__weakref__', '_bind', '_configure', 
'_create', '_displayof', '_do', '_getboolean', '_
getconfigure', '_getconfigure1', '_getdoubles', '_getints', 
'_grid_configure', '_gridconvvalue', '_last_child_ids', 
'_nametowidget', '_noarg_', '_options', '_register', '_
report_exception', '_root', '_setup', '_subst_format', 
'_subst_format_str', '_substitute', '_tclCommands', '_
windowingsystem', 'addtag', 'addtag_above', 'addtag_all', 
'addtag_below', 'addtag_closest', 'addtag_enclosed', 
'addtag_overlapping', 'addtag_withtag', 'after', 
'after_cancel', 'after_idle', 'anchor', 'bbox', 'bell', 
'bind', 'bind_all', 'bind_class', 'bindtags', 'canvasx', 
'canvasy', 'cget', 'clipboard_append', 'clipboard_clear', 
'clipboard_get', 'columnconfigure', 'config', 'configure', 
'coords', 'create_arc', 'create_bitmap', 'create_image', 
'create_line', 'create_oval', 'create_polygon', 'create_
rectangle', 'create_text', 'create_window', 'dchars', 
'delete', 'deletecommand', 'destroy', 'dtag', 'event_add', 
'event_delete', 'event_generate', 'event_info', 'find', 
'find_above', 'find_all', 'find_below', 'find_closest', 
'find_enclosed', 'find_overlapping', 'find_withtag', 
Table 8-­
5: Other methods of Canvas within Tkinter (continued)
	446	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
'focus', 'focus_displayof', 'focus_force', 'focus_get', 
'focus_lastfor', 'focus_set', 'forget', 'getboolean', 
'getdouble', 'getint', 'gettags', 'getvar', 'grab_
current', 'grab_release', 'grab_set', 'grab_set_global', 
'grab_status', 'grid', 'grid_anchor', 'grid_bbox', 
'grid_columnconfigure', 'grid_configure', 'grid_forget', 
'grid_info', 'grid_location', 'grid_propagate', 'grid_
remove', 'grid_rowconfigure', 'grid_size', 'grid_slaves', 
'icursor', 'image_names', 'image_types', 'index', 'info', 
'insert', 'itemcget', 'itemconfig', 'itemconfigure', 
'keys', 'lift', 'location', 'lower', 'mainloop', 'move', 
'nametowidget', 'option_add', 'option_clear', 'option_get', 
'option_readfile', 'pack', 'pack_configure', 'pack_forget', 
'pack_info', 'pack_propagate', 'pack_slaves', 'place', 
'place_configure', 'place_forget', 'place_info', 'place_
slaves', 'postscript', 'propagate', 'quit', 'register', 
'rowconfigure', 'scale', 'scan_dragto', 'scan_mark', 
'select_adjust', 'select_clear', 'select_from', 'select_
item', 'select_to', 'selection_clear', 'selection_get', 
'selection_handle', 'selection_own', 'selection_own_
get', 'send', 'setvar', 'size', 'slaves', 'tag_bind', 
'tag_lower', 'tag_raise', 'tag_unbind', 'tk_bisque', 
'tk_focusFollowsMouse', 'tk_focusNext', 'tk_focusPrev', 'tk_
setPalette', 'tk_strictMotif', 'tkraise', 'type', 'unbind', 
'unbind_all', 'unbind_class', 'update', 'update_idletasks', 
'wait_variable', 'wait_visibility', 'wait_window', 
'waitvar', 'winfo_atom', 'winfo_atomname', 'winfo_cells', 
'winfo_children', 'winfo_class', 'winfo_colormapfull', 
'winfo_containing', 'winfo_depth', 'winfo_exists', 'winfo_
fpixels', 'winfo_geometry', 'winfo_height', 'winfo_id', 
'winfo_interps', 'winfo_ismapped', 'winfo_manager', 'winfo_
name', 'winfo_parent', 'winfo_pathname', 'winfo_pixels', 
'winfo_pointerx', 'winfo_pointerxy', 'winfo_pointery', 
'winfo_reqheight', 'winfo_reqwidth', 'winfo_rgb', 'winfo_
rootx', 'winfo_rooty', 'winfo_screen', 'winfo_screencells', 
'winfo_screendepth', 'winfo_screenheight', 'winfo_
screenmmheight', 'winfo_screenmmwidth', 'winfo_screenvisual', 
'winfo_screenwidth', 'winfo_server', 'winfo_toplevel', 
'winfo_viewable', 'winfo_visual', 'winfo_visualid', 'winfo_
visualsavailable', 'winfo_vrootheight', 'winfo_vrootwidth', 
'winfo_vrootx', 'winfo_vrooty', 'winfo_width', 'winfo_x', 
'winfo_y', 'xview', 'xview_moveto', 'xview_scroll', 'yview', 
'yview_moveto', 'yview_scroll']
	
Modules and Packages	
447
 https://doi.org/10.15215/remix/9781998944088.01
You can then call help on each of the names in the list to learn more about 
the name defined. The following are just two examples:
>>> help(Canvas.addtag)
Running help on the function addtag in module tkinter outputs the following:
addtag(self, *args)
    Internal function.
>>> help(Canvas.after)
Running help on the function after in module tkinter outputs the following:
after(self, ms, func=None, *args)
    Call function once after given time.
    MS specifies the time in milliseconds. FUNC gives the
    function, which shall be called. Additional parameters
    are given as parameters to the function call. Returns
    identifier to cancel scheduling with after_cancel.
>>> help(Canvas.create_image)
Running help on the function create_image in module tkinter outputs the 
following:
create_image(self, *args, **kw)
    Create image item with coordinates x1, y1.
The following coding example will draw a line on a Canvas:
import tkinter
from tkinter.constants import *
tk = tkinter.Tk()
canvas = tkinter.Canvas(tk, relief = RIDGE, borderwidth = 2)
canvas.pack(fill = BOTH, expand=1)
ln1 = canvas.create_line(100, 100, 300, 300, width = 6)
tk.mainloop()
	448	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Manipulate Images with Pillow
Another way you can work with visual objects in Python is to manipulate images 
stored in files. These manipulations include the following:
•	 rotating
•	 converting from colour to grey-­
scale
•	 applying colour filtering
•	 highlighting a specific area of an image
•	 blurring an image or part of it
•	 sharpening an image or part of it
•	 changing the brightness of an image
•	 detecting the edge on an image
•	 scaling an image
•	 applying colour inversion to an image
•	 morphing one image into another image
How can all these manipulations be done within your computer? First, an image 
is made of pixels, which can be stored in an m × n matrix, or two-­
dimensional 
array, mapped to a rectangular area of the computer screen. The value of each 
cell of the matrix represents a pixel and contains all the information about it. 
All manipulations to the image can be done by manipulating the matrix or its 
values.
To manipulate an image with Python, you can use a package called Pillow 
(available from https://​
pypi​
.org/​
project/​
Pillow/​
2​
.2​
.1/ or https://​
github​
.com/​
python​
-pillow/​
Pillow). Because it is not a standard part of the Python library, 
you will need to install it with the following statement:
Figure 8-­
3: Drawing on TK Canvas
	
Modules and Packages	
449
 https://doi.org/10.15215/remix/9781998944088.01
pip install Pillow
Collecting Pillow
Downloading
wordhttps://​
files​
.pythonhosted​
.org/​
packages/​
70/​
21/​
04723e78916eff8e0
9901dbb7dc9705f4de8a0dfe7882a9ed56982bd128e/​
Pillow​
-­
6​
.0​
.0​
-­
cp37​
-­
cp37m​
-­
win32​
.whl (1.7MB)
|████████████████████████████████| 1.7MB 
1.3MB/s
Installing collected packages: Pillow
Successfully installed Pillow-­
6.0.0
Once this is done, you can import and then use the following two 
modules:
Image,
ImageFilter
The following is a coding sample:
from PIL import Image, ImageFilter
# read the image
im = Image.open('./resort.jpg')
im_sharp = im.filter( ImageFilter.SHARPEN )
# save the filtered image to a new file
im_sharp.save( './resort-­
sharp.jpg', 'JPEG' )
 
# display the image
im_sharp.show()
The sharpened image is shown in Figure 8-­
4.
Note that the Image module has a class with the same name as the module, 
Image, although it is more convenient to construct an object of Image with the 
open statement rather than the constructor of Image class.
Once an image object has been generated with the open statement, we can 
check its format, size, and mode by looking at the format, size, and mode attrib­
utes and using the following methods of the Image class to manipulate the image 
object:
•	 Image.convert(self, mode = None, matrix = None, dither = None, palette 
= 0, colors = 256) makes various conversions to the image object.
	450	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
•	 Image.copy(self) makes a copy and retains the original image object.
•	 Image.crop(self, box=None) returns a rectangular region of the image, 
defined by box.
•	 Image.draft(self, mode, size) returns a draft version of the image, such 
as a grey-­
scale version.
•	 Image.effect_spread(self, distance) returns an image with pixels 
randomly spread throughout the image.
•	 Image.filter(self, filter) filters this image using the given filter specified 
in the ImageFilter module.
•	 Image.paste(self, im, box=None, mask=None) pastes another image 
(im) into this image.
•	 Image.putalpha(self, alpha) adds or replaces the alpha layer in this image.
•	 Image.putdata(self, data, scale = 1.0, offset = 0.0) copies a sequence of 
pixel data to this image.
•	 Image.putpalette(self, data, rawmode = 'RGB') attaches a palette to this 
image.
•	 Image.putpixel(self, xy, value) modifies the pixel at the given position.
•	 Image.quantize(self, colors = 256, method = None, kmeans = 0, palette 
= None, dither = 1) converts the image to P mode with the specified 
number of colours.
Figure 8-­
4: Picture sharpened with Pillow (©Harris Wang, Athabasca University)
	
Modules and Packages	
451
 https://doi.org/10.15215/remix/9781998944088.01
•	 Image.emap_palette(self, dest_map, source_palette = None) rewrites 
the image to reorder the palette.
•	 Image.resize(self, size, resample = 0, box = None) returns a resized copy 
of this image.
•	 Image.rotate(self, angle, resample = 0, expand = 0, center = None, 
translate = None, fillcolor = None) returns a rotated copy of this 
image.
•	 Image.split(self), splits the image into individual bands, such as 
R, G, B.
•	 Image.tobitmap(self, name='image') converts the image to an X11 
bitmap.
•	 Image.tobytes(self, encoder_name = 'raw', *args) returns the image as a 
bytes-­
object.
•	 Image.toqimage(self) returns a QImage copy of this image.
•	 Image.toqpixmap(self) returns a QPixmap copy of this image.
•	 Image.transform(self, size, method, data=None, resample = 0, fill = 1, 
fillcolor = None) transforms this image to a given size but in the same 
mode as the original.
•	 Image.transpose(self, method) transposes the image (flips or rotates in 
90-­
degree steps).
There are other methods defined within the Image class for other purposes. 
You can find out more info about the Image class by running the following 
statement in Python interactive mode:
>>> from PIL import Image, ImageFilter
>>> help(Image.Image)
As we have seen from the above list, the Image class has provided a good 
set of methods to manipulate an image.
The ImageFilter module provides some filtering operations on images, as 
the name implies. These filtering operations include blurring, box blurring, 
contouring, colour transformation, detailing, edge enhancing, embossing, sharp­
ening, smoothing, and more.
8.12 Modules for Data Analytics
The modules often used for data analytics include pandas, NumPy, SciPy, 
and matplotlib. Among the four modules, pandas is mostly used to prepare 
	452	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
data; NumPy and SciPy are used for numeric analysis and science computing, 
respectively; and matplotlib is for visualization.
Since data analytics is a big topic, we will only give some examples of how 
the modules can be used.
The first example is to show how to use matplotlib to visualise the square 
root function in math.
import math
import matplotlib.pyplot as mpl
sqrt_data = {i+1 : math.sqrt(i+1) for i in range(100)}
x1 = list(sqrt_data.keys())
y1 = list(sqrt_data.values())
mpl.plot(x1, y1)
mpl.title("visualization of square root")
mpl.xlabel('x')
mpl.ylabel('y')
mpl.show()
The plot produced by the program is shown in Figure 8-­
5.
0
20
40
60
80
100
x
2
4
6
8
10
y
Visualization of Square Root
Figure 8-­
5: Visualization of square root
	
Modules and Packages	
453
 https://doi.org/10.15215/remix/9781998944088.01
Our next example is to visualize the world population changes in some 
regions as well as world total since 1960. The program code is as follows:
import pandas as pd
import matplotlib.pyplot as mplt
content = pd.read_excel("world-­
population.xls")
years = [1960, 1970, 1980, 1990, 2000, 2010, 2017]
mplt.plot(years, content.iloc[0, 1:])
mplt.plot(years, content.iloc[1, 1:])
mplt.plot(years, content.iloc[7, 1:])
mplt.plot(years, content.iloc[11, 1:])
mplt.plot(years, content.iloc[12, 1:])
mplt.plot(years, content.iloc[17, 1:])
mplt.plot(years, content.iloc[22, 1:])
mplt.title("Population -­
 World Total and Region Total")
mplt.xlabel("years")
mplt.ylabel("Populations (in millions)")
mplt.legend(["World Total", "Africa", "Latin America", 
"North America", "Asia", "Europe", "Oceana"])
mplt.show()
In the program, the pandas module is used to read and prepare the data. 
For details on how it works, please read the complete documentation at https://​
pandas​
.pydata​
.org/​
docs/—­
the user guide at https://​
pandas​
.pydata​
.org/​
docs/​
user​
_guide/​
index​
.html​
#user​
-guide in particular.
The rendered result of the program is shown in Figure 8-­
6.
NumPy allows you to do math manipulations on a data set, most often 
manipulations on a matrix. Here is an example:
import numpy as np # import numpy
 
a = np.array(range(21,25)) # create an array from a 
python list
print(a, a.shape) # print the array and its shape
 
# create a 2-­
D array from nested lists
b = np.array([[1, 2, 3, 4], [5, 6, 7, 8],
        [11, 12, 13, 14], [15, 16, 17, 18]])
 
print(b, b.shape)  # print the array and its shape
	454	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
c = a + b # perform element-­
wise addition on two arrays
 
print(c, c.shape)  # print the result and the shape
 
d = np.dot(a, b)  # perform matrix multiplication
 
print(d)  # print the result
 
e = np.cos(a) # apply a mathematical function to an array
 
print(e)  # print the result
 
f = np.sort(b, axis=0) # sort an array along a given axis
 
print(f)  # print the result
The output from the program is as follows:
[21 22 23 24] (4,)
[[ 1 2 3 4]
1960
1970
1980
1990
2000
2010
years
2000
1000
0
3000
4000
5000
6000
7000
Populations (in million)
Population - World Total and Region Total
World Total
Africa
Latin America
North America
Asia
Europe
Oceana
Figure 8-­
6: Visualization of world population changes
	
Modules and Packages	
455
 https://doi.org/10.15215/remix/9781998944088.01
 [ 5 6 7 8]
 [11 12 13 14]
 [15 16 17 18]] (4, 4)
[[22 24 26 28]
 [26 28 30 32]
 [32 34 36 38]
 [36 38 40 42]] (4, 4)
[ 744 834 924 1014]
[-­
0.54772926 -­
0.99996083 -­
0.53283302 0.42417901]
[[ 1 2 3 4]
 [ 5 6 7 8]
 [11 12 13 14]
 [15 16 17 18]]
More details on NumPy can be found at https://​
numpy​
.org/​
doc/​
stable/.
SciPy is built upon NumPy, including various functions often needed for 
scientific computing. The following example shows how integration function 
in SciPy is used to integrate a function.
import numpy as np # import numpy and scipy.integrate
from scipy.integrate import quad  # import quad integral 
function
 
# define a function to be integrated
def f(x):
  return np.exp(-­
x**2)  # use exp function from NumPy
 
# integrate the function from 0 to 1 using quad
result, _ = quad(f, 0, 1)
 
# print the result and the estimated error
print(result)
The result is 0.7468241328124271.
Chapter Summary
•	 In addition to functions and classes, modules and packages are 
important constructs that can be used to do modular programming in 
Python.
	456	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
•	 A module can be any file with a py extension that has legitimate Python 
program codes or scripts in it.
•	 A package is a file directory containing several Python modules.
•	 To identify the directories in which the Python packages reside, each 
such directory must contain a file named ​
_​
_init​
_​
_​
.py.
•	 The ​
_​
_init​
_​
_​
.py file defines what can be imported from the package. 
These may include variables, functions, and classes.
•	 Packages can be nested to any depth, just like file directories are 
nested. However, each directory for a package must have its own ​
_​
_init​
_​
_​
.py file.
•	 Dotted notation is used to refer to a package or module within a deep 
package hierarchy.
•	 To use variables, functions, and classes defined in a module, you 
have to import the module or the specific variables, functions, and/or 
classes, using the import statement or from … import statement.
•	 A large number of Python modules and packages have been developed 
and made available on the internet for Python programmers. Many 
of these modules and packages have been already installed with the 
standard Python distribution, such as the Anaconda package.
•	 A good Python programmer or software developer should have 
knowledge of existing modules and packages, including what they are 
developed for and what they do.
•	 Programmers can develop their own modules for their own 
applications and development.
Exercises
	
1.	 Open VS Code, create or open a Jupyter Notebook file (.ipynb), and 
select a Python virtual environment for the notebook file. Open a 
terminal and run the pip list command to see what library modules 
have been installed in the virtual environment.
In the output of your VS Code shell terminal, identify some 
interesting packages and modules, and write a summary of those 
packages and modules in a Word document, including what each is 
developed for, where it may be used, and so on.
	
2.	 In VS Code, open the Jupyter Notebook file named chapter-­
8.ipynb. 
Create a new cell and import the math module, run the help command 
to study each of the functions defined in the math module, and do 
some hands-­
on coding with the function.
	
Modules and Packages	
457
 https://doi.org/10.15215/remix/9781998944088.01
	
3.	 Search the internet for tutorials or other web documents related to 
web scraping with Python and choose some to watch or read. Take 
some coding samples to run in your Jupyter Notebook within VS Code, 
then develop your own application based on the code samples.
Projects
	
1.	 Rational numbers are those real numbers that can be represented as 
a quotient of two integers such as a/b, which can then be represented 
by the pair of integers a and b. For this project, define a module 
that contains the definition of a class named Rational, within 
which dunder methods for print, addition, subtraction, division, 
multiplication, and various comparisons are defined.
	
2.	 Develop an application using the math module to calculate and display 
a table of squares for integers from 0 to 99. The layout is illustrated in 
Table 8-­
6.
Table 8-­
6: The layout of the table to be produced
0
1
2
3
4
5
6
7
8
9
0
0
1
4
9
26
25
36
49
8
9
1
100
121
144
169
196
225
256
289
324
361
2
…
…
…
3
4
5
6
7
8
9
	
3.	 Develop an application to calculate and display a table showing the 
square roots of integers from 0 to 99 (similar to what you did for 
Project 2).
This page intentionally left blank
 https://doi.org/10.15215/remix/9781998944088.01
Chapter 9
Develop GUI-­
Based 
Applications
In terms of user interface, there are two types of computer systems or appli­
cations: terminal-­
based, which can be run from a terminal, and those with a 
graphical user interface (GUI), or GUI-­
based. So far, the applications we have 
programmed have all been terminal-­
based. In this chapter you will learn how 
to develop GUI-­
based applications in Python.
Learning Objectives
After completing this chapter, you should be able to
•	 explain terminal-­
based applications and GUI-­
based applications as 
well as their differences.
•	 explain which Python libraries are available for developing GUI-­
based 
applications.
•	 discuss the widgets, functions, other classes, and methods provided in 
the Tkinter module.
•	 use widgets, functions, classes, and methods provided in the Tkinter 
module to design and implement a graphical user interface for a given 
application.
•	 develop GUI-­
based applications using the Tkinter module.
•	 discuss the themed Tkinter(Ttk) module and how it differs from the 
Tkinter module.
	460	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
9.1 Terminal-­
Based Applications Versus GUI-­
Based 
Applications
A computer terminal is a device, often referring to a utility program in today’s 
Windows environment, that can receive and deliver data or commands. The 
following shows what a terminal on Windows 11 looks like:
(base) PS C:\Users\james>
A terminal-­
based application is a program that runs from the command line 
within a terminal. For that reason, terminal-­
based applications are also called 
applications with a command-­
line interface. The following shows a Python 
program with a command-­
line interface running within a terminal.
(base) PS C:\workshop\comp218\samples\project2> python 
'.\perfect number​
.py'
tell me the upper bound:33
6 = [1, 2, 3]    28 = [1, 2, 4, 7, 14]
(base) PS C:\workshop\comp218\samples\project2> python 
'.\perfect number​
.py'
tell me the upper bound:53
6 = [1, 2, 3]    28 = [1, 2, 4, 7, 14]
(base) PS C:\workshop\comp218\samples\project2>
The terminal-­
based program shown above takes an integer as upper 
bound from the user and then finds all perfect numbers between 1 and the 
upper bound. With a terminal-­
based application, only a keyboard can be used 

by users to interact with the application.
A GUI-­
based application provides users with a graphical interface so that 
users can interact with the application with keyboard and mouse. VS Code 
IDE is an example of a GUI-­
based application we have been using throughout 
this text.
The difference between terminal-­
based and GUI-­
based applications is 
obvious. Although GUI-­
based applications are more user-­
friendly and more 
common today, terminal-­
based applications still exist and are used by some 
IT professionals, such as system administrators.
In the next section, we will learn how to develop GUI-­
based applications 
with Python.
	
Develop GUI-­
Based Applications	
461
 https://doi.org/10.15215/remix/9781998944088.01
9.2 Designing and Developing GUI-­
Based 
Applications in Python
The key component of a GUI-­
based application is a graphical user interface 
(GUI) on which both mouse and keyboard can be used to interact with the appli­
cation on a two-­
dimensional graphic interface. As mentioned above, GUI-­
based 
applications are more user-­
friendly than terminal-­
based applications. This is 
why most computer applications used today are GUI-­
based.
In general, you need to ask yourself the following questions when designing 
a GUI app:
•	 What will be shown to users?
•	 What input will be taken from users?
•	 What actions will we allow users to take?
•	 What actions will be taken in response to the users’ input?
•	 Where do we display the results of the actions?
Several Python modules are available for developing GUI-­
based applications.
•	 Tkinter, a de facto GUI library for Python applications, comes with the 
standard Python distribution so that you can import and use it right 
away. Documentation on tkinter can be found at https://​
docs​
.python​
.org/​
3/​
library/​
tk​
.html. You learned how to use Python modules and 
packages, including tkinter, in Chapter 8.
•	 PyGObject is a Python implementation of GObject-­
based libraries such 
as GTK, GStreamer, WebKitGTK, GLib, GIO, and some others. If you 
have played with Linux, you will probably know the GTK-­
 and GNOME-­
based graphical user interfaces. The project is hosted at https://​
pygobject​
.readthedocs​
.io/​
en/​
latest/.
•	 PyQt5 is another GUI library for Python GUI-­
based application 
development that implements the well-­
known Qt graphic framework. 
Information about PyQt5 can be easily found on the internet, and its 
home is at https://​
pypi​
.org/​
project/​
PyQt5/.
We chose to use a module called tkinter for its popularity among Python 
application developers and because of its light weight. The tkinter module 
usually comes with the standard Python distribution. To test if you have it 
installed, run import tkinter as shown below to see if you will get the same 
output:
	462	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> import tkinter
>>> dir(tkinter)
['ACTIVE', 'ALL', 'ANCHOR', 'ARC', 'BASELINE', 'BEVEL', 
'BOTH', 'BOTTOM', 'BROWSE', 'BUTT', 'BaseWidget', 
'BitmapImage', 'BooleanVar', 'Button', 'CASCADE', 
'CENTER', 'CHAR', 'CHECKBUTTON', 'CHORD', 'COMMAND', 
'CURRENT', 'CallWrapper', 'Canvas', 'Checkbutton', 
'DISABLED', 'DOTBOX', 'DoubleVar', 'E', 'END', 'EW', 
'EXCEPTION', 'EXTENDED', 'Entry', 'Event', 'EventType', 
'FALSE', 'FIRST', 'FLAT', 'Frame', 'GROOVE', 'Grid', 
'HIDDEN', 'HORIZONTAL', 'INSERT', 'INSIDE', 'Image', 
'IntVar', 'LAST', 'LEFT', 'Label', 'LabelFrame', 
'Listbox', 'MITER', 'MOVETO', 'MULTIPLE', 'Menu', 
'Menubutton', 'Message', 'Misc', 'N', 'NE', 'NO', 
'NONE', 'NORMAL', 'NS', 'NSEW', 'NUMERIC', 'NW', 
'NoDefaultRoot', 'OFF', 'ON', 'OUTSIDE', 'OptionMenu', 
'PAGES', 'PIESLICE', 'PROJECTING', 'Pack', 'PanedWindow', 
'PhotoImage', 'Place', 'RADIOBUTTON', 'RAISED', 
'READABLE', 'RIDGE', 'RIGHT', 'ROUND', 'Radiobutton', 
'S', 'SCROLL', 'SE', 'SEL', 'SEL_FIRST', 'SEL_LAST', 
'SEPARATOR', 'SINGLE', 'SOLID', 'SUNKEN', 'SW', 
'Scale', 'Scrollbar', 'Spinbox', 'StringVar', 'TOP', 
'TRUE', 'Tcl', 'TclError', 'TclVersion', 'Text', 
'Tk', 'TkVersion', 'Toplevel', 'UNDERLINE', 'UNITS', 
'VERTICAL', 'Variable', 'W', 'WORD', 'WRITABLE', 
'Widget', 'Wm', 'X', 'XView', 'Y', 'YES', 'YView', 
'__builtins__', '__cached__', '__doc__', '__file__', 
'__loader__', '__name__', '__package__', '__path__', 
'__spec__', '_cnfmerge', '_default_root', '_exit', '_
flatten', '_join', '_magic_re', '_setit', '_space_re', 
'_splitdict', '_stringify', '_support_default_root', 
'_test', '_tkerror', '_tkinter', '_varnum', 'constants', 
'enum', 'getboolean', 'getdouble', 'getint', 'image_
names', 'image_types', 'mainloop', 're', 'sys', 
'wantobjects']
A GUI application starts with a frame or window of a given size in terms of 
pixels, which is divided into rows and columns. Each of the grids is numbered 
from top to bottom, left to right, as shown in the following diagram:
	
Develop GUI-­
Based Applications	
463
 https://doi.org/10.15215/remix/9781998944088.01
(0,0)
(0,1)
(0,2)
(0,3)
(0,4)
(0,5)
(1,0)
(1,1)
(1,2)
(1,3)
(1,4)
(1,5)
(2,0)
(2,1)
(2,0)
(2,3)
(2,4)
(2,5)
(3,0)
(3,1)
(3,2)
(3,3)
(3,4)
(3,5)
(4,0)
(4,1)
(4,2)
(4,3)
(4,4)
(4,5)
(5,0)
(5,1)
(5,2)
(5,3)
(5,4)
(5,5)
Please note that although the frame size is measured in pixels, the coordinate 
of each grid above is only a relative location within the grid and has nothing to 
do with pixels. The size of each grid is dynamically determined by the object 
or widget placed in it.
Tkinter Module
The following code running from Python interactive mode renders a window/
frame (as shown in Figure 9-­
1):
>>> from tkinter import *
>>> f = Tk()
The following statements can be used to set the title and the size of the 
window:
>>> f.title("My First GUI App")
>>> f.geometry("300 x 200")
Figure 9-­
1: A window rendered by Python with Tkinter
	464	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Within this frame/window, we can place specific objects, called widgets, to 
serve their designated purposes, as detailed below:
•	 Label displays text and bitmaps.
•	 Entry displays simple text.
•	 Button displays a button and associates a command with the button that 
can be invoked.
•	 Checkbutton displays a button with only an on or off state. It is often 
used in groups to provide a number of options for users to select.
•	 Menu displays menu bars, pull-­
down menus, and pop-­
up menus.
•	 OptionMenu allows the user to select a value from a menu.
•	 PanedWindow is a container that may contain a number of panes.
•	 Radiobutton displays a radio button with an on/off state. It is used in 
groups, from which the user can select only one option at a time.
•	 Frame is a container to organize other widgets.
•	 LabelFrame is a spacer or container for complex window layouts.
•	 Text displays text in multiple lines.
•	 Canvas provides an area on which you can draw shapes such as lines, 
ovals, polygons, and rectangles in your application.
•	 Scale provides a slider showing numerical scale.
•	 Scrollbar adds scrolling capability to various widgets, such as text and 
list boxes.
•	 Spinbox is a variant of the standard Tkinter Entry widget and selects 
from a fixed number of values.
•	 Toplevel provides a separate window container.
The following is a code sample in Jupyter Notebook:
In [ ]:
f = Tk() # make an instance of Tk window
f.title("My First GUI App") # add a title to the window
f.geometry("300 x 200") # set the size
# add a label widget with text
lb = tkinter.Label(text = "This is my first label") # 
label
lb.grid(row = 0, column = 0) # place the window
f.mainloop() # render it up to show
Out [ ]:
The window will be rendered as shown in Figure 9-­
2:
In the above, the first statement creates a label object with the text “This 
is my first label” on it, whereas the second statement places the object in a 
specific grid of the window. If no arguments are specified for the grid, the 
	
Develop GUI-­
Based Applications	
465
 https://doi.org/10.15215/remix/9781998944088.01
default value is used, which is the next available grid in the window in order 
from top to bottom, left to right.
Similarly, we can add an Entry widget to the window using the following 
statements:
In [ ]:
 f = Tk()
 f.title("My first GUI app")
 f.geometry("300x200")
 lb = tkinter.Label(text = "Please input here")
 lb.grid(row = 0, column = 0)
 ent = tkinter.Entry()
 ent.grid(row = 0, column = 1)
 f.mainloop()
By now the window should look like the one shown in Figure 9-­
3.
Figure 9-­
3: A GUI example with added entry widget
Figure 9-­
2: A GUI example with more details
	466	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In addition to the Entry widget for taking single-­
line text input, the Button 
and Text widgets take mouse click and multiple-­
line text input, respectively, 
from users. We can add buttons and text boxes to the window with the follow­
ing statements:
In [ ]:
f = Tk()
f.title("My first GUI app")
f.geometry("300 x 200")
 lb = tkinter.Label(text = "Please input here")
 lb.grid(row = 0, column = 0)
 ent = tkinter.Entry()
 ent.grid(row = 0, column = 1)
 btn = Button(text = "Click me")
 btn.grid(column = 0, row = 1)
 txt = Text(width = 20, height = 10)
 txt.grid(column = 1, row = 2)
 f.mainloop()
The rendered window is shown in Figure 9-­
4.
Within the window, you can type in the entry field, type more in the text 
area, and click the button, but the app does not do anything in response, as 
shown in Figure 9-­
5.
Figure 9-4: A GUI example with more widgets added
Figure 9-­
5: A GUI example taking user input
	
Develop GUI-­
Based Applications	
467
 https://doi.org/10.15215/remix/9781998944088.01
How can we make the app respond to the user’s input and do what we want 
it to do? We need to attach an even handler to the intended object, such as a 
button, as shown below:
In [ ]:
 f = Tk()
 f.title("My first GUI app")
 f.geometry("300 x 200")
 lb = tkinter.Label(text = "Please input here")
 lb.grid(row = 0, column = 0)
 ent = tkinter.Entry()
 ent.grid(row = 0, column = 1)
 btn = Button(text = "Click me")
 btn.grid(column = 0, row = 1)
 txt = Text(width = 20, height = 10)
 txt.grid(column = 1, row = 2)
 def hdl():
 btn.config(text = "You clicked me!")
 btn.config(command = hdl) # add handler to act
 f.mainloop()
In the above, we first define a function as a handler, which simply 
changes the text on the button to “You clicked me,” then attaches the hand­
ler to the button using the config() method built into the button object. 

As expected, the text on the button changes after a click on the button, as 
shown in Figure 9-­
6.
To learn more details about each of the widgets listed above, we can call for 
help in Python interactive mode or Jupyter Notebook. The following example 
shows how to get help on the Frame widget in Jupyter Notebook:
Figure 9-­
6: Now the GUI is able to respond to user input
	468	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
from tkinter import *
help(Frame)
As always, you can also search the internet for any widget in the tkinter 
module to get help, including very detailed discussions on its use.
With what we have learned so far, we should be ready to develop a real 
GUI-­
based application, which is the GUI version of a grade conversion pro­
gram. The conversion is based on the data in Table 9-­
1, and the case study 
is in Table 9-­
2.
Table 9-­
1: Grade conversion table
Letter grade
%
Letter grade
%
A+
90–­
100
C+
67–­
69
A
85–­
89
C
64–­
66
A-­
80-­
84
C-­
60-­
63
B+
76–­
79
D+
55–­
59
B
73–­
75
D
50–­
54
B−
70–­
72
F
0–­
49
Table 9-­
2: Case study: How to convert grades in a GUI program
The problem
To develop a GUI-­
based application that can take the a numerical 
grade from a user and convert it to a letter grade.
The analysis 
and design
The application is meant to convert numerical grades to letter 
grades based on the conversion table shown as Table 9-­
1. The 
information flow is:
Get a numerical grade from user → convert to a letter grade → 
display the letter grade
In previous chapters, we showed how to develop a terminal-­
based 
application to do this conversion, where the input and output 
were all done on a standard terminal. In a GUI-­
based application, 
the input and output/display need to be done on a graphic 
interface.
Consider the widget in the tkinter module. We need an Entry widget 
for input and a Label widget to display the converted letter grade, 
a Button to start a conversion, and another Button to exit and 
close the application. Of course, we also need a function to do 
the actual conversion.
	
Develop GUI-­
Based Applications	
469
 https://doi.org/10.15215/remix/9781998944088.01
The code
"""
A GUI-­
based program using the Tkinter module
to convert numeric grades to alpha letter/grades.
"""
from tkinter import *
def n_to_l(n_g):
  n_g = round(float(n_g))
  if n_g in range(90, 101):
    lg = f"Letter grade of {n_g} is A+"
  elif n_g in range(85, 90):
    lg = f"Letter grade of {n_g} is A"
  elif n_g in range(80, 85):
    lg = f"Letter grade of {n_g} is A-"
  elif n_g in range(76, 80):
    lg = f"Letter grade of {n_g} is B+"
  elif n_g in range(73, 76):
  lg = f"Letter grade of {n_g} is B"
  elif n_g in range(70, 73):
    lg = f"Letter grade of {n_g} is B-"
  elif n_g in range(67, 70):
    lg = f"Letter grade of {n_g} is C+"
  elif n_g in range(64, 67):
    lg = f"Letter grade of {n_g} is C"
  elif n_g in range(60, 64):
    lg = f"Letter grade of {n_g} is C-"
  elif n_g in range(55, 60):
    lg = f"Letter grade of {n_g} is D+"
  elif n_g in range(50, 54):
    lg = f"Letter grade of {n_g} is D"
  elif n_g in range(0, 50):
    lg = f"Letter grade of {n_g} is F"
  else:
    lg = "invalid mark!"
  return lg
def hdl():
  n = int(ent1.get())
  lb2.config(text = f"{n_to_l(n)}")
  return -­
1
w = Tk()
w.title("My GUI-­
based grade converter")
w.geometry("500 x 200")
lb1 = Label(text = "Please input percentage grade:")
lb1.grid(column = 2, row = 1, rowspan = 3, pady = 30)
ent1 = Entry()
ent1.grid(column = 3, row = 1, rowspan = 3, pady = 30)
btn = Button(text = "Convert", background = "#00FF00")
btn.grid(column = 2, row = 5, rowspan = 3, pady = 30)
btn.config(command = hdl)
btn_quit = Button(text = "Quit", background = "#FF0000")
btn_quit.grid(column = 6, row = 5, rowspan = 3, pady = 
30)
btn_quit.config(command=quit)
lb2 = Label(text = "Letter grade will be displayed here")
lb2.grid(column = 2, row = 8, rowspan = 3)
mainloop()
# this statement must be placed here to keep the window 
alive
	470	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In the coding example, the .grid() method positions a widget in the parent 
widget in a grid or cell. The options that can be used with the .grid() method 
are as follows:
column = number—­
uses cell identified with given column (starting 
with 0)
columnspan = number—­
spans several columns
in = master—­
uses master to contain this widget
in_ = master—­
uses master to contain this widget
ipadx = amount—­
adds internal padding in x direction
ipady = amount—­
adds internal padding in y direction
padx = amount—­
adds padding in x direction
pady = amount—­
adds padding in y direction
row = number—­
uses a cell identified with a given row (starting with 0)
rowspan = number—­
span several rows
sticky = NSEW—­
tells on which sides this widget will stick to the cell 
boundary if the cell is larger
Note that we placed a method of the imported tkinter module named 
.mainloop() at the very end of the program. The call to the method is neces­
sary to keep the window of the GUI-­
based app alive when running the code 
from the Python program file. Otherwise, the window will disappear as soon 

as the Python Virtual Machine (PVM) reaches the end of the program file.
You may wonder why the GUI window we created from the Python inter­
active shell stays alive without the .mainloop() statement. The reason is very 
simple: because PVM is still waiting for you to input a numeric grade, which 
means that the file (standard IO file) won’t reach the end as long as you have 
not quit the Python interactive shell.
The GUI application can also be placed in a frame. The result and the code 
are shown in Figure 9-­
7 and below. As you can see, it has become nicer.
Figure 9-­
7: A GUI application doing grade conversion
	
Develop GUI-­
Based Applications	
471
 https://doi.org/10.15215/remix/9781998944088.01
"""
You are required to design a GUI-­
based program using the 
Tkinter
module to convert numeric grades to alpha letter/grades.
"""
from tkinter import *
 
def n_to_l(n_g):
  n_g = round(float(n_g))
  if n_g in range(90, 101):
    lg = f"Letter grade of {n_g} is A+"
  elif n_g in range(85, 90):
    lg = f"Letter grade of {n_g} is A"
  elif n_g in range(80, 85):
    lg = f"Letter grade of {n_g} is A-"
  elif n_g in range(76, 80):
    lg = f"Letter grade of {n_g} is B+"
  elif n_g in range(73, 76):
    lg = f"Letter grade of {n_g} is B"
  elif n_g in range(70, 73):
    lg = f"Letter grade of {n_g} is B-"
  elif n_g in range(67, 70):
    lg = f"Letter grade of {n_g} is C+"
  elif n_g in range(64, 67):
    lg = f"Letter grade of {n_g} is C"
  elif n_g in range(60, 64):
    lg = f"Letter grade of {n_g} is C-"
  elif n_g in range(55, 60):
    lg = f"Letter grade of {n_g} is D+"
  elif n_g in range(50, 54):
    lg = f"Letter grade of {n_g} is D"
  elif n_g in range(0, 50):
    lg = f"Letter grade of {n_g} is F"
  else:
    lg = "invalid mark!"
  return lg
 
def hdl():
  n = int(ent1.get())
  lb2.config(text = f"{n_to_l(n)}")
	472	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
  return -­
1
 
w = Frame()
# to add frame widget
 
w.master.title("My GUI-­
based grade converter in Frame")
w.master.geometry("500 x 200")
lb1 = Label(text = "Please input percentage grade:")
lb1.grid(column = 2, row = 1, rowspan = 3, pady = 30)
ent1 = Entry()
ent1.grid(column = 3, row = 1, rowspan = 3, pady = 30)
btn = Button(text = "Convert", background = "#FF0000")
btn.grid(column = 2, row = 5, rowspan = 3, pady = 30)
btn.config(command = hdl)
btn_quit = Button(text = "Quit", background = "#FF0000")
btn_quit.grid(column = 6, row = 5, rowspan = 3, pady = 
30)
btn_quit.config(command = quit)
lb2 = Label(text = "Letter grade will be displayed here")
 
lb2.grid(column = 2, row = 8, rowspan = 3)
mainloop()
# this statement must be placed below all others to keep 
the window alive
If you don’t like placing widgets with the .geometry() method, you may 

use the .pack() method to let the PVM automatically place the widgets for you. 
The new GUI-­
based app and the revised Python code are shown in Figure 9-­
8 
and below.
Figure 9-­
8: Frame widget is used in the GUI application
	
Develop GUI-­
Based Applications	
473
 https://doi.org/10.15215/remix/9781998944088.01
"""Revised grade conversion: placing widgets with the 
.geometry() method."""
 
from tkinter import *
 
def n_to_l(n_g):
  n_g = round(float(n_g))
  if n_g in range(90, 101):
    lg = f"Letter grade of {n_g} is A+"
  elif n_g in range(85, 90):
    lg = f"Letter grade of {n_g} is A"
  elif n_g in range(80, 85):
    lg = f"Letter grade of {n_g} is A-"
  elif n_g in range(76, 80):
    lg = f"Letter grade of {n_g} is B+"
  elif n_g in range(73, 76):
    lg = f"Letter grade of {n_g} is B"
  elif n_g in range(70, 73):
    lg = f"Letter grade of {n_g} is B-"
  elif n_g in range(67, 70):
    lg = f"Letter grade of {n_g} is C+"
  elif n_g in range(64, 67):
    lg = f"Letter grade of {n_g} is C"
  elif n_g in range(60, 64):
    lg = f"Letter grade of {n_g} is C-"
  elif n_g in range(55, 60):
    lg = f"Letter grade of {n_g} is D+"
  elif n_g in range(50, 54):
    lg = f"Letter grade of {n_g} is D"
  elif n_g in range(0, 50):
    lg = f"Letter grade of {n_g} is F"
  else:
    lg = "invalid mark!"
  return lg
 
def hdl():
  n = int(ent1.get())
  lb2.config(text = f"{n_to_l(n)}")
  return -­
1
 
	474	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
w = Tk()
w.title("My GUI-­
based grade converter")
w.geometry("500 x 200")
lb1 = Label(text = "Please input percentage grade:")
lb1.pack(fill = Y, expand = 1)
ent1 = Entry()
ent1.pack(expand = 0)
btn_convert = Button(text = "Convert", background = 
"#33FF88")
btn_convert.pack(padx = 10, side = LEFT, expand = 0)
btn_convert.config(command = hdl)
btn_quit = Button(text = "Quit", background = "#FF0000")
btn_quit.pack(padx = 10, side = RIGHT, expand = 0)
btn_quit.config(command = quit)
lb2 = Label(text = "Letter grade will be displayed 
here")
lb2.pack(fill = Y, expand = 1)
mainloop()
# this statement must be placed at the end to keep the 
window alive
As you can see, the GUI-­
based app is rendered much more nicely with the 
.pack() method. The .pack() method is used to pack a widget in the parent 
widget. The options of the .pack() method and their meaning are as follows:
•	 after = widget—­
packs it after you have packed the widget
•	 anchor = NSEW (or subset)—­
positions widget according to a given 
direction
•	 before = widget—­
packs it before you pack the widget
•	 expand = bool—­
expands the widget if the parent size grows
•	 fill = NONE or X or Y or BOTH—­
fills the widget if the widget grows
•	 in = master—­
uses master to contain the widget
•	 in_= f—­
uses fx to contain the widget
•	 ipadx = amount—­
adds internal padding in x direction
•	 ipady = amount—­
adds internal padding in y direction
•	 padx = amount—­
adds padding in x direction
•	 pady = amount—­
adds padding in y direction
•	 side = TOP or BOTTOM or LEFT or RIGHT—­
indicates where to add the 
widget
	
Develop GUI-­
Based Applications	
475
 https://doi.org/10.15215/remix/9781998944088.01
Because all the widgets inherit behaviours from the Widget class, it is worth 
learning about the general methods available in the Widget class for manipu­
lating widgets.
tkinter.ttk—­
Tk-­
Themed Widgets
In the past, people have complained about the look of GUI and the widgets of 
tkinter, which led to the development of themed widgets of tkinter, or Ttk for 
short. Now the Ttk module is part of the standard Python distribution. To use 
it, all you need to do is to import the modules in the sequence shown below to 
make sure Ttk overrides definitions of classes as intended.
>>> from tkinter import *
>>> import tkinter.ttk
Because themed widgets is based on the tkinter module, it overrides defin­
itions of classes, widgets, and methods.
Again, once imported, you can use help(tkinter.ttk) to get a rather detailed 
documentation of the module, as summarized below:
As for all GUI libraries, the core of the module are the widgets and meth­
ods associated with the widgets. All widget classes inherit from a generic 
class called Widget. The following is a list of widgets defined in the themed 
Tk module.
BUTTON(WIDGET)
Ttk Button displays a textual label and/or image and evaluates a command 
when pressed. In addition to the methods inherited from Widget, it has 
method specific for its purpose, invoke(self), which invokes the command 
associated with the button.
CHECKBUTTON
Ttk Checkbutton will be either in an on or off state. It has a specific method 
called invoke(self) in addition to those inherited from Widget. The invoke(self) 
will switch the Checkbutton between on and off states, further invoke the asso­
ciated command, and return the result of executing the command associated 
with Checkbutton.
ENTRY(WIDGET, TKINTER.ENTRY)
Ttk Entry displays a one-­
line text string that allows that string to be edited by 
the user. It inherits from Widget and tkinter.Entry.
	476	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
COMBOBOX(ENTRY)
Ttk Combobox widget combines a text field with a pop-­
down list of values. It 
inherits from Ttk Entry, described above. It has two methods of its own:
	
1.	 current(self, newindex = None)—­
if newindex is supplied, it sets the 
combobox value to the element at position newindex in the list of 
values. Otherwise, it returns the index of the current value in the list 
of values or −1 if the current value does not appear in the list.
	
2.	 set(self, value)—­
sets the value of the combobox to “value.”
SPINBOX(ENTRY)
Ttk Spinbox is an Entry with increment and decrement arrows. It is commonly 
used for number entry or to select from a list of string values.
FRAME(WIDGET)
Ttk Frame is a container used to group other widgets together.
LABELEDSCALE(FRAME)
Ttk Scale is used with Ttk Label, indicating its current value. Ttk Scale can 
be accessed through instance.scale, and Ttk Label can be accessed through 
instance.label.
LABEL(WIDGET)
Ttk Label displays a textual label and/or image.
LABELFRAME(WIDGET)
Ttk Labelframe is a container used to group other widgets together. It has an 
optional label, which may be a plaintext string or another widget.
MENUBUTTON(WIDGET)
Ttk Menubutton displays a textual label and/or image. It will display a menu 
when pressed.
OPTIONMENU(MENUBUTTON)
Ttk OptionMenu allows the user to select a value from a menu.
NOTEBOOK(WIDGET)
Ttk Notebook manages a collection of windows and displays a single one at a 
time. Each child window is associated with a tab that the user may select to 
	
Develop GUI-­
Based Applications	
477
 https://doi.org/10.15215/remix/9781998944088.01
make the associated window show up. This gives us a way to implement tabs 
like those in web browsers.
PANEDWINDOW(WIDGET, TKINTER.PANEDWINDOW)
Ttk Panedwindow displays a number of subwindows stacked either vertically 
or horizontally. It has the following specific methods:
	
1.	 remove(self, child)
	
2.	 insert(self, pos, child, **kw)—­
inserts a pane at the specified positions.
	
3.	 pane(self, pane, option = None, **kw)—­
queries or modifies the options 
of the specified pane.
	
4.	 sashpos(self, index, newpos = None)—­
if newpos is specified, sets the 
position of sash number index and returns the new position of sash 
number index.
PROGRESSBAR(WIDGET)
Ttk Progressbar shows the status of a long-­
running operation. It can operate 
in two modes. Determinate mode shows the amount completed relative to the 
total amount of work to be done, and indeterminate mode provides an animated 
display to let the user know that something is happening.
RADIOBUTTON
Ttk Radiobuttons are used in groups to show or change a set of mutually exclu­
sive options. The specific method invoke(self) sets the option variable to the 
option value, selects the widget, and invokes the associated command. It returns 
the result of the command or an empty string if no command is specified.
SCALE(WIDGET, TKINTER.SCALE)
Ttk Scale is typically used to control the numeric value of a linked variable that 
varies uniformly over some range.
SCROLLBAR(WIDGET, TKINTER.SCROLLBAR)
Ttk Scrollbar controls the viewport of a scrollable widget.
SEPARATOR(WIDGET)
Ttk Separator displays a horizontal or vertical separator bar.
SIZEGRIP(WIDGET)
Ttk Sizegrip allows the user to resize the containing top-­
level window by press­
ing and dragging the grip.
	478	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
TREEVIEW(WIDGET, TKINTER.XVIEW, TKINTER.YVIEW)
Ttk Treeview displays a hierarchical collection of items. Each item has a textual 
label, an optional image, and an optional list of data values. The data values 
are displayed in successive columns after the tree label. It has the following 
specific methods:
•	 bbox(self, item, column = None)
It returns the bounding box (relative to the Treeview widget’s window) 
of the specified item in the form of x y width height. If a column is 
specified, it returns the bounding box of that cell. If the item is not 
visible (i.e., if it is a descendant of a closed item or is scrolled off-­
screen), it returns an empty string.
•	 column(self, column, option = None, **kw)
It queries or modifies the options for the specified column. If kw is not 
given, it returns a dictionary of the column option values. If option is 
specified, then the value for that option is returned. Otherwise, it sets 
the options to the corresponding values.
•	 delete(self, *items)
It deletes all specified items and all their descendants. The root item 
may not be deleted.
•	 detach(self, *items)
It unlinks all of the specified items from the tree. The items and all of 
their descendants are still present and may be reinserted at another 
point in the tree but will not be displayed. The root item may not be 
detached.
•	 exists(self, item)
It returns True if the specified item is present in the tree; returns False 
otherwise.
•	 focus(self, item = None)
if an item is specified, it sets the focus item to item. Otherwise, it 
returns the current focus item, or '' if there is none.
•	 get_children(self, item = None)
It returns a tuple of children belonging to item. If the item is not 
specified, it returns root children.
•	 heading(self, column, option = None, **kw)
It queries or modifies the heading options for the specified column. If 
kw is not given, it returns a dict of the heading option values. If option 
is specified, then the value for that option is returned. Otherwise, it sets 
the options to the corresponding values. Valid options/values include 
text, image, anchor, and a callback command.
	
Develop GUI-­
Based Applications	
479
 https://doi.org/10.15215/remix/9781998944088.01
•	 identify(self, component, x, y)
It returns a description of the specified component under the point 
given by x and y or the empty string if no such component is present at 
that position.
•	 identify_column(self, x)
It returns the data column identifier of the cell at position x. The tree 
column has ID #0.
•	 identify_element(self, x, y)
It returns the element at position x, y.
•	 identify_region(self, x, y)
For the given coordinator (x, y) of a point related to the widget, it 
returns a string indicating one of the following: nothing (not within any 
functional part of the widget), heading (a column heading), separator (a 
separator between columns), tree (the icon column), or cell (a data cell 
within an item row).
•	 identify_row(self, y)
It returns the item ID of the item at position y.
•	 index(self, item)
It returns the integer index of an item within its parent’s list of 
children.
•	 insert(self, parent, index, iid = None, **kw)
It creates a new item and returns the item identifier of the newly 
created item, where parent is the item ID of the parent item or the 
empty string to create a new top-­
level item and index is an integer 
or the value end, specifying where in the list of parent’s children to 
insert the new item. If index is less than or equal to 0, the new node 
is inserted at the beginning; if index is greater than or equal to the 
current number of children, it is inserted at the end. If iid is specified, 
it is used as the item identifier, but iid must not already exist in the tree. 
Otherwise, a new unique identifier is generated.
•	 item(self, item, option = None, **kw)
It queries or modifies the options for a specified item. If no options are 
given, a dict with options/values for the item is returned. If an option is 
specified, then the value for that option is returned. Otherwise, it sets 
the options to the corresponding values, as given by kw.
•	 move(self, item, parent, index)
It moves item to position index in parent’s list of children. It is illegal 
to move an item under one of its descendants. If an index is less than 
or equal to 0, the item is moved to the beginning; if greater than or 
	480	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
equal to the number of children, it is moved to the end. If the item was 
detached, it is reattached.
•	 next(self, item)
It returns the identifier of an item’s next sibling, or '' if the item is the 
last child of its parent.
•	 parent(self, item)
It returns the ID of the parent of an item, or '' if the item is at the top 
level of the hierarchy.
•	 prev(self, item)
It returns the identifier of an item’s previous sibling, or '' if the item is 
the first child of its parent.
•	 see(self, item)
It ensures that the item is visible and sets all of the item’s ancestors’ 
open options to True and scrolls the widget if necessary so that the item 
is within the visible portion of the tree.
•	 selection(self, selop = <object object at 0x000002122111D7F0>, 
items=None)
It returns the tuple of the selected items.
•	 selection_add(self, *items)
It adds all of the specified items to the selection.
•	 selection_remove(self, *items)
It removes all of the specified items from the selection.
•	 selection_set(self, *items)
It makes the specified items become the new selection.
•	 selection_toggle(self, *items)
It toggles the selection state of each specified item.
•	 set(self, item, column = None, value = None)
It queries or sets the value of a given item.
•	 set_children(self, item, *newchildren)
It replaces an item’s child with newchildren.
•	 tag_bind(self, tagname, sequence = None, callback = None)
It binds a callback for the given event sequence to the tag tagname. 
When an event is delivered to an item, the callbacks for each tag option 
of the item are called.
•	 tag_configure(self, tagname, option = None, **kw)
It queries or modifies the options for the specified tagname.
•	 tag_has(self, tagname, item = None)
If an item is specified, it returns 1 or 0 depending on whether the 
specified item has the given tagname. Otherwise, it returns a list of all 
items that have the specified tag.
	
Develop GUI-­
Based Applications	
481
 https://doi.org/10.15215/remix/9781998944088.01
The Treeview widget provides a way to use tree-­
like structures to visualize 
and manipulate data and information. The methods available for manipulating 
trees are versatile.
Among all the widgets provided in themed tkinter, the newly added Treeview, 
Progressbar, and Notebook are very powerful and can be very useful in develop­
ing today’s GUI applications, such as those in the exercises, and projects below.
The content above Ttk and Treeview in particular are mostly taken from 
the official documentation of Tkinter, for the purpose to prepare readers 

for the projects at the end of this chapter.
For details on how Ttk can be used to develop GUI applications, please 
read the Ttk documentation at https://​
docs​
.python​
.org/​
3/​
library/​
tkinter​
.ttk​
.html and tutorials online such as the one at https://​
www​
.pythontutorial​
.net/​
tkinter/​
tkinter​
-ttk/.
Instead of giving code samples for each widget like we previously did, we 
conclude this chapter with the following sample program to show how Ttk and 
Treeview can be used in GUI application development:
import tkinter as tk
from tkinter import ttk
 
class FileManager:
    def __init__(self):
        self.root = tk.Tk()
        self.tree = ttk.Treeview(self.root)
        self.tree.pack()
        self.tree["columns"] = ("one", "two", "three", 
"four")
        self.tree.heading("one", text="Path")
        self.tree.heading("two", text="File name")
        self.tree.heading("three", text="File size")
        self.tree.heading("four", text="Last modified")
        self.tree.insert("", "end", text="1", values=("/
home/james/", "a.txt","213","June 3, 2023" ))
        self.tree.insert("", "end", text="2", values=("/
home/james/", "b.txt","215","June 5, 2023" ))
        self.tree.insert("", "end", text="3", values=("/
home/james/", "c.txt","217","June 7, 2023" ))
        self.root.mainloop()
 
FileManager()
	482	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Chapter Summary
•	 Terminal-­
based applications are those started and rendered within a 
terminal.
•	 A terminal is a system command-­
line-­
based application in which you 
can interact with a computer.
•	 On the Windows platform, Windows terminal, Windows PowerShell, 
and command prompt are examples of terminals.
•	 Within a terminal-­
based application, pointing devices such as a mouse 
cannot be used to interact with the application.
•	 A graphical user interface is a two-­
dimensional graphic area in which 
graphic objects or widgets can be created, placed, located, and accessed 
with mouse and keyboard.
•	 GUI-­
based applications look nicer and are much more user-­
friendly.
•	 Python has some very well-­
developed library modules for the 
development of applications with graphical user interface.
•	 The Tk and Themed Tk (Ttk) are the modules covered in this text; both 
come with the Tkinter package.
•	 The Tk module provides the fundamental widgets and operations 
needed for a graphic interface.
•	 To use the Tk module, use import tkinter, import tkinter as tk, or from 
tkinter import. *.
•	 The Themed Tk (Ttk) module provides programmers with more styled 
widgets to develop applications with a nicer graphical user interface.
•	 To ensure you are using the Ttk module instead of Tk module, override 
Tk by running statements from tkinter import * and from tkinter.ttk 
import * in order.
•	 To build a graphical user interface, create a main frame or window 
first.
•	 Other widgets can be created and added to the main frame/window as 
needed.
•	 Each widget has certain properties/attributes such as size, colour, and 
more.
•	 The properties of a widget can be set when created and changed later.
•	 A widget can be placed at particular location within the main frame or 
subframe.
•	 A function/method can be bound to widgets, such as a button, to help 
users interact with the graphical user interface.
•	 A graphical user interface needs to be rendered by calling the 
mainloop() method of main frame object.
	
Develop GUI-­
Based Applications	
483
 https://doi.org/10.15215/remix/9781998944088.01
Exercises
	
1.	 Explore the relationship between Tk and Ttk, and explain what the 
following code does:
from tkinter import *
from tkinter.ttk import *
	
2.	 Write a script that will render a window as shown in Figure 9-­
9.
	
3.	 Write a script that will render a page for login or registration, as 
shown in Figure 9-­
10.
Figure 9-­
10: Required GUI interface for the project
Figure 9-­
9: Required GUI interface for the exercise
	484	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Projects
	
1.	 For this project, develop a GUI-­
based music player with the module 
mixer.music as well as the os and os.path modules for file navigation. 
The player should have a panel for the navigation and selection of 
music files, as well as buttons to control play, stop, and pause.
	
2.	 For this project, develop a course management system with a 
graphical user interface that meets the following requirements:
	
a.	 Define a student class modelling a student, including their name, 
student id, and start date in the class, as well as the name of the 
tutor assigned to them and a list of their assessment records. Each 
assessment record will be a tuple containing a number to identify 
the assessment, the weight of the assessment, and the mark, which 
should be 0 for a newly added instance to a course.
	
b.	 Define a course class modelling a course, including its course 
number (such as comp218), title, and revision number, as 
well as the date of its initial offering and a list of its students, 
professor(s). Additionally, include an assessment schedule as a list 
of assessment items where each assessment item is represented as 
a tuple of (id, name, weight) in which the id is the assessment item 
id, the name is the assessment name such as assignment 1 or final 
exam, and the weight is the percentage of the assessment that will 
go toward the final grade.
	
c.	 The GUI program should include and do all of the following:
•	 There should be a button for adding a new course to the system, 
which will open a form for input and save the basic course info 
(previously mentioned), with the list of students as empty. Note 
that when saving the basic course info, the system should be 
able to check whether the weight of all the assessment items 
makes up 100%.
•	 When a new course is added to the system, a unique binary file 
will be created as permanent storage of the course data.
•	 At the start of the system, it should automatically load all 
courses from their respective binary files to restore their 
internal object representation.
•	 There should be a button to get a list of courses being offered to 
students.
•	 A user should be able to select a course from the list.
•	 A user should be able to add students to the selected course.
•	 A user should be able to see a list of students in the course.
	
Develop GUI-­
Based Applications	
485
 https://doi.org/10.15215/remix/9781998944088.01
•	 A user should be able to select a student from the list.
•	 A user should be able to record an assessment for the selected 
student.
•	 The system should be able to automatically calculate and display 
the final grade of the student for the course.
•	 A user should be able to see a list of assessments, including the 
calculated final grade for the selected student.
•	 There should be a button to shut down the system, but before 
shutting down the application, the system must save/pickle each 
piece of course data back to its binary file.
	
d.	 Your analysis and design of the system should be well documented 
in your assignment report.
	
e.	 Within each of your program files, there should be a docstring at 
the beginning stating the name and purpose of the file, as well as 
its ownership and revision history. One docstring is required for 
each class and function/method class. An end-­
of-­
line comment is 
desired when deemed necessary.
	
3.	 In Project 1 of Chapter 7, you developed a terminal-­
based quiz system. 
For this project, you are required to develop a GUI-­
based quiz system 
also using the Quiz_item and Quiz classes you wrote in Chapter 7’s 
Exercises 7 and 8. The system should have controls/widgets on the GUI 
that will allow a user to do the following:
	
a.	 Create a quiz.
	
b.	 Select a quiz and add new quiz items.
	
c.	 Select a quiz and preview all the quiz items.
	
d.	 Select a quiz and execute the quiz by presenting the quiz items one 
by one.
	
4.	 Modify the quiz system developed for Project 3 so that after the quiz, 
it will present to the user the score as a percentage and the correct 
answers to incorrectly answered questions. The quiz items should be 
displayed to the user one by one during the quiz. Add a timer to the 
quiz so that the entire quiz must be done within a given time. To make 
sense of the timer function, you will need to show the total number of 
quiz items, the number of items left to be answered, the total amount 
of time allocated for the entire quiz, and the amount of time left for 
the remaining quiz items.
	
5.	 Further modify the quiz system developed for Projects 3 and 4, so 
that not only is the quiz timed, but each quiz item is also timed too, 
meaning that the user must answer each quiz question within a given 
time. For simplicity, we can assume that the time allocated to each 
	486	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
quiz item is the same and equal to the total time allocated to the quiz 
divided by the total number of questions in the quiz. To make better 
sense of both timers now, the time (number of seconds) left for a quiz 
question also needs to be displayed, and the quiz will move to the 
next question as soon as the question is answered or the timer for the 
question has run out.


ID: https://leanpub.com/s/21266BDE86AA47EA8A2D75570C7C1193.pdf
Document: Your First Year in Code
A complete guide for new & aspiring developers
Isaac Lyman
This book is for sale at http://leanpub.com/firstyearincode
This version was published on 2022-02-17
This is a Leanpub book. Leanpub empowers authors and publishers with the Lean Publishing
process. Lean Publishing is the act of publishing an in-progress ebook using lightweight tools and
many iterations to get reader feedback, pivot until you have the right book and build traction once
you do.
© 2019 - 2022 Isaac Lyman
Contents
Foreword . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
About the editor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2
About this book . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4
Introduction: Code is the best, code is the worst . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
Different learning pathways into tech . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
How (not) to learn . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
14
How to code (in one chapter) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21
Steps to better code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
41
Programming tools . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
51
You are an interpreter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
56
What to learn first . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
61
Learning to learn . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
64
Make the most of side projects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
70
Getting your first job . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
76
My first job . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
83
I got my dream job. Now what? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
85
Burnout, part 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
89
Burnout, part 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
92
Do I fit in? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
95
Women in code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
CONTENTS
What to do when you’re stuck . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
Choosing a job title . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
The DevOps introduction I wish I had . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
A coder’s code of ethics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
Software development beyond the keyboard . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
Code reviews . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
Appendix A: A coder’s vocabulary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
Appendix B: To make this, learn that . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
Appendix C: Recommended reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158
Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
Foreword
Your first year in code is a whirlwind, I know it was for me. The more you learn, the more you learn
that there’s more to learn. Code is such an abstract problem that there’s no set of always-applicable
rules or rock-solid advice. Code powers the planet these days, but knowledge is still passed down
through our elders and cultivated via community.
There is no one true way to be a coder. Gone are the days, if ever they truly existed, of the archetypal
“programmer.” We all carry supercomputers in our pockets. Cloud service outages are front page
news; email servers and encryption can be everyday political topics. The nerds have won and code
has become mainstream.
The only way for code to be for the people is if it is created by the people. We cannot let this craft
become magic wielded by a select few. We must ensure that the discourse is accessible to all.
The fact that this book is such a true bottom-up community initiative speaks to the soul of the
material. Isaac and the rest of the incredible authors assembled in these pages represent the warmth,
humanity, and diversity of our industry. If you are in your first year of code, you’re lucky to have
discovered material like this. I wish I had. It’s still a tremendous read years into my career.
Happy coding!
Ben Halpern
Founder, The DEV Community
dev.to/ben
About the editor
I’m a self-taught programmer.
By that I mean a lot of different people taught me to code. Mostly strangers. When I was in middle
school, I found an ebook called C++ For Dummies that my brother had bought. I read it until the
chapter on pointers, where I got confused and gave up. Then a few months later I did it again. I read
the first several chapters of that book over and over until I practically knew them by heart. I wrote
a Fahrenheit-to-Celsius converter. I started thinking about classes and objects. I was so curious.
Part of that curiosity stemmed from the fact that I identified with code. Computer programming was
nerdy, and I was a nerd. I mean, I had friends who wore Naruto headbands and played Yu-Gi-Oh!
in the cafeteria, and I wasn’t quite that nerdy. But by my senior year of high school I was president
of the computer support team and co-president of the speech and debate team, so that should tell
you what kind of kid I was. Code was exactly the kind of thing I wanted to play with.
Anyway, I learned Python a year or two after I first picked up that C++ book, and then a bit of
HTML, and then Visual Basic, and before long I had filled up a folder on my family’s computer with
ebooks and CHM files (an old form of hyperlinked documentation) that all had ridiculous titles like
Learn PHP in 24 Hours. I had even written a couple of programs on my TI-84 calculator to save
time on calculus homework. But I had also written off computer programming as an unrealistic
career ambition. Back then coding just seemed like a fun hobby for a kid who didn’t get out much.
I had no way of knowing that over the next decade Silicon Valley would explode with tech startups,
web developers would command salaries comparable to corporate lawyers, cell phone apps would
become a 100 billion dollar market, and nerds would take over the world.
So I set a more attainable career goal: become a business lawyer, then a politician. And that’d be the
whole story if I hadn’t run out of money during my sophomore year of college. After a disappointing
job search, I managed to land a position as a technical support agent, fixing printers and upgrading
operating systems in a cubicle on the outskirts of campus. And on the days when all the computers
were working and the printers were attending to their queues, I was learning JavaScript. The first
version of my personal website, isaaclyman.com¹, was built almost entirely during downtime on
that job. And I have that first website to thank for the career I have now.
I love this career, and I’m happy to report that I’ve been cured of all my former political ambitions.
I’m now a senior software engineer at a billion-dollar company that helps hospitals save lives
through cutting-edge healthcare analytics. I didn’t know it was possible to have this much fun at
work. But coding is fun, and I think that’s the first thing I want to say about it: for all the negatives
in this field of work (and there are a few), I still get a thrill whenever I write a clever piece of code.
Looking back on my career, it’s clear that I’ve had an extraordinary amount of privilege on my
side. Tech is full of gatekeepers, unwritten rules, poor documentation, and unacknowledged bias.
¹http://isaaclyman.com
About the editor
3
Sometimes it seems that everywhere you look, there’s someone else telling you you’re “not a real
developer” unless you’re exactly like them. Many talented programmers have been squeezed out
by these institutional problems. It will take a generation’s combined efforts to fix them, but in the
meantime, I hope this book can make a difference. In its pages are the encouraging and persistent
voices of your colleagues, telling you that you can do this, you’re smart enough, others have been
where you are, and we’re all in it together. My co-authors and I have done our best to write the tech
industry’s unwritten rules, call attention to its blind spots, share the knowledge we wish we’d had
years ago, and open the gates.
I hope this book is useful to you. If you have questions about anything you read here or just want
to say hello, you can drop me a line on Twitter (@isaacdlyman).
Good luck!
Isaac Lyman
About this book
It all started with a question: what do you wish you had known during your first year as a
programmer? I asked this question online when I announced the book, and before I knew it almost
a hundred software developers from around the world had volunteered to help me answer it. Some
signed up as beta readers and others offered to write content. The whole thing came together at an
incredible pace. In the end, the work of 15 other authors was selected for inclusion. The following
chapters represent some of the best, most practical advice the development community has to offer.
The author of each chapter is listed underneath the title.
The goal of this book is to help you start your programming journey a year or two ahead of where
we were when we started. There’s a lot of how-to, a splash of career advice, and a bit of pep talk. It’s
a good read for Computer Science majors, dev bootcamp students, beginning devs on a self-learning
path, or anyone who wants to figure out if programming is for them.
More importantly, this is stuff you won’t easily find elsewhere. You won’t get it in a college course or
a bootcamp. It won’t be in the company manual for your first job. Most software books are extremely
technical; this one is different. It will apply to you regardless of what sector or programming
language you want to get into. It’s mostly about the squishy stuff: what happens around and
outside the code. This is important because writing code is only a small part of a programmer’s
job—researchers have² found³ that the average programmer only writes about 25 lines of code per
day. Code is really just the beginning.
So what do programmers actually do? They go to meetings. They draw diagrams. They learn. They
get stuck. They bang their heads on their desks. They help their teammates solve problems. They
wade through an ocean of self-doubt. They field messages from tech recruiters. They update their
resumes and negotiate for remote work options. They balance their three-month-old baby on one
knee and a book about C++ on the other. They think methodically and ask questions nobody else
has thought about.
These things aren’t code, and in many ways they’re more important than code. They’re what this
book is about. And it’s about you: your career, your journey, all the amazing options that will open
up to you as you learn to code.
The book is not cumulative; each chapter stands on its own, so read them in any order you like.
We’ve done our best to keep things simple and avoid jargon, but if you encounter an unfamiliar
term, you can refer to Appendix A for a definition.
Whoever you are, we’re excited that you’re here. We have the highest of hopes for you. And we
hope you enjoy Your First Year in Code.
²https://blogs.msdn.microsoft.com/philipsu/2006/06/14/broken-windows-theory/
³https://dzone.com/articles/programmer-productivity
Introduction: Code is the best, code is
the worst
Isaac Lyman
Code is the best
Coding is an act of pure creation. It’s often exhilarating: you type a sequence of words into the
void and, assuming you don’t mess up, entire worlds begin to exist. Software development is one of
the few fields where you can create something of extraordinary value without expending any raw
materials. In a way, coding more closely resembles the TV stereotype of witches and wizards than
the TV stereotype of coders (or developers, or engineers, or whatever they call themselves—see my
chapter “Choosing a job title” for more on that topic).
There are moments as a software engineer when you know exactly what you’re doing. You come
into a project, see a problem you’ve solved before, and every component of the solution springs into
your mind. Suddenly you are a being of unstoppable force; you are elemental. You are typing as fast
as you can, everything is working perfectly, every piece is elegant. You hand off the finished product
and take in the admiration of your peers. It’s a triumph.
There are other times where you come up against a challenge you don’t have the first idea how to
solve. And this makes you happy too, because learning is fun. You start exploring, surfing Q&A sites,
reading the 11th page of old forum threads, copying snippets, compiling and debugging code, and
before you know it you’ve figured it out. You tuck the solution safely away in your mind for next
time. You can’t wait to do it again.
In the right environment, code is the ultimate brain teaser. Every last scrap of intelligence, creativity,
determination, quirkiness, playfulness, intuition—none of it goes to waste when you’re writing code.
You get so close to your own potential that you feel like you could reach out and touch it. That’s not
to say you’ll always be recognized for it, but it’s satisfying in and of itself.
Programming is a science, as we all know. But it’s also an art. Like the painter who imagines beautiful
sun-dappled landscapes, or the musician who wakes up whistling a tune, many programmers find
their imagination filling up with code. They daydream of apps and libraries. Their GitHub profiles
are full of projects that never got finished, but only because they were so eager to start on something
else. Not everyone is so obsessed—you certainly don’t need to be to have a successful career in code—
but everybody is here for something, even if it’s just the salary and benefits. And whatever your
reason is, there’s a place for you.
Introduction: Code is the best, code is the worst
6
Code is the worst
Coding can be a real headache.
There’s a well-known cycle to fixing bugs. You examine the problem; you make a guess about what
might be causing it; you update the code based on your theory; you test the new code; if the problem
isn’t fixed, you start over. Sometimes this goes on for hours. Sometimes for days. Sometimes until it
just doesn’t seem worth it anymore.
In the best of circumstances, you’ll be on a team of compassionate and attentive people. They’ll
listen to you and make tactful suggestions. You’ll take their ideas back to your computer and ride
a wave of genius all the way to your next task. Your boss will drop by your office afterward to tell
you what a great job you did. You’ll go home at 4:30 and spend the evening relaxing at home.
You don’t always get to work in the best of circumstances. Someday you may find yourself struggling
to concentrate in an open floor plan office, sharing a desk with eight other programmers, drowning
in noise from phone calls and water-cooler conversations. The company will expect you to work
16-hour days if you’re not meeting their deadlines, which they never consulted you about in the
first place. Your manager will think coding is black magic. Your teammates won’t seem to think you
belong in tech, and some of them will have never learned how to hold a polite conversation. Some
days will be a nightmare of egotistical managers, unreadable error messages, burnout and anxiety.
Sometimes you’ll wonder if you chose the wrong career.
Code is just a tool
The truth is, most of the time coding isn’t amazing. And most of the time it isn’t miserable. Code
is a means to an end, and the ups and downs of your career will be more about people than about
lines of code.
For now other people will decide what you build, who’s on your team, and whether you feel
emotionally safe at the office. But you’ve still got a few responsibilities. To be a good teammate—to
say things like “you belong here” and “it’s okay to make mistakes” and “you deserve a break.” To
break stereotypes about programmers being insensitive and rude. To have the courage to quit if your
boss doesn’t treat you or your teammates well.
Later on, you’ll be the one making decisions. Code will be the best on some days and the worst on
others, and it’ll be because of you. You’ll set the tone for an entire team or department or company.
We’re trusting you to do the right thing.
Different learning pathways into tech
Clifford Fajardo
There are many industries (law, medicine, etc.) where a formal credential is required before you
begin work in the field. By contrast, the software development field, like many creative fields
(business, art, etc.), does not require that you have a formal credential to start working in the field.
Given this fact, there are different learning pathways you can take to reach your goal of becoming
a professional software developer.
In the pages that follow, I’ll outline the learning path I took to become a professional software
developer. I’ll start off by sharing how I began programming, then cover my self-learning path,
coding bootcamp path, and university path, then circle back to the self-learning path I’m on now.
My aim is to shed light on the thought process I used to inform which learning path to embark on,
based on my circumstances, and ultimately demonstrate that there are several paths you can choose.
The night I discovered code
It was mid-December. I had just finished a semester of classes at my community college, and now
I had two weeks of vacation before the beginning of the new year. On one of these evenings, while
browsing the web as usual, I discovered a free learn-to-code website called codecademy.com. A few
short minutes into using the site, I made a blue box with HTML and CSS. A few minutes later I
made an alert box pop up on my screen with the message, “Hello Clifford.” I was astonished that I
had just made my computer bring an idea to life before my eyes. Thus began my journey into the
world of software development and teaching myself how to code.
The path of self-learning
After discovering codecademy.com, I continued learning the fundamentals of web development
whenever I had free time after work or class.
In 2016, halfway through my second year of college, I had been teaching myself to code for almost a
year. At that point I became curious about this hobby of coding I had picked up and naively started
doing research online to see if programming was something I could do full time as a job. To my
surprise it was, and in my research I stumbled upon some coding bootcamps. I found out that this
was an alternative learning path to a traditional college degree.
After this discovery, I started following the blogs of several bootcamps and the blogs of their students
who were sharing their experiences. Despite the excitement I had about bootcamps at the time, I
continued teaching myself web programming, kept the idea of attending a bootcamp as a possibility
in the back of my mind, and continued through college.
Different learning pathways into tech
8
My decision between college and a coding bootcamp
When April 2016 came around, I had completed my general education requirements at community
college and my college transfer letters came in. I was fortunate enough to receive full scholarships to
study Sociology at UC Berkeley and many other flagship state colleges. Despite this accomplishment,
I knew deep down that I wanted to pursue computer programming. More specifically, I knew front-
end software engineering was what I enjoyed and wanted to focus on.
I had a decision to make. I was conflicted about which path to take so I asked myself: Do you want
to spend two more years as a transfer student to complete the remaining half of your undergraduate
degree, studying something you’re no longer enthusiastic about? Or would it be better to pursue
your dream now and maximize your personal growth and development?
I decided to make a seemingly risky but nonetheless well-calculated decision based on my
circumstances: to put my formal education on hold and do the Hack Reactor coding bootcamp,
an immersive 12-week course. Choosing Hack Reactor, I would later come to realize, was one of the
best decisions I had ever made in my life.
Why I chose a bootcamp
The bootcamp approach made the most of my circumstances. I didn’t want to switch majors and be
in a classroom for another four years, despite having had a fantastic experience in college. Instead,
I felt I could be gaining years of work experience, problem-solving skills, and personal growth, all
while getting paid to learn and earning income for my family.
I considered continuing on the self-learning pathway. However, I felt I could accelerate my learning
by being around other highly motivated peers and following a rigorous curriculum, which I probably
wouldn’t have had the courage to tackle alone at that time. Ultimately I wanted to obtain a high
degree of competency quicker, in a more structured environment, and kickstart my career.
Truthfully, another major factor that influenced my decision was the fact that I was tired of
struggling financially and living under the poverty line. I was tired of seeing my twin brother and
my parents, a janitor and a physically disabled stay-at-home mom, under financial strain. If I had
chosen to go major in computer science given my circumstances, I would still be finishing my last
year of college right now and my family would still be struggling, which is no longer the case.
Though I did have to combat thoughts about being a “dropout,” I believed I could break into the
software industry. Market conditions in my area were favorable (they generally still are across the
United States) and there was plenty of evidence and testimony that I could start a fantastic career
as a software developer without a degree, since thousands of other bootcamp graduates had done so
before me.
“Why didn’t you just change your major to computer science (CS) at community college?”
Different learning pathways into tech
9
Changing my major to CS would have meant staying another 2 - 2.5 more years at my community
college and taking several classes merely to complete prerequisites so I could qualify for the CS
major at the universities I was applying to.
Another consideration was that all of the colleges I was applying to transfer to didn’t offer a
curriculum covering the topics I was most interested in. I wanted to take courses where I could
learn about web applications, JavaScript and NodeJS, front-end web development, and responsive
design.
“Why didn’t you change your major to computer science (CS) at the four-year university,
UC Berkeley?”
I wouldn’t have been able to switch my major to CS without taking all the pre-requisite classes for
the major. Again, that would have meant two more years of classes just to qualify for the major.
On top of that, after qualifying, I would need another two years’ worth of upper division credits to
graduate. This meant it would take me four more years of school before obtaining a degree and my
first full-time entry-level job. The idea of spending four more years in large classrooms worrying
about my grades and studying a wide array of topics that weren’t immediately relevant to my goals
didn’t resonate with me.
In summary, I chose the bootcamp for three main reasons: (1) To get to my goal sooner by being in
a structured, immersive learning environment; (2) To support my family; and (3) To study the areas
of software development that I wanted, which weren’t offered at colleges in my area.
After beginning my career as a software engineer at Salesforce in San Francisco, I attended a semester
at UC Berkeley as a working student and took one of their most popular computer sciences classes. I
had the opportunity to experience what it was like to study computer science in a college setting, and
it validated what I felt previously. I preferred learning environments where I had more flexibility
to choose what to learn and where I didn’t need to worry about grades. Although the college path
wasn’t for me, for many people the college path is excellent and offers a lot of value.
A high-level overview of coding bootcamps
Coding bootcamps are immersive technical coding schools that teach the essential programming
skills and technologies that employers seek.
In terms of curriculum and learning structure, not all bootcamps are the same. Some are in-person,
others are online; the majority require a full-time commitment while others are part-time. The goals
and curriculum of each coding bootcamp may be different as well. For example, there are bootcamps
that focus on mobile development, data science, machine learning, full-stack web development, and
so on.
A few more considerations about bootcamps are:
• Instruction: There are bootcamps that help people with very little or almost no coding
experience get to a job-ready stage. In contrast, some coding bootcamps require candidates to
Different learning pathways into tech
10
have a minimum of a few months of self-study experience and meet a specific technical bar via
an admissions test. Most coding bootcamps require admitted students to complete pre-course
material before starting the program. This ensures every student is beginning with nearly the
same baseline knowledge and helps maximize the content that can be covered in the program’s
few months.
• Quality: Generally, the more rigorous the admissions standards are, the higher the quality of
instruction, curriculum, students, alumni network and job success outcomes.
• Alumni networks: Generally, the longer a bootcamp has been around, the more alumni you
have access to. For example, I’m part of an alumni network of several thousand graduates
who are working across nearly every subset of the software development industry. As a new
graduate or an experienced alumnus, this may be helpful since you have a large pool of people
you can connect with.
• Price: The tuition varies for each bootcamp. Many programs allow you to put down a small
down payment (or nothing at all) and pay back the rest of the program fee once you secure a
job as a software developer.
• The job hunt after the program: Similar to colleges that may have a career center to help guide
and support students in their job hunt, most bootcamps offer that as well. It’s important to
note that if you are coming into a bootcamp with the expectation that a job will be handed to
you after you graduate or that it’s the bootcamp’s responsibility to find you jobs, that’s not the
reality. You should leverage all of the resources that your bootcamp has to offer to maximize
your odds.
• How long it takes to obtain a job: Some of your peers will find jobs much faster than others,
due to varying circumstances. For example, it took me two and a half months of studying and
job hunting every day to secure my first software developer job, but it may be different for
you.
I want to highlight that bootcamps are not for everyone. It’s essential to evaluate your own goals
and learning style and make the choice that meets your needs best.
The cost of forsaking a computer science degree
It’s important to briefly address a few points concerning the cost of forsaking a computer science
degree, as to avoid any surprises:
• You will be competing for the same jobs that computer science graduates are applying for. You
will need to work hard to demonstrate that you have what it takes to do the job and have the
ability to fill any knowledge gaps for a role.
• It may be harder to initially demonstrate to employers the value you bring without a formal
credential. However, do not be discouraged. The good news is many (perhaps most) employers
nowadays have progressive hiring practices and will consider anyone who has the skills
required for the role and who they feel is a good match.
Different learning pathways into tech
11
• Some jobs and employers require a computer science degree, which is fair given that every
employer has different needs.
• Often, as a bootcamper or self-learner, you won’t get the broad exposure to software (operating
systems, compilers, distributed systems, etc.) that most computer science graduates obtain.
Some may doubt the importance of this; however, no one can dispute that knowing more
about what exists and what tools are available to you is beneficial. Of course, you can always
fill in gaps in knowledge if you’re deliberate about your learning.
Differences between bootcamps, colleges and self-taught
pathways
Below is a brief overview of the differences and similarities between the different learning paths
discussed in this chapter. At the end of this chapter, additional resources are provided for those who
would like more information.
Time Commitment
• Bootcamp: 3-9 months; varies depending on the bootcamp.
• College: 4 years; varies depending on the college or individual.
• Self-Taught: varies depending on the individual and whether they are studying part-time or
full-time. Some people qualify for a development job in a few months, others may take several
months and others a year or more.
Financial Cost
• Bootcamp: Varies depending on the reputation and duration of the program. Most immersive
bootcamps range from $9,000 - $20,000 USD.
• College: Varies depending on the college, reputation and duration of the program. According
to a 2019 statistical report on the average cost of a 4-year college in the United States:
– Public 4-year college: ∼$20,000 / year (assuming no financial aid or help at all). Subtract
∼$11,000 if you are living at home.
– Private 4-year college: ∼$46,950 / year. Subtract ∼$11,000 if you are living at home.
• Self-Taught: Cost varies depending on the courses and resources you purchase. It’s possible to
obtain most or all of the information you need for free, online or with a library card. Some
libraries have partnerships with paid services (e.g. Treehouse or LinkedIn Learning).
Learning Curriculum
• Bootcamp: Shorter length programs (∼12 weeks) focus on a very specialized curriculum to
help students develop expertise in only a few technologies. This tradeoff is intentional, as most
bootcamps assume and trust that their graduates will continue learning the necessary skills they
need throughout their career. Longer programs, like the Lambda School which is 9 months long,
not only teach highly marketable technologies but also do their best to bridge the gap between
the exposure computer science majors typically obtain and what shorter bootcamps often don’t
cover.
Different learning pathways into tech
12
• College: Given that there is more time to cover material, computer science graduates tend to
have a much broader view of the entire field of programming, especially when it comes to
theory. As one computer science graduate, Christian Charukiewicz, puts it:
Personally, as someone who has just finished their CS degree, I can tell you that I feel like
my learning has only begun. I think one of the most valuable aspects of my degree is that
it has lifted many of the “unknown unknowns” and turned them into “known unknowns.”
That means I may not be an expert in compilers, or system programming, or CS theory, or
any of the topics I studied in college. However, I know that they are out there, and I know
what most of them are so that I can research them and hone my skills as needed as my
career progresses.
• Self-Taught: With freedom comes a great deal of responsibility. You will need to dedicate lots
of time to curating your own learning material and continuously evaluate the quality of the
resources you are consuming, as opposed to a college student or bootcamper who is following
a structured learning curriculum. For the highly dedicated learner, being in complete control of
one’s education can be a source of great satisfaction. On the flip side, it’s easier to consciously
or unconsciously neglect learning topics that may be essential for your growth, since there is
less guidance. You don’t know what you don’t know.
Networking and Cultural Growth
• Bootcamp: The majority of my peers already had years of professional experience and degrees
in other industries, as many bootcampers are transitioning between careers. Bootcampers can
leverage their past experience to help them obtain new opportunities in the software field. For
example, I have a friend who was a DJ/audio engineer before becoming a programmer. He
went on to work for a music streaming company after bootcamp.
• College: Typically younger aged peers, 18-25, without full-time work experience. Colleges
usually offer internships, volunteer opportunities, and projects for students to gain practical
experience.
• Self-Taught: There’s no built-in network when you’re self-taught, so you’ll need to rely on
jobs, meetups, conferences, open-source projects, social media, and other self-driven forms of
outreach in order to build your network.
Similarities: bootcamps & college
Networking and Cultural Growth
• Your peers, instructors and alumni network are easily accessible since you typically see them
daily. This translates into having people close by to quickly learn and expand your worldview
from, not just in programming.
Different learning pathways into tech
13
Job Support
• Nearly all bootcamps and colleges have a career or job resources center for students and
alumni; they have a vested interest in your success. After all, what institution wouldn’t want
to showcase their graduates succeeding?
Learning Curriculum
• The material you are learning has been evaluated and selected by others. Thus, you can spend
your energy on learning, instead of hand-curating your learning resources.
Additional resources
• Teach Yourself Computer Science⁴ - An opinionated guide to Computer Science learning for
self-taught devs and bootcamp grads.
• CourseReport: Coding Bootcamp Cost Comparison⁵ - A list of coding bootcamps in the United
States and how much they cost.
• Average Cost of College in America: 2019 Report⁶ - An overview of the full cost of college
attendance in the United States.
• Coding Bootcamp vs. Computer Science Degree⁷ - An infographic comparing several aspects
of college degrees and development bootcamps.
• Bootcamps vs. College⁸ - A comparison of bootcamp and college grads from the perspective of
a company that specializes in developer job placement.
• Would you choose a coding bootcamp or a computer science related degree? Why?⁹ - A
collection of differing opinions on whether a bootcamp or college degree is the better choice.
• Treehouse for Libraries¹⁰ - Information on the availability of Treehouse’s software development
courses through your local library.
• The Odin Project¹¹ - A course in web development for self-taught developers.
⁴https://teachyourselfcs.com/
⁵https://www.coursereport.com/blog/coding-bootcamp-cost-comparison-full-stack-immersives
⁶https://www.valuepenguin.com/student-loans/average-cost-of-college
⁷https://www.whatsthehost.com/coding-bootcamp-vs-cs-degree/
⁸https://triplebyte.com/blog/bootcamps-vs-college
⁹https://www.quora.com/Would-you-choose-a-coding-bootcamp-or-a-computer-science-related-degree-Why
¹⁰https://join.teamtreehouse.com/libraries/
¹¹https://www.theodinproject.com/
How (not) to learn
Vlad Levin
Image licensed by Pixabay¹²
When I was younger, I remember having some odd ideas about what it meant to learn. In particular,
I recall that I thought learning meant reading a textbook very diligently from beginning to end. I
would even read the foreword. Maybe that was just me! Now I look back and wonder why I had
such strange and unproductive notions.
However, I think the education system at every level does tend to suffer from problems that prevent
people from learning effectively: students are shepherded through too many subjects at a time and
learn the material in a linear and rote manner. As a result, I think it’s not uncommon for people
to promptly forget much of what they “learned” in school, including at colleges and universities, as
soon as they pass their exams.
The following are some heuristics I’ve built up over time which have helped me when I’m learning
something new. If you have the luxury of learning something on your own, consider trying these
out. Even if you’re in school, I hope some of these ideas may be of help if you actually care about
learning instead of just getting through the classes.
¹²https://pixabay.com/es/illustrations/narrativa-la-historia-sue%C3%B1o-decir-794978/
How (not) to learn
15
Build intuition
With almost any technical subject, it’s easy to get involved in all of the complicated details. Doing so
prematurely can be a bad idea though. If we don’t understand the broader context, those technical
details can quickly overwhelm us.
When you’re first reading about a given topic, try to grasp the big picture. Why is this important or
useful? How does it fit with other topics or technologies? What’s the problem that it’s trying to solve?
Is there another way to look at this? Answering questions like these will give you a perspective that
will help motivate a deeper understanding as you dig into the more technical details.
Building intuition is a gradual process. Often clues can be found sprinkled through a given book
or other source of information. Keep an eye out for the clues and use them to build up a picture in
your mind of the high level principles and connections. Always keep asking yourself: “What’s the
big idea here?”
Intuition is something everyone works on, from novices to experts. As a novice programmer, I
remember learning C for the first time. At first I had difficulty understanding the starting and ending
conditions of for loops, e.g. for (int i=0; i<length; i++). I distinctly remember making notes
in a notepad, manually tracking the value of i, as well as sketching an array with arrows pointing
to the current index during and after each iteration. Eventually it became second-nature, but I still
remember that it wasn’t obvious to me in the beginning.
Later on, I used similar strategies to get familiar with increasingly complex recursive algorithms. I
would work through small examples manually. Again, I drew small sketches, showing everything
on the stack before and after each recursive call. This helped me to internalize what was really going
on with a given algorithm.
Here’s another real-world example of building intuition: fairly recently I needed to look up the
formula for standard deviation in statistics. It wasn’t my first time using it, but this time I suddenly
noticed that part of the formula looked a lot like the Pythagorean theorem. That had never occurred
to me before. I was able to work out that the standard deviation can be thought of geometrically, in
terms of the distance between two points. This was very exciting for me. Before, I had always taken
the formula for granted, as a black box. I knew how to use it, but I didn’t know why the equation was
what it was. Afterward, I felt that I understood it much better. I could visualize what was happening,
and I knew that from now on, it would be easy for me to derive the formula from scratch.
Once something becomes intuitive, you can visualize it, you know when it applies and how it works,
without needing to consciously think about it.
Knowledge debt
In the same way that there’s financial debt and technical debt, there’s also knowledge debt. If we’re
faced with something we don’t understand, often the temptation is to move ahead anyway, hoping it
won’t bite us later. In fact, sometimes that’s okay. Maybe an in-depth understanding isn’t necessary—
we just need to get a specific thing done. Or maybe going further into the material will elucidate the
point we’re stuck on right now.
How (not) to learn
16
Both of these things can be true at times, but it’s not a good approach to leave behind such gaps
as a matter of course. It will cause the foundations of our knowledge to get more and more shaky.
Eventually, that’s precisely what will stall progress completely. For instance, a lot of people think
math is “too hard.” I believe the reason is that they kept being pushed along in school to more
advanced topics, but all the while they were leaving more and more loose ends behind.
Any technical subject, including math, computer science, and programming, requires effort (at least
for us mortals), but if you take it one step at a time, and you make sure to master the individual
steps along the way, you can go a lot further than you might think.
PDL: Problem-Driven Learning
Just as test-driven development (TDD, see below) is about writing code to satisfy a measurable
criterion—making a test pass—I like applying the same notion to learning. Learning can seem like a
passive process of osmosis. However, we’re fooling ourselves if we think we understand that way. It’s
okay to read something lightly to get a broad overview of a topic, but if we really want to understand
how to apply our knowledge, we should make the learning a result of solving problems. This is the
best way to make the leap from theory to practice.
We can start with a simple problem and learn just enough to solve it, kind of like making a test
pass in TDD. Moving on to a similar, maybe slightly harder problem, can we solve it without doing
any extra reading? If so, great. Otherwise, we go back over our material to find what we need. This
makes our reading much more active and goal-oriented.
The more problems we can solve and the more diverse those problems are, the stronger and more
concrete our understanding becomes. This is the only real measure of how well we understand
something.
What is TDD? Test-Driven Development, or TDD, is a practice that’s used to improve the
quality of new code. The idea is to develop functionality in small steps. Each step starts
with a unit test (see Appendix A, “Automated test” and “Unit test”). Each test has 3 parts.
The first part describes the initial conditions for the test. The second part describes the
action to be taken by the test. The third part describes the changes that are expected as a
result of the action.
After you’ve written a test, you start things off by running it. It’s good practice to run a
test before you actually implement the behavior described in the test. Therefore, a brand
new unit test should generally fail when you run it for the very first time. Once you’ve
demonstrated that the test initially fails, you fill in the code that the test is targeting.
Having done this, you can confirm your code works correctly by running the test again.
This time it should pass. The last step is called refactoring. The idea is to look at the
code you’ve written to make the test pass and to clean it up. This is your opportunity to
remove duplicate logic and to clarify the naming of things like classes, functions, variables,
etc. Basically you can reorganize your code however you wish as long as the expected
behavior doesn’t change. Once you’re done refactoring, you can run the test once more to
How (not) to learn
17
make sure that it still passes. Unit tests are helpful when you’re initially developing a piece
of functionality, but they’re also useful in regression. That means you can periodically run
your entire test suite, say before committing your code to your repository. If anything
you’ve done breaks older tests, that alerts you to the possibility that you’ve introduced
bugs with your latest code, and gives you a chance to fix those bugs first. Making sure all
of the tests pass before checking in is a good practice. It gives you additional confidence
that your code is still all working properly.
Multiple sources of truth
Reading a single textbook or article is often a bad idea. Any source of information will be written
in a particular context. It will skip some steps and also make assumptions about what you know. If
you’re confused (and even if you’re not!), it’s good to look for additional sources.
If the material you’re reading seems too advanced, look for more beginner-friendly treatments. If
you’re reading about something in a particular programming language and it is not making sense,
try to find the same topic addressed in a language you’re more familiar with. Maybe what you’re
currently reading is too technical. In that case, look for high level descriptions to build intuition
about the subject. In that regard, I really like the idea of ExplainLikeImFive¹³, a tag used online for
articles that explain complex topics very simply.
Fewer subjects at a time
I’ve talked to a lot of graduates from schools in many fields about their experiences, including math,
science, medicine, dentistry, etc. Often enough, it’s the same story: Learn by memorization, pass the
exam, forget most of it, and repeat. I don’t think it’s the students’ fault either. Students are loaded
with so many classes to take each semester that it’s very hard to do even a halfway decent job of
learning. I think this is true in pretty much every field of study, and it’s certainly true in computer
science.
For most people, I think that cutting down the number of courses and focussing on fundamentals
would be much better. When a student completes a class, it should mean they have mastered the
material. The same idea applies for people learning on their own: Pick one or two subjects to work
on at a time, and pay careful attention to really figure them out.
Ask your own questions
While solving pre-defined problems and exercises is very useful, it can get monotonous. There’s
also something a bit passive about it. It’s better than merely reading, but we’re still leaving it up to
someone else to test our knowledge.
¹³https://dev.to/t/explainlikeimfive
How (not) to learn
18
How about coming up with our own problems? When you’re learning something new, ask yourself
questions about it. What does this imply? Is there a more general way of looking at it? Is it similar
to something else? Can it be applied like so?
With programming, you can write small programs to test your ideas. I highly recommend creating a
coding playground folder. Any time you are trying to understand something, create a small example
program to test it out in your playground. You can also come up with larger projects to work on.
Such larger projects will force you out of the tidy confines of well-defined exercises. You’ll need to
integrate disparate areas of knowledge and think creatively to make your way around roadblocks.
Often questions will arise naturally when you’re learning something new. It’s easy to let those
questions drift by and to forget about them. Or, a question may occur to you, but you’ll dismiss
it with negative self-talk, “oh that’s a dumb question.” That’s really a disservice to yourself though.
Being curious and making connections is a good thing. Censoring yourself, on the other hand, will
just slow down your learning process.
There are naive questions, tedious questions, ill-phrased questions, questions put after
inadequate self-criticism. But every question is a cry to understand the world. There is
no such thing as a dumb question.
∼Carl Sagan
You may find it helpful to have a notebook (or note app on your phone) always nearby. As soon as a
question comes up, make a note of it. Then see if you can figure out the answer yourself. If so, great.
If not, that’s okay too. It’s still good that you thought of your own brand new question! Now you
can practice your research skills to get an answer.
As an example, a while ago I was writing some JavaScript code using async functions. As I was
working, it occurred to me that it would be nice to combine a generator function and an async
function together. I didn’t know whether that was possible. After doing a bit of research, I found
out that asynchronous iterators and generators had been proposed as a new feature for JavaScript.
As of 2019, the new syntax is part of the ECMAScript 2020 Language Specification. It’s also already
supported by Node.js and by several major browsers.
When you take a hands-on approach to learning, I think you’ll find that questions will naturally
come up. If you want to practice though, try thinking about ways that an existing concept can be
extended or combined with something else. Asking yourself questions is like exercising a muscle.
The more you practice, the easier it will get.
Challenge your material
Whenever you’re learning something, challenge the material and look for mistakes. Don’t just take
everything as gospel. Even when there aren’t mistakes, this kind of active learning will ensure that
you really do get it. When you challenge the material, it makes you explore edge cases and counter-
intuitive possibilities. Doing so will make your understanding robust. You’ll know how something
How (not) to learn
19
works, and you’ll also know in a hands-on, concrete way, the limitations and exceptions that go
along with it.
A friend of mine told me a story from when she was in high school. She was learning special
relativity in physics, and kept pestering her teacher with examples that seemed to defy the principles
of relativity. I think her teacher was not equipped to answer those questions properly. It’s actually
well-known that there are a lot of scenarios in special relativity that initially seem to violate the
rules. Understanding those edge cases is essential to have a proper understanding of the subject. I
think what my friend was doing was great, and it’s too bad that her teacher didn’t understand the
material well enough to encourage her properly.
Go back and review
Sometimes we don’t realize that we missed something in our study until later. We start a new topic
and suddenly things we thought we understood become confusing. That’s a good time to stop and
go back to review that earlier subject matter. Don’t just re-read it passively though. Go hunting for
insights relative to the new information you’re grappling with. Real understanding is not a linear
process. It’s iterative. There is a continual need to go back and shore up gaps in our learning that
maybe we didn’t know were there, or that reappear over time as we forget things.
When I am studying something new myself, I find that I will regularly return to the same material
several times. The first time I may struggle with completely new concepts. The next time around,
I will start to get it. The third time, I begin to focus in on a smaller number of things that stand
out as being harder than the rest. As time goes on I come up with more of my own questions and
sometimes push the material in directions that are not mentioned in the book, article, or tutorial
that I’ve been reading.
It can also be okay to study something up to a point, put it away, and return to it later on. Often
we can acquire background knowledge in the meantime that makes us more prepared to tackle the
material again once we come back to it.
Fundamentals are important
Often, especially in the field of technology, there tends to be a bit of an obsession with specifics,
like a particular programming language, library, or framework. I think this is a tendency we should
resist, especially since technologies go through such incredible turnover. The darling of the moment
may be all but forgotten in a couple of years.
If you start your education with overly specific technologies, I believe it will limit your ability to
adapt, or to switch from one area to another. In addition, when we learn a particular technology in
isolation, it often makes our level of understanding more superficial. It means that as soon as we
leave the comfort zone of the context in which we learned the technology, we can quickly become
lost.
Focussing on fundamentals means trying to identify the core concepts and building blocks under-
lying any technology or paradigm. Doing so is like having a good understanding of how to build
How (not) to learn
20
things using lego blocks. It gives you the power to imagine any structure and build that from scratch
rather than having to follow the blueprint that comes with a pre-packaged set.
Here’s one possible example: Let’s say you’ve learned how to use several frameworks and libraries for
a front-end application. Perhaps you’ve used a CSS library like Bootstrap or a JavaScript framework
like React, Vue, or Angular. Do you know what problems these frameworks are trying to solve? It can
be helpful to develop a small browser application using only HTML, CSS, and plain Javascript—no
CSS framework, no JavaScript framework, nothing else. You’d be responsible for updating the page
yourself whenever something changes. You’d also be responsible for making sure your JavaScript
works properly for every browser that you want to support. Doing something like this can provide
insight into why we use certain technologies. It also tends to make it easier to learn a new technology
in the same general category, because you understand the underlying motivation of its developers.
More generally, it’s always good to delve into the basics of computer science. You can consider
investing some time learning about boolean logic, electronics, data structures, algorithms, operating
systems, networking protocols, databases, computer graphics, AI and machine learning, bioinfor-
matics and genomics, discrete math, linear and abstract algebra, probability and statistics, calculus,
etc. There are so many fascinating fields that computer programming touches or relies on. Building
up the depth of your knowledge in such fundamental areas will enrich your understanding and
appreciation. Don’t worry about trying to do this all at once though! (Unless you’re doing a C.S.
degree, that is.) If you can pick one or two areas at a time, and just build up your knowledge gradually,
that’s great. Over time, every small step will add up.
Any specific technology can be seen as some combination of fundamental ideas applied in a
particular way. Looking at things in this way is very powerful. It’s like a superpower, allowing
you to pick up new things quickly and leaving your colleagues wondering how you did it!
How to code (in one chapter)
Isaac Lyman
Note: This is the longest chapter by far. It also contains a fair amount of sarcasm. Many people
appreciate the light humor in such a long read, but be sure to take it with a grain of salt.
This chapter is not a complete coding manual. It’s a drive-through introduction to just enough coding
concepts and keywords to get you from zero to a basic script.
First of all: take a deep breath. The picture above isn’t real code. At least, it isn’t code that anyone
uses. Real code—what I write on the job—is mostly composed of English words, symbols, numbers
(all ten of ‘em, not just ones and zeros), and made-up names. Once you learn a bit of vocabulary, it’s
readable. I’m going to cover each of these later on.
Let’s get started.
What is a computer program?
A computer program—also known as an app, an application, or a piece of software—is a collection of
many lines of special text. They’re special because a computer can understand them, and computers
are incredibly dumb. The smallest practical apps have a hundred or so lines of text in them. The
largest apps have billions¹⁴.
¹⁴http://cacm.acm.org/magazines/2016/7/204032-why-google-stores-billions-of-lines-of-code-in-a-single-repository/fulltext
How to code (in one chapter)
22
We call this special text code. Code is a set of step-by-step instructions, like a recipe. It tells computers
what to do with data. Data is any piece of information that a computer can hold in its memory.
Modern computers are pretty good at holding things like dates and sentences. If you have a Twitter
account, then Twitter’s got some flat, ugly computers at a warehouse that are holding your birthday
and every tweet you’ve ever tweeted. Along with 300 million other people’s birthdays and tweets.
Source: https://commons.wikimedia.org/wiki/File:CERN_Server_03.jpg¹⁵. Unmodified image licensed
under CC BY-SA 3.0¹⁶ by Florian Hirzinger
That’s all data. Don’t worry, the computers aren’t sitting around reading your old tweets for fun.
And if they did, it wouldn’t be “fun,” anyway. It would be painful. Your tweets are dumb, just like
mine.
When you visit twitter.com, your computer borrows a whole bunch of code from one of those ugly
warehouse computers. It speed-reads the heck out of that code. And then it executes that code, which
means that the computer does exactly what the step-by-step instructions tell it to do.
If the instructions are written very carefully, it’s all peaches from here on out. Twitter will work. It
will publish your dumb tweets to the entire world. It will let you read other people’s dumb tweets.
It will let you “like” those tweets.
If there is any flaw in those instructions—anything from a typo to complete misinterpretation of
the data—then Twitter will not work. It will show an “Error” message, or crash the app, or suffer in
silence, secretly doing things with your data that you would prefer it not to.
That’s the catch. Coding isn’t very hard. It requires you to memorize a couple hundred terms and
¹⁵https://commons.wikimedia.org/wiki/File:CERN_Server_03.jpg
¹⁶https://creativecommons.org/licenses/by-sa/3.0/deed.en
How to code (in one chapter)
23
learn some grammar rules—you could do this with English (or your native language) by the time you
were two, and human languages are a mess. What is hard is being called out by an anal-retentive
computer every time you press a wrong key or misunderstand a concept. The hard part about coding
is the sheer amount of frustration you have to absorb.
The fun part is the problem-solving. In modern software, real-world problems become puzzles that
can be solved by code—but only after you truly understand them. Once you wrap your mind around
every possible permutation of a problem, you can write code that addresses it thoroughly, step by
step.
The tools of the trade
A programmer’s toolbox typically consists of a few things:
• A computer.
• An internet connection. You need an internet connection so you can use Google. When you
don’t know how to do something (which happens about 787283493857 times per day) you
Google it. When your app gives you an error message, you Google it. You Google everything.
• A code editor (or an IDE, which is a code editor on steroids). Think of it as Microsoft Word for
coding. It helps you organize and proofread your code.
• A compiler or interpreter. This is a program that reads your code, tries to find mistakes so it
can bug you about them, gathers your code into a nice little package, and then passes it on to
the computer to execute. It does a lot of other things, too, but these are the things you need to
know about right now.
• A good pair of headphones. These help you ignore people so you can focus.
You probably already have a computer. Since you downloaded this book, you definitely have an
internet connection and an interpreter (Firefox and Chrome have interpreters built in). There are
plenty of free code editors available online (like VS Code¹⁷ or Atom¹⁸). I can’t help you with the
headphones, but a good alternative is staring at people until they leave.
So you’re all set, right?
Programming languages
There are thousands of programming languages in the world. Many of them are dumb¹⁹ and useless²⁰.
You can have a long and happy career only knowing three or four—but don’t worry, this isn’t as hard
as learning three or four human languages.
Programming languages are often described by their paradigm, which is a way of categorizing the
kinds of features they have. For example, JavaScript is the language that all web browsers run, and
¹⁷https://code.visualstudio.com/
¹⁸https://atom.io/
¹⁹https://en.wikipedia.org/wiki/Esoteric_programming_language
²⁰https://en.wikipedia.org/wiki/Code_golf#Dedicated_golfing_languages
How to code (in one chapter)
24
possibly the most popular programming language in the world. It has a diverse feature set; I might
say that JavaScript supports imperative, structured, object-oriented, and event-driven paradigms.
And you might say I’m a pretentious geek.
You don’t need to know what all those words mean. What you do need to know is that programming
languages with similar paradigms usually have similar syntax—that is, vocabulary and grammar. So
once you’ve learned one language (like JavaScript), you’re already 75% of the way to learning similar
languages, like Python and Ruby.
The best coders understand problems in terms of an algorithm—a series of steps that can be used
to do a certain thing, even if the details are different each time. Have you ever bought something
on Amazon? The checkout experience is a sort of algorithm. No matter what you’re buying, the
steps are roughly the same: fill up your cart, choose your credit card and shipping address, pick a
shipping speed and place your order. The code, in fact, is the same for each purchase. The difference
is all in the data. Now get this: every algorithm that can possibly exist can be written in every
normal programming language. It’s a mathematical fact²¹. Once you learn to think in algorithms,
the programming language is secondary. Sure, it kicks and drags its feet a little. But in the end it’s
not about the keywords and symbols you’re using. It’s about the processes you’re describing.
From here on out, I’m going to use the JavaScript programming language to give examples. I’m
doing this for my benefit, not yours. I’m good at JavaScript.
Code examples will be printed in monospace²², which is a special typeface that looks like this.
Monospaced fonts give the same exact width to every letter, number, symbol and space. All code is
written in monospace even though it is harder to read than normal fonts. This is because it helps
align blocks of code and allows coders to give equal attention to every letter and symbol, which
helps them avoid errors. As an example, look at the following sentence in both a regular font and
monospace:
There are three mistakes in the sentence: the extra space after “for”, the extra apostrophe in “Alice’s”,
and Bob’s exploitation of Alice’s friendship and trust. Oh, and “without” is misspelled. You probably
saw all these mistakes in the first sentence, but they’re more obvious in the second one, and obvious
is your best friend when you’re scanning a 200-line code document.
Whenever you read something written in monospace, it’s okay if you do a robot voice in your head.
²¹https://en.wikipedia.org/wiki/Turing_completeness
²²https://en.wikipedia.org/wiki/Monospaced_font
How to code (in one chapter)
25
Putting data in code
Enough background: let’s write some code. The most basic building block of a computer program is
a variable. A variable is a name for a piece of data, like a number or a sentence. You have to name
your data.
There are two reasons you name your data:
1. You don’t know what it is beforehand. Does Facebook know your birthday before you type it
in? No, of course not. Facebook’s code is using a name like humans_birthday behind the scenes
(the underscore is there because variable names can’t have spaces in them). It attaches that
name to whatever birthday you type in. That way, the code can be exactly the same whether
your birthday is June 10th, September 9th, or December 86th. It just moves humans_birthday
around in the program until it reaches an ugly warehouse computer.
2. You don’t want to forget what it means. Suppose the computer program needs to know that
December 86th isn’t a real date. So somewhere you have to tell it that December has 31 days. 31
is a number, a piece of data. But if you’re using the number 31 all over your code, and also using
numbers like 30 and 28 (because, thank goodness, December isn’t the only month), your code is
going to be confusing to read. What are all those numbers for? So you name them. 31 becomes
the_number_of_days_in_december, and your code becomes self-explanatory. Beautiful.
Computers expect you to declare your variables. A variable declaration is like a birth certificate for
a piece of data. It looks like this:
1
var the_number_of_days_in_december
The operative word here is var. It’s short for “variable.” The abbreviation is nice because it’s faster
to type. It can also be typed with only one hand, so if all you’re doing is declaring variables all day,
your other hand is free to do awesome things like juice grapefruits and practice with a quarterstaff.
Another thing you do with variables is assign them. This is where you attach the name to a piece of
data. It looks like this:
1
the_number_of_days_in_december = 31
Easy stuff. You declare the variable, then you assign it, and then any time you want to use the
number 31 in your program, you can type the_number_of_days_in_december and the computer will
know what you mean.
You don’t have to assign every variable to an explicit piece of data when you write your program. You
can declare variables and assign them to things that don’t exist yet. For example, you can declare
var humans_birthday and tell the app to wait for the user to type it in. Whatever they type will
become humans_birthday. You don’t even have to worry about it.
Variables can hold way more than just numbers and dates. For example, you can declare a string, or
a piece of text:
How to code (in one chapter)
26
1
var great_song_lyrics = 'La la la, la la la tonight'
Whoa. Curveball. I just declared a variable and assigned it at the same time. I’m so hecking efficient.
Bring this man a grapefruit.
Now I can write great_song_lyrics in my code, wherever I want, and the computer will know that
I mean 'La la la, la la la tonight'. It’s like we’re talking…in code.
Don’t believe me? Try it right now. If you’re reading this on your phone, you’ll need to open a web
browser, like Chrome or Firefox, on a computer. Press the F12 key on your keyboard (if you’re using
Safari, you’ll have to find the developer tools in the menus). You’ll see something like this:
This may be aligned to the right or bottom edge of your browser.
Make sure the “Console” tab is selected. Click in the blank area next to the > symbol, type a variable
declaration and assignment, and press Enter:
The console is saying undefined because the line of code you typed didn’t produce any data. That’s
okay, it wasn’t supposed to. Now type the name of your variable and press Enter again:
How to code (in one chapter)
27
Hooray! The console (which is an interpreter) understands your variable. The variable great_song_-
lyrics evaluated (it was understood) as "La la la, la la la tonight". That’s perfect (by the way,
it doesn’t matter if you use single quotes ' or double quotes " as long as you use them in matching
pairs).
We’ll talk about other things variables can hold in just a second.
Many programming languages require you to be specific about what kind of variable you’re
declaring. In C++, for example, there is no var keyword. There’s an int keyword (for declaring small
whole numbers), a long keyword (for declaring big whole numbers), float and double keywords
(for declaring decimal numbers), a string keyword (for declaring pieces of text), and a few others.
Don’t worry about that right now. You can learn it later.
Complex types
Objects
An important part of coding is learning how to organize data. Take the birthday example: Facebook
has hundreds of millions of birthdays (and anniversaries and breakup dates) stored in computer
memory in its warehouse. How does it know what’s what? If I gave you a list of a billion dates,
would you know who they belong to and what they’re for? Of course you would, because you are
the great Calendifus, Greek god of randomly significant dates.
Luckily, Facebook doesn’t just have a pile of arbitrary dates sitting around. They connect your
birthday, your anniversary, your hometown, your employment history, your name, and everything
else they know about you together with a unique ID (like the one on your Social Security card or
your driver’s license). It’s probably a big number that they picked out of a hat, so to speak. That is,
you are number 12884002, and every piece of data they have on you has a label that says “12884002”,
and when you log in they look up everything with that number on it. It’s all organized just like that.
How to code (in one chapter)
28
In code, you would do this with an object. An object is a bunch of pieces of data all organized together.
We can also call this an associative array, a dictionary, or a map. But most often I just say object.
In JavaScript, objects are declared and assigned much like other variables. Here’s an example object:
1
var human = {
2
id: 12884002,
3
age: 28,
4
name: 'Bob',
5
favorite_song: 'Half Light, by Athlete'
6
}
Each piece of data in an object is like a seesaw. The name is on the left, the data is on the right,
and there’s a : in the middle to balance on. Really all we’ve done is declare four variables: the first
two are numbers, and the last two are strings. But they’re organized together so we can find them
whenever we need to know something about human. And instead of calling them “variables,” we call
them “properties” or “fields.” An object can have any properties you want, as long as you put them
all together inside of { curly brackets }.
We can move the human object around and refer to it just like any other variable. The computer
knows what we mean. If we ever want to refer to just one property of human, we use a dot, like this:
1
human.id
2
human.age
3
human.name
4
human.favorite_song
Each of these is just like any other variable. We can assign something to it and refer to it later. Want
to change Bob’s name? Easy:
human.name = 'Alice'
And that’s that. It’s a really good upgrade, isn’t it? From now on, whenever you type human.name, it
will refer to “Alice”.
Arrays
Sometimes you don’t want to think up a unique name for every property in an object, especially if
they’re all very similar. Or you don’t know how many there are going to be. That’s when it’s time
to use an array, which is a list of similar pieces of data. Arrays can grow or shrink as needed.
A good example is all your dumb tweets. Twitter doesn’t know how many tweets you’re going to
write. You started at 0, and look where you are now. Twitter could use an array to hold them all.
Arrays in JavaScript look like this:
How to code (in one chapter)
29
1
var dumb_tweets = [
2
'Hello, Twitter!',
3
'My friends are so cool',
4
'Does anyone want a LaCroix?'
5
]
Remember how objects used { curly brackets } ? Arrays use [ square brackets ]. This array has
three strings in it, separated by commas. And yes, it’s a variable just like anything else. You can use
dumb_tweets anywhere in your code, and it will refer to the array we defined just now.
If you want to refer to a specific string in the array, you’d do it like this:
1
dumb_tweets[0]
2
dumb_tweets[1]
3
dumb_tweets[2]
We use the name of the array, dumb_tweets, and then inside of [ square brackets ] we use the number
(or index) of the thing (or element) we want to refer to. I know it’s weird that the first element in the
array is number 0. But this is your life now. From this day forward, you will always begin counting
at 0. It’s the programmer way.
Each of the above expressions (an expression is any code that turns into a piece of data when you
run it) is a variable. You can assign something new to it, if you want.
1
dumb_tweets[2] = 'I regret literally everything I have ever said'
Whatever happened to 'Does anyone want a LaCroix?'? It’s gone forever. Swallowed by the abyss.
G’bye!
Arrays can hold strings, numbers, dates, objects, and even other arrays. You can put arrays inside
of arrays inside of arrays inside of arrays.
How to code (in one chapter)
30
Photo: Lachlan Fearnley²³. Unmodified image licensed under CC BY-SA 3.0²⁴
Any time code or data gets all Russian-doll-ish like that, we say it’s nested.
Arrays can also be properties of objects. An object can have a property that is an array of objects,
each of which has a property that is an array of objects…and I’ve done it again. It sounds like a tax
form, but it’s how data is structured. For example, your Twitter account could be an object that has
a property which is an array of tweets; each tweet could be an object that has properties that are
arrays of replies, likes, and retweets; each reply, like or retweet could be an object that has properties
that are the name, profile picture and bio of the user that gave them; and so on.
1
var nested_object = {
2
an_array: [
3
{
4
another_array: [
5
{
6
yet_another: [
7
{
8
message: 'Blink twice if you need help'
9
}
10
]
11
}
12
]
13
}
²³https://commons.wikimedia.org/wiki/File:Russian_Dolls.jpg
²⁴https://creativecommons.org/licenses/by-sa/3.0/deed.en
How to code (in one chapter)
31
14
]
15
}
To access message, you can write:
1
nested_object.an_array[0].another_array[0].yet_another[0].message
And the computer will know that you mean 'Blink twice if you need help.'
Objects (continued)
One more trippy part, and then we can move on to the fun stuff.
Everything in JavaScript is secretly an object (don’t tell! Its parents would be so mad). For example,
our dumb_tweets array has a property that we never declared:
1
dumb_tweets.length
What the heck is length? Well, it’s a property that JavaScript creates and updates for you
automatically. It tells you how many elements are in the array. In this case it would be 3. There
are 3 elements in the array. Go count ‘em, but don’t start from 0 this time because I lied and you’re
only supposed to start counting from 0 on special occasions. Dang it.
APIs
Time for a scary campfire story.
Once upon a time, in an alternate universe, there was a programmer named McChuck. He was the
only coder in the whole universe. He had to write all the code that would ever exist, all by himself.
How to code (in one chapter)
32
Photo: hannah k²⁵. Unmodified image licensed under CC BY 2.0²⁶
Sheesh, it was just a story. Calm down.
The truth is that no coder is an island. Nobody starts from scratch. We’re all constantly using code
we didn’t write—buckets of it, in fact.
Even if you are a prolific coder and write millions of lines of code in your lifetime, you will use far
more lines of code that someone else wrote. Most of this code will come from complete strangers.
Some of those strangers will be dead. Their code lives on, even though the fingers that typed it are
decomposing in a grave. It’s zombie code. But instead of eating your brain, it saves your brain from
doing a lot of hard work. Best. zombie. ever.
How do you use this zombie code? Copy and paste? Occasionally, yes, but not often. Most of the
time you’ll access it through an Application Programming Interface or API. An API is a bundled-up
set of properties and methods (purpose-built pieces of code) that are named, like variables, so you
can refer to them by their name and let them do their thing. They do all kinds of useful things for
you.
JavaScript arrays have their own API. The length property is part of this API. Another part of it is
the push method, which adds an element to the end of the array:
²⁵https://www.flickr.com/photos/90692443@N05/8239219385
²⁶https://creativecommons.org/licenses/by/2.0/
How to code (in one chapter)
33
1
dumb_tweets.push('Man I hate good attitudes')
A method is like a property because you access it with a dot. A method is different from a property
because you have to put ( parentheses ) after it. These parentheses are holding the data we want to
add to our array. Now dumb_tweets has four elements. It looks like this:
1
[
2
"Hello, Twitter!",
3
"My friends are so cool",
4
"I regret literally everything I have ever said",
5
"Man I hate good attitudes"
6
]
Remember, the index of this last element is 3 (because you started counting at 0). So you would refer
to it as dumb_tweets[3]. And dumb_tweets.length would now evaluate to 4.
The JavaScript array API has a lot of different methods in it, but it’s outside the purpose of this
chapter to explain them all. You can see them in their full glory at this link²⁷.
Web browsers have a huge API that JavaScript coders use every day. This API has methods for things
like animating stuff in a website, getting user input, communicating with other computers over the
internet, manipulating strings, and loads of other stuff. Building a working vocabulary in this API
is an essential part of becoming a web developer.
Functions
Function is another word for method. It’s just a piece of code that does something and (usually) has
a name. Functions are easy to declare in JavaScript:
1
function giveMeOne() {
2
return 1
3
}
We start with the keyword function. Then we give the function a name, just like if we were declaring
a variable (here I’ve used capitalization, instead of underscores, to separate words). Then we use
parentheses (you’ll see why in a second). Then we use { curly brackets }. Inside the curly brackets
are all the lines of code we want to execute whenever the function is called (whenever an expression
refers to it by name).
The word return is another special keyword. It makes a value (a piece of data) pop out of the function.
Then it ends the function (if you write any code after a return statement, that code won’t execute).
So you could do something like this:
²⁷https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array
How to code (in one chapter)
34
1
var the_loneliest_number = giveMeOne()
This isn’t too hard, right? We declare a variable named the_loneliest_number. The assignment
part of our statement calls giveMeOne(), and since that function says return 1, a 1 pops out. So our
variable will hold the number 1. Go ahead and execute both of these blocks of code in your browser’s
console. Then type the_loneliest_number, press Enter, and you’ll see that it evaluates to 1.
A function can be a property of an object. It can be an element of an array. It can return a number,
a date, a string, an object, an array, another function, an array full of functions, and so forth. This
stuff is like LEGO bricks. Put any kind of piece anywhere you want and it will fit.
giveMeOne() is kind of like dumb_tweets.push(). The main differences are:
1. giveMeOne() is a function we wrote by ourselves. push() is a function that some strangers
wrote. It’s okay, they don’t mind if we use it.
2. push() is a method of dumb_tweets (and any other array we’ll ever create). giveMeOne() is
global, meaning that we don’t need to refer to a specific object in order to use it.
You’ll notice one more thing that seems different about them: giveMeOne() uses empty parentheses,
but push() expects us to put a piece of data in the parentheses. In fact, push() would be useless
if we couldn’t tell it what to add to our array. The piece of data we give it is called an argument.
An argument is just a piece of data that we drop into a function. Declaring a function that expects
arguments looks like this:
1
function addTheseNumbersTogetherPlz(number1, number2) {
2
return number1 + number2
3
}
This function isn’t too different from giveMeOne(). But instead of empty parentheses, these have
variable names in them, separated by a comma. These are our arguments. The return statement
does exactly what it looks like it’s doing: it adds number1 and number2 together, then pops out the
result. You’d call the function like this: addTheseNumbersTogetherPlz(3, 4). And it would pop out
a 7.
Ooh! Math! Scary, right? Almost all coding languages let you write math expressions the same way
you used to write them in those bricky TI calculators you might have used in high school. You can
use + to add, - to subtract, / to divide, * to multiply, ( parentheses ) to enforce an order of operations,
% to get the remainder of division, and ^ to instantly grow a neckbeard (no, it doesn’t do exponents;
you need an API for that).
You could also write the function this way:
How to code (in one chapter)
35
1
function addTheseNumbersTogetherPlz(number1, number2) {
2
var sum = number1 + number2
3
4
return sum
5
}
This function does exactly the same thing. It just uses a variable named sum as a middleman, where
the result is stored so we can return it later.
There are many ways to write a function. You should choose the way that most clearly expresses
what the code is doing. Code that is concise and easy to understand is often called expressive or
elegant. There’s an artistic pleasure in writing this kind of code.
Programs must be written for people to read, and only incidentally for machines to
execute.
∼Harold Abelson
Logical branches and comparisons
This is where code gets extra fun. (It was fun already.)
Computer programs don’t do the same exact thing every time you run them. If they did, then video
games would play themselves. That would be a letdown. You’d have to just sit there and watch the
story play out on the screen, like a…I don’t know, but it would be boring. There definitely wouldn’t
be an entire industry²⁸ dedicated to it.
Programs have to respond to different situations. They have to make decisions. And that’s where
things like if statements come in.
Let’s say we’re writing an app that determines whether a particular person is allowed to enter
a nightclub. Pretend there’s a method in the JavaScript API that gets a user’s age. We’ll call it
getUserAge(). We’ll also imagine that there are two other methods, allowThemInTheNightclub()
and throwThemOutOnTheirButt(). How can we help our program decide which of these last two
methods to call, based on the returned value of the first method?
²⁸https://en.wikipedia.org/wiki/Film_industry
How to code (in one chapter)
36
1
var age = getUserAge()
2
3
if (age >= 21) {
4
allowThemInTheNightclub()
5
} else {
6
throwThemOutOnTheirButt()
7
}
See how nice the alignment is on the right side? Monospace is great.
You already know what the first line does. age will hold a value like 13 or 21 or 101. Now we need
to know: is age 21 or over? If so, they can party away. If not, they’ll need to leave.
We do that using an if statement. if is a keyword that looks a little bit like a method. The argument
it expects is an expression of some kind, usually a comparison. Comparisons take two values and
compare them to each other, resulting in a value of true (if the comparison is true) or false (if
it’s not true). These two values are called booleans and they’re the only two booleans in existence.
Lucky they’ve got each other. We can make six different kinds of comparisons:
• === (three equals signs) compares the values on either side to see if they are exactly equal. If
they are equal, the result is true. 6 === 6 would be true.
• !== compares the values on either side to see if they are not exactly equal. If they are not equal,
the result is true. 6 !== 3 would be true.
• > checks to see if the value on the left side is bigger than the value on the right side. 6 > 3
would be true.
• < checks to see if the value on the right side is bigger than the value on the left side. 3 < 6
would be true.
• >= checks to see if the value on the left side is bigger than, or equal to, the value on the right
side. 6 >= 6 and 6 >= 5 are both true.
• <= checks to see if the value on the right side is bigger than, or equal to, the value on the left
side. 6 <= 6 and 6 <= 7 are both true.
if statements evaluate the comparison you give them. If it evaluates to true, they execute the code
inside their block (the lines of code inside { curly brackets }). If it evaluates to false, they skip that
code.
if statements can also have an else statement attached to their tail end. The else statement has
a block that will be executed if the comparison is false. Look back at our nightclub app. It should
make a lot of sense to you now.
Hey, we just made a bouncer redundant (he was replaced by a computer program). Isn’t that a good
feeling?
How to code (in one chapter)
37
Loops
Sometimes, especially when you’re working with an array, you want to execute a block of code
several times in a row. This is not the time to use copy and paste. Instead, you should use a loop.
The simplest kind of loop in JavaScript is a while loop:
1
var knock_knock_joke = ['Knock knock', "Who's there?", 'Banana', 'Banana who?']
2
3
var index = 0
4
5
while (index < knock_knock_joke.length) {
6
say(knock_knock_joke[index])
7
8
index = index + 1
9
}
while loops use the same syntax as if statements. You use parentheses, you pass in a comparison,
you follow it up with a block. But an if block only executes the code inside of it once (or zero times,
if the comparison evaluates to false). A while block executes the code inside of it over and over
again until the condition is false. That is, it evaluates the condition; if it’s true, it executes the
block; then it evaluates the condition again; if true, it executes the block again; then it evaluates the
condition again; and so on, forever. I’ve invented an imaginary API here that has a say() method,
but everything else is regular JavaScript.
How many times will the loop execute? Well, the first time it evaluates the comparison, it checks to
see if index (which is 0) is smaller than knock_knock_joke.length (which is—go on, count them—4).
Since the comparison is true, it executes the code, which raps knock_knock_joke[0], because index
is still 0. Then the magic happens: it changes index to index + 1, or 0 + 1, which is 1. Then it
evaluates the comparison expression again. 1 is still less than 4, so it executes the block again—but
this time, since index is 1, it raps knock_knock_joke[1]. Get it? It will stop executing the block when
index equals 4, which is good because knock_knock_joke[4] doesn’t exist. When a loop operates on
multiple elements in an array, we say it’s iterating.
Null and undefined
If you declare a variable and do not assign a value to it, it will hold a special value called undefined.
This is a geeky word that means “move along, nothing to see here.” It’s mostly useless.
How to code (in one chapter)
38
JavaScript also has a special value called null. It means roughly the same thing as undefined. They
really shouldn’t have included both words in the language. But they did and it’s too late now.
Scopes
Functions are very selfish. If you declare a variable inside of a function, the function won’t let any
of the code outside of itself use the variable. For example:
1
function whatHappensInVegas() {
2
var wildIndiscretions = ['partied', 'danced']
3
4
return 'I admit nothing'
5
}
6
7
whatHappensInVegas()
8
whatHappensInVegas()
9
whatHappensInVegas()
10
11
if (wildIndiscretions.length > 0) {
12
getInTrouble()
13
}
We have a very simple function. It declares the variable wildIndiscretions, but it doesn’t return
it. The outside world knows nothing about it! We even run the function three times, because
we’re young and full of stamina. The if statement is trying to pry into the function’s personal
life, but it can’t. The code inside of the if block will never execute. In fact, the comparison
wildIndiscretions.length > 0 will throw an error (it won’t work and you’ll see a message explain-
ing why) because wildIndiscretions is undefined outside of the function whatHappensInVegas. It
doesn’t have any properties, let alone length.
However, if you move that if block inside the function block (before the return statement, of
course) then it will gain access to wildIndiscretions. Hope you have a good lawyer!
Comments
It isn’t always obvious what a piece of code is doing, or what still needs to be done with it. If you
need to break out of the computer language and have some real talk about what’s going on in the
code (or just drop some dope lyrics), you can use a comment, or a line of code that the computer will
ignore. You start a comment with // two forward slashes. Like this:
How to code (in one chapter)
39
1
function isEven(num) {
2
// This function determines if "num" is even or odd.
3
//
If even, it returns true. If odd, it returns false.
4
// TO DO: add a second argument that lets you specify
5
//
a message to display if "num" is odd.
6
7
return num % 2 === 0
8
9
// Hey, yo, do it like Isaac
10
// If you ain't with me, baby ain't wise-aac
11
}
Don’t worry about the maths in the return statement. I’m just demonstrating that you can use
comments to explain what’s going on, to leave a note for your future self, and to spit bars. The last
usage is probably frowned upon in serious codebases. But don’t let that hold you back. You were
born to do what you were born to do.
Searching for clues
The last and most important thing I can teach you is this: when you don’t know how to do something,
immediately go to google.com and ask. The generosity of the programming community will astound
you. Thousands of developers all around the world have freely shared their code and knowledge on
sites like GitHub²⁹ and Stack Overflow³⁰, which means that all you need to become an expert in any
programming language is a steady internet connection and the ability to read.
Good Google queries take a little bit of practice to write. A good template is something like this:
[programming language] how to [something]
For example, want to know how to remove an element from an array in JavaScript? I’m not gonna
teach you. Try typing this into Google: “JavaScript how to remove an element from an array”. The
first few results should give you all the information you need (with examples).
For more discussion of this topic, see Yechiel’s chapter “Learning to learn”.
What is an application?
Most large-scale apps use all the concepts and keywords I’ve described. Their code comprises
thousands upon thousands of lines of code, all built from these same basic elements. So what are
they doing?
On a basic level, they’re receiving inputs (data that enters the code from somewhere else, like a user’s
keyboard), transforming them (often by iterating over them, doing maths on them, or reorganizing
²⁹https://github.com/
³⁰http://stackoverflow.com/
How to code (in one chapter)
40
their properties), and providing outputs (data that leaves the code). Every computer program can be
described in terms of its inputs and outputs. Every programming language has methods in its API
for accepting inputs and providing outputs.
An ice maker is a good analogy for a computer program. Its inputs are water and electricity (they
come from an API known as “municipal utilities”). Its output is ice (which is submitted to an API
known as “a tall glass of Coke”). Do you care what happens in the middle? Not right now, as long
as you get your ice without too much trouble. But someday the ice maker will break down. And
whoever has to fix it will care a lot about how simple, robust and well-built its internal components
are.
A coder’s job isn’t just to provide the ice, although that’s important. A coder’s job is to make sure
that when the ice maker breaks, the person who has to fix it doesn’t develop an explosive headache
in the process. That’s the difference between an amateur coder and a pro.
Conclusion
You’ve done good. I’ve taught you enough programming basics that, with a little imagination and
plenty of Googling, you can teach yourself everything you need to know to write apps. If you want
to.
You may still feel like you’re missing some vital information. And you are. But you’ll never learn it
all, and this is a good start.
If you’re still shaky on your feet, go check out some more JavaScript tutorials. There are tons of free
ones online on sites like Codecademy³¹. And once you feel confident enough to write some code of
your own, go build something. There’s no substitute for getting your hands dirty.
³¹https://www.codecademy.com/learn/introduction-to-javascript
Steps to better code
Isaac Lyman
When you start out coding, you usually spend a year or two completely oblivious to the rules of
“good code.” You may hear words like “elegant” or “clean” tossed around, but you can’t define them.
That’s okay. For a programmer without any experience, the main metric worth keeping tabs on is
“does it work?”
Soon, though, you’ll need to raise your expectations. Good code doesn’t just work. It’s simple,
modular, testable, maintainable, thoughtful. Some of these terms may apply to your code without
you even knowing it, but probably not. If you’re lucky, your team carefully plans and architects
its code solutions and guides you gently, trusting that you’ll develop an intuition for well-written
software. If you’re not lucky, they wince³² or³³ complain³⁴ every time they see your code. Either
way, you can get a lot of mileage out of learning a few universal principles.
Take, for example, the global variable: a variable that can be used anywhere in the project. Suppose
your app has a username variable that’s set when the user logs in and can be accessed from any
function in the app just by referencing the variable name—that’s a global variable. Global variables
are universally despised by bloggers and style guides, but most entry-level coders don’t understand
why. The reason is—and pay attention, because this is the reason for almost all best practices in
coding—that it makes the code faster to write, but harder to understand. In this case, a global variable
makes it really easy to insert the user’s username into the app anywhere you want, which may mean
fewer lines of code and fewer minutes until you finish your current task. That’s false comfort, though:
you’ve sacrificed safety for convenience. If you discover a bug involving username, you will have to
debug not just a single file or function, but the entire project. I’ll talk more about this later.
The difference between “good code” and “bad code” isn’t usually based on the way it affects you as
you write it. Code is always a shared resource: you share it with other open-source contributors, or
with the other developers on your team, or with the person who will have your job in the future,
or with “future you” (who won’t have a clue what “present you” was thinking), or even just with
“debugging you,” who is going through your fresh code looking for bugs and is totally frustrated.
All of these people will be grateful if your code makes sense. It will make their job easier and less
stressful. In this way, writing good code is a form of professional courtesy.
You may still be skeptical, but read on—I’ll talk about several principles that lead to good code and
try to justify each one.
³²https://xkcd.com/1513/
³³https://xkcd.com/1695/
³⁴https://xkcd.com/1833/
Steps to better code
42
0. Naming things
There are only two hard things in Computer Science: cache invalidation and naming
things.
∼Phil Karlton
Well-written code tells a story, and is often readable even for someone who only has a passing
familiarity with code. An important part of this is well-named variables, classes, files, and methods.
When naming something, it’s far more important to be descriptive than brief: a variable name
like “elementarySchoolStudentLastNameFirstLetterRegEx” may have room for improvement, but
it’s much better than “b”. It’s useful to be able to know what something is immediately, right when
you look at it, even if you haven’t read the rest of the file or project. And that goes double for public
fields and methods. Any element of code whose name doesn’t fully communicate its purpose is one
more thing you have to think about every time you use or modify it.
Beyond descriptiveness, uniqueness is also valuable. Sometimes when modifying code, you’ll want
to do a project-wide search for a method or variable and find everywhere it’s being used. In this
situation it’s best if its name is unique. If you’ve been calling things method1 and stringA, your
search results will be full of irrelevant stuff and it will be hard to make changes without breaking
anything.
Renaming things is a great way to improve code quality as a junior developer. Make sure you
know the naming conventions of your team and project—if they use underscores or capital letters
to separate words, if they like to include a variable’s type in its name, and so on—then find a couple
of things with confusing names and suggest better ones.
1. Separation of concerns
A fair analogy for coding is writing a recipe. In simple recipes, each step depends on the one before
it, and once all the steps are complete, the recipe is done. But if you’ve ever tried to follow a more
complex recipe, you’ve probably experienced the stress of having two pots boiling on the stove, a
plate spinning in the microwave, three kinds of vegetables half-chopped on a cutting board, and a
smorgasbord of spice and herb shakers strewn across the countertop (and you can’t remember which
ones you’ve already added).
Having another cook in the kitchen complicates the problem as often as it simplifies it. You
waste time coordinating, handing things back and forth, and fighting over stove space and oven
temperature. It takes practice to figure out how to do it well.
If you know you’re going to have several cooks in the kitchen, wouldn’t it be more efficient for the
recipe to be split into mostly-independent sub-recipes? Then you could hand part of the recipe to
each cook and they could work with as little interaction as possible. One of them is boiling water
for pasta. One of them is chopping and cooking vegetables. One of them is shredding cheese. One
of them is making sauce. And the points of interaction are clearly defined, so each of them knows
when to hand off their work.
Steps to better code
43
The worst form of code is like a simple recipe: a bunch of steps in order, each written out in the
same space, and listed from top to bottom. In order to understand it and modify it, you have to read
the whole thing a couple of times. A variable on line 2 could affect an operation on line 832, and the
only way to find out is to read the entire program.
A slightly better form of code is like having a second cook in the kitchen. You hand off some
operations to other parts of the program, but your goal is mostly to make your files smaller, not
necessarily to organize and simplify your code. It’s an improvement, just not taken far enough.
The best form of code is like splitting a recipe into sub-recipes, usually called “modules” or “classes”
in code. Each module is concerned with a single simple operation or piece of data. The vegetable
chef shouldn’t have to worry about the sauce ingredients, and the person cooking pasta shouldn’t
have to worry about the cheese grater. Their concerns are separated (hence the term separation of
concerns).
The benefits to this are significant. Suppose a coder needs to modify the program later—to make
it gluten-free for a client with celiac disease or to add a seasonal vegetable. That coder will only
need to read, understand and modify one small part of the program. If all of the code dealing with
vegetables is contained in a single small class with a few well-defined inputs and outputs, the coder
never needs to worry that adding a vegetable will ruin the sauce.
The goal here is to make sure that, to make any given change, the coder has to think about as few
parts of the program as possible, instead of all the parts at once.
2. Global variables (are bad)
Let’s jump back to your username variable. When you built the login page for your app, you realized
you’d need to display the user’s username in a few other places, like perhaps the site header and the
settings page. So you take the path of least resistance: you create it as a global variable. In Python, it’s
declared with the global keyword. In JavaScript, it’s a property of the window object. It seems like
a good solution. Anywhere you need to show the username, you just pop in the username variable
and you’re on your way. Why aren’t all variables maintained like this?
Then things go sideways. There’s a bug in the code, and it has something to do with username.
Despite the availability of an instant search tool in most code editors, this is going to take a while to
fix. You’ll search username and there will be hundreds or thousands of results; some will be the global
variable you set up at the beginning of the project, some will be other variables that also happen
to be named username, and some will be the word “username” in a comment, class name, method
name, and so forth. You can refine your search and reduce the amount of noise, but debugging will
still take longer than it should.
The solution is to put username where it belongs: inside of a container (e.g. an object) that gets
imported or passed as an argument to the classes and methods that need it. This container can also
hold similar pieces of data—anything that’s set at login is a good candidate (but don’t store the
password. Don’t ever store a password without encryption). If you’re so inclined, you can make this
Steps to better code
44
container immutable, so that once username is set, it can’t ever be changed. This will make debugging
extremely easy, even if username is used tens of thousands of times in your app.
Coding this way will make your life easier. You’ll always be able to find the data you’re looking for,
in exactly one place. And if you ever need to track when a piece of data is used or changed, you
can add some functionality to your object (like a getter and setter—see Appendix A) and be on your
way.
3. DRY
Suppose you’re building a website that sells fancy hats. You build a page for the first hat and write
the code for adding it to someone’s shopping cart. You’ve got 24 more hats, so you build pages for
them, then copy the shopping cart code from the first page and paste it into each one. Everything is
working great. You make little modifications here and there: some of the hats have optional feathers
or lace, others have a lot of color options. After a while, that shopping cart code doesn’t look quite
the same on any two pages.
Then you learn there’s a bug in the original shopping cart code and it’s making your customers upset.
You need to fix it right away. And you realize you’ve made a huge mistake: since you copied and
pasted the code from one page to another, you have to fix it 25 times, once for each fancy hat. You
have to do it by hand, since the code is a little different on each page. That’s going to take forever.
You’re up late rubbing your eyes and coding fix after tedious fix, and your customers are buying
their fancy hats from competitors.
Ugh.
There’s a better way: next time you build a website, don’t be so quick to copy and paste. Write the
code for the first page, then if you need some of that code in other pages, put it in a class method or a
function and let each page refer to it, passing in arguments to handle any little differences between
them.
DRY stands for “Don’t Repeat Yourself.” It’s a good guideline to remember.
The goal is this: if an operation needs to change in some way, you should only have to modify a
single class or method. This is quicker and far more reliable than trying to maintain several copies
of the same code.
Don’t take it too far, though—if two operations are really different, let them be different. Trying to
force two distinct pieces of code into the same function can result in strange and confusing code.
Many programmers prefer the acronym WET, for “Write Everything Twice.” That is, go ahead and
copy something once, but if you find yourself with three copies of the same code, then it’s time
to refactor them into shared functionality. This is a very practical way to apply the spirit of DRY
without overdoing it.
4. Hiding complexity
Imagine I’m selling you a car. It will take some training for you to learn how to use it.
Steps to better code
45
To start the car, take red wire #2 and white wire #7 and touch them together while kicking the
engine-rev pinwheel with your foot and pouring an appropriate amount of fuel into the injector,
which you’ll find under the center console. Once the car has started, reach into the gearbox and
push the layshaft into place against the first gear on the differential shaft. To accelerate, increase the
flow of gasoline into the injector. To brake, hold your feet against the tires.
I’m sure this car frustrates you as much as it frustrates me. Now let’s channel that angst toward
code elements with over-complicated interfaces.
When you build a class or method, the first thing you write should be the interface: the part that
a different piece of code (a caller) would need to know about in order to use the class or method.
For a method, this is also called the signature. Every time you look up a function or class in API
documentation (like on MDN Web Docs³⁵ or the Python documentation³⁶), what you’re seeing is
the interface—only what you need to know to use it, without any of the code it contains.
An interface should be simple but expressive. It should make sense in plain English, without
expecting the caller to know about the order in which things happen, data that the caller isn’t
responsible for, or external variables.
This is a bad interface:
1
function addTwoNumbersTogether(
2
number1, number2, memoizedResults, globalContext, sumElement, addFn
3
) // returns an array
This is a good interface:
1
function addTwoNumbersTogether(
2
number1, number2
3
) // returns a number
If an interface can be smaller, it should be. If a value you’re providing with an argument could be
calculated from other values instead, it probably shouldn’t be an argument (or the others shouldn’t
be). If a method has more than a few parameters, you should ask yourself if you’re doing something
wrong (although you might make an exception for some class constructors).
Don’t take this too far. If you’re setting and using global variables in order to avoid passing
arguments to a function, you’re doing it wrong. If a method requires a lot of different pieces of
data, try splitting it out into more specific functions; if that’s not possible, create a class or object
specifically for passing this data around.
Remember that all methods and data that are in a class but can be accessed from outside of that
class are part of its interface. This means you should make as many methods and fields private as
you possibly can. In JavaScript, variables declared using var, let, or const are automatically private
³⁵https://developer.mozilla.org/en-US/
³⁶https://docs.python.org/3/
Steps to better code
46
to the function they’re declared in, as long as you don’t return them or assign them to an object; in
many other languages, there is a private keyword. This should be your best friend. Only make data
public on a need-to-know basis.
5. Proximity
Declare things as close as possible to where they’re used.
Your instinctive urge to organize can work against you here. You may think an organized method
looks like this:
1
function () {
2
var a = getA(),
3
b = getB(),
4
c = getC(),
5
d = getD();
6
7
doSomething(b);
8
doAnotherThing(a);
9
doOtherStuff(c);
10
finishUp(d);
11
}
getA() and its compatriots aren’t defined in this snippet, but imagine that they return useful values.
In a small method like this, you may be forgiven for thinking the code is well-organized and easy
to read. But it’s not. d, for some reason, is declared on line 5 even though it isn’t used until line 10,
which means you have to read almost the entire method to make sure it isn’t used anywhere else.
A better method looks like this:
1
function () {
2
var b = getB();
3
doSomething(b);
4
5
var a = getA();
6
doAnotherThing(a);
7
8
var c = getC();
9
doOtherStuff(c);
10
11
var d = getD();
12
finishUp(d);
13
}
Steps to better code
47
Now it’s clear when a variable is going to be used: immediately after it’s declared.
Most of the time the situation isn’t so simple; what if b needs to be passed to both doSomething()
and doOtherStuff()? In that case, it’s your job to weigh the options and make sure the method is
still simple and readable (usually by keeping it short and using more descriptive variable names than
a and b). In any case, make sure you don’t declare b until immediately before its first use, and use it
in the shortest possible code segment.
If you do this consistently, you’ll sometimes find that part of a method is completely independent
from the code above and beneath it. This is a good opportunity to extract it into its own method.
Even if that method is only used once, it will be valuable as a way to enclose all the parts of an
operation in an easily understandable, well-named block.
6. Deep nesting (is bad)
JavaScript is known for an uncomfortable situation known as “callback hell”:
1
function getSumOfLetters(callback, errorCallback) {
2
getA().then(a => {
3
getB().then(b => {
4
getC().then(c => {
5
getD().then(d => {
6
getE().then(e => {
7
getF().then(f => {
8
postSum([a, b, c, d, e, f]).then(
9
sum => callback(sum),
10
err => errorCallback(err)
11
)
12
})
13
})
14
})
15
})
16
})
17
})
18
}
See that trail of }) running down the last several lines? That’s the calling card of callback hell. It’s
avoidable, but that’s a subject that plenty of other writers have already addressed.
What I want you to consider is something more like “if hell.”
Steps to better code
48
1
callApi(function(result) {
2
try {
3
if (result.status === 0) {
4
model.apiCall.success = true
5
6
if (result.data.items.length > 0) {
7
model.apiCall.numOfItems = result.data.items.length
8
9
if (isValid(result.data)) {
10
model.apiCall.result = result.data
11
}
12
}
13
}
14
} catch (e) {
15
// ignore errors
16
}
17
})
Count the pairs of { curly braces }. Six, five of which are nested. That’s too many. This block of
code is hard to read, partially because the code is about to creep off the right side of the screen and
programmers hate horizontal scrolling, and partially because you have to read all the if conditions
to figure out how you got to line 10.
try and catch are keywords you may not have encountered yet. Any time an error occurs inside of
a try block, it will immediately skip the rest of the block and jump to the following catch block to
be processed. In this case, the catch block isn’t doing anything, so we’re ignoring errors completely.
This is a bad idea because if something goes wrong, we have no way of knowing.
Now look at this:
1
callApi(function(result) {
2
if (result.status !== 0) {
3
return
4
}
5
6
model.apiCall.success = true
7
8
if (result.data.items.length <= 0) {
9
return
10
}
11
12
model.apiCall.numOfItems = result.data.items.length
13
14
if (!isValid(result.data)) {
Steps to better code
49
15
return
16
}
17
18
model.apiCall.result = result.data
19
})
That’s a lot better. I removed the try/catch block, for starters (although it would have been equally
good to properly handle and report the error). We can clearly see the “normal path” for the code
to follow, and only in abnormal situations does the code stray off into an if block. Debugging is
much simpler. And if we want to add extra code to handle error conditions, it will be easy to add a
couple of lines inside those if blocks (imagine if the if blocks in the original code had else blocks
attached! That would be so confusing).
7. Pure functions
A pure function (or functional method) is a function that does not alter or use external data (it’s
stateless). In other words, for a given input, it will always provide exactly the same output, no
matter what has changed outside of it, and all your other variables will be completely unaffected
by what happens inside of it. All pure functions have at least one argument and return at least one
value.
This function is pure:
1
function getSumOfSquares(number1, number2) {
2
return Math.pow(number1, 2) + Math.pow(number2, 2)
3
}
And this one is not:
1
function getSumOfSquares() {
2
scope.sum = Math.pow(scope.number1, 2) + Math.pow(scope.number2, 2)
3
}
If you want to debug the first function, everything you need is right there in three lines of code. You
can paste it into a separate environment, like jsfiddle³⁷ or the browser console, and play with it until
you find out what’s wrong.
If you want to debug the second function, you may have to dig through the entire program in order
to make sure that you’ve found all the places where scope.sum, scope.number1 and scope.number2
are accessed. And if you ever want to move the function to another class or file, you’ll have to worry
about whether it has access to all the same data.
Not all methods can be pure; if your application didn’t have state, its usefulness would be limited.
But you should write pure functions often. This will make your program easy to maintain and scale.
³⁷https://jsfiddle.net/
Steps to better code
50
8. Automated tests
An automated test is a piece of code that executes another piece of code and checks the results to
make sure it’s working. This is much faster and more reliable than trying to test every feature of the
app on your own every time you make a change. Every major programming language has tools and
libraries to help you write these tests. Some are called unit tests, which test a small, self-contained
piece of code (like a class or method), and others are integration tests, which test the way different
pieces of code interact.
Writing automated tests for your own code is considered an essential part of being an effective
programmer. Any class or method that’s more than a bare wrapper over other code—that is, any
class or method that contains logic—should be accompanied by a unit test. That unit test should run
automatically whenever your team merges code to the main branch.
Unit tests, properly written, weed out false assumptions and make your code easier to understand.
If someone doesn’t know what a piece of code does, they can look at the unit test and see use cases.
Writing tests can be tedious, and there’s such a thing as too many tests, but if you ever go into a task
thinking, wow, this one’s tricky, that’s a sure sign that you should be writing tests along the way.
Conclusion
Good code is a joy to maintain, build upon, and solve problems with. Bad code is painful to work
with. Choose to write good code; you’ll thank yourself for it.
A good question to ask yourself when writing code is: will this be easy to delete when we don’t need
it any more? If it’s deeply nested, copied-and-pasted all over the place, dependent on various levels
of state and lines of code throughout the program, and otherwise confusing, people will be unable to
understand its purpose and impact and they’ll be uncomfortable deleting it. But if it’s immediately
clear how it’s used and what other code it interacts with, people will be able to delete it confidently
when its usefulness runs out. I know you love your code, but the truth is that the world will be better
off without it someday. And that’s okay.
Programming tools
Gianluca Fiore
In your climb to the highest peaks of the programming world, hopefully you will encounter a
plethora of languages, resources, conversations, and people. All of them will be accessible to you
through tools, whether they be a web browser, an editor, a compiler or something else, depending
on the task at hand. The choice of what tool to use for a given job may be daunting at the beginning
and is one you shouldn’t waste too much precious time on—that time is best spent actually learning
and coding. This chapter will help you to understand how important your choice of tools for coding
is, or is not, and why so many programmers care a great deal about theirs.
Programming is luckily extremely forgiving of not choosing the best tool for a specific task,
especially for advanced programmers who have learned how to “bend” tools and languages to their
will. Yet at the beginning a poor tool for what you’re trying to achieve could make you waste a lot
of time and possibly give up altogether. Please don’t.
The tool of choice will depend on your area of expertise. If you are doing front end web programming,
the choice of browser you’re developing on first is vital, since they differ in the features and
development tools they support; a back end programmer may care more about a good debugger
and compiler, if any, and so on.
Every programming language has its strengths and weaknesses. Some are truly fast, like C, but ask
you to do more math and be more careful with possible bugs in your code. Others are much easier,
like Python and Ruby, but will usually be slower unless heavily optimized—something that, at the
beginning, may be hard to master. If you need to write a website nowadays JavaScript is king so
trying to do it with a language not specifically designed for the web, like Go or Java, might increase
the difficulty for you. You could still do it, sure, but very few beginning programmers have the
knowledge to depart from the specific goal that a programming language was designed for.
Thus, it’s best to focus on what your project needs to achieve and what you would like your path
in the programming world to be and choose the right language for them. You will learn faster and
will meet less difficulties with your projects. There is always time to learn other languages later
and to expose yourself to their new concepts. No language is useless to learn. But don’t try to learn
language X because Y is using it and it sounds cool. Learn what is useful for you.
The same is valid for operating systems and editors. Pick the tool you feel most productive and
comfortable in. It may not be the best operating system ever nor the one with the best tools or
the editor that will make you type fastest, but it’s more important to get started and not waste
time fighting against the tool to make it behave like you want. There’s no need to make it more
complicated than it should be.
Programming tools
52
Wars? What wars?
Related to this, if you follow news or discussions about programming on social media or online
groups you may be surprised to find that the word “war” is used when discussing various tools.
It may be an “editor war” or “browser war” or the “tabs vs spaces” war. Or the “OSes war”, which
stands for “Operating Systems war”. They are not actual wars fought with weapons and soldiers,
luckily, but with words and interminable discussions on which tool is the best for a specific job or
task, or about which one is simply better or whether you should code in a specific way or not. These
“wars” date back decades, a few even before some of us were born, and show no signs of ever ending
in a truce.
So what are those wars then? And why should you care (or not)?
The origin of it all lays in the tendency of many programmers of average or high experience to stick
with a system, be it a language, a framework, or a tool, throughout their career—either because it is
the one they like the best, they find themselves the most comfortable coding with or in it, or simply
because it was the first one they truly mastered and don’t feel like learning a new one. There’s
absolutely nothing wrong with that and it’s part of the reason some languages have had such a long
life despite tens of newer languages having been developed after them.
In any case, some programmers may seem outraged that you use, let’s say, Windows instead of
MacOS. Or that you chose to start coding with a visual code editor like Atom or Visual Studio instead
of a text-based editor like Emacs or Vim. Or that your personal browser of choice doesn’t appeal to
them because it’s not up to date with modern web standards or is developed by EvilCompany™and
by using it you are contributing to their world dominance plans or something.
These are the “wars” you will definitely hear about. Some people will try to convince you to use
a different tool for your job, for practical or ideological reasons. Even ethical ones, sometimes.
Whatever you may think about them, they’re part of the history of computing and are part of
the folklore, along with countless jokes and memes, of the programming community as a whole.
Knowing a bit about them will help you navigate the references that may occasionally pop up in
threads on social media and forums and help you choose the right tools at the beginning of your
programming journey.
The ancient editor war
One of the most famous, and still going strong, is the religious war between Emacs and Vim
(“religious” as there actually is a Church Of Emacs, no joke). For those who don’t know them well,
Emacs and Vim are two ancient text editors that over the years have developed a vast community
around them, with thousands of plugins to increase their functionality and an array of different
themes to change their appearance. If you haven’t had the chance to read their history yet, Vim
stands for “Vi Improved” as it is the direct successor of a previous editor, Vi, which in turn was
inspired by an even older one, Ed. We’re talking early 70s here. Bram Moolenaar, the author of Vim,
ported it to various platforms and made it “modern” in its functionality for that time. Curiously,
Programming tools
53
Emacs was also indirectly inspired by Ed as its ancestor was TECO, which was similar to the Ed
editor. Later Richard Stallman improved it (see the pattern?) and renamed it Editor Macros, Emacs
for short. End of history lesson.
On the deepest level, the rivalry between the 2 editors is not a practical one: they both do their job
very well, in our case allowing us to code in an efficient way, and are great at not overwhelming a
new programmer with too many features—you won’t feel too lost at first as you can just learn what
you need to start coding without getting lost in a ton of menus and options. Actually, in their text
versions, neither has any menus at all.
Where they do differ is in the philosophy: Vim espouses the small is beautiful and do one thing
well tenets of the system it was originally developed for, Unix, while Emacs centers on supporting
development as an entire operational hub. Emacs tries to be the center of your coding experience,
providing you with all the features you need to develop with ease, whereas Vim tries to just edit
text very well and lets you add other features with plugins. Emacs is all-encompassing, Vim is
more focused. Both are very quirky by today’s standards and may seem extremely counterintuitive
at first. That in turn gives rise to a smaller “war” between those preferring more modern coding
environments, graphical ones usually, and those that stuck with Emacs or Vim.
The point of this particular war is how one prefers to code: with a single program, which you
probably never leave and contains all your code, debugger and text editing capabilities, or with
multiple programs that you open from time to time, when you need, and can keep in the background
of your work, occupying less hardware resources at the cost of being more minimal. Whether
you prefer one philosophy or another, or want to totally avoid both Emacs and Vim, it’s not
important when you are starting out as a coder. Your focus should be on learning to code. You
will develop preferences for one mainstream philosophy or another, or perhaps even develop your
own alternative, in the future. Right now these editors are just tools that can help you code better,
not necessarily faster. If you don’t feel at ease with them, postpone learning them until later. Stick to
solving problems and completing code projects, not getting to know all the idiosyncrasies of various
editors. If you prefer a beginner-friendly interface, editors like Atom or Visual Studio Code will
make you feel at home.
The Windows/Linux war
The same attitude can be held regarding the OS wars too. There are plenty of opinionated
programmers that will swear by using Windows or MacOS, and others that will laugh at them
as the “real” coding experience can be had only with more minimal, “barebone” operating systems
like Linux³⁸ and BSD³⁹. Either can be right of course, this isn’t the book to discuss which operating
system is the best for programming. The best one for you is the one that allows you to be the most
productive, that gets least in the way of your learning and improving as a programmer. If you are
already using one that you feel perfectly comfortable with, have no grudge against and have perhaps
explored a few alternatives but none have sparked any interest, keep using your current operating
³⁸https://en.wikipedia.org/wiki/Linux
³⁹https://en.wikipedia.org/wiki/Berkeley_Software_Distribution
Programming tools
54
system. Don’t get bogged down in perfecting what already works. The tools are for you to use and
if you aren’t more productive with a commonly reputed “better” one, stick with the one you have.
Browser and style wars
Of a slightly different nature, and here is where you should start to care more, are the “tabs vs
spaces” war and the browser war. The latter is easier to understand so let’s start there. If you are
heading towards being a front end web developer, you may already know that different browsers
have different rendering engines—how they create the actual pieces that a webpage is composed of,
and render or “show” them on the screen. That (as a really simplified explanation) is what browsers
do, they take instructions in the form of HTML, CSS or JavaScript code and process them through
their internal engine to produce a visual result, a webpage that can be read and interacted with
by users. Having different engines, the process by which they render the webpage is different and
thus the results can be different too. That means a webpage can look different depending on what
browser you use to access it. The same is true for mobile devices: a webpage is shown in a different
way depending on the size of the device the browser is installed on. That’s a well-known fact and
an intentional feature meant to adapt any webpage to any device, from the tiniest cell phones to the
largest quad-monitor setups.
The browser wars were born out of different browsers competing to capture the widest audience; in
ancient times they were sold on CDs and thus they had to be commercially successful. Nowadays all
browsers are free to download (except for Safari that is only available for Apple machines) and the
commercial incentive is not directly money but instead related to the rendering engines: if a browser
becomes so widespread that it has an absolute majority of the internet users, then it is easier for
developers to write their webpages targeting only its rendering engine, making sure it looks the best
on it and not considering minimal differences in appearance with other browsers. Thus, indirectly, a
browser that has a dominant share of the market can influence the development of the technologies
that compose the Web by implementing some of them earlier, or not implementing others at all,
knowing that many developers will follow their lead.
Over the course of the last 30 years since the Web was born, various browsers have reached a
dominant status over the others. Netscape, Internet Explorer, Firefox, and Chrome have all had their
share of the spotlight in these browser wars. Regardless of the reasons why each browser rose and
fell, what’s important to us as developers is that using one browser over the others will mean not
only having different tools for development (usually called “Dev Tools” or “Developer Tools”), but
running the risk of optimizing the websites we write for that browser and that browser only. It’s
way too common to be lazy and content with your website looking good on your browser of choice,
assuming that it’s okay for others too. Or, worse, noticing some small issue with the layout or an
oversized font or a slightly misplaced menu in another browser and ignoring it because “only a few
people use it”. That may be true, but if not, its users won’t have a good experience using the site and
this will increase the feeling that the most widespread browser is the “best” one. You are indirectly
and involuntarily creating a monopoly in the browser market. This is why I try to make sure I test
my webpages with all major browsers at the very least. If we keep the competition open and fair,
developers and users alike will benefit from it.
Programming tools
55
“Tabs vs spaces” is a more technical war. In the beginning, talking again of the early 70s, editors would
use a tab character to indent code. One tab character was the equivalent of eight space characters
and in the old days disk space was scarce, so one character was better than eight. Nowadays we have
disks in the order of terabytes so the difference is negligible. Yet the issue here is of interoperability:
Mac and Windows editors tend to make a tab character the equivalent of four spaces while on Linux
and BSD, it is still eight. Unless you change the preference in your editor of choice, of course. Because
of this, most fans of spaces instead of tabs will consider you wrong for using tabs because a space
character is always a space character, no matter the editor and system you are using. On the other
hand, tab fans claim that one tab is much less typing than four to eight spaces.
The issue is, if you are using four spaces, for instance, and your programming buddy uses eight,
then the code will be indented differently and some languages, like Python, will even bail out with
errors as the syntax of the language depends on the correct indentation of the code. And besides,
the resulting code will look messy and hard to read. Moreover, copying and pasting from a web
browser in a local editor will most definitely screw up the indentation as it will depend on which
browser, which website, which editor and which operating system you are copying and pasting
from/to. There’s far from a standard here.
So for portability, do consider what you prefer and stick to it, but not before having spent a little
bit of time to check what is the recommended way to indent in your programming language and
in the project you are coding on. There are guidelines about tabs vs spaces in all the most popular
languages. It will make everybody’s life easier and save you from arguing with older programmers
that will most surely believe their stance in this war is the “right” one.
Use what you like, focus on learning
In an ideal world, nobody would judge you because you have taken a specific stance in one of these
wars (or not) or because of your choice of tools. Some will joke about it and some will fake being
offended that you have a different opinion, but nobody should discriminate against you in your
path to becoming a good programmer, just because you use a specific editor or prefer a Mac to a PC.
Yet it will happen, so it’s important to be at least aware of each of these wars. They may influence
your choice of coding tools. And hopefully this bit of history will save you from endless discussions
about which side is right, if any. As Bertrand Russell famously said, “War does not determine who
is right—only who is left.”
You are an interpreter
Edaqa Mortoray
Programming is primarily about translation. You take the desires of a user and translate them into
source code. It’s a process requiring a strong understanding of technology, the users, and all the
people involved in development.
I know a lot of you may wish to keep your head in the code, but becoming a great programmer
depends on you becoming a great mediator. Imagination far outpaces our current technology,
leading to extreme mismatches in what users expect and what our computers can actually do. As a
programmer, you’ll be required to temper those expectations and produce a nonetheless desirable
product.
You’ll need to empathize with the user and consult with colleagues on their views. Development is
not a process that can be done by one person. Programmers represent the technology, which is a
cornerstone to the process, but still only one part. Our products entirely hinge on the software doing
something useful, but without teamwork working towards a shared vision, that’ll never happen.
Soft skills is often the term used to refer to this part of the job—interacting productively with users
and teammates in pursuit of a common goal. I don’t know if that term accurately represents this
skill set. The ability to communicate is an essential skill. Your ability to get inside the user’s head is
critical to the success of the project. The importance of you as a translator and mediator of technology
cannot be overstated.
Nobody cares about your code
Let’s back up for a second, and start at the code. While it is only part of our job, it is the domain where
a programmer’s presence dominates. We own this artifact of development. It is our responsibility to
create it, and we have to address all issues with the code.
The ability to write code is a significant competence that all programmers must develop. There is no
way you can translate requests into code if you don’t know how to write it. Your ability to translate
is limited by your vocabulary.
Imagine having to work with somebody who doesn’t share a language with you—say someone who
only speaks Italian, while you only speak English. You’d need an interpreter that can translate for
you. The quality of the translation is limited by the interpreter’s understanding of both English and
Italian. If they can speak only a bit of Italian, their interpretation won’t be natural, and your Italian
colleague will have a hard time understanding what you meant to say. Similarly, it doesn’t help if
the translator speaks Italian fluently but is weak with English. The translator can formulate great
sentences in Italian, but potentially from a misunderstanding of what you said.
You are an interpreter
57
In programming, you are an interpreter who must speak two languages. Code is one of the languages
you need to speak. But you also need to speak the language of users and other developers in your
company. It’s irrelevant that you weave wondrous structures of code if you’ve misunderstood what
you’re supposed to be building. It’s also pointless if you’re a master empath, and you can understand
the user perfectly, but you can’t figure out how to express that in code.
Source code is a work artifact. It’s there to support the high-level goals of the product. Ultimately,
other than you and a few other programmers on your team, nobody cares about the code. It’s all
about the product. The user cares about what you’ve built and how it solves their problem, not so
much about how you got there. Knowing this improves the appreciation of your work, and lets you
make the right decisions.
Sharing the journey of the user
But what goals does the code need to support? Here we look to the users of the products: the people
that will be installing the app on their phone, going to your web page, or downloading a desktop
program. Understanding the people using our software is the highest priority of development. The
user experience is our utmost goal.
You may have already heard about user stories, journeys, and personas. These are all tools that
capture what the user wants. They should be used on most projects. It’s actually hard to avoid them.
Even if you don’t use a strict method or have rigid formality, you will be considering the user’s
wishes in your project. Learning user tools, such as user stories and portraits, makes the process
easier and more robust. But just like code, they are not the purpose of the project.
The purpose of user portraits and stories is to keep the focus on the user. A portrait tells us what job
a user has, where they live, and what their goals are in life. We create these descriptions to better
empathize with people using our product. If these people remain nameless and abstract, it’s easy to
forget about who they are.
Having a bit of formality, such as writing down our ideas, allows us to communicate with other
teams. It’s more comfortable to talk to other departments in the domain of the user than of
technology. By talking about the product from the user’s viewpoint, we stick to a universal language
that everybody can understand.
This is more challenging than talking about code. Code has a strict structure and lack of ambiguity.
By contrast, human language is full of amorphous thoughts and wandering ideas. It’s this lack
of clarity that causes most issues within development. But as difficult as it may be, getting all
departments to talk in the language of the user is worth it. It’s how great software is made.
Much like the code isn’t the product, the product isn’t actually what the user wants. People have
real-world tasks they wish to perform. They are willing to use a tool to get them done, but that’s
all it is: a means to an end. They may not even know what kind of tool they need (see Appendix A,
“XY Problem”). This is why it’s essential to talk in the language of the user, not the product. This
subtle distinction in wording shifts the emphasis of development from technical requirements to
user expectations.
You are an interpreter
58
For example, most people don’t want a car for the purpose of having a car. Many people don’t even
want to drive, but they have a car to get to other locations. These drivers care primarily about how
they get somewhere with their vehicle. All the polish and extra features are pointless if it’s hard to
get somewhere. This is why things like public transit and taxis compete in the same market. When
stating requirements, there’s a significant difference between “wanting to own a car,” and “wanting
to travel between locations.”
As another example, we have apps that allow us to organize events, from large to small. As the
developer, you must keep in mind that the users are trying to hold an event. Your app is strictly a
tool the organizer and attendees will use. Adding features that don’t support the event organizers
may at best be ignored by the user, and at worst get in the way. I’m sure we can all think of numerous
apps that have nonsensical features in them.
Everything and yet nothing we want
Ensuring our high-level requirements stay in the domain of our users addresses a fundamental
problem. Technology can’t do everything. Indeed, it doesn’t come anywhere close to all the things we
want to do. It can neither do them the way we want to do them nor understand what we actually
want to do. Despite the extreme reliance we have on computers, they are still constrained when
compared to all that is possible.
People’s desires are not limited by technology. Their imagination shows no bounds. The expectations
placed on technology tend to grow faster than technology itself advances. The demands placed on
our computers, our gadgets, our networks, increase at alarming rates.
It’s your job as a programmer to translate these unbound ideas into the limited space of what
computers can actually do.
Losing track of the user’s desires means you run the risk of working on the wrong things. While
computers are limited in fulfilling user desires, they are unbound in their own domain. There’s a
wide variety of interesting, cool, and clever things we get a computer to do. It’s easy to go down the
road of technical beauty and stray far from the goals of the project.
Your focus on the user is what keeps you on track. For every line of code you write, for each module
you install, for every host you deploy, you should be thinking about why the user needs this. If you’re
unable to draw a clear connection from your work to those high-level user goals, then something is
wrong.
Part of a larger development community
This focus on the user isn’t only for programmers. No project can be done by programmers alone.
Beyond the users, there are numerous other departments in a development company—designers,
product owners, project managers, executives, quality assurance, and so on. You have to be able to
converse with all of them about the product. You need to all be working towards a shared vision.
You are an interpreter
59
When somebody is left out of the process two things happen. First, their ideas, concerns, and
requirements will be lost. This could result in a product of lower quality. Second, they feel
marginalized and may become demotivated. Continuing in that state, they may become bitter and
angry.
Tensions between teams are unfortunately all too familiar. A lot of this tension comes from people
not properly communicating. While two teams may both fully believe in the product, an inability
to share that vision can lead to hostility.
This discord can rapidly foment an unpleasant workplace. Nobody, including you, wants that. You
work there, so keeping everything pleasant is in your best interest.
When things turn sour, productivity suffers. Not only are people, including you, demotivated, but
they also end up working on the wrong things. The vision of the product becomes blurred, and
ultimately it will fail. Instead of working together, everybody starts complaining about the other
teams, how they don’t listen and don’t understand.
Always remember, communication is a two-way street. The best way to be misunderstood by
someone is by not talking to them. The best way to misunderstand someone is to close your ears to
them.
As technology and time are limited, development is all about compromise. Not everything can
be done. You, as a programmer, represent the technical side of the equation and must bring that
knowledge to the negotiating table. Learn when to speak up and how to bring your concerns to the
table.
If you can’t build a particular feature, you must make that clear. If you have an idea for a feature
that you think would help the user, but that nobody has mentioned yet, you should bring it up. If
teams have requests for features that would help them and cost little, it’s worthwhile to implement
them to improve relations. If a high-visibility defect isn’t getting fixed, you need to explain why that
is.
Your prioritization process must be transparent, or tension will build. People are better able to accept
the rejection of their ideas if they understand why they are being rejected. When people share a user-
focused vision of the product, it’s easier to identify high impact items and work on them first.
Deserving of trust and autonomy
By having open processes and taking the time to listen to other teams, you’ll build trust between
each other. We rely on other teams to do their job. Just as we translate others’ wishes into code, our
own requirements will be converted into work processes in various teams. A request for artwork
will be taken by a graphic artist and turned into images. We may ask marketing about our target
user, and they’ll come back with a persona. We have some idea of what they’re doing, but the details
of their work aren’t our concern.
Development is not an exact science, and we all need room to maneuver if we’re to get the system
right. This is why it’s crucial that requirements stay in the realm of users. The internals of the
software must be flexible.
You are an interpreter
60
If requirements specify how a system should work internally, they interfere with the job of the
programmer. The same goes for other departments. We aren’t going to tell the graphics team what
Photoshop layering technique they should be using, nor will we specify which ERP accounts the
finance team should create to handle microtransactions. All teams have an expected amount of
autonomy to perform their work.
This autonomy is based on everybody having a shared vision. We are all allowed, and expected, to
contribute to the product’s goals. That shared user domain is everybody’s responsibility. This goes
hand-in-hand with trust. There’s no way you can implement the system correctly if you don’t know
what those high-level goals are.
Your flexibility and trust in your work depend on your understanding of the user. And that’s tied to
how well you can communicate with other teams.
Becoming a great programmer
The emphasis for programming is often placed on coding. It’s a comfortable place to start learning.
Initially, it’s likely the place where you lack the most skills. You’ve grown up in the real world, so
to some degree, you’ve been working on your soft skills for years already.
Natural experience won’t be enough, however. The particular skills needed for communication as a
programmer require additional training. You need to take the time to learn the various techniques
used for translating user desires into code.
Don’t feel overwhelmed though. Nobody can naturally do everything, and it’ll take time to learn
both code and communication. You’ll be part of teams that will help you along. You and your
teammates will have strengths and weaknesses to compliment each other.
You won’t always act on your own. If you’re a junior programmer, it’s vital to have a mentor that
can help you along. It’s expected that programming teams discuss how the code should work. It’s
important to have a good leader who can make good decisions, and when needed, state precisely how
some system should work. The dynamics within a programming team differ; however, the dynamic
is always based on communication. And you should never let anybody hide the user’s wishes from
you.
Becoming a great programmer is primarily about your ability to act as an interpreter. You can’t be
ultra-productive only by being awesome at coding. Productivity is about choosing the right things
to work on and figuring out the best way to cover the product requirements. Your value will be
measured by how well you appear to be supporting the company. The better you perform with
other people, the better you can tailor your effort towards high impact items.
What to learn first
Isaac Lyman
I occasionally get a message from a brand-new developer who’s overwhelmed by all the technologies
and choices that exist in the world of software development. Where do you even start? Some of these
devs have seen job advertisements like the following:
This is for a standard, mid-level web development position. It lists 14 specific technologies, alludes
to many more, and if that weren’t enough, it has an “etc.” Even as a senior software engineer, I’m
not sure what that “etc.” refers to. Maybe I could Google it:
What to learn first
62
Oh, great. 16 more technologies. If I were brand-new to this, I’d be thinking, “you mean I have to
learn 30 different programming languages just to get a mid-level job?” And then I’d throw up my
hands and apply for a job in something less demanding, like brain surgery.
Let’s put that fear to bed: no, you don’t have to learn 30 different programming languages, now or
ever. You need to learn one. Then you need to learn a few tools that are commonly used with that
language. That will get you a junior position. Afterward, you’ve got options: get better and better
with the languages and tools you already know (you might call this the “expert in the room” route),
or learn several more (the “startup engineer” route). Either route will let you advance your career
and make more money, and neither is necessarily better than the other, but you’ll probably find that
you strongly prefer one of them.
So where should you start?
Make a list of technologies you’re considering. Then pick one, any way you like. If there’s a company
you want to work for and they recruit heavily for one of them, pick that one. Or if you know what
you want to build, pick the tech that goes with it (see Appendix B for ideas). Or go with your gut.
Or flip a coin, or roll a d20, or pick one out of a hat. There’s no “best” technology. What’s important
here is that you commit. Spend time getting to know the technology, building simple projects with
it, reading articles about it, finding GitHub repositories that use it.
Some people start second-guessing themselves after a day or two with a new technology, so they
switch to a different one, and then another one, and then another. This is like learning to say “Good
morning” in 50 different languages. It’s a party trick, not a marketable skill. Don’t let yourself do
this. Even if you spend five years with something and decide it’s not for you, it’s not a total loss; 75%
or more of the skills you’ve learned will transfer neatly to your next technology. The consequences
of choosing the “wrong” technology are tiny.
If you don’t know a programming language yet, I recommend starting with JavaScript, Python or
C#. All of these are extremely popular and in high demand. If you already know JavaScript, learn a
utility tool like Lodash and a web framework like React or Vue, or learn Node.js and a server-side
framework like Express or Hapi. If you know Python, learn a data science library like NumPy or
Pandas, or a web framework like Django or Flask. If you know C#, learn ASP.NET MVC to build
What to learn first
63
web applications, Xamarin to build native apps, or Unity to build video games.
Once you’ve picked some technologies, the best thing you can do is start a project (see Leonóra’s
chapter “Making the most out of side projects”). Think up something small and simple you want to
build, then put it together a step at a time, learning what you need to learn as you go along. This is
the best way to gain competence. It doesn’t much matter what you build, as long as it’s interesting
to you—to-do list apps are the cliche, but you could just as easily build a game, a unit conversion
calculator, a chat room, a conversation bot, or anything else that comes to mind. The only limit
is your imagination. For some free ideas, check out the graveyard tag⁴⁰ on dev.to, where several
developers have written about the projects they’ve built on their own over the years.
Once you finish your project you’ll have a nice portfolio piece, along with the confidence of knowing
you can see a project through from start to finish. And you’ll be well on your way to being an expert
in the technology of your choice.
I promise, as long as you don’t go out of your way to choose strange and obscure technologies,
anything you choose can lead to a successful career. There are plenty of jobs out there waiting for
you.
⁴⁰https://dev.to/t/graveyard
Learning to learn
Yechiel Kalmenson
“You need to learn how to learn” is a phrase you will often hear as you start on your journey.
Don’t worry about which language/framework resource X or course Y teaches, people will tell you,
what’s important is that they show you how to learn on your own.
There is truth to that. The majority of new developers don’t get a job using the first stack they
learned. Even if you are lucky enough to get a job using the frameworks you learned, the breakneck
pace of the tech world virtually guarantees that your knowledge will be outdated in no time and
you will have to learn the next shiny thing every few years.
Students who find themselves too focused on acquiring a particular technology, instead of focusing
on acquiring the skills needed to keep learning on their own, might find themselves blindsided when
tasked with learning a different technology just to get their first junior role. They may feel like the
experience they gained at their bootcamp or college (or the resources they spent self-teaching) was
a waste of time and money.
Changing your perspective from thinking that you need to learn Ruby, or JavaScript, or React, or
what have you, to realizing that you are really trying to learn how to learn those skills will leave you
better prepared for the task of finding your first job as a developer and for the lifetime of learning
and growth that will follow. Not to mention that it will help you learn whatever technology it is
that you decided to go with first more effectively.
But what does it mean to “learn how to learn”? What are the skills that developers use to help them
keep up with a never-ending stream of new frameworks and technologies?
After many conversations with both former and potential students and career changers, I believe I
was able to narrow it down to four skills that you need to acquire if you want to be able to learn on
your own after graduating:
1. How to read and understand error messages.
2. How to Google things.
3. How to read and understand technical documentation.
4. How and when to take a step back and ask for help.
From my experience as a developer, I can say that I spend 90% of my workday doing one of those four
things. If you can master these skills, you can be reasonably confident that there is no technology
you can’t pick up.
Learning to learn
65
Reading error messages
This was one of the first lessons I had to learn when learning to code, and, in my opinion, what
separates developers from the rest of society.
Back in my “civilian life” error messages were scary, they were opaque, they felt like the computer
was screaming at me in a foreign language and blaming me for something which it probably thought
was my fault.
When I started learning how to code I naturally ran into many error messages, and that felt very
discouraging; I felt like I must be doing something wrong.
Then one day it “clicked” for me. I was watching a lecture by one of the bootcamp instructors
where he was coding an app. At one point he ran the code and hit an error and instead of getting
embarrassed or flustered he exclaimed, completely unironically, “We hit an error! Great!” That’s
when I realized that error messages are far from our enemies. When we encounter an error message
as developers, it’s the computer’s way of letting us know what’s wrong with our code; it’s how it
provides clues on what we need to fix.
As a developer, you will be working exclusively with broken code (if the code already works then
who needs you?). Reading and analyzing error messages is how you will go about fixing it.
The kinds of error messages you get and how helpful they are will depend a lot on which
language/framework you are using. Some languages have more helpful errors than others, but some
elements are universal.
Every error message will usually contain:
1. The error message: what actually went wrong. These can vary from a few cryptic words to a
full paragraph containing suggestions on what you might be able to do to fix the bug.
2. The location where the error occurred: the file, line number, and sometimes the function name
where your program was when it crashed.
Learning to learn
66
3. The stack trace: all the lines in your code that the program executed until getting to the function
in number 2. This can help trace where your function was called and with which parameters.
Reading all that and getting comfortable with parsing the different parts of the error message can
take some practice, but that’s the first place to look when your code doesn’t behave the way you
expect it to.
A good bootcamp or Computer Science course will encourage you to play around with the code and
break things, and will celebrate error messages instead of just showing you how to fix them.
But error messages, helpful as they are, are limited in how much they can help you. After all, the
designers of the language can’t know in advance all of the different ways programs written in their
language can break. That’s when the next skill comes in handy.
How to Google stuff
As a developer, you will spend the majority of the time doing things you don’t know by heart. Google
(or DuckDuckGo, Bing, etc.) will be your best friend.
For beginners, it can be hard to know what to Google for, especially in the beginning when you
aren’t even sure what it is you’re trying to do, never mind verbalize it in a way that a search engine
can understand. Learning how to structure your query for best results is an art that comes with
experience, but some rules will help you get started:
• Include the language you are using: if you are learning Ruby and have an array you want to
sort, searching for “how to sort an array” will probably not be very helpful; when I just did
Learning to learn
67
it the first page of results contained only answers about how to do it in Java, Visual Basic,
and JavaScript. Always start your query with the name of the language you are searching for
(in our example, “ruby sort an array” will give you plenty of results that a Ruby programmer
would actually find useful).
• Use well-defined keywords: this comes more with experience, but knowing which keywords
represent the actual information you need will save you time filtering through unhelpful results.
As a general rule, don’t include words that aren’t necessary; crafting the shortest query that
contains all the keywords relevant to your search will help make sure that you get only the
results you want.
• Know which results are more likely to be helpful: again, this comes with experience, but some
results are more likely to be useful than others. You will develop a taste for this with time, but
in general, more recent results are less likely to be out of date, and an answer on Stack Overflow
with a hundred upvotes is more likely to be helpful than a blog-post from a no-name author
(which isn’t to say there aren’t great blog-posts by relatively unknown authors).
This last point brings us to the next skill.
How to read technical documentation
Languages/frameworks have many features and functions, and unless you use a particular function
on a semi-regular basis, it is unlikely that you will have the syntax memorized.
This doesn’t mean that you are a lousy programmer. Even accomplished programmers with many
years of experience find themselves Googling things like “concatenate a string” or “filter an array.”
Source: https://twitter.com/dhh/status/834146806594433025?lang=en⁴¹. DHH is the founder of Base-
camp and the creator of Ruby on Rails, one of the most popular frameworks for web development.
The documentation for most languages is usually the most comprehensive and concise reference for
language features, saving you the trouble of memorizing hundreds of obscure language features.
⁴¹https://twitter.com/dhh/status/834146806594433025?lang=en
Learning to learn
68
For example, Ruby has about 20 different ways to iterate over an array. If you are trying to learn
Ruby, you might think that you have to memorize all 20, but if your goal is to learn how to learn
then all you have to remember is that you can find all the ways of iterating over an array in the
documentation on Ruby’s Enumerable module⁴².
The problem for beginners is that the documentation can look dense and intimidating; its conciseness
means that the page can look like a scary wall of jargon and technical terms and symbols, but with
practice, you can learn the patterns and learn how to find the information you need. With time you
will see that the official docs will become your go-to reference for simple syntax.
Ask for help
Finally, there is another very crucial skill that is not exactly about self-learning, but it’s an essential
skill to have if you want to be an effective learner.
Photo: WOCinTech Chat⁴³. Unmodified image licensed under CC BY 2.0⁴⁴
The last skill is knowing when to step back and ask for help.
None of us ever did it on our own; the “self-taught developer” is a myth.
⁴²https://ruby-doc.org/core-2.6.1/Enumerable.html
⁴³https://www.flickr.com/photos/136629440@N06/25392428253
⁴⁴https://creativecommons.org/licenses/by/2.0/deed.en
Learning to learn
69
Surrounding yourself with a network of mentors and fellow learners, and knowing when/how to
leverage said network, will save you time best spent actually learning new things. It will mean that
you don’t have to spend hours banging your head against the keyboard over a simple typo that a
second, fresh pair of eyes would have caught right away (though we’ve all been there).
There are many online communities geared at beginners. If you are in a bootcamp they probably
have ways for students (both current and former) to connect. Dev Twitter is extremely friendly,
helpful, and supportive (some of my favorite communities are the #CodeNewbie⁴⁵ community
and @ThePracticalDev⁴⁶). Find your corner, your people you connect with, and you will see that
traveling together is 100 times better than traveling alone.
In conclusion
In conclusion, learning to code is a big decision. Many factors are involved in what makes a good
bootcamp, course, or resource. I hope that reading this chapter will give you an idea of which skills
are essential to focus on and which are just a passing fad.
Good luck!
⁴⁵https://twitter.com/CodeNewbies
⁴⁶https://twitter.com/ThePracticalDev
Make the most of side projects
Leonóra Dér
This chapter will be about side projects and I would like to convince all of you that they are great!
So what comes to your mind when I say “side projects”?
Maybe you know of CommitStrip. It’s a blog about the daily life of developers and I just love reading
their stuff, but one of my favorite strips⁴⁷ from them is about side projects. It shows a very typical
situation: a developer having millions of unfinished, never-going-to-end projects. Have you ever felt
like this? Not yet?
In some ways I’m writing to motivate you to do this. To start new side projects. To also finish them,
of course, but to be able to finish one, first you have to start it! But why would anyone want to do
that?
Famous examples
To get an idea of what side projects really are, first check out a few famous ones. I guess I have
to start with a couple of the most famous side projects, Gmail and AdSense. Both were created by
enthusiastic Googlers.
Twitter, ProductHunt and even GitHub were once side projects. And the list of side projects that
became million-dollar startups goes on…
My projects
But don’t tune out just yet! You might think that I’m crazy about side projects and the truth is, I am.
I’d like to show you a few of my own side projects so you can see how they’ve helped me. I picked
very different ones:
The very first of my side projects was an online tool where you could create, edit, and share a
business model. I used this project as an opportunity to learn Vue.js (a web framework) and Spring
Boot (a Java server framework). Now, I’ve struggled to find users, but I recently made some progress:
I spoke with a startup incubator who said they would love to use it! I’m more than happy with that.
If you’d like to take a look, you can find it online⁴⁸!
My current project is a challenge for developers. It will be a collection of challenges soon, but at the
moment there is only one. It’s called the Cretan Maze. You’re trapped in a maze and have to get out,
⁴⁷http://www.commitstrip.com/en/2014/11/25/west-side-project-story/
⁴⁸http://businessmodelcanvas.io
Make the most of side projects
71
but you have to collect three gold coins first and you control the game through a REST API. So as a
developer you have to write a program to find your way out of the maze. I shared it on a few sites
when I finished coding it. To tell the truth, it was a bit like testing in production. I mean…I checked
the functions, everything was working properly more or less, but when a lot of people started to use
it, bugs came out immediately. So I learned that I should conduct a beta test before I let everyone in
through the front door. Anyway, you can try your hand at the challenge here⁴⁹.
Last but not least, the project I am most proud of is my blog. It’s a blog for software developers,
written in Hungarian. It is called ‘fejlesztő lány’ and I started it as a personal challenge; I needed
something in my life I would have to spend at least 10-20 minutes with daily so I can keep track
of the days. It might sound a bit weird, but sometimes I lose track of time. This blog and Facebook
have helped me a lot and I know it’s not a traditional side project, but I truly recommend to any
developer to start a blog!
Cons
Now that we have an idea of what a side project can be, let’s ask an obvious question: Why would
anyone want to spend time on a side project?
I mean, you might say that you don’t have time. I guess most of you have full-time jobs. You could say
that after working for eight hours you are tired and you don’t care at all. Or you have a family you
would prefer to spend time with, and on the weekends you want to be far away from the keyboard,
hiking in the mountains or playing on your local football team.
But remember, people say that you have time for what you make time for. I know it’s a cliche but it
is very true. Once I read a post by a dad who learned how to program in the evenings, and couldn’t
even sleep much as he had a newborn daughter to look after, but a few months later he got his very
first developer job.
Think about that for a second. He put his time into it and he got a reward: a job offer. Sounds great,
doesn’t it?
You might also say that side projects are something that no one pays for, and no one will praise
you for the effort and time you put into a side project if you fail or abandon it. The bitter truth is,
undoubtedly, most side projects will fail. We all know this. The majority of them don’t even reach
the first release, and those that do often become abandonware, no longer supported by the developer.
GitHub is a graveyard for them.
You could also say that it’s useless to spend time on this stuff, creating another note-taking app, an
alternative to one used by millions or billions of people, whatever for?
Pros
Let me show you all the advantages!
⁴⁹https://coding-challanges.herokuapp.com/challanges/maze
Make the most of side projects
72
The first advantage I’d like to emphasize is learning new technologies and dev skills.
For example, if you’re a Java coder, why not try Python with a data science side project? Or if you’re a
backend developer, why don’t you try out a shiny new frontend framework? Or let’s say you usually
do coding stuff, but deploying your own app to Heroku and setting up a database, Jenkins jobs, or
code analysis with SonarQube could be a challenge for you!
We live in a world with constantly changing technologies. So if you want to keep up with the new
trends, the best tool for the job is side projects, making some useless or not-so-useless projects to try
out a new library, framework or tool.
Instead of staying updated on the latest frontend frameworks in the JavaScript universe, you could
also have a project focused on learning how to write clean code, how to refactor legacy code, or
how to do Test-Driven Development, because these things take a lot of time to master. You could try
reading a well-known book on the topic and implementing the knowledge at the same time.
Another great benefit of side projects is that you are practising outside of your office hours. If you
use the same technologies at work and for your hobby projects, you’ll meet the most typical bugs
and pitfalls beforehand so that you can feel more confident at work. You’ll get to know the best
practices, so you can help others make better decisions or give advice on using library A rather than
library B, saving time for you and money for your company.
The next advantage I’d like to mention here is simply the joy of building something. It’s fulfilling
when you can show your product to others, or take a look at something and know you’re the one
that created it. You should be proud of yourself if you’ve completed a project that others can use or
download. The feeling when other people are happily using your product is quite satisfying.
And there’s another skill that you can build using your old side projects: refactoring. Think about
it as working on legacy code that you have to make work by turning buggy, vulnerable code into
something beautiful, making changes line by line, starting small but making powerful improvements
in the long run.
Side projects are also great because they look great on your CV or resume. During the interview,
when they ask about projects you’ve worked on, you’ll be happily saying that you did this, that and
some other stuff too. They help build your online presence and that certainly won’t do any harm to
your CV, career, network, or professional growth either.
If one of your projects gets serious then you can even quit your job, start a business, and become an
entrepreneur. I’m not encouraging you to quit your job right now, but it might happen…
A friend of mine always says that a good side project makes you money while you sleep. But
sometimes that mentality can do harm, as some people get very anxious when their projects start
to make even a little money. Generally, the primary goal is not to make money, but to learn, to
advance, to grow.
I have a few more advantages of side projects to share with you. For example, if you collaborate on
an open source project or build something for a community, then you will be able to connect with
developers from all around the world and make some new friends and connections. That sounds
good, doesn’t it?
Make the most of side projects
73
Also, it’s refreshing. It’s a great way to get out of your comfort zone and do something different
from your day job.
Last but not least, I would say that it’s FUN! Think about it! You have the freedom to do whatever
you want—there’s no boss or client to tell you what to do and how to do it! You don’t have to spend
hours in useless meetings. You don’t have to convince anybody of your own point of view. Your
code will be super consistent and strictly follow all the best code conventions: yours.
How
Now that you know all the advantages and disadvantages of side projects, I would like to give you
some advice on how to get the most of the time you’re willing to spend on them.
Step 1: Find a topic
Usually when I want to learn a new technology, I build something. Getting your hands dirty is the
only way of actually making sure that you got it right. You need those “aha!” moments you can’t
have just by reading or watching tutorials. A lot of people build “To Do List” apps, which are nice
because they’re easy to get started with and everyone is familiar with them. But I personally don’t
want to make yet another To Do app! If I’m going to spend my super precious time on something, I
want to be making something that has a chance of creating value for someone. For me it’s best to
make something useful, but of course sometimes it’s nice to do something just for fun.
Another suggestion: use a note-taking app. Ideas can come anytime, so be prepared! Otherwise you
will forget them.
If you are clueless as to what to do, you can find millions of ideas on the internet!
Step 2: Make a plan
Don’t worry, I’m not saying that you should start by writing a detailed, 100-page document. I’d
guess you’re used to that because of your day job. Your plan can be a random text file a few lines
long, with core features, goals and milestones. It’s usually useful to make separate files for the first
version of the project and for changes, new features, etc. And don’t forget to limit the scope and set
a deadline!
Step 3: Find a community
You can find online forums and groups that are made for sharing and receiving constructive feedback
on side projects. One of my favorites is the r/SideProject subreddit⁵⁰. It’s very active and well-
moderated and you can even get some new ideas from there or use it for brainstorming.
⁵⁰https://www.reddit.com/r/SideProject/
Make the most of side projects
74
Step 4: Build something minimal, and I mean minimal
Believe me: even if you are an experienced developer, chances are that you’re going to overestimate
your own capacity. It’s common to feel like you’re more productive alone than you are inside your
organization, and this is true to a certain extent. But if you don’t keep your feature list short enough,
chances are that you won’t finish the project before you lose your motivation and interest.
Step 5: Become a finisher!
Despite your best intentions, things will come up. You’ll always have good reasons not to finish a
project, like going on holiday, taking German lessons, or reading funny stuff on the internet. But
sometimes you have to say to yourself, “Hey, you are going to finish this app and put it on the
Android app store. It doesn’t matter how long it takes, you are going to work on this app at least an
hour each day until it’s done.”
Step 6: Go live!
Going live isn’t just about publishing your app to the app store or deploying your website to the
web. It can be publishing a library to npm or even just open sourcing the code so people can see
it, use it and learn from it. Don’t forget to spread the word! Post about it on your blog, subreddits,
dev communities, even ProductHunt. You will love receiving feedback from your actual users and
contributors.
Pro Tip 1: Go to hackathons!
Hackathons are getting more popular and more frequently organized as they’re a great way to
bring people together. You’re usually closed up with a few people to work on a project for a while,
sometimes up to three or four days. By the end you’ll have a team, a detailed concept, even a demo
version of a product. Sounds good, doesn’t it?
Pro Tip 2: Find a supportive workplace
At the company a friend of mine works for, they have an ‘Experiment Day’ every month. It’s great
for trying out interesting technologies. Similar ideas are found across a lot of tech companies—and
it’s easy to see why. You could even be the person who organizes these events.
I’ve heard that at some companies they have a “Demo Day” where anyone from the company can
show what they’ve been working on in their free time.
There is also Google’s famous “20% policy”, which means their employees can work on anything they
want for up to 20% of their work time. Why would a company do that? Because they’ve recognized
that it’s beneficial for their employees and their company too.
Keep in mind that if you create something using company time or computers, it may legally belong
to your employer, so check your contract to make sure you’re aware of that possibility.
Make the most of side projects
75
So why not start one?
As you can see, your precious time spent working with side projects can be beneficial. Your small
ideas can even grow into big companies. I hope that you are all motivated now to start and to finish
one! In the end, the most important thing you can do is to grow and gain experience.
Getting your first job
Isaac Lyman with Clifford Fajardo
Getting hired is hard at first. I mean, eventually you’ll have an amazing resume and recruiters will
be flooding your inbox with interview requests, but for the first little while it can seem like an
incredibly tough market. Everyone’s looking for senior developers, interviews are all whiteboards
and obscure data structures, and some jobs turn out to be unpaid “internships” or “software farms”
that mistreat and devalue their employees.
Luckily, software development is a field where you can get a lot of valuable experience without even
having a job. And there are things you can do to improve your resume, grow your network, build
your skills, and interview at better companies, all without a heavy time investment.
Side projects
Coding in your spare time may not be appealing or even possible for everyone, but it’s an effective
way to add qualifications to your resume. Even a small project put together over the weekend can
add value to your portfolio. There are a few different sites where you can upload your projects for
free. The most popular⁵¹ is GitHub⁵², with over 100 million projects hosted, but BitBucket and GitLab
are also popular choices.
A side project can fulfill many purposes. It can help you learn a framework or tool that’s trending
in the market, explore a technique you want to apply at work, exercise your creativity, prototype a
product you want to start your own company with, and/or demonstrate your technical skills. And
because you’re building it for yourself, you may find that it’s far less frustrating than coding at your
day job. In fact, if my job is growing too tedious, I sometimes use a side project to remind myself
why I love code. Taking time to create without limits or rules is always refreshing.
Potential employers who review your projects will be looking for a few different things:
• Well-organized folders and files. Most programming languages and frameworks have conven-
tions for how things are organized. If your chosen technology doesn’t, use a consistent structure
that makes everything easy to find. Most files should be relatively small (a few hundred lines
or less).
• Consistent code style. It doesn’t matter what styles you choose (tabs or spaces, line lengths,
brackets on their own line), as long as you stick to them.
• Unit tests. Writing tests shows that you care about code quality and maintainability.
⁵¹https://en.wikipedia.org/wiki/Comparison_of_source-code-hosting_facilities#Popularity
⁵²https://github.com/
Getting your first job
77
• Documentation. The ability to describe and explain your code makes you a better teammate.
You should at least have a “Readme” file explaining how to set up the project and run the tests.
If you have trouble coming up with project ideas, start with something simple: a tic-tac-toe game,
an “About Me” web page, a metric unit converter.
Revising your resume
When you’re working on your resume, consider the following guidelines:
• Use standard, professional typefaces like Helvetica or Times New Roman. Don’t use more than
two.
• Use a professional-looking email address. Employers will think twice about interviewing you
if your email address is “doomslayer420@onlinedating.com”.
• Put the most impressive stuff at the top of your resume and the least impressive stuff at the
bottom. If that means your education and job experience are on page 2, that’s okay. Don’t let
fluff like a “personal statement” or “career goal” take the top spot unless it’s expected in the
industry or culture you’re applying in.
• Don’t overcomplicate. Unless you’re a visual designer, you should avoid using images,
illustrations, or multiple colors.
• People scan down the left side of the page when they’re in a hurry, so left-align everything and
put main points like categories, job titles, and project names in bold or capital letters.
• Be consistent. Make sure you’re using the same typeface, font size, emphasis, bullets, alignment
and spacing throughout your resume for headers and text at every level.
• Mention specific technologies, programming languages, and projects you’ve worked with.
Hiring managers love specifics.
• Hiring managers also love numbers. Quantify your work wherever you can. Even if your last
job was shift manager at a fast food place, you can say something like “Responsible for $2
million per year of physical product, serving over 180,000 customers.”
• Resumes aren’t only for job history. Include everything you’ve done that’s relevant to your
career. If you have a blog or GitHub profile, you’ve presented at a meetup or contributed to
open source projects, you were president of a coding club in high school, or you were top of
your class at development bootcamp, it belongs on your resume!
• Always provide your resume as a PDF.
• Don’t call your resume “Resume.pdf”. It will get lost too easily. Instead, use your name, job
title, and (optionally) the date of the most recent revision: “Isaac Lyman - Software Engineer -
Mar 2019.pdf”.
• If English isn’t your first language, ask a native speaker to review your resume and help you
with spelling and grammar. This can make a big difference in the number of interviews you
get.
Getting your first job
78
A resume doesn’t have to be complicated. Here’s mine (slightly anonymized):
Meetups, events and channels
The best way to meet other developers and find out about jobs that aren’t posted online is to go to
meetups and events. Meetups are easily found in most cities, and often associated with a specific
technology or product (for example, you can Google “Vue meetup” or “Adobe user group”). If you go
to a small meetup, you may be asked to introduce yourself, which is a great opportunity to mention
that you’re looking for work. By the time the meetup is over you should have a couple of new leads.
Larger meetups don’t usually do this, but you can still meet a lot of local developers and find new
opportunities if you attend.
Tech companies sometimes host events for developers to socialize and learn about their products,
so this can also be a good way to expand your job search. You can find out about these events by
following those companies and their employees on social media. (Programmers in particular have
a strong presence on Twitter.) Tech conferences can be good events for networking as well, but are
usually expensive (they assume your company is paying for the ticket).
It’s also pretty common for a city—or, in the case of Utah, an entire state—to have a Slack workspace
or other chat room for software developers. If you join, you can find out about open job opportunities
by searching the archives or asking around. If you belong to a minority group, you can find a relevant
Getting your first job
79
Slack channel (like latinos.slack.com⁵³ for Latinx people in tech, blacksintechnology.slack.com⁵⁴ for
black people, or womenintechto.com⁵⁵ for people who identify as women, genderqueer or non-
binary).
Learning about roles from other developers is ideal. They’ll usually tell you more about a company’s
work environment, benefits, and pay than you’d learn from an online posting or a recruiter.
Mentors
A strong connection to someone with a lot of industry experience can be game-changing. If you
don’t have a mentor, set a goal now to find one. “Professional generosity” is one of the unwritten
core values of the programming world, so if you reach out to a few developers you’ll likely find at
least one who’s willing to answer questions, introduce you to recruiters, and give you career advice.
(Others may be too busy or just not interested—don’t let that discourage you.)
In your search for a mentor and in your career in general, social media can be invaluable. If you
don’t have an account on Twitter or LinkedIn, setting one up is a great next step. An account on
dev.to⁵⁶ will also help you meet and learn from other programmers.
The best way to begin a mentoring relationship is to choose a programmer you know or admire,
introduce yourself if they don’t know you, and ask them a specific knowledge-based question, like
“how did you find your first job?” or “can you help me understand how to search an array?” If they
don’t respond, you can follow up later, but don’t be offended if they never get back to you (some
programmers get hundreds of requests like this). If they do respond and the interaction goes well,
you can ask another question or even ask for help with something bigger, like “can you help me
practice for my next interview?” or “can you introduce me to someone in your area who’s hiring?”
Be patient and let the relationship grow. If you are polite and thank them for their time, you could
end up with a connection that will transform your whole career.
Keep in mind that your mentor is just another developer and they don’t know everything. They
won’t be able to solve all your problems or tell you exactly what to do. But their encouragement and
advice can still make a big difference.
Interviewing
Interviewing is a skill that most people have to learn the hard way. The best way to get better at it
is to practice; apply for a variety of jobs, even jobs you don’t feel qualified for.
Companies vary widely by the way they vet candidates. Be prepared for multiple types of interviews:
• An unstructured interview is one of the most popular but least effective forms of screening.
Any interview where the questions aren’t chosen in advance is unstructured. These often
⁵³http://latinos.slack.com/
⁵⁴http://blacksintechnology.slack.com/
⁵⁵http://womenintechto.com/
⁵⁶https://dev.to
Getting your first job
80
include questions about your work experience, hobbies, problem-solving approach, and career
goals. I recently read a story about a CEO who hired someone on the spot after a brief, casual
conversation, claiming that he could tell more about a person from five minutes face-to-face
than from any amount of structured interviewing. This CEO was wrong. Multiple⁵⁷ studies⁵⁸
have⁵⁹ found⁶⁰ that selecting candidates using unstructured interviews is worse than choosing
them at random.
• A take-home project is a technical assignment candidates are expected to complete on their
own time, like creating a simple website or adding features to an example app. This usually
takes four to five hours. Be aware that some companies use this as a dishonest way to get free
work; if you’re being asked to spend an unreasonable amount of time, or to do work that an
employee would do, ask them to pay you for your time.
• A verbal technical interview is a structured interview including several questions about
programming languages, technologies, software architecture, and problem-solving. Many
companies make the mistake of asking questions that could easily be Googled on the job. You
can prepare for these using a Google query such as “JavaScript interview questions”.
• A whiteboard interview involves asking candidates to write code on a whiteboard without
consulting reference books or the internet. Whiteboarding is quickly falling out of style because
writing code on a board and writing code on the job are very different skills. If you are asked
to whiteboard, focus more on finding a solution than writing perfect code. Even pseudocode
(see Appendix A) is usually fine.
• A live coding interview is an interview where candidates are asked to write code while the
interviewer watches, either in person or on a screen-sharing call. Being watched while you
code can be nerve-wracking, but it’s also something you can easily practice with a friend.
• A short-term contract is like a “trial period” for employment. Candidates sign a limited contract
(usually for less than a month) during which they work like a regular employee and are paid by
the hour. When the contract is complete, the candidate may be hired as a full-time employee.
In every contact with a company, remember that it’s not about why you need them—it’s about why
they need you. Figure out what kinds of problems you’re good at solving, then communicate that to
them clearly and confidently.
Be sure not to let your interviews be one-sided. Take the opportunity to ask serious questions about
the company. Some of my favorite things to ask in an interview are:
• “What keeps you at this company when there are so many other opportunities for a software
developer like yourself?”
• “How much overtime have you worked in the last year?”
• “How hard is it to buy an educational book on company money?”
⁵⁷http://journal.sjdm.org/12/121130a/jdm121130a.pdf
⁵⁸https://blogg.hrsverige.nu/wp-content/uploads/2010/04/Stubborn1.pdf
⁵⁹https://www.nytimes.com/2017/04/08/opinion/sunday/the-utter-uselessness-of-job-interviews.html
⁶⁰https://hbr.org/2016/04/how-to-take-the-bias-out-of-interviews
Getting your first job
81
Depending on the culture and circumstances where you live, you may also want to ask about
company ethics, paid time off, parental leave, retirement savings plans, tuition reimbursement, or
anything else that’s important to you (for a longer list of values that might fit the bill, check out
keyvalues.com⁶¹). This is stuff you don’t want to be surprised by later on.
Keep in mind that some interview questions are illegal in many parts of the world. For example, in
the United States, an interviewer cannot ask certain questions⁶² about your marital or family status,
sexual identity, disabilities, or religion, among other things.
It’s worth checking the company’s reviews on Glassdoor before the interview to look for red flags—
every company will have a few negative reviews by former employees who had a bad experience
or got fired, but if a lot of reviews talk about similar issues, that may be something to keep in mind
or even ask about in your interview.
Negotiating
Getting your first job offer is exciting, but the process isn’t over yet. Negotiation is an important
opportunity to learn more about your value, the company’s benefits, and what’s important to them.
There are five basic rules of negotiation:
1. Always negotiate. Every offer is negotiable, but most candidates are too nervous to stand up
for themselves. Even if negotiating makes you anxious (like it does for me), the value is hard
to ignore—an hour or so of negotiation can get you tens of thousands of dollars more. Some
unfunded companies and nonprofits aren’t willing to budge on salary; all the same, bringing
it up will give you leverage to ask for other things you care about, like flexible hours, remote
work options, vacation time, sick leave, parental leave, or stock options. And almost nobody
will fault you for asking, even if they have to say no.
2. Don’t tell them how much you currently make. This makes it too easy for them to offer you
just a little bit more, instead of what they really think you’re worth. If they ask, say “out of
respect to my current employer and their policies, I can’t share that information.” Some places
(like California, USA) even have laws prohibiting employers from asking.
3. Take your time. Don’t let anyone rush you. If you start running out of steam in a negotiation,
or just aren’t getting the offer you want, say “that’s a generous offer and I appreciate it, but
I’m sure you understand this is a big decision and I need some time to think it over. I really
hope we can figure out an offer that makes sense to both of us.”
4. If they give you a salary number, say “that offer is interesting; can you do better?” (borrowed
from Patrick McKenzie⁶³). Really, that’s all you have to say. Then quietly wait for them to
respond. Count to 100 in your head if the silence grows uncomfortable.
5. If they ask you for a salary number, tell them the highest number you can say without laughing
(borrowed from Cindy Gallop⁶⁴). They may not meet that number, but they’ll probably offer
⁶¹https://www.keyvalues.com/
⁶²https://www.betterteam.com/illegal-interview-questions
⁶³https://twitter.com/patio11/status/1046569259743100928
⁶⁴https://www.bustle.com/articles/129373-how-to-get-a-raise-no-matter-what-according-to-businesswoman-cindy-gallop
Getting your first job
82
you more than they would have otherwise—whether it be in salary, job title, flexibility, or other
benefits. It helps if you’ve done some research already so you know what’s reasonable for your
job title and where you live—but whatever the salary range is, aim for the high end.
Negotiation is an uncomfortable and sometimes long process, but it can teach you a lot about the
company you’re applying to work with. And it can put you years ahead on salary increases and
career progression.
Growing and succeeding
It may take you a while to get your first job offer, and that’s okay. It doesn’t mean you’re a bad
candidate. It doesn’t mean you’re in the wrong profession. Keep trying, keep interviewing, keep
building your network. Good opportunities are out there.
My first job
Muhammad Arslan Aslam
My first job was at a small tech firm as a Junior Front End Developer. The salary was low, but I was
desperately needy and eager to get into the industry, learn, and work. I didn’t care about anything
in the contract. They asked me when I could join, and I went straight to the office the very next day.
I learned a lot there about many things. Design. User experience. Development. WordPress. It was
a good journey for a couple of months until they started asking me to stay late. I knew that on rare
occasions, if a project was past the deadline or close to it, putting in some extra hours to complete
it wasn’t gonna hurt. But an extra 5-6 unpaid hours per day? That was a lot to ask for, considering
I wasn’t even getting paid as much as the average intern.
I left the company after one year and they never paid me my last month’s salary.
A month later I got another job offer. This time I asked about company policies regarding overtime,
medical expenses, staying late, etc.
It worked very well for a few months but then it was the same story all over again. The manager
would force me to stay late and would even say he wasn’t going to let me leave until I was finished.
I’d get late night calls to get up and do something because the person who was responsible for it
wasn’t picking up the call. I would work from midnight until 8AM and couldn’t be late for work
afterward.
I actually blogged about it when I was getting frustrated with the situation and got a lot of feedback
from the community, including senior developers, which helped me a lot. Right after I published
that post and heard people’s advice, I decided to quit the job. I stood up for myself and told my
manager that putting in so many extra hours was affecting my personal life and I had started to get
depressed.
It felt like a prison (not that I’ve been to prison, but still). You know how you can sit in your room
watching Netflix all day and it doesn’t bother you, but if someone orders you to sit in your room
and watch Netflix all day, it becomes an awful chore.
I was worried at first about leaving the job. I was getting good money and the medical insurance
was a good thing (more or less) but I gained the courage to leave the job and move on.
There are a lot of things that happened as a beginner that I feel a little ashamed to share. I should’ve
stood up for myself right then but I didn’t. I thought I might not get another job. But fortunately for
me, everything worked out.
I have a stable job now which pays me well. The hours are flexible and the work environment
is great. Learning opportunities are abundant plus I get to work with people who are much more
experienced than I am and everyone here is eager to teach.
My first job
84
To summarize a few things that I learned from all of these experiences:
• When signing a contract at your first job (or any job as matter of fact), read it carefully. Ask
about the company’s policies regarding different aspects of normal everyday work. The ideal
would be if you could get some legal advice on it. If that’s not possible, just ask someone who
has been through the same process, a friend or family member. Be careful about what you sign.
• Stand up for yourself when there’s an issue. If you “let it pass this one time,” it’s gonna stick
forever. I ignored my boss being abusive once and he continued being abusive for the rest of
my time there. Don’t let that happen to you.
• In the tech industry, occasionally putting in extra hours to meet deadlines isn’t necessarily a
big deal. People do it a lot, some times more than others. But make sure it’s not because of
someone’s ego. I was asked to stay late because my boss “just felt like it”. That’s over the line.
Never settle for this kind of behavior.
• Know your rights. Workplace toxicity can affect your personal life and mental health. Unfor-
tunately, in many Asian countries, management doesn’t pay much attention to this serious
issue. If you’re not feeling well, you can’t work properly. Workplace toxicity comes in many
different forms. If you feel like you are suffering harassment from a co-worker, a manager or
anyone else, contact the people in charge. If they don’t do anything about it, reach out to other
organizations or the authorities. Someone else at your company might be facing the same issue.
Stand up for yourself and others too.
• Last but not least, know your worth, and never settle for less.
I got my dream job. Now what?
Desi Rottman
When I started my first job in tech, it was as a support team member at a website builder geared
toward musicians. My background made me ideal: years of retail and entertainment-industry
customer service, HTML and CSS experience with an interest in web design, a music business degree,
and the vocabulary to communicate with low-level tech users. I was pumped—a dream job that
felt created just for me. I’d never considered that there was a company out there that married my
disparate passions, let alone that I could land a job there.
In that position, I was doing a lot of intense troubleshooting for both clients and co-workers while
getting comfortable with how the tech industry works and how companies are structured. It was a
company with a QA department of one, and though I fell in love with troubleshooting and breaking
things, we already had a great employee in that position. I didn’t see myself having the opportunity
to transition over. A small, awesome company means low turnover, so I didn’t really give much
thought to if there would be additional positions on the QA team to transition to eventually. But
when our new CEO did some restructuring, she promoted the old QA guy to Project Manager, and
behold—I had the opportunity to train for my (new) dream job!
Over the course of a career, your dream job can change and shift—and that’s a good thing. As you
work you’ll learn more about the industry you’re in and see more facets of it, discovering positions
you never knew existed. In tech and dev, things are always changing. There’s always something
new to learn or a new startup being founded. That’s another reason you might have to continually
revisit and redefine your “dream job”: new positions and new fields are often being created, so your
eventual dream job might not even exist today, though your dream company might.
Advancing in your career also opens more opportunities—and once you start to stagnate, even the
perfect job can stop feeling perfect. That’s a good thing, but it can feel confusing to know how
to keep growing and keep going. After all, wasn’t this your ideal position? When this happens in
technology, we have a unique opportunity to shape and design our dream jobs.
Even if you’re not in a place to consider a transition right now, it’s beneficial to look around and
see what types of positions are open from time to time. Being aware of what else is out there and
interests you is important to keep in mind. Being able to clearly recognize the next great fit when
you see it can help stave off self-doubt, while staying prepared to apply when opportunities arise
can combat impostor syndrome.
What else is out there?
A great way to start considering what your new “dream job” might be is to review open positions
even before you’re ready to leave your company or position. Not only does this give you an idea of
I got my dream job. Now what?
86
what new skills or education you can focus on, it can also put new jobs, industries or technologies
on your radar. Specialties like Developer Relations and industries like the Internet of Things might
not have even been on the map when you started your tech career. As these categories get more
popular and more positions are being created, keeping abreast of what companies are looking for
lets you tailor your experience to a new, growing industry.
Case Study: Accessibility Expert
The web has long been developed with mainly able-bodied users in mind. In recent years,
accessible development and design have become hot topics and very important for many
companies, but as a relatively new priority, many experienced developers weren’t focused
on it in the past. Lindsey Kopacz of Acquia Professional Services is an Accessibility Expert,
and she also teaches others how to make their products more accessible.
Feeling unsure of where to start looking for other things that would interest you? Take a look around
at your co-workers. Is your project manager always asking the other dev team members interesting
questions about their projects? Is the support team consistently bringing up the same pain point
about accessibility? If those kinds of things interest you, keep your eye on them. See if there’s an
issue you can help the support team fix, or a project you can shadow the PM on. Not only will that
open your eyes to another facet of your company’s work, it could be something to add to your new
dream job resume.
Case Study: UX Engineering
UX Engineering is a relatively new position that many companies are hiring for. It
blends principles of UX/UI design with front-end development, and can really appeal to
developers who have a bent toward user experience. Emma Wedekind of LogMeIn blends
her past experience in engineering at IBM with her interest in design (which she exhibits
in her open source project, Coding Coach) to build accessible design systems and user
interfaces.
How to start preparing
Starting where you are is a good place to prepare. Look at your current company again, and take a
look at what your co-workers’ backgrounds are. See if anyone in an interesting position is willing
to meet with you for coffee, or even an informational interview. Connecting with someone who is
already doing what might be your next dream job will help you learn the real nitty-gritty of their
position. It’s also likely to help your confidence—it’s a fairly low-stakes networking opportunity
with someone you already share some commonalities with, and that can end up being a boost when
you do start going to interviews again.
Social media sites, particularly places like Twitter and StackOverflow, are also excellent places to
learn about emerging tech, connect with others in the space, and even find open positions. The same
principle applies here—if you see someone doing work that interests you, try to send them a DM
and ask some questions about what they do and how they got there.
I got my dream job. Now what?
87
Keep your resume and portfolio up to date as you continue to learn and grow your skills, putting
most of the focus on the tasks you hope to primarily work on in your next dream job. You’ll thank
yourself for this later when you don’t have to try to throw something together at the last minute
when the dream job gets posted.
As you continue to build your skills and learn more about technologies or areas you’re drawn to,
taking on a side project or signing up for a class to further your knowledge in that specialty will also
help you get that much closer to the new dream job. If you’re not sure what new skills to build, start
looking at job descriptions for other positions that interest you. You’ll get an idea of what employers
are looking for in hires for that position, and you’ll have some great experience and project examples
to add to your portfolio!
Case Study: User Experience Advocate
I always knew that advocating for users and keeping our product looking and working
well, while providing them the features they’re looking for, was where my passion was.
What I didn’t realize was that this is an actual position that many companies are looking
for! By doing research into what other types of opportunities are out there, it’s allowing
me to tailor my skills and experience so that when I am ready to leave (or get promoted),
I’ll be confident and ready.
More things to consider
As you start to think about what kind of work you might be interested in next, you’ll likely start
noticing some trends in the job postings. When you see another description that makes your heart
soar, take a look at a few things:
• Job Title: Job titles may not say much about the actual position duties, especially in tech—
“Rockstar Ninja” or “Smile Engineer” doesn’t say very much about the day-to-day. Focus on
the responsibilities listed rather than the hip titles.
• Education Requirements: Do they require a computer science degree, or a master’s degree? Do
they consider experience as an equivalent? If they do have a hard requirement for a degree,
and it’s not one you already have, consider if you’re willing to get that degree or endorsement.
(And if they aren’t interested in applicants with diverse experience and education, that may
be a red flag in itself.) Get in touch with someone who is already in that position and see if
that’s truly required for the kind of work you want, or if they use it as a screening funnel for
applicants. Furthering education is understood as a requirement for advancement these days,
and this can help you know where to focus to be ready for the next position.
Maybe the next move in your ideal career is less about the kind of work you’re doing, and more
about where you’re doing it. It’s becoming more and more common for “employment goals” to refer
to a company rather than a specific position, and that could be something else to consider if you’re
looking to move on from that first dream job.
I got my dream job. Now what?
88
• Lifestyle: Another big consideration in sussing out your next dream job is the intangible quality-
of-life factor. Maybe you’ve enjoyed being a full stack developer, but you’re feeling maxed out
on your career growth and want to make a transition to system administration. Is it worth
making a nice six-figure salary if you’re required to be on-call 24/7 to fix any issues? Are you
willing to sacrifice a big-city salary in order to have a remote position? These are more ethereal
issues that aren’t going to be nicely laid out in a job posting, so being prepared to know what
you will or won’t accept from a company can well prepare you.
One last (but no less important) facet to consider here is the culture of a prospective new company.
Similar to the lifestyle you’ll have, think about what’s important to you at work—a kitted-out game
room with arcade games and ping pong tables, with weekly happy hours in the break room, but
the understanding that you work closer to 50 hours a week? Or would you rather have less fancy
“perks,” but more flexibility and freedom? Do the employees seem to relish being there beyond
9-5 hours? In an effort to promote diversity and reduce harassment or abuse, codes of conduct are
growing in popularity. Does this company have one that reinforces the culture you want to associate
with? Another common “perk” for companies is providing philanthropic opportunities—paid days
off for volunteering, or matching employee donations to nonprofits. If possible, try connecting with
someone at the company you’re interested in to get some of your questions about these things
answered.
Does that company culture align with your values? If not, maybe it’s not actually your dream
company. If the company’s ethics don’t align with your own, you might not be taking pride in
your work, which can take a toll mentally.
Keeping these things in mind is important for any job change in your career, but it can also help you
really develop your dream job description.
Exercise
To start evaluating your next move, even if it feels far off, try to take a look every week or two at
open positions at your dream company. If you see one that particularly interests you, save it to your
computer. Highlight or circle aspects of the job that interest you, and you can update your resume
or portfolio using the same wording.
This also helps you to know what parts of the job you wouldn’t be interested in—your “dream job”
likely has parts that feel very dry to you, and that’s important to keep in mind as you continue
searching as well.
Keeping up to date and being educated on other current openings and industry growth will make
you confident that you’ll know when your new dream job pops up, and be ready to land it!
Burnout, part 1
James Turner
Editor’s Note: Burnout is so pervasive and harmful in tech that I’ve chosen to include two perspectives
on it. Programmers burn out for a lot of different reasons and you will either witness it or experience
it yourself at some point. When that happens, take some advice from these authors and make a
change.
You may have heard the phrase “burnout” before. I can assure you that in this context it has nothing
to do with cars laying down rubber.
Occupational burnout is a feeling of exhaustion, where what you previously enjoyed working on
becomes less enjoyable, where things get on your nerves more easily or even where you have feelings
of depression. One of the first uses of the phrase dates back as far back as 1974 when psychologist
Herbert Freudenberger used the term in one of his published works.
At the end of 2014, I had the opportunity to take on more responsibilities where I worked, being
promoted from a Web Developer to an Account Manager. While I was still programming, my new
responsibilities included liaising with clients, discussing business requirements as well as managing
current and upcoming projects. It was a great experience and I am grateful to have had that
opportunity, but it wasn’t without its problems.
I may not have been the “cool” or “fun” person in the office, but I’d say I was the “brains trust”—there
wasn’t a problem I wouldn’t try to help solve and most of the time I was successful. I may not have
even known anything about the topic beforehand but if someone asked me a question, I would as
quickly as possible research the topic to work out the answer. This eagerness to help my colleagues,
while an admirable trait, was one part of my problem. It took time to be thorough and I didn’t want
my colleagues to struggle on something that I could help them with.
I didn’t just want to avoid disappointing my colleagues, I didn’t want to disappoint my boss—I had
been given this great opportunity and trusted to do it well. I am a good programmer, and one day I’d
like to think I’ll be a good boss, but some of the traits that make me a good developer didn’t transfer
as well to this role as I hoped. Larger projects were coming in on top of the business-as-usual work
which led to work piling up. I was in meetings every other day, constantly liaising with clients and
managing projects while also still programming. Rather than tell anyone that I was struggling, I
decided I’d just work a few extra hours that week to make sure everything was done. Those few
extra hours in a week turned into a few extra hours each day till it even got as bad as working an
additional day on top of those extra hours.
While no one asked me to do those extra hours and I didn’t even want to do them, I still did them
because I believed it was just a short-term thing that would blow over soon. I was tired, I was
stressed, and every morning I didn’t even want to go to work yet the problems that led me here
were so simple.
Burnout, part 1
90
In mid-2015 the stress peaked and my colleagues were starting to take notice. Two of my colleagues
took me out to lunch to see how I was doing. They asked me if I was okay, knowing something was
going on, and I said no, I wanted to quit. I talked through what was happening with them, they
understood the issues and were sympathetic. They gave suggestions on how to make my workload
easier, helping me with anything I needed. Over the next few months, things were a little easier and
I stopped pushing myself as hard to please everyone.
It took just over 6 months to go from an employee happy to come to work to one who dreaded it
because I couldn’t stand the thought of disappointing others. It took a single lunch out for me to
admit how far I had gone and start the journey back to a happier me.
Identifying burnout from the point of view of the person experiencing it is hard—how do you know
if the stress you’re feeling about a situation is burnout or not? Burnout, however, isn’t black and
white; it is many shades of grey. Burnout may reach a tipping point but that is not a useful measure
to help prevent burnout in the future. With how the feelings of burnout can gradually build up, you
need to look at your own long-term trends in your life. From your mood, to sleep patterns, to diet,
to participation in social gatherings—these can all help indicate whether something is changing in
your life.
One of the more obvious indicators for me should have been realising that I didn’t want to go to
work when I woke up in the morning. While this feeling might happen for a lot of different reasons,
it is an indication that something is up in your life and it is best to evaluate what that might be.
Determining the cause for such feelings is incredibly important in trying to address them. When
trying to identify the cause, it is best to keep an open-minded approach as it really can be from
things you didn’t even realise. The causes that lead to burnout don’t even need to be exclusive to
your job, they can be events in your personal life or social circles.
The causes leading to my burnout came from my actions at my job, not from my personal life and
not from expectations by my colleagues or boss. I chose to accept the opportunity to take on more
responsibilities and I chose to work extra hard to make sure I would succeed. This may seem like I
am trying to carry the burden for the situation, but I don’t blame myself for burning out. Instead, I
take responsibility for the fact that my own actions allowed stress to build up.
Although I can say that about my situation, it doesn’t necessarily mean that your feelings of burnout
are caused by you. You may not be remotely the cause of the feelings; you are only responsible for
how you handle those feelings and what you are going to do about them.
The most appropriate action for handling burnout will vary widely depending on the cause. With
that being said, the one thing you can always do to help your state of mind is to talk to someone
about the situation. It may be best that this person is not involved in what you believe are the causes,
but the key here is that you are talking about it at all. The reason I see this being effective is the
same reason Rubber Duck Debugging (see Appendix A, “Rubber Ducking”) is effective: when you
talk through a problem aloud it can help you have a deeper understanding of it, leading to ways to
resolve it.
When you are on the path to resolving your feelings of burnout, I think it is important to consider
what you want your future self to be. Of course you want to be happy and healthy but is it at the
Burnout, part 1
91
same job? Are you wanting to stay in this industry? Do you see yourself living in the same location
or having the same friends? These questions might seem dramatic, but dramatic changes might be
what you need. The decisions you make here are wholly your own and it is important to weigh
everything in perspective to your own life.
If your causes are primarily job-related, it might be enough to try and move to a different team or
department. For situations where you see no resolution at your workplace, speaking with your feet
and finding a different job is the most powerful action. If your causes are primarily social life related,
work out what specific things you could do to have a positive impact. Maybe at the end of the day,
you may only need a break to do something else—only you will know if that is what is best for you.
When you have resolved your current feelings of burnout, it is important to stay vigilant as they
can always creep back. Look after yourself; you only live once.
What if you’re not the person experiencing burnout, but you want to make sure anyone you know
or work with isn’t having issues? While you can potentially identify it through a decrease in work
performance or long-term changes in mood, it can be as simple as asking if they are okay. I wouldn’t
recommend doing it over a Slack message or in front of a group of people but if you can have a one-
on-one conversation with them, don’t hesitate to ask. Asking someone that question may be exactly
what they are needing to hear, genuine support from a friend or colleague so they can evaluate
themselves and their situation.
At the end of the day, while burnout can be a serious topic, it isn’t an impossible problem to resolve
and isn’t something you need to handle alone.
Burnout, part 2
John Woodruff
Burnout: a hazard that the software industry is particularly prone to, and one that occurs far more
often than it should. Over the course of your career you’ll hear the stories of your co-worker’s friend
who burned out so badly they ended up changing careers. Perhaps it is closer to home and happens
to someone you personally know. We all tell ourselves that it won’t happen to us, that we love
programming far too much to burn out, so we don’t take the necessary steps to avoid it. But burnout
is a very real threat, and it will happen to some extent to many of us. I didn’t believe it could affect
me, yet I have dealt with episodes of burnout throughout my career. By understanding burnout, its
symptoms and causes, we can take concrete steps to avoid it altogether and to come back from being
burned out.
Burnout is a slow process. You don’t just wake up one day and suddenly you’re burned out. For me
it was a state that set in gradually, with the symptoms becoming worse over time. At the beginning,
they may be insignificant enough that you barely notice anything is amiss, which makes it difficult
to determine that you’re on the path to burning out. There are a variety of symptoms that may
manifest themselves. Please note that this is by no means an exhaustive list, these are simply some
of the most common issues related to burnout.
You may feel anxiety, often about your job, usually carrying over into your personal life. It’s also
common to experience depression, especially if you are already prone to it, but someone who has
never felt depressed before can experience it as a symptom of burnout. One of the most common
symptoms is a lack of attention span and motivation at your place of work. It becomes very difficult
to focus on tasks, in meetings, and during general workplace activities. You may feel constantly
exhausted, both at work and at home, whether or not you’ve gotten enough sleep. It can affect your
sleep too, possibly manifesting itself in new or worsening insomnia. You may find yourself becoming
more irritable or pessimistic in your interactions with friends and co-workers. You could experience
guilt for not feeling like you used to in your job, or like you perceive your co-workers feel.
All of this and more leads to the most common symptom: poor job performance. You are no longer
motivated to do your work. Tasks that once would have seemed small to you suddenly appear
enormous or insurmountable. You may find yourself coming in late, taking extra long breaks, or
leaving early because you feel like you can’t handle it. You aren’t paying attention or participating
in meetings where your input is wanted or required, which affects everyone involved. Unchecked
burnout can even lead to the need to stop programming altogether and change careers. Sadly, it’s
happened to many people before and it will continue to happen unless we as developers take the
proper steps to recover from and avoid burnout.
To understand how to avoid burnout, we need to first understand the common causes. There are
many reasons and ways one might get burned out. The most common ways are usually directly
Burnout, part 2
93
related to long term stress without relief. This could include any number of scenarios, including
working long hours for too long without a vacation; constantly working on projects that have
unrealistic deadlines set by others without your input; being stuck on project maintenance while
you watch other developers working with cool new tools and technologies; having an unhealthy
work-life balance that is skewed too far towards work; or working in a dysfunctional environment
that makes you feel unsafe. All of these contribute directly to your level of burnout.
I’ve experienced many of those scenarios, and unless you’re exceptionally lucky, you will too
throughout your career. My most recent episode of burnout was due to being on a project for two
years with no end in sight—a project I desperately wanted to succeed, but which seemingly had
everything thrown in its way to stop it from doing so. The stresses of that environment grew and
grew until I found myself dreading going to work. I couldn’t fall asleep at night for hours thinking
about this project. I no longer wanted to work on the previously enjoyable side projects I’d had
going on. In addition to that, the project was frequently put on hold for another project that had an
extremely short deadline imposed by others that I had no control over. So instead of finishing the
new project and being relieved to go back to my old project, it was simply more stress. It was a very
difficult time in my career.
The above situation boils down to several basic feelings you might relate to. You feel stuck or trapped
with no end in sight. You are dealing with impossible goals which makes you more depressed each
time you miss them. You’ve overworked yourself. When the mind has endured high levels of stress for
too long, it becomes exhausted and craves relief. This exhaustion is central to many of the symptoms
I listed previously, such as anxiety, depression, and lack of focus. If you let any of this get too far
without intervention, you risk burning yourself completely out of your career.
With all that in mind, let’s talk about avoiding burnout. If you’re currently suffering from burnout,
these principles apply to recovering from burnout as much as to avoiding it. In short, it’s about
taking control of your professional (and personal) life, which will help you to be a well-balanced
individual. Having proper balance in our lives leads to better mental and physical health, improved
mood and happiness, and increased productivity, whether that be at work or in other pursuits.
The first thing you need to do is make sure you set proper boundaries. You’re in a form of a
relationship with your work and employer, and as with any other type of relationship, good
boundaries exist to keep the relationship healthy and happy. While looking for a job, you should
know the limits of what you’re able and willing to do for the company. An employer may have the
expectation that you work 12 hour days, 6 days a week (rather than a standard 40 hour week) to
further the goals of the company. They may think you should forego using your vacation time to put
in more hours at work. While there may be people who are okay with that kind of an environment,
I see it as a form of abusive relationship between employer and employee. With the companies I’ve
worked for thus far, I’ve been very careful to research their culture and determine whether I would
be required to do things that are unreasonable and go past my established boundaries. This is not
to say, of course, that I refuse to work a minute past 40 hours. There have been many occasions
where I’ve worked long hours to meet a deadline, fix an issue, or help mentor someone else. In these
situations, however, I was usually able to recover adequately by (for example) taking a day off the
next week.
Burnout, part 2
94
The ability to take time off is key to avoiding burnout. Time off, even if that’s simply making sure
you don’t work on the weekend, is time our mind needs to be able to recover from the stresses of
the workplace. By working constantly with little to no breaks, that mental stress continues to build
without relief, slowly burning you out. It’s a common false belief that by working that much, you’ll
become a better programmer. I held that belief at the beginning of my career and have since changed
my attitude. In the long run, becoming burned out will severely harm, if not destroy, your ability
to work effectively. Taking a vacation where you completely disconnect from work (and coding in
particular) can be incredibly therapeutic for programmers who may be slowly burning out. Even
doing this during the weekends can help stave off the struggles that are associated with burnout,
so make sure to take the time for yourself to unplug and rejuvenate. Also take advantage of your
employer-provided vacation days; they’re given specifically as a benefit for you to use to recharge.
There are many other small things I recommend for helping to keep your work-life balance in check.
Engaging in non-work related hobbies and activities, for example, is a great way to keep your
personal life separate from your work life. Keeping your body healthy through regular exercise
is also important and helps keep your mind stimulated. Perhaps the most helpful thing to do is to be
consistent. Inconsistency causes stress, and if there’s anything we’ve learned thus far, it’s to reduce
the amount of stress we feel on a regular basis.
Occasionally more drastic measures are necessary. While most of my small burnout episodes were
solved by taking a couple days or a week off from work and totally disconnecting to rejuvenate,
the most recent episode I talked about required a different approach when my standard methods
had failed. It wasn’t so bad that I quit coding, but it was bad enough that I was no longer in an
environment conducive to a good career. I needed to find a new job and get out of that situation so I
could bring myself back. I’m very happy to report that at the time of writing I’m happily employed
at a new company working on a product that is much more stable and healthy than what I was on
previously. I also am part of an excellent team that highly values work-life balance and shows it
by example. I’ve never been happier in my career than I am right now, mere months after dreading
going in to work.
Burnout is a difficult trial to overcome, but if I can tell you anything, it’s that it can be recovered
from successfully. I can say that from experience, having felt varying levels of burnout at various
times throughout my career. Even better than recovering from burnout is avoiding it entirely,
something I’ve re-committed myself to more fully in recent months. By putting into practice the
recommendations mentioned above and taking control of our professional lives, we can make real
strides towards keeping our personal and work life in balance, and keeping burnout at bay.
Do I fit in?
Editor’s Note: Following are some true stories and advice from developers who have wondered if tech
is the right place for them. If you’ve had the same doubts, I hope their words will encourage you.
Sabrina’s story
Sabrina Gannon
Despite coming from what’s generally considered a traditional computer science background, “Do I
fit in?” is a question I’ve had to tackle many times in my programming career. The first time I asked
myself this question was when I was applying to university for Computer Science, because math
was the subject I performed lowest in and English was my highest. The most exposure I had to code
came in the form of customizing my Neopets HTML pages; it was just enough to make me curious
enough to take the leap and apply anyway.
I thought a University degree would give me a feeling of legitimacy that would put the nagging
question “Do I fit in?” to a stop. Instead, the work I did at a very research-focused University,
alongside many classmates who had far more coding experience than I did, exacerbated the feeling
to the point that I doubted I would even finish my degree, let alone have a sunny employment
outlook.
My first technical full-time role came in the form of an internship the summer after I’d finished
my degree; this was the next level of questioning my own sense of belonging and identity. I had
moved out of my family’s home and across the country, and I was surrounded by smart people and
learning about web development, a development specialization I had little to no experience in. It was
a whirlwind, and I spent far too much time convinced that my presence there was happenstance.
At the end of that internship, a full time job offer came through. My four month interview had
paid off, and what felt surreal became that much more so. This is a moment I come back to often
on the more difficult “Do I fit in?” days, because that was one day that I can look to as a source
of validation. I definitely recommend collecting these moments to remind yourself when the little
voice suggesting you don’t belong speaks up, because there will always be moments when it does
and being prepared to tell it off never hurts.
Being a woman does not help with managing this feeling; being reminded how rare you are because
of your gender in a group project does nothing positive for feelings of imposter syndrome. Nor
does the implication that you might get hired to inflate a company’s diversity numbers and be a
spokesperson for them. These were all said to me casually, as if they were stating the sky is blue,
which made them that much easier to internalize.
There will be jerks, and worse, there will be jerks who aren’t even self-aware enough to be called
jerks.
Do I fit in?
96
But in all these steps, I met good people too. People who encouraged me to take a chance on myself
when I otherwise would have backed down, people who listened to me unpack the self doubt and
negative thoughts that I’d internalized along the way. Without them, I wouldn’t have had the
opportunity to take the next step. I’ve been very fortunate to know them, and now am very fortunate
to be able to be this person for others as well.
Here’s what I’ve learned time and time again when I’m faced with the question “Do I fit in?”:
• A lot of what made me feel excluded was rooted in technical jargon I didn’t know and the fact
that everyone using it seemed so much smarter than me.
• Tech is a huge, vast field—no one knows everything, and adaptability is key. Taking the time
to figure out how I learn best and continually invest in that development has helped me offset
my experiences with imposter syndrome immensely.
• Be patient with yourself!
• Take note of and celebrate little wins and steps forward.
• Keep an ear to the ground on what’s going on in the industry, the types of conversations being
had. I find Twitter useful for this.
• There are jerks, but there are also good people out there. Don’t be afraid of seeking them out;
whether through local meetups or online communities, growing your support network really
helps you foster a sense of belonging for yourself and others.
• If you are coming from a non traditional background, that is an asset; don’t let anyone convince
you otherwise. Many of the skills that make me most effective at working with others and
communicating with stakeholders were gained working part-time jobs while I was in school.
My own answer to the question “Do I fit in?” is always shifting. I’ve found the more that you work
and engage with others to make a given environment a little warmer and more welcoming, the
more you’ll find yourself a place to fit into that process, and while tech might have a few characters
who seem resistant to this, every day there are more and more people like you—people who have
wondered if they fit in—writing their first line of code.
My software developer journey
Clifford Fajardo
At the beginning of 2016, I had just graduated from a coding boot camp, finished a long job search
and was starting my career as a software developer at Salesforce in San Francisco. I was excited
about the journey ahead and equally very nervous.
I felt as if I had stepped into a whole new world! I was starting my first full-time job; I was now
working in a corporate environment; I was working on a fully remote team; I was worried that I
didn’t fit the typical software developer profile and was concerned about how I would perform on
the job.
Do I fit in?
97
This new world I had stepped into felt like a long shot from where I had come from. Before this job,
I had been a student at community college and the only work experience I had at the time was as a
student tour guide and pizza chef.
It was still hard for me to believe that I, a kid from a first generation immigrant family from
Nicaragua who had been living on the poverty line for most of his life, was now the first person
in his family to work in a corporate environment and the first to become a software developer.
As I transitioned into that role, it felt like I was on a roller coaster ride. There were lots of great high
moments and low moments. I would have work days where I would create something or fix a bug
and feel complete joy. There were other days where I questioned if this was the right career for me
because of how challenging it felt or how long it was taking me to complete my work, relative to
my peers.
There was even a point during my first year as a developer when I seriously questioned whether I
fit in and belonged in this industry. I almost decided to go back to my old, easier but less fulfilling
life, which for me meant not confronting my fears head on and growing from them.
When I had these types of days what helped me push through were the thoughts of my family
and the vision I had when I first started to learn to code. The vision that one day I would become
knowledgeable enough to build out any idea I could envision and impact the lives of millions of
people.
Looking back, I’m so happy I didn’t give in to my fears. If I had, I wouldn’t have had the opportunity
to later work at LinkedIn, my second job, where I worked on apps impacting over half a billion people.
I would have missed out on the opportunity to gain the experience, knowledge, and confidence that
I needed to eventually venture out and start working full time on the business and app I work on
today.
Everyone is different, own your individuality
In retrospect, most of the low experiences and feelings I had about not belonging came from not
appropriately managing my own expectations, my lack of experience, oftentimes my impatience,
and being too hard on myself.
During tough times, it was easy to forget the reality of the situation I was in:
• I’m new to this job and industry, so it absolutely takes time to adjust.
• I’m taking longer than all my peers to complete tasks, but that’s normal at any new job or role.
• Just like me, everyone on my team was once new and inexperienced at something.
And equally as easy to forget the things I had control over:
• Though I’m not at the level I want to be at now, I can make a change and take ownership of
my learning and growth. It may require some extra time outside of work, but it’s doable.
• I don’t have to be the same person I was yesterday. I can learn to be a more effective leader,
communicator, and developer. Pushing myself out of my comfort zone little by little every day
will build my character and confidence.
Do I fit in?
98
• I don’t have to travel on my journey alone. I can find a mentor or employee resource group
and accelerate my learning and growth with the help of others.
Once I started realizing all of these things, all areas of my life quickly and dramatically improved.
I no longer spent time thinking about whether or not I fit in, regardless of where I was. I finally
internalized that I could carve out my own unique place, co-exist with everyone around me, and
bring a different perspective to the table.
Own your unique experiences. Own your individuality and be open-minded. Be ready to learn,
unlearn and relearn. Lastly, don’t be too hard on yourself.
LGBT
Casey Ocampo
Do you identify as an LGBT person? Are you in the process of applying for jobs? Are you concerned
with how you might fit in and want some tips on how to best go about including this information
in your application? If yes, then this section is for you.
There are many reasons why someone may want to include these personal details in their application,
the most important one being to avoid employment with a company that discriminates. The fact is,
discrimination among all kinds of minority groups is still a very real occurrence. Because of this, it’s
important to safeguard yourself against any potential threat that may happen, be it physical, mental
or emotional.
Everyone wants to work for a company where they are accepted and can work comfortably. The
good news is, there are steps we can take to ensure this outcome.
In this section, I’ll outline what I did to communicate my gender identity and other possible ways
to go about including this information. I’ll share with you how I went about arranging my portfolio
to “wave the flag” and express my gender identity.
What I did to be visible
The first question I asked myself was, “how can I go about this while staying relevant to the
application?” There were a couple steps I took to achieve this.
The first was to include one of my trans-related side projects in my portfolio—it was an online
transgender and allied apparel company. In 2016, I found myself with a unique opportunity to create
something, launch it, and see how the market responded. It was a success, I learned a lot, and I figured
it was as good a project (and as relevant) as any to showcase in my portfolio.
This checked off two relevance requirements, one being that it was something I created, and two, it
dealt with supporting transgender folks.
Do I fit in?
99
Now, I can’t tell you how every recruiter felt about this information, but I can tell you that the
subject of starting a company itself was a strong and positive talking point. And while I did worry
that being so visible might hurt my job prospects, I reasoned with it by telling myself if they didn’t
accept it, then I’m better off not being in that environment.
If someone reading this was worried about “waving the flag”, I’d tell them the same thing. Be strong
in your conviction to be yourself. Be unapologetic about it! Anywhere with anyone that stands to
discriminate against you isn’t a place you want to be. And on a positive note, anywhere with anyone
that stands to accept you and welcome you as you are is exactly the place you want to be!
Leaving more clues
Another approach I took was including personal details in my about/bio section of my portfolio
website. These are more simple and subtle steps you can take to ensure that the company is aware
of your identity.
I’m very transparent in mine, openly addressing my gender identity and my belief that it’s important
for minority groups to be visible. This is a great and appropriate way to be visible!
Visibility over 9000!
If you want to raise your visibility beyond those two methods, leave more digital footprints. Blog
about LGBT topics that matter to you. These could be published on any digital medium, including
your own personal website or on social media in microblog form. Just remember to include links to
your social media profiles in your portfolio website if you choose to be visible on them!
If the hiring manager is thorough with vetting their candidates, these thoughtfully sprinkled-in
details will surely catch their eye. And if they’re a super awesome, diversity-advocating company,
they’ll have all the more reason to welcome you with open arms.
During the initial interview
First, congrats on the interview! You’ve done great so far. Time to keep going!
At this stage in the interview process, the conversation should be fairly laid back with the recruiter’s
focus being to get acquainted with you. In my experience, you’ll find a lot of opportunities to speak
about what you’ve worked on and what you’re proud of so far. The recruiter usually sets the stage
for this.
Ideally, it’d be a good idea to bring up two or three pieces of work with either an LGBT project or
blog being casually looped in the mix. That way, if for whatever reason the recruiter overlooked that
detail in your portfolio, it’d be 100% clear and open now for you to assess how they respond to it.
If they respond negatively, you’ll know. I’ve never had this happen to me. But in case it does, stay
cool, be the bigger person, and exit the conversation. We can flip this unfortunate situation and
think of it as being one step closer to the right fit. The important thing here is to keep moving.
If they respond positively, you’ll know. This has happened 100% of the time for me. In this case,
stay cool (while having an internal celebration) and keep the conversation flowing. You’ll feel great
knowing that you were brave enough to bring it up and you’ll be more comfortable and confident
in the conversation.
Do I fit in?
100
Wrapping it up
The question of “Do I fit it?” can be a tough question to face, especially for individuals in historically
oppressed minority groups. But take solace in knowing that times have changed and are continuing
to change. We’ve come a long way as a society and you have the opportunity to allow it to keep
going just by being open about who you are.
You are a smart, capable, and highly skilled human being deserving of respect. Whether you’re
lesbian, gay, bisexual, or transgender, being visible is important in your journey to fitting in with
the right team.
I hope this section was able to help you in some way.
Best of luck to you, friend!
Women in code
Ilona Codes
Introduction
I got my first PC when I was 11 years old and it became everything to me. I remember that “after
computer” time when the real world didn’t seem as interesting anymore. Like many children, I
started spending hours playing video games, and with an internet connection, I went deeper into
the flow of information and ideas.
As the years went by my interest in computers and computer science only increased. This played the
main role in my career choice and selection of my university major. I was facing a choice between
computer science and medicine. I couldn’t decide what was more interesting to me. And as you’ve
guessed by now, I made the decision to pursue computer science.
Early in my career I remember thinking, “maybe this was a bad decision.” I tried to give up twice in
my first year in the IT industry. There were many reasons and people around me at the time that
made me strongly consider that. And I’m far from the only one who tried to quit the industry.
So, why do women turn away from technology careers?
Because there are spoken and unspoken barriers that make it difficult for women to advance in IT.
Talking to women in tech and code at different events, I’ve observed some common problems which
have forced women to leave engineering careers:
• Poor working conditions: too much travel, lack of advancement, low salary, etc.
• Lack of respect for women in male-dominated fields.
• Unhealthy workplace climate: closed-minded managers, dev teams that are difficult to work
with, or lousy company culture.
To boil it down to the most universal problem, we see that bias pushes women out of the industry.
Moreover, that bias can play out even worse depending on a woman’s race or ethnicity.
Nowadays coding is becoming one of the most in-demand skills across industries, and the milestones
I’ll discuss here will help you to “overcome” your first year in code if you are a woman. Because,
honestly, being a software engineer is one of the best jobs for women. We implement products and
make life easier for people who use them. Sometimes I feel like a hero doing it. Isn’t that amazing?
But because of that bias, you can miss out on all the benefits of a programming career. Here’s a list
of the advantages of being a software engineer at the company where I currently work:
Women in code
102
• We work five days a week. We have a flexible schedule and can even work from home.
• We learn new things constantly while solving problems, working with other software engi-
neers, watching webinars, doing courses, visiting conferences, etc.
• We celebrate all occasions with our teams. We go to team parties and do team-building
exercises.
• We make friends from different countries and cultures, and they enrich our life experience.
• We can easily switch from client to client or product to product. If we don’t find our work
challenging, we can change the type of work that we do.
It’s not my first job, but so far it is my best one.
Choosing a company with the right values
Only now do I understand that when I was looking for my first job and sent out lots of applications
for entry-level frontend positions, I didn’t pay enough attention to the companies I was applying to.
I didn’t even clearly understand the differences between types of companies: a startup? A consul-
tancy? An agency? A public company? A product company?
I knew HTML, CSS, and JavaScript. And I had made fancy web pages and implemented mini projects
to consolidate my technology stack knowledge and create a portfolio. My only focus was on getting
professional experience—and finding my first job.
As a result, out of 20-30 CVs sent to different companies, I got 2-3 invitations to interviews. I
didn’t much care about what kind of company they were with, what products/services the company
provided, the company’s values or the team lead/manager I was going to work with. And that was
a big mistake on my part. If I had known better, my first job could have been at a company I’d be
happy to work at.
You can always get insights about a company before applying for a position. For example, through
the company’s reviews on job search websites. You can meet current and former employees at
meetups or other events and get more details about the company’s purpose or vision or whether
the company has open positions at the moment.
Then Google the name of the company and check their job postings. After getting enough
information, you can understand whether the company is diversity-friendly and worth applying
at, how the company is organized, what the working process would be like for you there, etc.
Different types of software engineering jobs demand different kinds of preparation. If you’ve done
your research and decided which company you would like to join, then start by sharpening your
skills and focusing on your strengths and weaknesses. Do some side projects to learn the required
tech stack for the position. Add all these to your resume and send it to the company.
If it’s your first year in code, I would suggest you apply at startups and mid-size companies.
These companies are full of hands-on work. You’ll get good exposure to things to learn and, more
importantly, your ideas and suggestions will be taken into consideration. You’ll be able to challenge
Women in code
103
yourself, showcase your creativity and learn how to work on a team. These jobs can give you a
clearer picture of yourself regarding what skills and knowledge you need to get. Also, you’ll get the
chance to build your professional network.
The importance of telling the truth
As women in tech, we always face more problems at work than men. This observation comes not
only from my life experience but also from my women friends and acquaintances who work in IT.
I am lucky now to be working in a healthy environment, and along with a professional relationship
with management, we are building trust between the two sides: employer and employee.
Once, when I was visiting a meetup for women who code, I met Clara (name has been changed).
She is a junior software engineer at company X.
At that time she was a new employee. And you know how it’s difficult to adapt to company processes,
a new project, and your coworkers in your first weeks or even months, especially if it’s your first
year in the field.
Later I texted her to invite her to meet up for a cup of coffee. I wanted to hear her story. While we
were sitting in the cafe, drinking coffee and speaking about our jobs, Clara confessed that she was
afraid of saying “I don’t know” when in fact she didn’t know something. Instead of that, she was
trying to bluff her way through the situation and not lose control.
Her apparent reason was fear of looking stupid in front of her colleagues and managers at work.
She’s a competent professional and she must have an answer because it’s her job, isn’t it?
A year ago, I would have answered “Yes.” It is my job. And I must know the answer to any question
related to my expertise. But not now.
It took years for me to understand that when you are telling the truth, you can breathe easier. It’s
a straightforward and selfish reason, one I truly learned through my experience. There are many
pros to the truth: you don’t need to focus on backstories, and backstories of backstories, and relevant
details to make what you’re saying appear plausible, and making your body language match up with
what you are saying.
When you are telling the truth, you are at peace; you are honest. So much less energy needs to be
spent.
Don’t be afraid of telling your team or manager that you cannot finish your work on time. I’m sure
you had reasons, perhaps a specific problem or blocker. The best solution is to provide an explanation
and make your case as to why you couldn’t finish this task as planned.
If you are blocked by a problem and cannot find a workaround, don’t hesitate to ask for help. An
answer or some useful advice from a colleague or team member can easily unblock you and allow
you to continue solving your problem. And it will help you solve the same problem in the future if
it arises again.
In the end, you will only benefit from gaining new knowledge, learning how to work as a team, and
spending less time on figuring out a solution.
Women in code
104
Some people think that having a gap in knowledge is a weakness. But the real weakness is being
close-minded and dishonest.
How to grow a thick skin and handle complexities
During my university studies I noticed that most of the students were men. Even at that time I could
imagine how my future working environment would look. And I was right.
During my first year in code I worked with men as the only woman on my team, and to be honest,
at that startup, it was hard to work together, not just for me but also for my teammates.
There was that bias against accepting code produced by me—by a woman.
Yes, women are different from men. And yes, women can definitely code. But many have stopped
coding because someone once made them feel like they can’t code well.
Looking back on that time, maybe you’re a beginner without any practical working experience at
all, still confused about processes, teamwork and code bases with tens or hundreds of thousands of
lines of code. The combination of unknown things, complexity, and a new team where you’re only
an intern surrounded by middle-level/senior software developers—it can make you feel as though
there’s a massive amount of pressure on you.
In the beginning, it was a significant challenge to go to work. But I did it, even if I was crying. I
understood the importance of it. I was trying to see things positively and benefit from them by:
• Learning from my failures
• Distinguishing between personal and business
• Trying to get constructive feedback from the team
• Not complaining about things
For the time being I worked with men, learned from them, and built stamina. And I saw how easily
some men separate personal and business. They can be fighting with each other about a topic at
work and then behave as if nothing happened. It’s just work, nothing personal.
If you are in your first year in code, one of the first, most important things you have to do is start
to develop a thick skin.
That means you have to be able to go into work, even if your performance isn’t perfect, even if
sometimes you don’t completely understand what you are doing (or if you thought you did but in
the end everything went wrong). At the same time, don’t forget to appreciate yourself and your
progress (which may be noticeable only to you), regardless of what happens.
Here are three more ideas for women on developing a thick skin:
1. Cut down your contact with abusive people
If your direct manager or team members are just plain unbearable and always trying to bring you
down with their obsessive words or actions, then start looking to join a different team or switch jobs.
You won’t be able to stand this atmosphere for long and it can ruin your self-esteem and confidence.
Women in code
105
2. Don’t let harsh words hurt you
Sometimes we care too much about what others think.
This especially happens if you are the only woman on a team and worry about the image you are
portraying to others. If someone insults you or insists on something you completely disagree with,
it keeps repeating in your head over and over because we’re taught to deal with that stuff head-on.
The best way to handle this situation is to replace the thought with a more positive one. Why should
someone’s negative words ruin your day?
Focus on yourself in this situation. Don’t let the hurtful words of others make your day worse and
take control of your mind. Think positively, cheer yourself up, surround yourself with optimistic
and supportive people.
3. Use your words instead of your feelings
If someone is trying to wound your feelings, for example with passive-aggressive feedback, turn
their words around and engage with the offender in constructive dialogue.
Don’t forget you are allowed to interrupt and say: “Okay. I get it. There’s a problem here. You have
explained it very clearly. Can we talk about how to fix it? That’s more helpful for both of us.”
Overall, you are better off being a person who cares too much than a person who doesn’t care at all.
With luck, these sorts of workarounds can help provide cushions so that criticism doesn’t hurt you
too much.
Breaking stereotypes: educate men at work
I can imagine what it means for you to join a new dev team and be the only woman there—
because I did it, three times. We’re always being “welcomed” with the stereotypes. There is a general
impression that men are better at “tech things,” that they’re more systematic and nuanced, and that
on the other hand, women are more intuitive and better communicators, but their judgment isn’t as
solid.
A friend of mine works at the same digital media agency I used to work at. We often share our
experiences and observations from working with each other. Once she told me, “You know, today
when I was in a meeting about the project I’m working on, I sat at the table and said something. My
team, all men, ignored my comment. Then I noticed whenever the male backend engineer spoke,
everyone just stopped and listened. And I thought, that’s what I want. I want people to take me
seriously and respect my work.”
Here’s what she did next: she changed her job and started working for a company that values
diversity. Now half of her engineering team is women. There she continues to work hard, learn new
things and grow professionally. Based on my own experience, if you’re new in the industry, the
expectations placed on you can be burdensome. But if you’re willing to work hard and understand
that your first job probably won’t be your dream job then it gets easier.
Women in code
106
I firmly believe in diversity at work, not only of gender but also of experience level. For example,
I believe in creating junior developer positions and training those juniors up. When they are fully
integrated into the company, junior developers become loyal employees. By comparison, companies
that only hire the most senior developers find that they often already have their own vision of how
things have to work, which can be unproductive.
My friend’s way worked for her, but she could have done it differently—break stereotypes, that is—
by working to bring diversity to her former workplace. The following principles can help you do
that.
Become an expert in a specific technology/approach and start advocating it
Currently my official title in the workplace is “Frontend Software Engineer.” In my opinion, you
can’t be an expert front end developer just by knowing one thing. An expert developer is not
necessarily skilled in any specific set of technologies; instead, they demonstrate the ability to learn
new languages, frameworks and libraries as the need arises. The more they learn, the more they can
compare and make informed decisions about what tech to pick and when.
Know the requirements of each situation. Don’t be afraid of meeting a new challenge, even if you
haven’t solved that problem before. The more “unknown” things you learn and apply, the more your
expertise will grow.
If you are fascinated by a technology, you can start to advocate it. Convince others to try it and use
it. It will help you grow your credibility and break false stereotypes about women.
Increase your network of women and bring women engineers to the company
If you feel bad working on a team that’s all men, what’s stopping you from bringing a new woman
colleague to your team?
Finding a woman developer is easier than it seems. You can start going to local meetups, volunteering
at coding schools, joining university groups, and visiting other local tech events.
Companies are always passively looking for new people. It’s normal for some people to leave the
company and others to join, and someone will grow to the next level professionally and free up a
junior position.
Help onboard new employees
This is the best way to learn and understand a project more deeply. Keep in mind that if you’re a
software developer at a product company, it’s important to write clean and readable code so that
even an intern can understand it—and by the way, you too, in case you return to that code in a week,
a month or a year.
I want to talk about the mentor/mentee relationship, which isn’t always strictly business. You can
develop some real friendships when you take the time to advise someone and help them succeed.
Women in code
107
When you develop a relationship with someone over time—when you help them, coach them, and
guide them—that person’s success is tied to you. Time after time, success will come back to you as
the mentor.
Also, your protege can teach you from their own unique experiences and perspective, which may
be very different from yours. They may also have new skills they can teach you.
People never forget their mentors.
Think back to when you first started working at your company. Wouldn’t it have been nice to get
some coaching from someone who had already been through that process?
Build trusting and professional relationships with colleagues and managers
In a company which incorporates people from diverse backgrounds into its network, each person has
to trust the others to help them accomplish their own goals and the collective goal of the company.
That’s why it’s crucial to build trust within teams. It’s a long process; it doesn’t happen overnight.
The most likable and trustworthy people know that it’s not worth offending people by expressing
everything they know, even if they are correct. They’re good listeners when someone else is talking.
It’s also important to show empathy for your colleagues and keep an open mind. Do not judge—
try to understand. Those who close themselves off from others’ ideas are missing out not only on
personal growth but also on opportunities for advancing their career.
People are different, and depending on the situation we may express ourselves differently, sometimes
too emotionally. Try to learn how to maintain professional behavior in all circumstances. Overreact-
ing to things, either positively or negatively, will make a poor impression. Always remember that
silence may be much more useful than angry words.
Women in code are driven. We want to prove ourselves. We want to work hard and grow, and it’s
impossible to buy that kind of enthusiasm.
In parting, I’d like to say: be the change you wish to see in our industry!
What to do when you’re stuck
Isaac Lyman
Part of a programmer’s job is chasing down missing semicolons and complex caching issues,
scrutinizing and head-scratching over every line of code in an application. This is one of the most
frustrating things about code: we use it to offload complexity from our brains, but the inverse of this
benefit is that any useful program will be too complex for us to wrap our minds around completely.
Complexity creates unknowns, and every unknown is a bug waiting to happen.
Another frustrating thing about code is that it has to be learned by rote. You’re unlikely to discover
the keyword or API you need by blind experimentation. And every language and library has gotchas,
which may or may not be described in the documentation. There’s no substitute for experience in
situations like this.
Most programmers (I’d guess) are acquainted with the deep, hot, crushing frustration that ensues
after hours of being stuck on a problem and not knowing how to progress. On that subject, here’s a
tweet from the guy who created Stack Overflow:
Source: https://twitter.com/codinghorror/status/695143348521140225⁶⁵
This particular usage of my head has probably shortened my life expectancy by a few years. If
you’re a new programmer, you can avoid some of that by following a process similar to the one I’ll
recommend here. Each step builds on and escalates the one before it, and most of the time you’ll get
un-stuck long before you reach the last step.
1. Be self-aware
This will all go a lot better if you’re taking care of yourself and paying attention to the way you feel.
Sleep deprivation, hunger, a hostile work environment, or stressors in your personal life can directly
affect your ability to solve problems. Ideally, you should be in a peaceful frame of mind when you
start working. Then when you get frustrated, you can label the problem (“I’m stuck”), take a deep
breath, and start on the path to resolving it.
⁶⁵https://twitter.com/codinghorror/status/695143348521140225
What to do when you’re stuck
109
To get off on the right foot, consider a morning routine that includes meditation and/or journaling.
These can help you be more aware of your feelings.
2. Timebox your frustration
Once you’ve determined that you’re stuck, set a timer for 20 minutes. Turn off Slack and email,
put on your headphones, politely postpone questions and conversations with coworkers, and start
Googling the problem. Read as much as you can about it. Try several different search queries. You
may be surprised at how many other people have had your specific problem, even if it seems unique
or proprietary. If you’re lucky enough to have an error message, search it in quotes. Consider all the
systems (libraries, packages, frameworks, APIs, services, etc.) that interact with the faulty part of
the application, and ask yourself if the problem may be in a different place than you thought it was.
3. Rubber-duck it
Explain the problem to an imaginary coworker. Got a rubber duck or stuffed animal handy? Even
better. I have a stuffed animal on my desk at all times. Describe the issue in as much detail as you
can, and assume that your coworker isn’t intimately familiar with the code you’re talking about.
If this is hard for you, try composing an email or Slack message to a coworker that might be able
to help. Don’t send the message yet—just write it out and revise until you’re satisfied that you’ve
covered the problem in clear terms. Make sure to mention the research you’ve done and anything
you’ve ruled out as the possible cause.
4. Draw it
On a piece of paper or a whiteboard, sketch out a basic diagram of the methods, classes and files
that are interacting in the problem area. No fancy murals here—a bunch of circles and lines should
be fine. Draw a piece of data traveling through this system as well. If you need to dig through the
code a little to make sure your drawing is correct, take a minute to do so.
5. Take five
By now you should understand the problem pretty well (or know what you don’t understand about
it). At this point, put your computer to sleep and give your brain a rest. Anything that isn’t mentally
demanding will do. Strike up some light conversation with a friend or coworker, take a nap, go for
a walk, get some lunch, watch a funny video, hit the gym, or take a shower. The solution may occur
to you while you’re doing something else entirely.
What to do when you’re stuck
110
6. Ask for help
By now, you’re reaching the limit of what you can do alone; you’ve probably spent 30-90 minutes
on this problem. It’s time to bring in reinforcements. Find a coworker who has relevant experience
and ask for help. If you have no coworkers or none are available, reach out to your mentor. If you
don’t have a mentor, now’s a good time to put that on your to-do list.
Don’t worry about wasting their time. You’ve researched and thought through the problem, so you
can describe it completely and succinctly. And for you to keep trying on your own could turn into
a much more serious waste of time.
7. Isolate the problem
If you’re still stuck, it’s time to start from scratch. Create a small repository or use an online tool
(like Codepen⁶⁶, Repl.it⁶⁷, or Stackblitz⁶⁸) and see if you can add just enough code to reproduce the
problem. One piece at a time, replicate the environment and code around the issue until you see it
happen. Then try to remove various pieces, in turn, to make sure you haven’t included anything
unnecessary. What you’ll end up with is the smallest possible example of the problem (an MCVE⁶⁹),
which will make it easier for someone to help you solve it. Review this with the person you asked
for help in the previous step.
8. Write it up
Write a full description of the problem. Include code samples, a link to your repository or online
code sample, screenshots (if applicable), and a summary of the things you’ve tried and the research
you’ve done. Don’t include anything that would pose a security risk to your company if it were
posted publicly, because that’s the next step.
9. Get a buddy and ask the internet
Find a buddy (possibly the person from step 6) and ask them to read through your writeup from
step 8 to make sure it makes sense. Then post it on the internet. Stack Overflow and other Stack
Exchange sites (like Server Fault, Software Engineering, or Database Administrators) are your best
bet for getting a timely answer to your question, but their communities can be hostile to question
askers, so don’t go in alone—ask your buddy to upvote your question and help you defend against
rude commenters or votes to close the question. With any luck, you’ll get some good feedback and
ideas within a day or two.
⁶⁶https://codepen.io/
⁶⁷https://repl.it/
⁶⁸https://stackblitz.com/
⁶⁹https://stackoverflow.com/help/mcve
What to do when you’re stuck
111
10. Find a workaround
If you still haven’t solved your problem, it’s time for Plan B. You might consider altering the affected
functionality, adding some fallback code, or switching to a different software library. This sounds a
lot like giving up, but compromises are at the heart of all software, so don’t beat yourself up over it.
Finally, document the solution
Once you’ve solved the problem, consider writing some documentation about it in order to alleviate
someone else’s frustration. This might be a comment in the code, a page on your company’s internal
docs, an email, a post on your blog or dev.to⁷⁰, or a self-answered Stack Overflow question.
And once again, keep an eye on your mental health. Programming is inherently frustrating. We all
need breaks. If you’re constantly getting burned out, it’s time to take a day off, change your routine,
or look for another job.
⁷⁰https://dev.to/
Choosing a job title
Isaac Lyman
Are you a coder, programmer, developer, engineer, architect or
something else?
My first job was an underage, under-the-table weekend gig at a pizza parlor. I’d show up at the local
strip mall early Saturday morning, stash my bike, and clock in. For me, the work was grueling. I
would haul 50-pound bags of flour and 10-gallon buckets of water to a giant stand mixer, and once
it finished spinning I’d lift armfuls of incredibly heavy dough to a metal table where I’d cut and oil
portions weighed for each size of pizza that the shop sold. By noon, I’d be exhausted. I’d clock out
and head home. And once a month I’d pick up an envelope with about $100 cash in it. It was an
awesome first job.
My official job title was Dough Boy (yes, like the Pillsbury mascot). But “Dough Boy” isn’t very
impressive on a resume, so for a while I listed my job title as “Dough Chef.” A teenager’s got to have
some dignity, right? In the end, I don’t think anybody cared.
Little did I know, that was the least problematic job title I would ever have.
I became a programmer several years ago. In 21st-century America—especially in the tech sector—
job titles are surprisingly fluid. I haven’t had an employer dedicate any real thought to my job title
for a long time. In fact, my first employer in the industry told me I could put whatever I wanted
on my resume and if anyone called she’d back me up. Naturally, I was tempted to write “Senior
Department Lead QA III Technical Architect”, when in fact I was just writing Selenium tests in a
cubicle. Go figure.
I’ve often puzzled over the plethora of job titles I now fit under. I write web applications for a startup,
so I do something at every level of the stack, from SQL Server at the bottom to CSS at the top. There
are a lot of things I could call myself: coder, programmer, engineer, developer, boffin. In keeping
with my pizza-infused legacy, I could even call myself a Software Boy⁷¹. So what am I?
⁷¹https://twitter.com/ivetwodads/status/854358415799312384
Choosing a job title
113
Source: https://twitter.com/jenlooper/status/854345325032747009⁷²
I’ve discovered that I’m far from the only one who has this question. And there are a lot of variables
to consider, so it’s not an easy one. In some countries it’s illegal to call yourself an engineer unless
you have certain certifications. In some cultures, general words (like “consultant”) may be preferred
over technical jargon (like “application developer”). And in the United States, where I live, small
differences in a job title can make a significant difference in salary.
This is my attempt to aggregate all the data I can find about the swath of job titles that apply to
people who code. I’ve gathered average salary information and definitions for several job titles that
might apply (but surely not all of them).
I’ve ignored titles like hacker, ninja, and rockstar because they’re silly and meaningless.
Sources
I pulled salary information from the U.S. Bureau of Labor Statistics (BLS), Glassdoor, PayScale, and
Indeed. Definitions come from the BLS or Wikipedia where available. Where neither has a definition,
I’ve searched out the most succinct, authoritative source I can find.
Salary data
This data is categorized by job title. Job titles are ordered by a subjective estimate of their complexity,
from least complex to most complex. Data was gathered in May 2019.
Each entry has a definition, national (USA) median salary data from each source, an average of the
salary data points, and a variability assessment (how wide the range of salary estimates is). Where
a specific job title or equivalent was not found in a database, “N/D” is used.
Statistical Note: PayScale.com uses the words “average” and “median” interchangeably. That’s not
how math⁷³ works, but oh well. Glassdoor and Indeed don’t offer a median at all, preferring a much
⁷²https://twitter.com/jenlooper/status/854345325032747009
⁷³https://www.vocabulary.com/articles/chooseyourwords/mean-median-average/
Choosing a job title
114
less useful⁷⁴ average. In a perfect world everyone would use medians for data sets like this, since
they may or may not follow a normal curve.
Coder
[A] person who writes computer code; a computer programmer. ∼Dictionary.com⁷⁵
Source
Salary
BLS
N/D
Glassdoor
$46,930⁷⁶
Indeed
N/D
PayScale
N/D
Average
N/D
Variability
N/D
Notes: I’d usually avoid a site with so little street cred as Dictionary.com, but definitions for this
word are surprisingly scarce.
Programmer
Create, modify, and test the code, forms, and script that allow computer applications to run.
Work from specifications drawn up by software developers or other individuals. ∼BLS⁷⁷
Source
Salary
BLS
$84,280⁷⁸
Glassdoor
$68,478⁷⁹
Indeed
$73,643⁸⁰
PayScale
$61,527⁸¹
Average
$71,982
Variability
Medium. Range of ∼$22k.
Developer
[A] person or company that develops computer software. ∼Merriam-Webster⁸²
⁷⁴https://surveymethods.com/blog/when-is-it-generally-better-to-use-median-over-mean/
⁷⁵http://www.dictionary.com/browse/coder
⁷⁶https://www.glassdoor.com/Salaries/coder-salary-SRCH_KO0,5.htm
⁷⁷https://www.bls.gov/oes/current/oes151131.htm
⁷⁸https://www.bls.gov/oes/current/oes151131.htm
⁷⁹https://www.glassdoor.com/Salaries/programmer-salary-SRCH_KO0,10.htm
⁸⁰https://www.indeed.com/salaries/Programmer-Salaries
⁸¹http://www.payscale.com/research/US/Job=Computer_Programmer/Salary
⁸²https://www.merriam-webster.com/dictionary/developer
Choosing a job title
115
Source
Salary
BLS
N/D
Glassdoor
$80,394⁸³
Indeed
$93,386⁸⁴
PayScale
N/D
Average
$86,890
Variability
Medium. Range of ∼$13k.
Notes: Several people have pointed out that the term “developer” could refer to someone in real
estate as well as someone in software, so it’s hard to know if these results are meaningful.
Front End Developer
A front-end developer is a type of computer programmer that codes and creates the visual
front-end elements of a software, application or website. He or she creates computing
components/features that are directly viewable and accessible by the end user or client.
∼Techopedia⁸⁵
Source
Salary
BLS
N/D
Glassdoor
$77,908⁸⁶
Indeed
$102,297⁸⁷
PayScale
$69,773⁸⁸
Average
$83,326
Variability
Extreme. Range of ∼$32k.
Web Developer
Design, create, and modify Web sites. Analyze user needs to implement Web site content,
graphics, performance, and capacity. ∼BLS⁸⁹
Source
Salary
BLS
$69,430⁹⁰
Glassdoor
$75,487⁹¹
Indeed
$72,644⁹²
PayScale
$58,593⁹³
Average
$69,038.50
Variability
Medium. Range of ∼$15k.
⁸³https://www.glassdoor.com/Salaries/developer-salary-SRCH_KO0,9.htm
⁸⁴https://www.indeed.com/salaries/Developer-Salaries
⁸⁵https://www.techopedia.com/definition/29569/front-end-developer
⁸⁶https://www.glassdoor.com/Salaries/front-end-developer-salary-SRCH_KO0,19.htm
⁸⁷https://www.indeed.com/salaries/Front-End-Developer-Salaries
⁸⁸http://www.payscale.com/research/US/Job=Front_End_Developer_%2f_Engineer/Salary
⁸⁹https://www.bls.gov/oes/current/oes151134.htm
⁹⁰https://www.bls.gov/oes/current/oes151134.htm
⁹¹https://www.glassdoor.com/Salaries/web-developer-salary-SRCH_KO0,13.htm
⁹²https://www.indeed.com/salaries/Web-Developer-Salaries
⁹³http://www.payscale.com/research/US/Job=Web_Developer/Salary
Choosing a job title
116
Full Stack Developer
The term full-stack means developers who are comfortable working with both back-end
and front-end technologies. To be more specific, it means that the developer can work with
databases, PHP, HTML, CSS, JavaScript and everything in between, also, venturing as far
as converting Photoshop designs to front-end code. ∼George Fekete on SitePoint⁹⁴
Source
Salary
BLS
N/D
Glassdoor
N/D
Indeed
$111,117⁹⁵
PayScale
N/D
Average
N/D
Variability
N/D
Notes: There’s⁹⁶ significant⁹⁷ doubt⁹⁸ as to whether this is a “real” job title, insofar as it refers to being
an expert in several different layers of web technology. Given that Indeed is the only site to cough
up a salary value, it seems that the industry shies away from it, whether for this reason or another
one.
Software Developer
Develop, create, and modify general computer applications software or specialized utility
programs. Analyze user needs and develop software solutions. ∼BLS⁹⁹
Source
Salary
BLS
$103,620¹⁰⁰
Glassdoor
$80,018¹⁰¹
Indeed
N/D
PayScale
$69,928¹⁰²
Average
$84,522
Variability
Extreme. Range of ∼$33k.
Software Engineer
A software engineer is a person who applies the principles of software engineering to the
design, development, maintenance, testing, and evaluation of the software and systems
⁹⁴https://www.sitepoint.com/full-stack-developer/
⁹⁵https://www.indeed.com/salaries/Full-Stack-Developer-Salaries
⁹⁶https://dev.to/remotesynth/theres-no-such-thing-as-a-full-stack-developer-2fp9
⁹⁷https://vitamintalent.com/blog/what-the-heck-is-a-full-stack-developer
⁹⁸https://medium.com/@alexkatrompas/the-hard-truth-about-the-full-stack-developer-myths-and-lies-945ffadeeb8c
⁹⁹https://www.bls.gov/oes/current/oes151132.htm
¹⁰⁰https://www.bls.gov/oes/current/oes151132.htm
¹⁰¹https://www.glassdoor.com/Salaries/software-developer-salary-SRCH_KO0,18.htm
¹⁰²http://www.payscale.com/research/US/Job=Software_Developer/Salary
Choosing a job title
117
that make computers or anything containing software work. ∼Wikipedia¹⁰³
Source
Salary
BLS
N/D
Glassdoor
$103,035¹⁰⁴
Indeed
$107,366¹⁰⁵
PayScale
$84,023¹⁰⁶
Average
$98,141.33
Variability
Medium. Range of ∼$23k.
Notes: In classic Wikipedia style, this definition is bafflingly circular. However, if you ignore the
“principles of software engineering” part, the definition becomes useful.
This concludes a nearly-complete list of job titles that apply to regular devs. However, I’m going
to go a bit further and see what “Junior”, “Senior” and “Architect” do to a job title, even though these
terms lie outside the mainstream.
Junior Software Developer
An entry-level engineer with limited exposure to development and development practice
who will need strong mentoring and support to grow their skills. ∼James Turnbull on
Kartar.Net¹⁰⁷
Source
Salary
BLS
N/D
Glassdoor
$64,962¹⁰⁸
Indeed
$59,913¹⁰⁹
PayScale
$59,579¹¹⁰
Average
$61,484.67
Variability
Very low. Range of ∼$5k.
Senior Software Developer
…either someone with a deep specialised knowledge beyond their peers or someone who
leads or instructs other developers. ∼Robert Rees on The Guardian¹¹¹
¹⁰³https://en.wikipedia.org/wiki/Software_engineer
¹⁰⁴https://www.glassdoor.com/Salaries/software-engineer-salary-SRCH_KO0,17.htm
¹⁰⁵https://www.indeed.com/salaries/Software-Engineer-Salaries
¹⁰⁶http://www.payscale.com/research/US/Job=Software_Engineer/Salary
¹⁰⁷https://kartar.net/2015/09/so-what-exactly-is-a-junior-software-engineer/
¹⁰⁸https://www.glassdoor.com/Salaries/junior-software-developer-salary-SRCH_KO0,25.htm
¹⁰⁹https://www.indeed.com/salaries/Junior-Software-Developer-Salaries
¹¹⁰http://www.payscale.com/research/US/Job=Junior_Software_Engineer/Salary
¹¹¹https://www.theguardian.com/info/developer-blog/2014/aug/28/what-does-it-mean-to-be-a-senior-developer
Choosing a job title
118
Source
Salary
BLS
N/D
Glassdoor
$95,791¹¹²
Indeed
N/D
PayScale
$101,732¹¹³
Average
$98,761.5
Variability
Very low. Range of ∼$6k.
Software Architect
A software architect is a software expert who makes high-level design choices and
dictates technical standards, including software coding standards, tools, and platforms.
∼Wikipedia¹¹⁴
Source
Salary
BLS
N/D
Glassdoor
$132,510¹¹⁵
Indeed
$142,078¹¹⁶
PayScale
$121,645¹¹⁷
Average
$132,077.67
Variability
Medium. Range of ∼$20k.
Analysis
Salaries
Job titles by salary from lowest to highest are:
• Junior Software Developer
• Web Developer
• Programmer
• Front End Developer
• Software Developer
• Developer
• Software Engineer
• Senior Software Developer
• Software Architect
¹¹²https://www.glassdoor.com/Salaries/senior-software-developer-salary-SRCH_KO0,25.htm
¹¹³http://www.payscale.com/research/US/Job=Sr._Software_Engineer_%2f_Developer_%2f_Programmer/Salary
¹¹⁴https://en.wikipedia.org/wiki/Software_architect
¹¹⁵https://www.glassdoor.com/Salaries/software-architect-salary-SRCH_KO0,18.htm
¹¹⁶https://www.indeed.com/salaries/Software-Architect-Salaries
¹¹⁷http://www.payscale.com/research/US/Job=Software_Architect/Salary
Choosing a job title
119
Coder and Full Stack Developer were lacking data. Since the BLS probably has the largest and least-
biased data set, I’ve bolded the job titles that had BLS data available. Incidentally, the ordering of
the list holds when BLS data is considered alone.
This data should be taken with a grain of salt for several reasons:
• I don’t have access to the original data sets. I don’t know the size of those data sets or the
algorithms used to calculate their average/median. I don’t have access to demographics data,
so important variables like race, gender, orientation and class aren’t considered here. A data
set of known size and diversity would yield better analysis.
• Glassdoor and Indeed are fundamentally job boards, not public data sets. Their data is based on
volunteered information: self-reported salaries and job postings. This makes it prone to several
forms of survey bias.
• PayScale, Glassdoor and Indeed are private companies and their data isn’t public. Any private
company is accountable to its shareholders, not the general public, and may be incentivized to
gather and calculate data in a way that increases the value of their product to customers. For
example, employers posting jobs on Indeed may prefer the site to report lower average salary
data, which would make their salary offers seem more competitive. Indeed could do this by
focusing its marketing on regions with low cost of living and low average salary, which would
skew its self-reported salary data toward the lower end of the scale. I’m not saying they do this,
but it could be profitable for them to do so.
The difference in average salary between a Developer and a Software Developer is about $3k,
which probably is not statistically significant. On the other hand, the difference between a Software
Developer and a Software Engineer is $13k, which may be meaningful. The biggest leap in salary is
from Senior Software Developer to Software Architect, with a difference of about $33k.
There are several more slight variations in wording that I could have looked into. A Senior Software
Engineer, for example, probably makes a little bit more than a Senior Software Developer, and a
Senior or Chief Software Architect surely makes more than a Software Architect. But this should be
enough to provide insight into a general trend.
Definitions
Enough with the cash: what’s the qualitative difference between these roles?
First of all, some titles to avoid (or at least approach with caution):
• Coder had the lowest Glassdoor salary of any position I looked at, even lower than Junior
Software Developer. It’s hard to argue in its favor. First of all, it’s much too brazen—it’s like a
construction worker calling himself a Nailer or a doctor calling herself a Scalpeler. “Code” is
better as a noun than a verb; it’s a tool you use to achieve a goal. If a candidate for a position
at my company billed themself as a Coder, it would give me the impression that they like to be
told what to do and how to do it—that is, they’ll write the code, but they won’t make decisions,
interact with people, or suggest ways to improve. That sounds like an unfulfilling way to build
Choosing a job title
120
software. What’s worse, an employer who creates a job posting for a Coder probably isn’t
looking for someone who engineers elegant solutions to complex problems—they probably
have only a shallow understanding of what software is, and want to hire the cheapest person
they can find to “just build a really simple app.”
• Full Stack Developer seems to beg the question, “but what are you good at?” As I’ve mentioned,
people tend to be incredulous of a candidate who claims to be an expert at every level of the
stack. There’s simply no way a normal person can keep up with everything. And knowing a
single technology at each layer (say, JavaScript, REST, .NET and SQL Server) probably doesn’t
cut it. Sure, those are the technologies in your stack, but someone else’s stack may consist of
Dart, Falcor, Python and Couchbase. You’re not a Full Stack Developer where they’re concerned.
At best you’re a regular Developer who’s willing to learn some new tech.
• (Computer) Programmer is a term that’s gone the way of the dinosaur, along with the
stereotype of the shirt-and-tie-wearing geek in a cubicle. All the word really means¹¹⁸
is someone who knows a programming language. This used to be a rare skill (and only
moderately in demand). But modern software construction demands more than just syntax
and vocabulary—the essential domains of “programming”—because modern software is more
than just a command-line interface and a set of database files on a floppy disk. Apps have to be
beautiful, accessible, user-friendly, fast, and above all, competitive. The word “Programmer”
doesn’t evoke any of that.
• Developer is, as previously noted, an unnecessarily ambiguous title. If your job involves
building condominiums, you’re reading the wrong book. If your job involves computer code,
you should call yourself a Software Developer. Anything built with code is software, so this is
more about clarification than qualification.
• Front End Developer is a very volatile title. Not only does it have almost the highest salary
variability of all the job titles researched, but anecdotally I’ve heard it defined in contradictory
ways. For some people, Front End Developer refers to a person who knows HTML and CSS
but not JavaScript; for others, a Front End Developer is someone who has a deep knowledge of
JavaScript and its most popular frameworks and libraries. The solution, in my mind, is to call
yourself a JavaScript Developer if that’s where your expertise lies, and to call yourself a Web
Designer or CSS Developer if you specialize in HTML and CSS.
The remaining titles differ semantically, but not in ways that necessarily make any of them superior.
You should determine which one best describes your career path:
• Software Developer and Software Engineer are, by many accounts, equivalent. Both mean that
a person knows the best practices in their field, is comfortable with multiple technologies,
and has transferable skills that allow them to recognize and write good code in any language.
These titles also indicate the ability to make smart decisions about software design and
implementation, and a willingness to participate in the software lifecycle above and beyond
writing code (see “Development beyond the keyboard” for more on this topic). Developers and
engineers are creative, thoughtful, knowledgeable people who deserve a place at the table in
¹¹⁸http://chrislema.com/programmer-developer-engineer/
Choosing a job title
121
every discussion about a product. “Engineer” connotes more seniority and preciseness than
“Developer”, so some would say that younger or less credentialed developers run the risk of
sounding pretentious if they bill themselves as Engineers. But considering that the average
salary difference between them is about $14k, I’d recommend using the term “Engineer” as
long as there aren’t any legal barriers to doing so.
• Web Developer is a title that flirts with ambiguity, if less dangerously than Front End Developer.
I’ve seen the term used to mean “a person who builds web applications, including the server
side” or just “a person who knows JavaScript.” But as unclear as it is to industry insiders,
it may be perfect for freelancers who cater to the “just make me a website” clientele. Most
individuals and small business owners don’t understand the complexities of front-end and
back-end; if they hire a developer, it’s to create an attractive single-purpose site that will show
up in Google results. I suspect that Web Developer is exactly what they’re looking for. If you’re
not a contractor, Software Developer may describe you more efficiently (and give you a $15k
bump in average salary).
• Junior and Senior are prefixes that make a big difference in salary. Generally speaking, you’re a
Junior Developer for your first few years or so in the industry, and you’re not a Senior Developer
until a few years after that. But most developers agree that graduating from Junior Developer
to Developer and from Developer to Senior Developer has less to do with the length of your
career and more to do with your humility, leadership, versatility, and experience (especially
the number of catastrophic failures under your belt).
• Software Architect is the most highly-paid job title on this list, and with good reason. It
represents a high standard and has a stable definition industry-wide. The Software Architect is
the ultimate technological resource—the person who’s “been there and done that” so many
times they can practically predict the future. At the last company where I worked, the
Enterprise Architect was equal in status to the CTO. It’s a position of extreme responsibility
and respect. You probably already know if this is you.
• One more title I didn’t investigate in depth is x Developer or x Engineer, where x is a specific
language, framework or technology. For example, I could call myself a JavaScript Developer,
a Vue Developer, or a .NET Engineer, and this would remove the ambiguity about what I’m
primarily good at. I would choose one of the above based on my career goals, or combine two
of them, e.g. Vue / .NET Developer. To look at every kind of x Developer would have increased
the scope of this chapter far beyond its original purpose, but in my opinion it’s the most useful
job title there is for someone who codes. Of course, if you don’t feel comfortable associating
yourself with a specific technology, Software Developer is a totally acceptable alternative.
I hope the data I’ve provided helps you in the process of choosing your job title.
Bibliography & further reading
• The role of a Senior Developer, by Matt Briggs¹¹⁹. This is an excellent take on the skill metrics
that various levels of developers should measure themselves against, rather than composing
job titles based on years of experience.
¹¹⁹http://mattbriggs.net/blog/2015/06/01/the-role-of-a-senior-developer/
Choosing a job title
122
• When should you call yourself a senior developer? on Stack Exchange¹²⁰. A few different takes
on what makes a “senior” versus “junior” developer.
• What’s the difference between Entry Level/Jr/Sr developers? on Stack Exchange¹²¹. Some
worthy additions to the above.
• What does it mean to be a senior developer? on The Guardian¹²². What an above-average set
of qualifications looks like.
• Programmer, Developer, Engineer: What’s in a name? by Chris Lema¹²³. A brief (and fairly
representative) interpretation of the three main nouns in development job titles.
• Developer, Programmer or Engineer? on Stack Overflow Talent¹²⁴. Some survey data and well-
considered quotes from industry insiders.
• Job Titles in the Web Industry, by Chris Coyier on CSS-Tricks¹²⁵. I think the distinctions here
may be a little too rigid, but to ignore Coyier’s take on the subject would be a significant
omission. At the very least, this is a good reference on what various titles should mean.
• What Does a Software Architect Do? by Yegor Bugayenko¹²⁶. This article proposes that
being a software architect isn’t just about smarts or experience, it’s about accountability and
responsibility.
• The Role of Software Architect, by Bredemeyer Consulting¹²⁷. Frames the architect as part
technologist, part business strategist—meaning that the sharpest dev in the company may or
may not be a good fit for the job.
¹²⁰https://softwareengineering.stackexchange.com/q/25564
¹²¹https://softwareengineering.stackexchange.com/questions/14914/whats-the-difference-between-entry-level-jr-sr-developers
¹²²https://www.theguardian.com/info/developer-blog/2014/aug/28/what-does-it-mean-to-be-a-senior-developer
¹²³http://chrislema.com/programmer-developer-engineer/
¹²⁴https://www.stackoverflowbusiness.com/blog/developer-programmer-or-engineer
¹²⁵https://css-tricks.com/job-titles-in-the-web-industry/
¹²⁶http://www.yegor256.com/2014/10/12/who-is-software-architect.html
¹²⁷http://www.bredemeyer.com/who.htm
The DevOps introduction I wish I had
Periklis Gkolias
Buzzwords are common in this industry. They’re used everywhere (sometimes in the wrong way)
and because of that, people are often afraid to ask 101-level questions as they don’t want to sound
ignorant.
Some years ago, my manager asked me if I wanted to do some DevOps work as part of my software
engineer job. Of course, I was young and afraid to ask what that meant so I just said “yeah, let’s give
it a try. Worst case scenario, I will die and you can take a day off to grieve.”
Thank God, I am still alive, as you have probably noticed. So now I want to give you a nice round
overview of the terms I encountered in my initial foray into DevOps and wish I knew back then.
Till not many years ago…
As software engineers, we write software on our computers for other people. And that is problem
number one. The software will eventually have to run on someone else’s computer because the end
user doesn’t have access to our computer. And this is a good thing; imagine the security implications
if anyone could access your computer.
But the end user doesn’t care how well the software works on our computer. They care how it works
on theirs. If we want to do something meaningful and maybe make some money, we have to put our
software out in public.
But who will do this job? Till not many years ago, it was up to the “operations people” of the company.
I might be oversimplifying here, but you can think of them as colleagues from the IT department that
had a technical background but weren’t coders or managers. For example, server administrators¹²⁸
and database experts¹²⁹.
Can you see a problem here? Think about that and I’ll explain in a moment.
DevOps
The DevOps discipline was created to bridge the gap between developers and operations people, the
groups discussed above. The goal is for the transition from a developer’s computer to the public to
be mostly quick, flawless, trackable, and repeatable, with as little as possible manual work. You may
hear this transition referred to as the deployment of the application.
¹²⁸https://en.wikipedia.org/wiki/Server_administrator
¹²⁹https://en.wikipedia.org/wiki/Database_administrator
The DevOps introduction I wish I had
124
Before that, deployments caused constant disagreement and blame between the two tribes. They
were slow and painful and required lots of working hours. This is the problem I mentioned in the
previous section.
The operations people often had no clue why the app couldn’t be deployed even though they were
doing everything they were supposed to do; after all, they didn’t write it or understand the internals.
And the developers were blaming the operations people because “it works on my computer.”
Starting in 2001 there was huge movement (called the Agile manifesto¹³⁰) to improve the way we
produce software and provide it to the public. The DevOps discipline was born as a side effect of
that.
The public
What is this terrifying “public” that led all those poor operations people to exhaust themselves
working overtime? At the time of writing, when people are speaking about deployments, they usually
mean deploying an application to a cloud server so that anyone with a URL (more or less) can access
it.
The cloud? What is the cloud?
When it comes to software engineering, it basically means “another company’s computer.” Giant
companies like Microsoft (with Azure¹³¹), Amazon (with AWS¹³²) and Google (with Google Cloud¹³³)
have thousands of servers running to support their business, as do some smaller companies.
Some of those computers are rented out for others to use and the users (usually companies that don’t
have such high-quality infrastructure and don’t want to buy it) are charged accordingly, based on
how much time they occupy it for. This offers a few advantages and disadvantages, but those are
outside the scope of this chapter.
What is the main problem when deploying to the cloud?
A major problem, as mentioned before, was that there was no guarantee that if a feature was running
on the computer of the original developer then it would run equally well on the cloud.
This can happen because of missing libraries, different library versions between the two machines,
or even because the local computer runs on a different operating system than the server, to name a
few examples.
Running an application in various operating systems
This is actually very common. Let’s say you’re at a company where the CTO used to work for
Microsoft, so having Windows workstations is something they are not willing to negotiate.
¹³⁰https://agilemanifesto.org/principles.html
¹³¹https://azure.microsoft.com
¹³²https://aws.amazon.com/
¹³³https://cloud.google.com/
The DevOps introduction I wish I had
125
Let’s also say one of your major customers is a giant Linux software company. As you can imagine,
they’re guaranteed to have Linux servers on their infrastructure.
What do you do? Do you switch to Linux or make them switch to Windows? Neither scenario is
viable. What if you had hundreds of customers which all had different operating systems in their
infrastructure? How do you make your applications run well for all of them?
There are various approaches to solve this problem. It’s one of the main concerns of not only a
DevOps engineer but also the whole team.
Docker and containers in general
The most popular solution goes by the name “containerization.” Containerization is an approach
where you enclose everything you need (literally everything) in a software “box” (or container) in
order for the software to run smoothly.
The container, for the sake of simplicity, can be thought of like a tiny operating system that runs on
top of your existing one and is completely portable.
You can move a container from computer to computer (and of course to a cloud server). If it works
on one computer, it will also work on another, equally well, with no strings attached. The only
prerequisite is to have the appropriate container technology like Docker¹³⁴ installed.
So for example, in order to solve the aforementioned issue, we could follow this approach (which is
very common):
• Create a container using your preferred operating system.
• Include the source code of our app in the container.
• Include the libraries our application needs, along with any other piece of software our app
relies on.
• Configure the container so that when it is accessed, the app starts automatically.
• Test the application thoroughly from inside the container.
• Once happy, send it to the customer(s). You are now confident that it will work on their side
too, regardless of the operating system they use.
Note: When it comes to Docker, we distinguish between a container and the file that runs inside of
it with the terms “Docker container” and “Docker image.”
Another famous solution is Packer¹³⁵ by Hashicorp¹³⁶. Feel free to read about them and see what
works best for you when the time comes.
¹³⁴https://www.docker.com/
¹³⁵https://www.packer.io/
¹³⁶https://www.hashicorp.com/
The DevOps introduction I wish I had
126
Docker vs. virtual machines
A virtual machine or VM is a standalone operating system that is treated as a normal application by
the host operating system. You can interact with it as if it were your actual environment and forget
about the host.
Yes, Docker¹³⁷ and VMs solve similar problems. They don’t work in the same way though, and
Docker is often the preferred approach nowadays.
The most important differences lie in their size and the way they utilize the host operating system.
For example, Docker is usually much more lightweight and tends to share more functionality with
the host operating system than a VM.
Provisioning
“Provisioning” is another term you might encounter and be too afraid to ask what it is.
In the DevOps context, it means to set up the infrastructure needed for an application to work. This
work is often automated and done in the cloud.
So if someone wants to provision a test environment, they probably have to allocate some server
space in order to put the containers inside and run them. If done manually, this can be a tedious
process.
Thankfully, there are provisioning tools on the market that do the job for you fairly easily, or at least
with minimal input (apart from the initial configuration).
Continuous Integration and Continuous Delivery (CI/CD)
Those two terms refer to an organization’s need to know if newly-written code has problems and if
not, to be able to send it to the customer in an automated way, whenever they want. It’s a common
practice and you should have a high-level understanding of it.
Here is how this works:
• You create a new feature requested by a customer.
• Your code gets reviewed and tested by members of your team.
• You add your changes to the code that will be delivered to the customer (the “release branch,”
as devs call it).
• An automated process notices what you did and starts doing various things with the new
version of the app, like trying to compile it, run any automated tests, and (you guessed it)
prepare your Docker image. This is the “Continuous Integration” step.
• If everything works, the process sends this image to the customer’s servers. This is the
“Continuous Delivery” step.
¹³⁷https://www.docker.com/
The DevOps introduction I wish I had
127
Some of the most well-known CI/CD tools are Jenkins¹³⁸, Travis¹³⁹, and Bamboo¹⁴⁰.
Tips for the future
Before closing this chapter, I would like to give you a couple of tips that you might find helpful
during your first years in tech.
• If you don’t understand something, Google it. If you can’t figure it out easily, ask. No one
expects you to know everything and you never have to. If someone has told you otherwise,
you’re in the wrong company.
• Automate as much as you can. Anything that has to be done manually is error-prone and far
more time consuming.
• Never stop learning. DevOps is a great field and is evolving rapidly. You need to keep your
knowledge up to avoid becoming outdated or obsolete.
¹³⁸https://jenkins.io/
¹³⁹https://travis-ci.org/
¹⁴⁰https://www.atlassian.com/software/bamboo
A coder’s code of ethics
Isaac Lyman
Code can do amazing things. We’re all the beneficiaries of it: computers, cell phones, the internet,
MRI machines—it’s hard to imagine a world without software.
Code can also do bad things. It can lie, steal, murder, surveil and discriminate. In fact it’s done
all of these things, wielded by programmers like you and me, programmers who sometimes didn’t
understand what they were being asked to do and other times didn’t care. Unless you’re very lucky,
at some point in your career you’ll be asked to develop a feature that seems questionable or even
just plain wrong. What will you do?
Will you rationalize it to yourself? It’s not like the feature was your idea. Your bosses sign the
paychecks, so they call the shots. It would be them in trouble, not you. Right?
Or will you take a stand? You’re not some mindless soldier.
The decision is up to you, but you may find that “I was just following orders” isn’t a very good
defense in a courtroom, much less against your own conscience.
Several writers have considered the need for a code of ethics in programming. In my research for this
chapter I studied the Hippocratic Oath, perhaps the most famous ethical code in any profession. Its
ideals include knowledge-sharing, humility, and good citizenship. (If you’re interested, check it out
on Wikipedia¹⁴¹.) These are great things to start with, but there is much more to discuss. Following
are some of the things to watch out for as you strive to be an ethical programmer.
Privacy
Privacy advocates have been railing against Facebook since the beginning¹⁴². Even the News Feed,
which we now take for granted, was once seen as invasive—and one reason we take it for granted
is because much bigger problems are rocking the social media platform on a regular basis, like the
still-fresh Cambridge Analytica scandal¹⁴³. And Facebook isn’t the only company in the doghouse:
Google¹⁴⁴, Amazon¹⁴⁵, Uber¹⁴⁶ and many others have spent time in the news for failing to protect
user data.
How did they go so wrong? There are a few factors at work here.
¹⁴¹https://en.wikipedia.org/wiki/Hippocratic_Oath#Modern_versions_and_relevance
¹⁴²https://www.nbcnews.com/tech/social-media/timeline-facebook-s-privacy-issues-its-responses-n859651
¹⁴³https://en.wikipedia.org/wiki/Facebook%E2%80%93Cambridge_Analytica_data_scandal
¹⁴⁴https://en.wikipedia.org/wiki/Privacy_concerns_regarding_Google
¹⁴⁵https://www.washingtonpost.com/technology/2018/12/20/amazon-alexa-user-receives-audio-recordings-stranger-through-human-
error/?noredirect=on
¹⁴⁶https://www.theverge.com/2017/8/15/16150902/uber-ftc-complaint-mishandle-privacy-data
A coder’s code of ethics
129
First, collecting user data is incredibly easy—you can collect a user’s name, phone number, home
address, government ID number or anything else they’re willing to give you in only a few lines of
code. Storing and retrieving data is so essential to computer applications that enormous sums of
money have been spent engineering APIs and platforms to make it easier. It’s almost the default
thing to do in most cases, only a couple steps behind displaying words on a screen.
Second, protecting user data is much harder, requiring both expertise and intent. In order to prevent
a password from being stolen, you have to know at least a few things about databases, cryptography,
one-way hashes, and secure transmission. And then you have to apply them consistently across an
entire system, no matter how large or complex it becomes. An application’s security is only as strong
as its weakest point, so this requires continuous investment. And security is generally inconvenient;
if a customer calls in because they forgot their password, it may seem easier to just tell it to them
rather than making them follow a password reset process over email. But no secure system will ever
allow you to see their password, let alone tell it to them.
Third, for businesses, “hard” and “expensive” are synonyms. And if no one in leadership is willing
to make a principled stand, a corporation will always choose money over human rights. This is
exacerbated by the fact that user data is worth a lot on the open market. Advertisers will do almost
anything to obtain people’s private information, and much of the software we use (especially free
software) is wholly dependent on advertising.
These factors in combination make a perfect storm: it’s cheap, easy, convenient, and profitable to
collect oodles of user data and store it practically in the open. And the consequences, although
certain, are never immediate. It’s easy to forget that there are consequences at all.
Ethics demands more of us. As programmers, we should refuse to collect more data than our
applications need. We should take users’ trust seriously and protect what they give us. We should
be sensitive to the kinds of data that are especially private and be especially diligent in protecting
them. We should educate ourselves in security best practices. When hackers come looking for easy
pickings (and they will) we should be confident that they’ll leave empty-handed.
Preventing bugs and outages
Most software is “line of business” software: applications people use on a daily basis to do their jobs.
When you write this kind of application, you’re holding a workforce’s productivity in your hands.
A bug, outage, or unnecessarily slow algorithm can cost someone several working days. That’s a lot
of responsibility.
Additionally, you probably know the frustration of buying an app or video game only to find that
it doesn’t work very well—maybe there are tons of bugs, or the servers go down a lot, or it loses
all your data for no reason. You feel cheated, and rightly so. The developer made you an unspoken
promise when they sold you the software, and now you’re left to deal with their carelessness.
Some software does damage when it works. Most software does damage when it’s broken. There
are many things we can do to avoid shipping broken software, but in general we should test every
release ahead of time with the assumption that it’s broken in some way. Then we should fix it before
A coder’s code of ethics
130
releasing. Automated tests, quality assurance, redundancy, monitoring, and automated rollbacks can
help reduce the frequency and impact of severe bugs (see Appendix A for definitions of these terms).
There’s a huge difference between teams that take this seriously and teams that don’t. And it isn’t
always the developers’ fault; if your boss is setting impossibly tight deadlines, making you work
overtime, or demanding you ship new features as quickly as possible, everything is going to be
broken every day. You simply won’t have the time or energy to keep your software bug-free. A
company that runs like this is in serious trouble. But in most situations, you can make a difference
by advocating for quality assurance and testing best practices. And this helps you keep your promises
to your users.
Avoiding dark patterns
A “dark pattern” is any feature of a user interface (UI) intended to trick users into doing (or not
doing) something. Many dark patterns rely on users not paying close attention to every detail and
every block of text in an application—and seriously, who does? If you’ve ever opted into something
you didn’t want because there was a “big green button,” or accidentally clicked an ad when you
were trying to make it go away, you’re the victim of a dark pattern.
The first rule of UI design is “users don’t read” (or, alternately, “users don’t think”¹⁴⁷). This can be
an inconvenience—we can’t just use paragraphs of text to tell users exactly what to do. We have to
make it obvious what the user should do through the careful use of color, contrast, sizing, positioning,
and iconography (and yes, text, but usually only a word or two at a time). This is hard, which is
one reason why designers are so valuable. But generally a dark pattern isn’t the result of a simple
oversight or design mistake. It’s an intentional attempt to take advantage of users’ trust in order to
hijack their time, attention, or wallet. And it’s incredibly common.
File sharing and download sites are full of dark patterns. Sometimes there are so many “Download”
buttons it’s nearly impossible to figure out which ones are ads in disguise and which one is real.
And many news and media sites are almost as bad, with so many ads and newsletter signup forms
you can’t see the content you came for. But even the most well-known sites on the web—Facebook,
LinkedIn, and TurboTax, for example—are notorious for their use of dark patterns to get users to
give up personal information, share contact lists, or pay for a service advertised as free.
Another kind of dark pattern relies not on tricking the user into doing something they don’t mean to,
but on making it difficult to do something they do mean to. Several major brands—like Blue Apron,
Marriott Hotels, and the New York Times—have recently been called out for making it incredibly
hard to unsubscribe from their emails or services, often requiring a lengthy phone call and identity
verification even though they allow you to sign up online with only a few clicks. If that isn’t bad
enough, most advertisers and data brokers will collect information about your internet browsing
habits without your permission or knowledge, effectively “signing you up” for a service you didn’t
even know existed—and you usually can’t close your account with them, regardless of how much
you may want to.
¹⁴⁷http://sensible.com/dmmt.html
A coder’s code of ethics
131
We may not be designing the apps we write, but we should still insist on ethical design standards.
There’s no excuse for employing underhanded tactics to trick our users or trap them into an
arrangement they want to leave.
Impartiality and accessibility
We’re tempted to think of computers as completely unbiased and objective, but this assumption
is problematic: it leads to systems that perpetuate our own biases and those of the world around
us. Computers may not be born with an understanding of racism, sexism, ableism, or classism, but
unfortunately, you can’t avoid bias just by being ignorant of it.
Our default approach to algorithms that deal with people may be to treat each of them as a data point,
completely equal in the eyes of the code. But this lofty ideal falls apart as soon as we introduce a
user interface, business logic, or artificial intelligence. Technical equality is not the same as fairness.
A blind user and a sighted user might be treated as equal data points by our code, but if we don’t
build accessibility into our UI, the blind user will be unable to use the software. Our equality is their
disadvantage. This isn’t the computer’s bias, it’s ours, manifested in code.
An application’s database might not store information about sexual identity, race, or social class, but
due to differences and biases in the real world, the software can effectively discriminate on any of
these bases by making assumptions about the user’s physical size, sexual preference, skin contrast,
living arrangements, or access to a cell phone.
Artificial intelligence is especially prone to bias. Amazon learned this the hard way¹⁴⁸ in 2018, when
it tried teaching an AI to select job candidates similar to the people they had already hired. The AI
quickly learned that most of their employees were men, so it started discounting resumes with the
word “women” or the names of certain women’s colleges on them. This was an egregious case of
sexual discrimination. But AI can be even more insidious, using much less obvious data points as
proxies for race and sex. Something as innocuous as a zip code can enable discrimination unless
careful controls are in place.
It’s our job to watch for and avoid these issues. And we’re likely to fail unless we have people on
our development teams who don’t look like us—people of other races, sexes, levels of ability, and
socioeconomic backgrounds. A combination of awareness, diversity, and broad user testing is the
best way to ensure our applications are truly impartial and accessible to all kinds of users.
Do no harm
The famous phrase primum non nocere (“first do no harm”) is a core tenet of the medical profession.
It should also be a tenet of ours. It’s important to consider the human cost of every development
project. Some software, whether by design or by lack of foresight, does harm in real and immediate
ways.
¹⁴⁸https://www.aclu.org/blog/womens-rights/womens-rights-workplace/why-amazons-automated-hiring-tool-discriminated-against
A coder’s code of ethics
132
Weapons are a case in point. No modern missile takes flight without a team of engineers behind
it. That’s a heavy responsibility, to write code knowing that it will end lives. No one would blame
you for refusing to be part of such a project. The ethics of military force are a topic of debate, but
wherever human casualties are involved, we’d better be prepared to account for our decisions.
Malware is a more clear-cut example: few of us would attempt an ethical argument to justify the
creation of viruses and ransomware. Yet malware is a fixture in the modern world, a constant threat
to our digital well-being. WannaCry¹⁴⁹, a piece of ransomware that made headlines in 2017, infected
thousands of computers throughout Great Britain’s National Health Service and forced hospitals
to turn some patients away. It also halted production at certain factories and automotive plants.
Thanks to some high-quality security research and a few lucky breaks, the impact of WannaCry was
relatively low. But it’s easy to imagine a much worse scenario: unusable MRI machines, hundreds
dead from health complications, frozen supply chains, mass layoffs, abrupt economic collapse in
some sectors, and so on. The creators of WannaCry appeared to be spreading it for their own financial
gain, requesting a few hundred dollars per victim. But there are credible allegations that they were
agents of the North Korean government, which makes the attack a potential act of war.
Make no mistake, you don’t need to be programming a ballistic missile to be dealing with life and
death.
Of a less catastrophic nature (but still decidedly bad) is software that uses your computer’s
resources in ways you wouldn’t appreciate, like 2018’s spate of cryptojacking¹⁵⁰—a word describing
applications that secretly use your processor to mine Bitcoin, enriching their creator while leaving
you with an inflated electricity bill, wear and tear on your hardware, and a slower computer. This
is more petty theft than high crime, but that doesn’t make it victimless.
Perhaps the trickiest time to apply “do no harm” is when we’re making tools that rely on user-
generated content. Twitter and Facebook, for example, are irreplaceable parts of many peoples’
personal and professional lives. The amount of good-natured media and humor generated daily on
the sites is impressive. But they’re also used daily to harass women, LGBT people, and people of color.
They’re used to encourage acts of group violence and suicide. They’re depressing and addictive¹⁵¹
to users. There are tools that allow users to report the worst cases of abuse, but moderation is spotty
at best—and the people who do it suffer severe mental and emotional consequences¹⁵². In these
circumstances, we’d be justified in asking if social media should exist at all.
Even in the simplest of situations “do no harm” is an essential standard. Any software that helps a
doctor do their job, even something as innocuous as a file-sharing server or document editor, can
become urgently important in a patient’s life during a medical crisis. A bug or bad UX could lead
to injury or death. The same goes for air traffic controllers, taxi drivers, manufacturers—even small-
time retailers stand to lose a great deal if their software is broken. Regardless of what you’re building,
the user’s worst case scenario may only be a few lines of code away.
These are concerns you should take with you to each job interview and each project. We should insist
¹⁴⁹https://en.wikipedia.org/wiki/WannaCry_ransomware_attack
¹⁵⁰https://www.nbcnews.com/tech/tech-news/your-computer-could-be-quietly-mining-bitcoin-someone-else-n922101
¹⁵¹https://www.marketwatch.com/story/new-study-claims-facebook-instagram-and-snapchat-are-linked-to-depression-2018-11-09
¹⁵²https://www.cnet.com/news/facebook-content-moderation-is-an-ugly-business-heres-who-does-it/
A coder’s code of ethics
133
on writing applications that are reliable, make the world better, earn users’ trust, and are thoughtful
about the ways they allow people to interact.
The golden user story
I often hear stories of CEOs who refuse to let their kids use software produced by their own
companies. And this illustrates perhaps the most essential principle of all: if you wouldn’t want
an app to do something to your child or significant other or friend, then don’t make that app.
We have the ability to make software that enriches lives and creates opportunities. And as Marc
Andreessen famously said, software is eating the world. We, the next generation of programmers,
can decide what the future looks like. It all depends on the code we write today.
Software development beyond the
keyboard
Isaac Lyman
One of the greatest paradoxes of software development is the relative unimportance of code. As
engineers we study code, we teach about code, we agonize over code, we go to conferences
and debate each other and dream vivid dreams about code. Yet there is no line of code in any
programming language that will make a company profitable or an idea successful. Applications are
of course valuable, and largely responsible for the experiences that shape the modern world, but
most applications could be equally useful if they were written in a different programming language,
under a different paradigm, using different techniques and algorithms. There are infinite ways to
write a program. Sometimes one way is faster than another, sometimes more readable, sometimes
more error-resistant. But usually it’s just different.
In many people’s minds, then, the difference between a good developer and a great developer
isn’t about how quickly or correctly they write code. It’s about skills beyond the keyboard:
communication, leadership, reasoning. Following are a few skills you can learn to raise your value
in the workplace.
Asking hard questions
Code hates ambiguity, which is one of the main reasons coding is hard. If you want to code an
idea, you have to convert it to an algorithm, which requires imagining it on a deep level: what are
the steps from beginning to end? How will you accommodate different users, different privileges,
different devices? How will the application know what it needs to know? What if something goes
wrong? What if the user does something unexpected? What if a hacker is trying to get in?
CEOs and managers usually think about products and features on a high level (and they should).
They’ll say something like “we need a button that lets people export their data as an Excel
spreadsheet.” They see this feature as if it were under a spotlight in a dark room; it seems so simple.
Your job as a programmer is to listen to them, stand in the spotlight with them and understand their
vision, and then grab a flashlight and explore the dark, dusty corners of the room. What should
the spreadsheet be called? What columns should it have? Does it need access controls? Should the
application warn the user if their data is empty, or corrupt, or larger than 100 megabytes? Is Excel
even the best way to handle this kind of data? Would a CSV file be acceptable instead, since it’s
easier to generate?
Sometimes the questions need to dig even deeper. Is this feature worth two months of our team’s
time and effort? What problem are we actually trying to solve (see Appendix A, “XY Problem”)?
Software development beyond the keyboard
135
Are we sure this will solve it? Are customers asking for this? What problem are they trying to
solve? And so on. Some questions you can answer on your own, but many will need to be discussed
by management. Sometimes you’ll have to explain your question several times before anyone
understands it. Sometimes they never will, and you’ll need to ask a different one.
This may not be coding, but it’s software development in the truest sense. It’s part of the painful
but necessary process of making software real, and it’s something that can only be done by people
like us: people who are methodical and thoughtful, people who see the smallest details and sense
problems before they happen. It’s a talent that runs strong among coders, and one you can develop
if you haven’t yet.
As a new programmer, you may feel nervous about asking questions that risk putting your lack of
experience on display. It’s normal to feel that way, but don’t let it silence you. If you prefer, you can
take the questions you’re most insecure about to your dev lead, mentor, or manager, one-on-one.
But keep in mind that your inexperience is in many ways an asset—you have a fresh perspective
and haven’t developed the same blind spots that many of your senior colleagues may have. And
even the most senior of programmers asks a dumb question now and then.
Contributing to UX and feature discussions
Some managers see developers as nothing more than code-producing machines, relegating them to
the last step in a lengthy design process. This often backfires. Without a developer in the room, it’s
difficult to know what is easy and what is impossible, what adds complexity and what reduces it,
what it costs to build something good enough versus perfect.
Developers are master problem-solvers. Coding is, after all, an exercise in working with constraints,
tradeoffs, and outcomes. The best companies recognize this skill and ask for developers’ input
throughout the entire product development process, from design to delivery.
If you can, take the opportunity to sit in on high-level product discussions. If you pitch in now and
then with “that’s an expensive feature—could we do it like this instead?” or “that’s a great idea, but
it will take some effort. Could we validate it with a few users first?” or “that’s simple, I can build it
in an afternoon,” you’ll quickly find yourself indispensable in the process. This is perhaps the place
where your skills make the biggest difference: not hunched over a keyboard, staring at an IDE until
your eyes blur, but at the table with product managers and executives, representing the possibilities
and limitations of code as everyone plans ways to improve customers’ lives.
Talking to users
A famous moment in the tech world occurred in 2001, when a group of 17 software professionals
gathered in Utah, USA, and agreed on a set of core principles to guide the development of software
in the Internet Age.
…we have come to value:
Software development beyond the keyboard
136
Individuals and interactions over processes and tools
Working software over comprehensive documentation
Customer collaboration over contract negotiation
Responding to change over following a plan
∼Manifesto for Agile Software Development
The last two values, “customer collaboration” and “responding to change,” point to one of the most
important processes a software company can adopt: regularly speaking to customers about their
needs, then updating priorities and plans to accommodate them better. Companies that fail to do this
may produce high-quality software but most of the time it won’t be very useful. Developers spend a
lot of time worried about “building things wrong”—writing bugs or misunderstanding specifications,
for example—but an even bigger problem is “building the wrong things.” If your app doesn’t solve
my problem, I don’t care if it’s the most beautiful and bug-free app in the universe.
As a developer, you could argue that it’s not your job to speak to users and gather feedback. The
problem is that in too many organizations, nobody thinks it’s their job (although good UX designers
or product owners will usually take it on). In reality it should be everyone’s job: every part of the
process exists to provide a better experience for users, so everyone has a stake in understanding
them. For a deeper discussion of this topic, see Edaqa’s chapter “You are an interpreter”.
Writing documentation
Poor, out-of-date or nonexistent documentation is the status quo for much of the tech industry. This
causes endless headaches for managers. When a developer leaves after a long employment, they
take knowledge with them that no one else has. When a new developer joins the team, it takes them
months to get up to speed. When two teams work together, they end up spending tens of hours
sharing knowledge face to face. Even in a small company with low turnover, “mental turnover” is
still expensive—I don’t remember the details of what I was working on a year ago, do you? It might
as well have been another life.
If you know how to write clear and organized documentation, you can reduce these expenses
dramatically. Documenting the setup process for new developers can help a recently-hired teammate
contribute much sooner. Documenting the architecture of a system and its core assumptions and
constraints can create an invaluable roadmap for developers tackling complex issues. Creating an
FAQ for bugs or error messages that frequently appear can save your teammates days of unnecessary
debugging. Whenever you or one of your teammates asks “how does that work again?” that’s a sure
sign documentation is needed.
Writing is hard, so don’t be afraid to take the easy route: use lots of bullet points, throw in a drawing
or diagram here and there, overexplain things a little, and ask your team to review and edit what
you’ve written.
One of the most powerful and respectful ways to leave your job is with a digital stockpile of excellent
documentation behind you. Once you give notice, insist on taking the time to write things down:
Software development beyond the keyboard
137
everything you built alone, everything you were the expert on, everything people asked you to
explain on a regular basis. Your coworkers will be thanking you until long after you’re gone.
Code design
Speaking of documentation, one of the best ways to develop both faster and smarter is to plan
out your solutions ahead of time. At a previous job, we called this a “dev design.” The developer
assigned to a task would write a summary of the code they planned to write, including a breakdown
of sub-tasks, a list of every file they planned to change, method signatures, class and field names,
table schemas, and—for especially tricky situations—even a few lines of pseudocode (see Appendix
A for definitions of these terms). Then they would take 20 minutes to review it with the team. This
was the most productive meeting of our day. More often than not, we’d save each other hours of
development time by saying things like “we already have a class that does that, we can reuse it” or
“that’s a tricky procedure, watch out for race conditions” or “I don’t think that’s what was intended
with that feature, let’s talk to our manager and clarify it.”
At that company, we further justified the time spent on dev designs by doing away with formal code
reviews. If our dev design turned out to be inadequate once we started coding, we would update
it and notify the team. This way, the actual code being written was never a surprise—it was “pre-
approved.” Replacing code reviews may not make sense for most teams, but when building new
products and features, I tend to believe that code design ahead of time is more valuable than code
review after the fact. Of course, it doesn’t have to be an either/or situation. On my current team we
do both.
Even if your team isn’t friendly to the idea, doing code design on your own has compelling benefits.
It helps you avoid rewrites by making sure all the parts of your solution work together conceptually.
It helps you find blockers sooner, so you can stay productive while they’re being resolved. It gives
you a record of why you coded things the way you did, so in six months when you’re refactoring
or extending a feature, you can remember the constraints you were working with.
Development isn’t just code
To call yourself a software developer is to claim the whole development process as your own. Don’t
forget that code is only one step of many in that process, and it’s near the end. Becoming proficient
in the other steps will make you a more well-rounded and valuable asset at every job you take.
Code reviews
Rosalind Thuy Pham
What is a code review?
Code Review is an activity performed by developers after finishing a feature or bug fix. A developer
requests a review from their peers. Depending on the impact of the code to the current code base, it
may require more than one developer to review.
Why do we do code reviews?
In software development, an application is broken down by features. A feature can be isolated or
depend on another feature. To ensure each feature is added without defects or side effects, developers
request a code review from their peers or voluntarily review each other’s code.
In most cases, reviewing code means validating and checking for code quality violations. However,
in many collaborative companies, code review is also seen as a way to share domain knowledge
within a team. Through code review, senior developers can share high-level understanding with
junior developers to avoid duplicate code and improve performance. Junior developers can also
review others’ code. It’s an excellent chance to see how others have applied code guidelines and to
learn best practices.
Who should review a junior developer’s code?
Any developer on their team. If the code is implementing a new feature, the junior developer should
pick a senior developer who recently worked on a related area of the code. Early involvement of a
senior developer can make the code review go more smoothly. If the code is a bug fix or improvement,
like a typo, missing variable, or wrong type, the reviewer can be any available team member.
How should you review someone’s code?
Ideally, the developer who wrote the code and their peers should have discussed the feature or bug
fix and designed the overall solution before the code was written. Understanding the context and
conceptualizing the solution are far more important than making the code pretty. Good planning
helps to avoid wasted time and effort if the requirements change or a solution already exists.
There are many possible solutions to most problems. At this point, reviewers and code authors should
feel that they both understand and agree on the chosen solution. Next, they should both agree on
the logic of that solution.
Code reviews
139
When viewing the code for the first time, reviewers refer back to the written product requirements to
get some context around the code and use a diff tool to identify the logic of the solution. For example,
say the solution is an input field for a user to type their name. The logic could be a function which
captures each key press and its value. This is a simple example, but the logic of a solution can span
multiple functions in different files. Reviewers should ask questions or leave comments based on
their impression of the code.
For many junior developers, this might be their first time receiving feedback on their work.
Therefore, some questions and comments may sound more sarcastic and offensive than they are.
Here are some example questions:
• “Why do you need these?”
• “I don’t think it makes sense to add this line.”
• “I don’t understand what this function is trying to do.”
Discussing someone else’s work is not easy, and not all developers are excellent communicators. My
best advice for junior developers is to focus on what you’ve learned at the end of the day, not what
people might think about you. The fact is the more feedback you receive, the more you learn, and
the better you figure things out. It’s hard to take criticism, but it’s better than no feedback at all.
The developer who submitted the pull request (the author) should read and respond to each question
and comment. If necessary, the author and reviewers can have a discussion in person, over the phone,
or while pair programming to explain the solution to reviewers.
At the end of this step, the author and reviewers should agree on the logic for the solution. With the
logic-first approach, the reviewers may remember some existing logic and suggest that the author
reuse it. In a smaller code base where there isn’t much existing logic, the reviewers might suggest
making a piece of code more generic so other developers can reuse it in the future. Everything other
than logic, such as typos and naming conventions, reviewers should note and save for later.
After reviewing the logic, reviewers should pull the code, run tests, and check for errors. After
resolving errors, the author should write new tests to cover those error cases. Reviewers should
double-check for basic mistakes such as syntax errors and infinite loops. After all tests are passing,
the author should revisit earlier feedback for any refactoring suggestions and improvements, such as
removing dead code or adding documentation. Before asking for another round of review, the author
should also validate their code with the team’s code guidelines. Here are some standard things to
check:
• Are function and method names clear and descriptive?
• Is the code consistent across different files?
• Do functions accept the same types of parameters and behave the same every time they
execute?
At this point, authors who are junior developers might ask their reviewers about ways to optimize
and improve code performance if needed.
Code reviews
140
Once each step has been completed—planning, reviewing logic, fixing bugs, and refactoring—the
process is complete and the code is ready to merge.
Appendix A: A coder’s vocabulary
Following, in alphabetical order, are some terms that are commonly used among software developers.
You may have learned some of them already. Note that these definitions aren’t intended to be
comprehensive, but rather to help you understand and participate in online and offline conversations
about code as quickly as possible. Many of them are based on the most common situations and may
not apply to every company or tool (e.g. the definitions relating to version control are specific to Git,
the most popular version control system).
Agile - A philosophy for creating and releasing high-quality software gradually (as opposed to
Waterfall, where software is delivered all at once). Even though the entirety of the Agile manifesto is
available online (https://agilemanifesto.org/¹⁵³) and takes less than ten minutes to read, most people
in the technology sector severely misunderstand it or ignore it altogether. If a company says they “do
Agile,” this generally means that they have a lot of meetings and sell subscriptions to their products,
not that they follow Agile principles like valuing simplicity and trusting their developers. Agile is
one of the most popular buzzwords in the technology sector.
Algorithm - A set of steps for doing something. An algorithm is the concept that drives a piece of
code, not the code itself.
Antipattern - Something that seems like an easy or obvious solution to a problem, but has hidden
negative consequences. In other words, “lots of people do this, but it’s a bad idea.” Be wary of
developers who use this to describe any pattern they dislike.
Application Programming Interface (API) - All the parts of a piece of software that are public in
a given context - for example, if you’re coding something that uses the software, the API is all the
parts you can refer to from your own code. The commands in a programming language are part of
its API. The methods you import from a third-party library are part of its API. If you write a web
server, all the methods that can be accessed via an HTTP request are part of its API. In your own
software, every public method and field you create is part of the internal API.
Argument - see “Parameter”.
Array - A collection of one or more pieces of data, together in the same group. An array can be as
simple as [1, 2, 3] or much more complicated—arrays can contain objects or even other arrays.
Assign - To set or change the value of a variable.
Associative array - See “Object”.
Asynchronous (async) - Refers to processes that don’t necessarily happen in order and could finish
at any time (or not at all). Different coding languages handle this in different ways, but usually
¹⁵³https://agilemanifesto.org/
Appendix A: A coder’s vocabulary
142
by letting you give them a function to execute when a process is finished, and another function to
execute if the process throws an error.
Automated test - A piece of code that executes another piece of code and makes sure it does what
it’s supposed to do. Automated tests include unit tests, integration tests, and end to end tests, among
others.
Back end - The server in a web application. This includes the database and all the server-side code.
Many developers specialize in back end development.
Best practice - Any standard that a group of experts have decided is the “best way” to do something.
Knowing the best practices of a programming language, framework, or business process can help
you develop quickly and avoid expensive mistakes. It’s also valuable to know when to ignore a best
practice in favor of something that’s faster or more practical.
Big O notation - A way of measuring the efficiency of an algorithm, like sorting an array or
retrieving data from an object. In Big O notation, O represents a function whose output is the amount
of time (or space) it takes to run the algorithm, and n represents the number of items the algorithm
is operating on. Since every computer is different, we don’t measure in absolute units, but for the
following examples I’ll use seconds. O(n) could mean “this algorithm will take 1 second to operate
on 1 item, 2 seconds to operate on 2 items, 3 seconds to operate on 3 items, and so forth.” You can
think of it as a line graph, like y = x. And O(2n) would mean the algorithm will take two seconds to
operate on each item. O(1) would mean the algorithm takes the same exact amount of time regardless
of how many items it operates on—this is usually the best case scenario. And O(n²) would mean the
algorithm takes as long as the number of items squared—this is one of the worst case scenarios, since
the algorithm will get exponentially slower as the number of items increases linearly.
Blocker - Anything outside of your control that is preventing you from moving forward with your
work. Blockers are a common topic of standup meetings.
Branch - One copy of a repository that can be worked on without affecting everyone else’s copy.
This is managed via version control. When you’ve finished doing a piece of work in a branch, you
merge it back to the main branch (the “trunk”). “Branch” can also refer to a logical possibility in a
piece of code—if a piece of code has an “if” statement, one logical branch is the code that executes
if the statement is true, and the other logical branch is the code that executes if the statement is
false.
Boolean - A data type that contains either true or false. A boolean variable is also called a bit or
a flag. Booleans are one of the most essential and useful data types.
Bug - When an application doesn’t behave the way it’s expected to. This is almost always due to
a mistake made by a developer while coding the application, or a miscommunication from their
manager when describing the requirements for the application. On rare occasions it’s due to a
deficiency in the programming language itself. Bugs are common and developers learn to expect
them in every piece of code. The term “bug” was coined by programming pioneer Grace Hopper, who
once traced a malfunction in a computer program to an actual moth trapped in an electromagnetic
relay.
Appendix A: A coder’s vocabulary
143
Build - A compiled version of a codebase, or the process that compiles it and prepares it for delivery
to the user or production server.
Caching - A way of speeding up access to data by storing it in memory. Generally, anything you
assign to a variable in code is cached, and retrieving it from that variable is much faster than reading
it from a database or a remote API call. Back-end developers tend to use caching liberally, since
memory is cheap and cached data scales extremely well.
Character - A letter, number, symbol, space, or other indivisible piece of a string. Some programming
languages have a specific data type for characters and represent strings as arrays of characters.
Class - The blueprint or instruction manual for an object. You can use a class to create an object,
usually with the new keyword. The class tells you what data the object can hold and what methods
it has.
Clean code - Code that has minimal dependencies and is easy to read, well-tested, and error-
resistant. Truly clean code is a standard that isn’t often achieved in the real world. The best
developers strive for this ideal in a pragmatic way, improving existing code while making realistic
compromises.
Client - In a web application, the computer on the user’s side (as opposed to the server). Can also
refer to an application that communicates with another computer over the internet.
Cloud - A general term for computers or servers that are owned by someone else and only accessible
via the internet, usually paid for by the consumer on a monthly basis. Your emails and Dropbox files
live in the cloud, as do most websites.
Codebase - All the code in a project or repository, or any collection of interconnected files that
together form the source code of an application.
Code quality - A measure of the usefulness and readability of a piece of code. See the chapter “Steps
to better code”.
Code review - When one developer reviews another developer’s code and provides feedback.
Code smell - A behavior in code that isn’t necessarily wrong, but is an obvious red flag for low-
quality code or hidden bugs. For example, a variable named x is a code smell, not because it doesn’t
work, but because it doesn’t describe what the variable contains and could easily be misinterpreted.
Code style - A matter of preference in how code is formatted. Code style includes topics like tabs
versus spaces, maximum line length, and bracket placement. Code style doesn’t matter much but is
still hotly debated on some teams. Ideally, a development team should set up an auto-formatter with
rules chosen by any arbitrary method. As a developer, you should conform to the style conventions
of whatever team or project you’re working in.
Command Line Interface (CLI) - Often called a “console.” A CLI is a text interface for using software.
The user (often a programmer) types a command and presses Enter, and the software responds and
puts the result on the next line. Bash, Powershell, Command Prompt on Windows, and Terminal on
Mac are popular examples of CLIs.
Commit - See “Git”.
Appendix A: A coder’s vocabulary
144
Compile - To transform code into lower-level code, like turning C++ code into machine language.
One way or another, this has to be done before the code can execute. Many programming languages
come with a compiler that does this transformation quickly and efficiently. Compilation is often
done ahead of time, before the software is released to users, but some languages have “JIT” (Just In
Time) compilation that happens while the software is being used; still other languages are interpreted
rather than compiled (See “Interpret”). Depending on the language and the environment it runs in,
a combination of compilation techniques may be used.
Concurrency - When multiple things can happen at once in code.
Constructor - A class method that is called the moment a new object is created. The constructor is
usually in charge of assigning default values to the object’s fields and setting up its dependencies.
Continuous Integration (CI) - On a software development team, the practice of merging each
developer’s code to a shared repository frequently and testing it after each merge. Any CI tool on
the market will allow you to automatically compile new code and run unit tests on it whenever it is
merged, then notify the development team if the tests fail.
Continuous Delivery (CD) - The practice of making sure a piece of software is always ready to
release, and releasing it frequently. This requires a little extra work to make sure that half-finished
or untested features aren’t released by accident. This can be done by hiding unfinished work behind
feature flags or by releasing a feature gradually in small but fully-implemented layers.
Convention - Tradition. Programmers speak of “the conventional approach” or “style conventions,”
by which they mean “the way things have always been done around here.” Here in this phrase could
mean your company, your city, a programming language, or the field of computer science as a whole.
Sometimes conventions are a useful shortcut to code and techniques that have stood the test of time;
other times, they’re obstacles that prevent you from seeing a better way to do things.
Create, Read, Update, Delete (CRUD) - Some of the most common behaviors in interactive
applications. A word processor app, for example, will have the ability to Create, Read, Update or
Delete documents. An app with little to no logic other than what’s required to store and retrieve
data is often described as a CRUD app.
Culture fit - This can usually be understood as “someone who looks or talks like us.” When a
company’s culture isn’t well defined, this is too often used to shut out job candidates for personal
reasons that have no correlation to competence or success in a given role. Using job interviews
as a chance to communicate specific cultural values, such as teamwork, inclusion and tactfulness,
can reverse these negative effects and produce “culture add” candidates who preserve a company’s
values while increasing diversity and reducing bias.
Data - Any piece of information that a computer can keep in its memory. Numbers, dates, strings,
booleans, and objects are all examples of data.
Database - A set of data stored in memory, usually on a hard drive. Applications almost always
have some kind of database where they store data they’ll want to use later. For example, an app can
store the name and email address of every person who signs up to use it.
Appendix A: A coder’s vocabulary
145
Dead code - Code that is unreachable; that is, it can never be executed. For example, if a function
is never called, or if code appears after a return statement, it’s considered dead code. In some cases
your IDE will automatically find dead code and bring it to your attention.
Debugging - Finding and fixing bugs in code. Bugs are very common. You should expect to spend
far more time debugging code than writing it.
Declare - To give a variable a name (and possibly a type). A variable declaration is like a birth
certificate for a piece of data.
Dependency - Anything that is required for a class to be constructed or for an application to run.
Dependency injection - The practice of passing a class’s dependencies to it as parameters to
the constructor, rather than making it responsible for gathering everything it needs. Dependency
injection is a best practice in most programming languages and makes it easier to write unit tests.
Deploy - To move resources from one environment to another. Deploying software is a process that
may include moving files to a server, compiling them, and running automated tests. Most companies
automate this process to make it predictable and convenient. See also “Release”.
Design pattern - A popular way to solve a particular problem in code. These often have odd names
like “the decorator pattern” or “the adapter pattern”. Sometimes language-specific patterns are called
design patterns, but generally a design pattern should be applicable to an entire family or paradigm
of languages. As you explore a codebase, you’ll notice the patterns that exist in it without necessarily
learning their names. It’s more important to know what a pattern does and why it’s useful than to
know what it’s called.
Dev - Short for “developer.” Someone who develops software, including the work of writing code.
DevOps - An abbreviation combining “development” and “operations”. DevOps describes the
overlap between development tasks—defining and creating a product—and operations tasks like
deploying software to an environment. Someone who works in DevOps will generally have
experience in both areas.
Dictionary - See “Object”.
Diff - The result of running a “diff tool.” A diff tool is a piece of software that compares two code files
and displays the differences between them, much like the “View Changes” tool in a word processor.
Code that was added will be shown in green and/or with a “+” symbol, while code that was removed
will be shown in red and/or with a “-“ symbol. Diffing is often done while merging code, to make
sure that changes made by different developers are all integrated together correctly.
Documentation - Written instructions, descriptions, or historical records related to a team or a piece
of software.
Edge case - Something that’s unlikely to happen in a particular application, but should be planned
for anyway. For example, the user of an email application could decide to forward an email to
themself, and while this isn’t something most users will ever do, the application should still be able
to handle it without breaking.
Appendix A: A coder’s vocabulary
146
Elegant - Code that is well-written, even beautiful. If two pieces of code do the same task and are
both performant and bug-free, the more elegant one is the one that is easier to understand or makes
better use of the programming language and its standard library. Calling someone’s code “elegant” is
a compliment. Elegance shouldn’t be confused with “cleverness,” which can sometimes mean using
language features in a confusing way to get shorter or faster code.
Encapsulation - Taking data and logic that belong together and putting them in a self-contained
unit of code. This makes it easy to hand them out to any code that wants to use them, and to control
the way they are used.
Encryption - The use of a secret cypher to make important data difficult or impossible for hackers
to read.
End to end (e2e) test - An automated test that runs an application as if it were a real user, including
clicking, tapping, typing, scrolling, or anything else a real user might do. These tests are time-
consuming but they’re also the only way to ensure the application actually works without testing it
manually. For that reason, they tend to provide a lot of value.
Estimating - The practice of trying to guess how long it will take to develop something. These
guesses are usually wrong. The more specific a guess is, the less accurate it’s likely to be. Nonetheless,
managers desperate for control will often try to get developers to give highly specific estimates for
all their work.
Evaluate - To execute a piece of code. If the code produces a value, we can say the code “evaluated
to” that value.
Expression - A piece of code that produces a value. Expressions can be made of smaller expressions.
The number 2 is an expression in code, as is 120 / 1 + 1 and getUserData().
Feature flag - A boolean value that determines whether a feature is visible or usable to the end user.
This is useful when a feature isn’t finished yet but the current latest version of the code needs to be
released. It can be as simple as placing a piece of code inside an if block, or as complex as using
different data types across multiple files based on a value in a database.
Flag - See “Boolean”.
Foo, bar, baz, qux - Generic, meaningless variable names often used in code samples or documen-
tation. They’re equivalent to a, b, c, and d. They shouldn’t be used in actual application code.
Framework - A generic piece of software that makes certain common tasks easier; this is meant to
be used as the foundation for an application. A web framework, for example, can simplify the work
of creating websites by providing methods for updating web pages when data changes, sharing data
between pages, and communicating with a web server.
Front end - In a web application, the code that runs on the user’s computer (generally a website
or an app). The opposite of “back end.” Many developers specialize in front end development. Front
end development often includes elements of graphic design.
Full stack - Both the front end and the back end in a web application. The term “full stack developer”
is contentious because many people believe that a developer can’t effectively specialize in both the
Appendix A: A coder’s vocabulary
147
front end and the back end. However, most web developers know some of both.
Function - One or more lines of code that are grouped together in the same block and share data with
each other. A function usually has a name so you can call it from another piece of code. Functions
can accept arguments and return values (but they don’t have to do either). They’re a good way to
break down a long process into simpler steps or share logic between several pieces of code.
Functional programming (FP) - A paradigm that describes programming languages or techniques
where all data is immutable, all functions are pure, and the core concepts are based on advanced math.
Haskell, Elm and F# are examples of functional programming languages. However, a functional
programming “style” can be used in many other languages, including JavaScript and C#.
Garbage collection (GC) - A feature in many programming languages that keeps track of data you
aren’t using anymore and automatically deletes it to free up memory. This is a major convenience
for developers. In languages without garbage collection, you have to keep track of all your data and
delete it yourself to avoid memory leaks.
Getter - A function that controls what happens when a variable is accessed. Getters are sometimes
used to control who can access a variable and what value they receive. The code referring to the
variable probably doesn’t know that it’s calling a function, so getters should be used carefully. See
also “Setter”.
Git - The most popular version control system. Git keeps track of a series of “commits,” each of which
is a collection of file changes or “deltas.” These commits exist in one or more “branches”. When one
branch is merged into another, Git tries to take all the changes in each file and weave them together.
It often can’t figure out how to do so without losing anyone’s changes; this results in merge conflicts.
Gotcha - A pitfall. Anything about a programming language, library, design pattern, or apparent
solution that can have unexpected effects, often without the developer realizing it.
Hard-coding - When data is written into code as a shortcut, forcing the code to use that data instead
of getting it from whatever “real” source it’s supposed to use. This is a form of technical debt. It’s
often done on purpose when building a new app or feature. For example, when you build a new
web page, you might hard-code some fake data for it to display (like a username, profile picture, and
map location) so you can focus on the design and interface. Every time you load the page, the same
fake data will be shown. Once the design work is finished, then you’ll need to refactor so that the
page uses data from a real logged-in user, maybe by fetching that data from the application’s server.
Hard-coding can also be called “stubbing.”
Graphical User Interface (GUI) - A visual interface for using software, generally accessed with a
mouse and keyboard. Ubuntu Linux, Mac OS, and Windows all come with GUIs installed, as does
every major internet browser and almost every other application meant for end users.
Idempotent - Describes a method that can be called once, twice, or multiple times, and the result is
always the same—that is, it doesn’t matter how many times you call it.
Idiomatic - The most obvious or normal way to do something in a programming language. Idiomatic
code takes advantage of a language’s built-in features and standard library to complete a task in
Appendix A: A coder’s vocabulary
148
an expectable way, rather than writing unnecessary methods or misusing language features to do
something they weren’t intended for.
Immutable - Refers to data that can’t or shouldn’t be altered. A changed version of that data could
be created and stored in a different variable, but the original data should always stay the same.
Immutable data can be nice to work with because it’s unlikely to surprise you.
Infinite loop - A loop, such as a while or for loop, that has a bug causing it to repeat forever.
This often happens when the programmer forgets to increase a value on each iteration, or when the
condition of the loop is written incorrectly. while(true) {} is an example of an infinite loop.
Integrated development environment (IDE) - A code editor that includes code-specific features,
like a compiler, a test runner, a debugger, and/or autocomplete. Visual Studio, IntelliJ, and WebStorm
are examples of IDEs.
Integration test - An automated test that makes sure two or more pieces of code work together
correctly.
Interface - The way you interact with a piece of code. This can refer to the input boxes and buttons
of a Graphical User Interface, the hardware buttons on a microwave, or the public parts of a class. In
code, the interface keyword is used to describe a collection of public fields and method signatures
which describe the interactivity an object is expected to have without specifying the exact logic it
should be using under the hood.
Interpret - Refers to the process of executing code without compiling it to machine language first
(see “Compile”). This requires a special piece of software called an interpreter. Languages that are
interpreted instead of compiled are often called “scripting” languages. JavaScript is an example of
an interpreted language; every major web browser comes with a JavaScript interpreter.
It works on my machine - Often said by a developer when an application is broken for the QA
team, managers, or users, but doesn’t seem to have any issues when they run it on their computer.
There are many reasons this can happen, including out-of-date code, a race condition, concurrency
bugs, differences in data, differences in environment, unforeseen user behavior, or bugs in the build
and delivery system.
Kanban - A set of processes that are often used in software development. Kanban is most easily
recognized by the presence of a “Kanban board,” a grid representing tasks that are available, in
progress, or finished, often with intermediate steps in between. See also “Scrum” and “Agile”.
Keyword - See “Reserved word”.
Legacy code - Any code that no longer brings joy to the developers that maintain it. Legacy code
may have been written ten years ago or last week; the point of the phrase isn’t necessarily to describe
the code’s age, but to indicate that it’s obsolete in some way and needs to be updated.
Library - See “Package”. Can also refer to a collection of related packages.
Linter - A tool that detects style issues or common mistakes in code without actually compiling or
running it. Linting is a form of static analysis.
Appendix A: A coder’s vocabulary
149
Load test - An automated test that simulates heavy usage of an application (e.g. by a lot of different
users at the same time). The goal is to measure the performance of the application “under load,” or
in other words, to find out how much it slows down or stops working in worst case scenarios.
Logic - What an application does or how it makes decisions.
Memory - See “Random access memory”.
Memory leak - When an application fails to free up memory it doesn’t need anymore, it can
gradually use more and more memory until the computer runs out. This can happen in any
programming language, whether or not it has garbage collection.
Merge - See “Git”.
Merge conflict - When two developers have modified the same code and the version control system
can’t figure out how to weave their changes together, the result is a merge conflict. A developer then
needs to resolve the conflict, usually by opening the file and modifying it so neither developer’s work
is lost.
Method - A function that lives inside of an object. It’s often defined in a class.
Minimum viable product (MVP) - The smallest and simplest version of a software product or
feature that could be valuable to a user. Releasing an MVP is a good way to find out what’s important
to users and learn about their needs without a lot of development effort.
Mob programming - Often called “mobbing”. When more than two developers gather around a
single computer and focus on a single task, with the entire group contributing to discussion about
how to do it.
Mock - A “fake” version of a dependency (like an object or method) that can be used during unit
testing, so the test won’t fail for reasons outside of the piece of code being tested.
Mockup - See “Prototype”.
Modular - Refers to a piece of code that is self-contained, making it portable between codebases.
Module - See “Package”.
Monitoring - Use of a system that keeps track of different events and metrics for an application.
You can use monitoring to learn what kinds of errors are happening for your users or how fast or
slow your app is. Monitoring can also notify you when a server crashes or a database takes too long
to perform an operation.
Mutable - Refers to data that can be altered. The opposite of immutable.
Namespace - A name that groups one or more pieces of code together under the same umbrella
for the programmer’s convenience. Some programming languages require every class to be in a
namespace. When one class refers to another, you can use its namespace to help the compiler find
it, or to differentiate between multiple classes with the same name.
Object - A piece of data that holds other pieces of data and/or logic. Organizing data like this is
a good way to describe a complicated real-world concept, like a person or a subscription. Objects
Appendix A: A coder’s vocabulary
150
are usually organized into keys and values. The keys are like words in a real-life dictionary; the
values are like the definitions of those words. Therefore, you use the keys (which you usually know
beforehand) to retrieve the values from the object or to change them. An object can be created by
using a class. Objects can also be called dictionaries or associative arrays.
Object-oriented programming (OOP) - A paradigm that describes programming languages where
the code is organized around mutable data objects. OOP languages generally use classes and each
class has methods for operating on its own data.
Open source - Describes a project or application whose code is publicly available. Open source
coding is extremely popular, and tens of millions of open source repositories can be found on sites
like GitHub and BitBucket. Developers value open source code because of the communities that
form around it, the way it propagates ideas, the transparency it offers, and the fact that most open
source code is free to use.
Package - A bundle of code intended to be used by other code. A package may depend on other
packages, but it usually handles those dependencies on its own. In the simplest situations, you can
add a package to your project and use it without worrying about how it works.
Pair programming - When two developers share a computer. One of them, the “driver”, controls
the mouse and keyboard; the other one tells them what to do or type. The goal is to reduce mistakes
and increase development speed by having two people focused on the same task.
Paradigm - A category of programming language, or a certain way of programming regardless of
language. Functional programming and object-oriented programming are examples of paradigms.
Parameter - A piece of data you provide to a function when you call it. It’s assumed that the function
will use and/or alter that data.
Performance - How fast or slow an application or part of an application is. Something that’s
relatively fast is called “performant.”
Premature optimization - When someone tries to make an application faster without knowing how
fast it is already. Most of the time, “fast enough” is good enough. Almost any piece of code can be
fine-tuned and worked over until it’s lightning-fast, but this is wasted effort if a user will never
notice the difference.
Primitive - A simple, “pure” data type that isn’t an object. What’s considered a “primitive” can vary
by programming language. Numbers, booleans and characters are usually primitives.
Production - In a web application, the server that is interacting with real users. This is the last stop
for any piece of code that’s been merged into the main branch.
Proof of Concept (PoC) - A small example of working software to demonstrate that a particular
idea or technique is feasible.
Prototype - An application design that represents both the appearance and the interactivity of the
app, usually put together by a designer. Usually a prototype is purely visual and doesn’t contain any
code or do any work under the hood.
Appendix A: A coder’s vocabulary
151
Pseudocode - Fake code written as an example or to describe how an algorithm might be written.
Pseudocode may look like a specific programming language or no programming language at all.
Many programmers like to write pseudocode when planning their approach to a problem, so they
can figure out the solution without worrying about syntax, spelling, code style, and errors.
Pull request (PR) - In version control, a proposal for one branch to be merged into another. A pull
request usually includes a written description of the changes the developer has made and a list of all
the commits that would need to be applied. Most online code repositories have a way to read through
all the code changes that a pull request is proposing, and a method for approving or rejecting the
request.
Pure function - A function that doesn’t change anything outside of itself and doesn’t use any data
aside from its arguments. A function that accepts a Fahrenheit value and returns the equivalent
Celsius value, doing the conversion with a simple mathematical formula, is an example of a pure
function. Pure functions are easy to use and very predictable, which makes them a useful tool for
any developer.
Quality assurance (QA) - Testing software to find bugs. Depending on the organization, this can be
a person or team’s full-time job, or a responsibility shared by everyone. It’s an extremely valuable
role that often prevents catastrophic bugs from affecting users.
Race condition - A bug that occurs when two or more things happen at the same time and are
expected to finish in a certain order, but might not. Race conditions are common in asynchronous
code and in web applications that expect data to be delivered from the server in a particular order.
Random access memory (RAM) - Often just called “memory”. The place where the computer stores
data temporarily. RAM is very fast and easy to access. All variables in a computer program are stored
in RAM.
Read–eval–print loop (REPL) - See also “Command Line Interface”. A text interface for evaluating
expressions in a programming language. Most languages ship with a REPL. The developer console
in Chrome, Firefox and Safari includes a JavaScript REPL.
Read the fucking manual (RTFM) - An abusive way to suggest that someone is asking an
excessively simple question, and instead of bothering you they should read the documentation for
the programming language or tool they’re struggling with. RTFM is an unhelpful response regardless
of the situation, and generally only used by people who are exceptionally difficult to work with.
Recursion - When a function calls itself. This is often done when a function is working with data
like an array or tree of indefinite length or depth. The function can operate on the first part of the
data, then call itself with the rest of the data. Eventually it will be called with the last piece of data,
and then it can finish.
Refactor - To change a piece of code without changing how the application behaves on the surface.
The purpose of refactoring can be to make code easier to read, to organize it better, to make it easier
to add new behavior in the future, or to take advantage of new features in a programming language
or library.
Appendix A: A coder’s vocabulary
152
Reference - The memory address of a variable. When you create a variable and use it, the code is
keeping track of its reference (usually behind the scenes). If you delete the variable or the compiler
notices you’re not using it anymore, it can “free” the reference so that memory can be used by
something else. If something is “passed by reference” to a function, that means its actual memory
address is provided, so modifying it within the function will modify it for the entire application.
Reflection - The ability of code to modify itself at runtime. In practical terms, this usually refers to
the ability in certain programming languages to look at an object and access any of its fields and
methods that are created at runtime or would usually be hidden. This is especially useful if you don’t
know what the object is going to look like ahead of time.
Relational database - A database consisting of tables that can refer to each other. You can think of a
database table like a spreadsheet. It commonly has an ID column and other columns that describe a
complex piece of data; in this way the table definition (or “schema”) is like a class and each row is like
an object of that class. If you have a table called “Orders” and a table called “Products”, the “Orders”
table could have a “ProductID” column that refers to the ID column of “Products”. Then each order
could be related to a product (usually by using the numerical ID of a single row). Relational databases
are the best choice for most applications. Most relational databases are created, queried and updated
via SQL, a programming language made for this purpose.
Release - To publish code to an environment, usually production; or, a version of code that is ready
to be released.
Repository - A collection of files that are all kept in the same place. Often abbreviated to “repo”.
Reserved word - In a given programming language, any word that has special meaning and
therefore can’t be used for variable or function names. For example, the word if is usually a reserved
word, and if you try to declare a variable named if you’ll get an error.
Representational state transfer (REST) - By strict definition, this is a set of rules for web server
APIs that dictates, among other things, how APIs are structured and what information the client
must provide. In common usage, a REST API is any web API that uses common HTTP request
bodies and HTTP verbs like GET, POST and PUT.
Retrospective - A meeting during which developers and managers consider the work they’ve done
recently and discuss ways to improve. This is the only meeting that is actually part of Agile: “At
regular intervals, the team reflects on how to become more effective, then tunes and adjusts its
behavior accordingly.” (https://agilemanifesto.org/principles.html¹⁵⁴)
Rollback - A process by which a piece of software is “un-updated”; any changes in the latest release
are undone and the software reverts to an older state. This is usually done when a severe bug or
security flaw that didn’t exist in previous versions is discovered. Software companies generally plan
for this possibility by (for example) setting up an automated way to do a rollback with a single click.
Rubber ducking - The practice of explaining a problem to an inanimate object (it’s called a “rubber
duck” for illustrative purposes). As you describe the issue out loud in your own words, the solution
will often become obvious. This is an especially effective tool for debugging.
¹⁵⁴https://agilemanifesto.org/principles.html
Appendix A: A coder’s vocabulary
153
Runtime - The time during which the code is actually running (not being written or compiled); or,
the environment in which the code runs.
Scaling - A set of strategies and considerations around the question, “how could our application or
organization handle a significant increase in the number of customers we serve?” Scaling can also
refer to challenges with increasing amounts of data or organizational growth.
Schema - See “Relational database”.
Scope - The boundary between what you intend to build and what you don’t intend to build. If
you’re planning to build a feature in a certain period of time, that feature is “in scope.” Otherwise
it’s “out of scope.” If you’ve already made plans but extenuating circumstances cause you to do more
work than you were planning, that’s called “scope creep.”
Scrum - A set of meetings and processes that are a popular way to “do Agile.” The most common
mark of Scrum is the “standup”, a daily meeting where members of a team report what they’re
working on. Some organizations wrongly believe that they are Agile solely because they have sprints
and standup; see “Agile”.
Setter - A function that controls what happens when a variable is changed. A setter can be used to
track changes to a variable, prevent it from being changed, or determine if the user has permission
to change it. The code referring to this variable probably doesn’t know that it’s calling a function,
so setters should be used carefully. See also “Getter”.
Ship - To release a version of a product, usually the latest version.
Signature - Everything you need to know in order to use a method: its name, the types of arguments
it expects, and what type of argument it returns.
Soft skills - Refers to non-technical skills that are essential in the workplace, like communication,
respectfulness, compromise, time management, and creativity. The phrase has some unfortunate
connotations, like wrongly implying that “soft” skills are less important than “hard” (technical) skills,
or that they’re a sign of intellectual weakness. Many programmers prefer to call them “catalytic
skills,” since they enable and facilitate every kind of work.
Software - Applications built with code that run on a computer.
Software as a Service (SaaS) - A way of delivering software on a subscription basis. Customers
usually pay monthly and receive regular, automatic updates. SaaS is a popular way to sell software
on the internet.
Software development kit (SDK) - The software and APIs necessary to develop an application that
works on a particular platform, like Windows 10, iPhone, or the Java Virtual Machine (JVM).
SOLID - An acronym for five principles that are common in the study of object-oriented program-
ming: Single responsibility principle, Open-closed principle, Liskov substitution principle, Interface
segregation principle, and Dependency inversion principle. These aren’t defined here because some
of them are relatively advanced, but you should study them once you feel confident with the basics
of object-oriented programming.
Appendix A: A coder’s vocabulary
154
Spaghetti code - Code that is disorganized, spread out, and hard to follow, as if the code were
noodles in a bowl of spaghetti. Developers who are in a rush to meet deadlines or don’t have the
guidance of a senior developer will often produce spaghetti code. An application made of spaghetti
code is a nightmare to debug, refactor, and build upon. Be wary of developers who use the term to
describe any code they dislike.
Specification - A detailed human-language description of a software or programming language
feature, including details on how it works and how to use it.
Sprint - A period of time during which software is built. The Agile principles state, “Deliver working
software frequently, from a couple of weeks to a couple of months, with a preference to the shorter
timescale” (https://agilemanifesto.org/principles.html¹⁵⁵). Sprints are a popular implementation of
this principle. A sprint often begins with a planning meeting and ends with a retrospective.
Stack - A memory structure where pieces of data are “stacked” on top of each other. Only the top
piece of the stack can be accessed or removed at any given time. The “stack” also refers to all the
lines of code that are active when a specific line of code is executed. If code A calls code B, which
calls code C, then A, B and C are all part of the stack. If C throws an error, you’ll usually see a “stack
trace” listing C, then B, then A.
Staging - The environment where an application is released before it goes to production. Staging
is where all the final testing and verification happens and often has similar data to production. If a
bug isn’t caught in staging, it will go to production and affect users.
Standard library - All the functionality that comes built-in with a programming language, even
though it isn’t part of the syntax itself. The standard library usually includes functions for
manipulating strings, handling input and output, and doing advanced math.
Standup - See “Scrum”.
State - The data kept in memory as an application runs.
Statement - A basic unit of code that describes an action. In programming, we often talk about “if
statements,” “return statements,” and several others. An “if statement” is a statement that uses the
if keyword, such as if (x == 2).
Static - A keyword in many programming languages that refers to a method or field that exists on
the class itself, not on objects of that class.
Static analysis - A type of debugging that can be done without compiling or running the code.
Linting is a form of static analysis. Most IDEs will do static analysis to let you know about bugs as
soon as possible.
String - A data type that holds text. In code, strings are usually put inside of quotes. "John Smith"
is a string, as is " " (a string full of spaces), "" (an empty string) and "￿".
Style guide - A set of rules documenting a group or project’s preferred code style. Some teams have
unwritten style guides; in this case, the best thing to do is explore the project beforehand and try to
make your code look like theirs.
¹⁵⁵https://agilemanifesto.org/principles.html
Appendix A: A coder’s vocabulary
155
Syntax - The grammar of a programming language, including all its reserved words and the way
numbers, symbols, and other tokens are used.
Technical debt - The gradual buildup of confusing, disorganized or buggy code in an application.
This is inevitable over time, especially if the team is rushed, the work environment is hostile, or
there’s a lot of pressure to produce new features. Technical debt can only be controlled by regularly
setting aside development time to refactor. If technical debt is allowed to grow too large, it can cause
mental exhaustion for developers, seriously slow down feature development, and make bugs hard
or impossible to fix.
Test-driven development (TDD) - The practice of writing unit tests for a piece of code before that
code is even written. The process can be remembered as “red-green-refactor”: first the test is written,
and it fails (red) because no code has been written. Then code is implemented so that the test passes
(green). Then the code can be refactored to improve quality.
Throw - If a piece of code runs into an error it can’t or shouldn’t handle on its own, it can throw the
error (or do nothing, in which case the error will usually be thrown automatically). Then the code
that called it will receive the error. That code can also handle, throw, or ignore the error. If the error
is thrown enough times, it can reach the user.
Type - The kind of data stored in a variable, e.g. a whole number, a decimal number, a boolean, a
string, or an object.
Unicorn - A privately-held tech company whose total stock value is over one billion dollars.
Sometimes this word is also used to indicate something incredibly rare and precious, like certain
types of developers.
Unit test - An automated test that makes sure a single, isolated piece of code (like a class or method)
does what it’s expected to do. Unit tests usually run very quickly and can help build confidence in
a tricky piece of code. The best unit tests verify a unit’s behavior, not its implementation—that is,
they test what it does, not how it does it. This way the code can be refactored without breaking the
test.
Usability testing - The practice of having someone (usually a person from outside of the team or
company) use an application or prototype while a member of the team watches. Ideally, the team
member shouldn’t tell the person how to do anything; instead, they should give them an objective
and see if they can figure out how to complete it in the application. This helps the team understand
what parts of the application are confusing or unintuitive.
User interface (UI) - The part of an application that a user looks at and interacts with; or, the work
of designing this part of an application, often done by a graphic designer or someone with artistic
training.
User experience (UX) - The field of study focused on improving the interactions between users and
applications. UX designers may build prototypes or design interfaces, but they’re generally more
concerned with usefulness and user-friendliness than with appearance.
Value - A piece of data. If we say something is “passed by value” to a function, then we mean the
data itself is provided, not the memory address of the variable that holds it. This way the function
Appendix A: A coder’s vocabulary
156
can modify it without affecting the rest of the application.
Variable - A named piece of data in memory. In the statement int x = 1, the variable is x.
Velocity - A measure of development speed based on estimates. Velocity is generally impossible to
measure in a useful way. Incompetent managers often try to increase velocity by making developers
work longer hours and meet shorter deadlines; this always results in a worse product and long-term
damage to the company.
Version control system (VCS) - A system for managing several different versions of a codebase.
Usually there is a main or “master” branch which contains the latest and most official version of
the code, and then several other branches containing work in progress. These other branches can be
merged into the master branch when they’re complete.
Vulnerability - A weakness or bug in an application that hackers could use to steal user data,
crash the application, or gain unauthorized access. Vulnerabilities can be avoided through the use
of security best practices, encryption, input sanitization, and penetration testing.
Waterfall - A development process for software that is delivered all at once, like on a CD. This was
popular in the days before the internet became the primary medium for software distribution. In
Waterfall, planning and design are all done at the beginning of the project, which can make the
process inflexible and prone to error.
Whiteboard interview - A popular but ineffective interview method where candidates are asked to
write code on a whiteboard, chalkboard or sheet of paper. This often includes asking them to solve
complex mathematical or data structure problems with code. Since this doesn’t resemble the work
they’d be doing on a day-to-day basis if they were hired, it’s almost irrelevant to the task of selecting
the most competent candidate.
Workaround - A less-than-ideal way to work when some issue makes the normal way impossible.
If the “Send” button on your email client is broken, but pressing Ctrl + Enter sends the email, that’s
a workaround. You can continue to use the software, but it definitely needs to be fixed.
XY Problem - When a user has a problem (“X”), thinks they know the solution (“Y”), and asks
for help with that solution (“Y”) instead of the original problem (“X”). People sometimes do this to
avoid looking naive (“I have a problem but no idea how to solve it” can be a hard thing to say), or
because they think asking about Y is a smaller or less intrusive question. Sometimes they may not
even recognize that X is their real problem. This often results in confusion and frustration, especially
when the user’s Y isn’t a good solution to X (or isn’t even related to it). For example, suppose your
computer won’t turn on and you decide—for good reasons or bad ones—that the problem is the
power cord. You might call a friend who’s good with computers and ask them where to buy a new
cord. If you’re lucky, they’ll ask some broader questions and find out what’s really going on. If not,
you may find out the hard way that a new cord doesn’t solve the problem, and lose a lot of time and
money in the process.
Appendix B: To make this, learn that
Deciding what to learn can be easier if you know what you want to build. To that end, below are
some things you might be interested in building and some of the most popular tools used to make
them. Note that this isn’t a complete or comprehensive list—there are many more things a developer
can make and many tools used to make them.
To make this
Learn that
Android apps
Java or Kotlin; Android Studio
Cross-platform apps
C# and Xamarin or HTML, CSS,
JavaScript and Phonegap or a front-end
framework and Ionic or Dart and Flutter
or a front-end framework and
NativeScript
Embedded systems, like ATM machines,
gas pumps and credit card readers
C or C++
iOS apps
Swift or Objective-C; Xcode
Video games
C# and Unity or C++ and Unreal Engine
or Lua and Amazon Lumberyard
Web apps
HTML; CSS; SASS or LESS; JavaScript;
Vue or React or Ember; Webpack or
Rollup; TypeScript
Web servers
C# and .NET Framework or JavaScript
and Node.js or Python and Django or
Erlang and Elixir or Ruby and Rails or
PHP and Laravel
Appendix C: Recommended reading
Code Complete by Steve McConnell. A several-hundred-page deep-dive on how to write clean, bug-
free code.
CSS-Tricks (https://css-tricks.com/¹⁵⁶). A website offering simple and extremely well-written guides
for many different web development topics (not just CSS).
Emotional Intelligence for Engineers by April Wensel (https://www.youtube.com/watch?v=yD0kzU4Pu-
Q¹⁵⁷). A discussion of oft-neglected but incredibly important skills in software development.
#firstyearincode on The DEV Community (https://dev.to/t/firstyearincode¹⁵⁸). A collection of posts
related to this book. May include book reviews, chapters from the book, unpublished chapters, and
more.
How to Manage Conflicts by Isaac Lee (https://dev.to/ijlee2/how-to-manage-conflicts-listen-4kmb¹⁵⁹).
A three-part series about effective teamwork, applying the principles of Crucial Conversations to
software development.
How to Think Like a Computer Scientist by Allen Downey, Jeffrey Elkner and Chris Meyers. A very
good how-to-code guide for beginners using the Python language.
It Doesn’t Have to be Crazy at Work by David Heinemeier Hansson and Jason Fried. A manifesto for
running a business, especially a software business, in a sensible way that respects employees and
clients.
Learn You a Haskell for Great Good! by Miran Lipovaca. An introduction to functional programming
with the Haskell programming language.
MDN Web Docs by Mozilla (https://developer.mozilla.org¹⁶⁰). The web’s most well-maintained and
up-to-date source for information about web technologies, including complete documentation for
HTML, CSS, JavaScript, and browser APIs.
The Nature of Software Development by Ron Jeffries. A brief overview of how Agile principles can
be applied to a real-world development team.
Refactoring UI by Adam Wathan and Steve Schoger. A brief introduction to the rules of good user
interface design, written for software developers.
SOLID on Wikipedia (https://en.wikipedia.org/wiki/SOLID¹⁶¹). A starting point for learning about
the most famous principles of good object-oriented code.
¹⁵⁶https://css-tricks.com/
¹⁵⁷https://www.youtube.com/watch?v=yD0kzU4Pu-Q
¹⁵⁸https://dev.to/t/firstyearincode
¹⁵⁹https://dev.to/ijlee2/how-to-manage-conflicts-listen-4kmb
¹⁶⁰https://developer.mozilla.org
¹⁶¹https://en.wikipedia.org/wiki/SOLID
Appendix C: Recommended reading
159
Structure and Interpretation of Computer Programs by Harold Abelson, Gerald Jay Sussman and
Julie Sussman. A classic computer programming manual used at MIT. The full text is available
online at https://mitpress.mit.edu/sites/default/files/sicp/index.html¹⁶².
Three Virtues by Larry Wall (http://threevirtues.com/¹⁶³). A summary of the tongue-in-cheek “great
virtues” of a programmer: laziness, impatience, and hubris.
¹⁶²https://mitpress.mit.edu/sites/default/files/sicp/index.html
¹⁶³http://threevirtues.com/
Acknowledgments
Thanks to everyone who supported this book. It was very much a group effort, and it’s been amazing
to work with all of you.
Thanks to the wonderful DEV Community¹⁶⁴ team for their help organizing and promoting the book.
Thanks to Dylan for your support during long hours of writing and editing. Love you always.
Each of our contributors and beta readers has written a brief message, which you can read below.
Guest authors
I am very thankful to Isaac Lyman for giving us this opportunity to contribute in this
great book. Find more about me @ arslanaslam.me
∼Muhammad Arslan Aslam
My name is Ilona and I am a Frontend Software Engineer based in Berlin. I develop web
apps, study psychology and help #womenwhocode live a life they don’t need a vacation
from. Read my blog at ilonacodes.com and say “Hi” on Twitter: @ilonacodes
∼Ilona Codes
I am a web application developer and passionate about functional programming and
open source. Having multiple side projects going on at the same while trying to fulfill
my entrepreneurial dreams… :) Follow me on Twitter @leonorader and check my blog:
https://fejlesztolany.hu
∼Leonóra Dér
Thank you mom, dad & friends for your support & Isaac Lyman for this opportunity to
help contribute to an amazing cause.
Readers: if you have questions or would like to follow my new journey as I build my new
company (rawpido.com), connect with me at cliffordfajardo.com
∼Clifford Fajardo
Hi, I’m Gianluca Fiore, a software developer from Italy. On the spare time between
tasting coffee, making pizza, travelling, blogging (on https://papersounds.eu) and reading,
I actually do develop software (mostly in Python, Go and JS).
∼Gianluca Fiore
¹⁶⁴https://dev.to
Acknowledgments
161
I would like to thank Kieran for believing in me and supporting me when life felt too
heavy. Thank you for always encouraging me to take the next step.
∼Sabrina Gannon
I would tell you a UDP joke, but you may not get it. I am a passionate software engineer,
dedicated to continuous personal/professional improvement and in the meanwhile, I am
torturing people with my jokes. I am glad to assist you in your first year in code.
∼Periklis Gkolias
I’m a career changer and bootcamp grad. I was helped along the way by so many awesome
people and I’m always trying to pay it forward. Please feel free to reach out!
∼Yechiel Kalmenson
“Simple things should be simple, complex things should be possible.” - Alan Kay
∼Vlad Levin
Thank you for joining the fabulous world of programming. Let’s keep it rich and
interesting, as my own career has been.
Check out my book, “What is Programming?” a further companion to your journey as a
programmer.
Find me at https://edaqa.com/
∼Edaqa Mortoray
During the moments of time where there are crucial decisions to be made, often you
already know what path you feel is the right one to take. I urge you to trust your gut. It’s
the one true compass you can always count on. Trust your compass.
∼Casey Ocampo
I run my life with three words: Build, Test, Launch.
∼Rosalind Thuy Pham
Hi, I’m Desi! I love UX research, finding bugs, and helping people find their dream jobs.
I’m on Twitter @desilove and my portfolio is www.desidoes.dev. Special thanks to my
partner, Evan, for relentless editing of chapter drafts!
∼Desi Rottman
A programmer and entrepreneur with a love of cars, music and technology. https://turnerj.com/
∼James Turner
Acknowledgments
162
I live in Utah and am currently a Senior Software Engineer at GoReact. I have been
programming as a hobby since 2009, professionally since 2012. I’ve contributed to the
community through open source, blog posts garnering over 100,000 reads, as well as
presenting at meetups.
∼John Woodruff
Beta readers
I am Mohammed and I am a Software Developer. I am passionate about social media
analytics and mentoring new or aspiring developers. Special thanks to Isaac Lyman for
the opportunity to participate in this interesting book. Please feel free to follow me on
Twitter @MohammedAlMarh
∼Mohammed Almarhoon
Hi there! I love learning about Web Development, drawing and doing a little bit of exercise
- just a bit! -. I’ll definitely use what I learned with the book to enter the Dev arena and
improve this https://github.com/john-angel. See ya!
∼John Angel
Hi, I’m Glenn, an android developer from Belgium and a huge open source fan. Checkout
my blog posts and projects on https://glennmen.dev
∼Glenn Carremans
I’m a Software Engineer, Entrepreneur and Investor. You’ll find all of my contact info at
http://www.jeremiahcooper.com. Feel free to reach out if you think we can work together
on something.
∼Jeremiah Cooper
I’m a self-taught email & front-end developer. I am passionate about open source
software and encouraging developers to participate. I can be found Tweeting about tech
(https://twitter.com/shannon_crabill) or speaking at conferences. My internet home is
http://shannoncrabill.com.
∼Shannon Crabill
I am a full stack web developer who loves learning and sharing knowledge. Firmly believe
“life is a marathon, not a sprint”. I enjoy sharing web development knowledge on a website
I run called dev-diaries.com
∼Khaliq Gant
Acknowledgments
163
FOR x equals one to ten;
Loop and do it again;
Not sure what to write, I truly am vexed;
This BASIC loop ends with a NEXT.
Doug is a coder, leader, innovator, and teacher. Engage with him at http://www.dougjenkinson.net.
∼Doug Jenkinson
I appreciate to Isaac Lyman, all the authors, and big thank you to Jiyoon. I’m working at
Emotion AI company, “GenesisLab” from South Korea who started a career 2.5 years ago.
I want to say to me in 2009 (when I started). “Please find Isaac and ask him to write this.”
∼Junhong Kim
Shoutout to Udacity and all the awesome people at Sovos who have helped me break into
software engineering, especially Dirk Diegnau!
Thinking about ordering pork online from from a small farm in Minnesota? I got you
covered! tfponline.squarespace.com
ericmiller.dev
@TFP_eric
∼Eric C. Miller, PhD
I am a Tech Writer and YouTuber who explains technology for a living!
∼Amruta Ranade
Thank you Isaac from your help and your support to the community, specially to newbies
like me and also to the authors who beautifully contributed to this great guide.
∼Adrian Skar
https://sysa.la
∼Jan Sysala
Cover design
Cover art created by Cover Story Book Design. Email us at coverstorybookdesign@gmail.com
for your own custom book cover, or to browse our gallery of premade ebook covers! We
design for all genres, fiction and nonfiction.


ID: https://www.mta.ca/~rrosebru/oldcourse/263114/Dsa.pdf
Document: DSA
D a t a  S t r u c t u r e s  a n d  A l g o r i t h m s
Annotated Reference with Examples
Granville Barne!
Luca Del Tongo
Data Structures and Algorithms:
Annotated Reference with Examples
First Edition
Copyright c
⃝Granville Barnett, and Luca Del Tongo 2008.
This book is made exclusively available from DotNetSlackers
(http://dotnetslackers.com/) the place for .NET articles, and news from
some of the leading minds in the software industry.
Contents
1
Introduction
1
1.1
What this book is, and what it isn’t
. . . . . . . . . . . . . . . .
1
1.2
Assumed knowledge
. . . . . . . . . . . . . . . . . . . . . . . . .
1
1.2.1
Big Oh notation
. . . . . . . . . . . . . . . . . . . . . . .
1
1.2.2
Imperative programming language . . . . . . . . . . . . .
3
1.2.3
Object oriented concepts
. . . . . . . . . . . . . . . . . .
4
1.3
Pseudocode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4
1.4
Tips for working through the examples . . . . . . . . . . . . . . .
6
1.5
Book outline
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6
1.6
Testing
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
1.7
Where can I get the code? . . . . . . . . . . . . . . . . . . . . . .
7
1.8
Final messages
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
I
Data Structures
8
2
Linked Lists
9
2.1
Singly Linked List
. . . . . . . . . . . . . . . . . . . . . . . . . .
9
2.1.1
Insertion . . . . . . . . . . . . . . . . . . . . . . . . . . . .
10
2.1.2
Searching . . . . . . . . . . . . . . . . . . . . . . . . . . .
10
2.1.3
Deletion . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11
2.1.4
Traversing the list
. . . . . . . . . . . . . . . . . . . . . .
12
2.1.5
Traversing the list in reverse order . . . . . . . . . . . . .
13
2.2
Doubly Linked List . . . . . . . . . . . . . . . . . . . . . . . . . .
13
2.2.1
Insertion . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15
2.2.2
Deletion . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15
2.2.3
Reverse Traversal . . . . . . . . . . . . . . . . . . . . . . .
16
2.3
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17
3
Binary Search Tree
19
3.1
Insertion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20
3.2
Searching
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21
3.3
Deletion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
22
3.4
Finding the parent of a given node . . . . . . . . . . . . . . . . .
24
3.5
Attaining a reference to a node . . . . . . . . . . . . . . . . . . .
24
3.6
Finding the smallest and largest values in the binary search tree
25
3.7
Tree Traversals . . . . . . . . . . . . . . . . . . . . . . . . . . . .
26
3.7.1
Preorder . . . . . . . . . . . . . . . . . . . . . . . . . . . .
26
I
3.7.2
Postorder . . . . . . . . . . . . . . . . . . . . . . . . . . .
26
3.7.3
Inorder
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
29
3.7.4
Breadth First . . . . . . . . . . . . . . . . . . . . . . . . .
30
3.8
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
4
Heap
32
4.1
Insertion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
33
4.2
Deletion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
37
4.3
Searching
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
38
4.4
Traversal
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
41
4.5
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
42
5
Sets
44
5.1
Unordered . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
46
5.1.1
Insertion . . . . . . . . . . . . . . . . . . . . . . . . . . . .
46
5.2
Ordered . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
47
5.3
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
47
6
Queues
48
6.1
A standard queue . . . . . . . . . . . . . . . . . . . . . . . . . . .
49
6.2
Priority Queue
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
49
6.3
Double Ended Queue . . . . . . . . . . . . . . . . . . . . . . . . .
49
6.4
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
53
7
AVL Tree
54
7.1
Tree Rotations
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
56
7.2
Tree Rebalancing . . . . . . . . . . . . . . . . . . . . . . . . . . .
57
7.3
Insertion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
58
7.4
Deletion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
59
7.5
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
61
II
Algorithms
62
8
Sorting
63
8.1
Bubble Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
63
8.2
Merge Sort
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
63
8.3
Quick Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
65
8.4
Insertion Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
67
8.5
Shell Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
68
8.6
Radix Sort
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
68
8.7
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
70
9
Numeric
72
9.1
Primality Test
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
72
9.2
Base conversions
. . . . . . . . . . . . . . . . . . . . . . . . . . .
72
9.3
Attaining the greatest common denominator of two numbers
. .
73
9.4
Computing the maximum value for a number of a speciﬁc base
consisting of N digits . . . . . . . . . . . . . . . . . . . . . . . . .
74
9.5
Factorial of a number
. . . . . . . . . . . . . . . . . . . . . . . .
74
9.6
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
75
II
10 Searching
76
10.1 Sequential Search . . . . . . . . . . . . . . . . . . . . . . . . . . .
76
10.2 Probability Search . . . . . . . . . . . . . . . . . . . . . . . . . .
76
10.3 Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
77
11 Strings
79
11.1 Reversing the order of words in a sentence . . . . . . . . . . . . .
79
11.2 Detecting a palindrome
. . . . . . . . . . . . . . . . . . . . . . .
80
11.3 Counting the number of words in a string . . . . . . . . . . . . .
81
11.4 Determining the number of repeated words within a string . . . .
83
11.5 Determining the ﬁrst matching character between two strings . .
84
11.6 Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
85
A Algorithm Walkthrough
86
A.1 Iterative algorithms
. . . . . . . . . . . . . . . . . . . . . . . . .
86
A.2 Recursive Algorithms . . . . . . . . . . . . . . . . . . . . . . . . .
88
A.3 Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
90
B Translation Walkthrough
91
B.1
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
92
C Recursive Vs. Iterative Solutions
93
C.1 Activation Records . . . . . . . . . . . . . . . . . . . . . . . . . .
94
C.2 Some problems are recursive in nature . . . . . . . . . . . . . . .
95
C.3 Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
95
D Testing
97
D.1 What constitutes a unit test? . . . . . . . . . . . . . . . . . . . .
97
D.2 When should I write my tests?
. . . . . . . . . . . . . . . . . . .
98
D.3 How seriously should I view my test suite? . . . . . . . . . . . . .
99
D.4 The three A’s . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
99
D.5 The structuring of tests
. . . . . . . . . . . . . . . . . . . . . . .
99
D.6 Code Coverage . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
D.7 Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
E Symbol Deﬁnitions
101
III
Preface
Every book has a story as to how it came about and this one is no diﬀerent,
although we would be lying if we said its development had not been somewhat
impromptu. Put simply this book is the result of a series of emails sent back
and forth between the two authors during the development of a library for
the .NET framework of the same name (with the omission of the subtitle of
course!). The conversation started oﬀsomething like, “Why don’t we create
a more aesthetically pleasing way to present our pseudocode?”
After a few
weeks this new presentation style had in fact grown into pseudocode listings
with chunks of text describing how the data structure or algorithm in question
works and various other things about it. At this point we thought, “What the
heck, let’s make this thing into a book!” And so, in the summer of 2008 we
began work on this book side by side with the actual library implementation.
When we started writing this book the only things that we were sure about
with respect to how the book should be structured were:
1. always make explanations as simple as possible while maintaining a moder-
ately ﬁne degree of precision to keep the more eager minded reader happy;
and
2. inject diagrams to demystify problems that are even moderatly challenging
to visualise (. . . and so we could remember how our own algorithms worked
when looking back at them!); and ﬁnally
3. present concise and self-explanatory pseudocode listings that can be ported
easily to most mainstream imperative programming languages like C++,
C#, and Java.
A key factor of this book and its associated implementations is that all
algorithms (unless otherwise stated) were designed by us, using the theory of
the algorithm in question as a guideline (for which we are eternally grateful to
their original creators). Therefore they may sometimes turn out to be worse
than the “normal” implementations—and sometimes not. We are two fellows
of the opinion that choice is a great thing. Read our book, read several others
on the same subject and use what you see ﬁt from each (if anything) when
implementing your own version of the algorithms in question.
Through this book we hope that you will see the absolute necessity of under-
standing which data structure or algorithm to use for a certain scenario. In all
projects, especially those that are concerned with performance (here we apply
an even greater emphasis on real-time systems) the selection of the wrong data
structure or algorithm can be the cause of a great deal of performance pain.
IV
V
Therefore it is absolutely key that you think about the run time complexity and
space requirements of your selected approach. In this book we only explain the
theoretical implications to consider, but this is for a good reason: compilers are
very diﬀerent in how they work. One C++ compiler may have some amazing
optimisation phases speciﬁcally targeted at recursion, another may not, for ex-
ample. Of course this is just an example but you would be surprised by how
many subtle diﬀerences there are between compilers. These diﬀerences which
may make a fast algorithm slow, and vice versa. We could also factor in the
same concerns about languages that target virtual machines, leaving all the
actual various implementation issues to you given that you will know your lan-
guage’s compiler much better than us...well in most cases. This has resulted in
a more concise book that focuses on what we think are the key issues.
One ﬁnal note: never take the words of others as gospel; verify all that can
be feasibly veriﬁed and make up your own mind.
We hope you enjoy reading this book as much as we have enjoyed writing it.
Granville Barnett
Luca Del Tongo
Acknowledgements
Writing this short book has been a fun and rewarding experience. We would
like to thank, in no particular order the following people who have helped us
during the writing of this book.
Sonu Kapoor generously hosted our book which when we released the ﬁrst
draft received over thirteen thousand downloads, without his generosity this
book would not have been able to reach so many people. Jon Skeet provided us
with an alarming number of suggestions throughout for which we are eternally
grateful. Jon also edited this book as well.
We would also like to thank those who provided the odd suggestion via email
to us. All feedback was listened to and you will no doubt see some content
inﬂuenced by your suggestions.
A special thank you also goes out to those who helped publicise this book
from Microsoft’s Channel 9 weekly show (thanks Dan!) to the many bloggers
who helped spread the word. You gave us an audience and for that we are
extremely grateful.
Thank you to all who contributed in some way to this book. The program-
ming community never ceases to amaze us in how willing its constituents are to
give time to projects such as this one. Thank you.
VI
About the Authors
Granville Barnett
Granville is currently a Ph.D candidate at Queensland University of Technology
(QUT) working on parallelism at the Microsoft QUT eResearch Centre1. He also
holds a degree in Computer Science, and is a Microsoft MVP. His main interests
are in programming languages and compilers. Granville can be contacted via
one of two places: either his personal website (http://gbarnett.org) or his
blog (http://msmvps.com/blogs/gbarnett).
Luca Del Tongo
Luca is currently studying for his masters degree in Computer Science at Flo-
rence. His main interests vary from web development to research ﬁelds such as
data mining and computer vision. Luca also maintains an Italian blog which
can be found at http://blogs.ugidotnet.org/wetblog/.
1http://www.mquter.qut.edu.au/
VII
Page intentionally left blank.
Chapter 1
Introduction
1.1
What this book is, and what it isn’t
This book provides implementations of common and uncommon algorithms in
pseudocode which is language independent and provides for easy porting to most
imperative programming languages. It is not a deﬁnitive book on the theory of
data structures and algorithms.
For the most part this book presents implementations devised by the authors
themselves based on the concepts by which the respective algorithms are based
upon so it is more than possible that our implementations diﬀer from those
considered the norm.
You should use this book alongside another on the same subject, but one
that contains formal proofs of the algorithms in question. In this book we use
the abstract big Oh notation to depict the run time complexity of algorithms
so that the book appeals to a larger audience.
1.2
Assumed knowledge
We have written this book with few assumptions of the reader, but some have
been necessary in order to keep the book as concise and approachable as possible.
We assume that the reader is familiar with the following:
1. Big Oh notation
2. An imperative programming language
3. Object oriented concepts
1.2.1
Big Oh notation
For run time complexity analysis we use big Oh notation extensively so it is vital
that you are familiar with the general concepts to determine which is the best
algorithm for you in certain scenarios. We have chosen to use big Oh notation
for a few reasons, the most important of which is that it provides an abstract
measurement by which we can judge the performance of algorithms without
using mathematical proofs.
1
CHAPTER 1. INTRODUCTION
2
Figure 1.1: Algorithmic run time expansion
Figure 1.1 shows some of the run times to demonstrate how important it is to
choose an eﬃcient algorithm. For the sanity of our graph we have omitted cubic
O(n3), and exponential O(2n) run times. Cubic and exponential algorithms
should only ever be used for very small problems (if ever!); avoid them if feasibly
possible.
The following list explains some of the most common big Oh notations:
O(1) constant: the operation doesn’t depend on the size of its input, e.g. adding
a node to the tail of a linked list where we always maintain a pointer to
the tail node.
O(n) linear: the run time complexity is proportionate to the size of n.
O(log n) logarithmic: normally associated with algorithms that break the problem
into smaller chunks per each invocation, e.g. searching a binary search
tree.
O(n log n) just n log n: usually associated with an algorithm that breaks the problem
into smaller chunks per each invocation, and then takes the results of these
smaller chunks and stitches them back together, e.g. quick sort.
O(n2) quadratic: e.g. bubble sort.
O(n3) cubic: very rare.
O(2n) exponential: incredibly rare.
If you encounter either of the latter two items (cubic and exponential) this is
really a signal for you to review the design of your algorithm. While prototyp-
ing algorithm designs you may just have the intention of solving the problem
irrespective of how fast it works. We would strongly advise that you always
review your algorithm design and optimise where possible—particularly loops
CHAPTER 1. INTRODUCTION
3
and recursive calls—so that you can get the most eﬃcient run times for your
algorithms.
The biggest asset that big Oh notation gives us is that it allows us to es-
sentially discard things like hardware. If you have two sorting algorithms, one
with a quadratic run time, and the other with a logarithmic run time then the
logarithmic algorithm will always be faster than the quadratic one when the
data set becomes suitably large. This applies even if the former is ran on a ma-
chine that is far faster than the latter. Why? Because big Oh notation isolates
a key factor in algorithm analysis: growth. An algorithm with a quadratic run
time grows faster than one with a logarithmic run time. It is generally said at
some point as n →∞the logarithmic algorithm will become faster than the
quadratic algorithm.
Big Oh notation also acts as a communication tool. Picture the scene: you
are having a meeting with some fellow developers within your product group.
You are discussing prototype algorithms for node discovery in massive networks.
Several minutes elapse after you and two others have discussed your respective
algorithms and how they work. Does this give you a good idea of how fast each
respective algorithm is? No. The result of such a discussion will tell you more
about the high level algorithm design rather than its eﬃciency. Replay the scene
back in your head, but this time as well as talking about algorithm design each
respective developer states the asymptotic run time of their algorithm. Using
the latter approach you not only get a good general idea about the algorithm
design, but also key eﬃciency data which allows you to make better choices
when it comes to selecting an algorithm ﬁt for purpose.
Some readers may actually work in a product group where they are given
budgets per feature. Each feature holds with it a budget that represents its up-
permost time bound. If you save some time in one feature it doesn’t necessarily
give you a buﬀer for the remaining features. Imagine you are working on an
application, and you are in the team that is developing the routines that will
essentially spin up everything that is required when the application is started.
Everything is great until your boss comes in and tells you that the start up
time should not exceed n ms. The eﬃciency of every algorithm that is invoked
during start up in this example is absolutely key to a successful product. Even
if you don’t have these budgets you should still strive for optimal solutions.
Taking a quantitative approach for many software development properties
will make you a far superior programmer - measuring one’s work is critical to
success.
1.2.2
Imperative programming language
All examples are given in a pseudo-imperative coding format and so the reader
must know the basics of some imperative mainstream programming language
to port the examples eﬀectively, we have written this book with the following
target languages in mind:
1. C++
2. C#
3. Java
CHAPTER 1. INTRODUCTION
4
The reason that we are explicit in this requirement is simple—all our imple-
mentations are based on an imperative thinking style. If you are a functional
programmer you will need to apply various aspects from the functional paradigm
to produce eﬃcient solutions with respect to your functional language whether
it be Haskell, F#, OCaml, etc.
Two of the languages that we have listed (C# and Java) target virtual
machines which provide various things like security sand boxing, and memory
management via garbage collection algorithms. It is trivial to port our imple-
mentations to these languages. When porting to C++ you must remember to
use pointers for certain things. For example, when we describe a linked list
node as having a reference to the next node, this description is in the context
of a managed environment. In C++ you should interpret the reference as a
pointer to the next node and so on. For programmers who have a fair amount
of experience with their respective language these subtleties will present no is-
sue, which is why we really do emphasise that the reader must be comfortable
with at least one imperative language in order to successfully port the pseudo-
implementations in this book.
It is essential that the user is familiar with primitive imperative language
constructs before reading this book otherwise you will just get lost. Some algo-
rithms presented in this book can be confusing to follow even for experienced
programmers!
1.2.3
Object oriented concepts
For the most part this book does not use features that are speciﬁc to any one
language. In particular, we never provide data structures or algorithms that
work on generic types—this is in order to make the samples as easy to follow
as possible. However, to appreciate the designs of our data structures you will
need to be familiar with the following object oriented (OO) concepts:
1. Inheritance
2. Encapsulation
3. Polymorphism
This is especially important if you are planning on looking at the C# target
that we have implemented (more on that in §1.7) which makes extensive use
of the OO concepts listed above. As a ﬁnal note it is also desirable that the
reader is familiar with interfaces as the C# target uses interfaces throughout
the sorting algorithms.
1.3
Pseudocode
Throughout this book we use pseudocode to describe our solutions. For the
most part interpreting the pseudocode is trivial as it looks very much like a
more abstract C++, or C#, but there are a few things to point out:
1. Pre-conditions should always be enforced
2. Post-conditions represent the result of applying algorithm a to data struc-
ture d
CHAPTER 1. INTRODUCTION
5
3. The type of parameters is inferred
4. All primitive language constructs are explicitly begun and ended
If an algorithm has a return type it will often be presented in the post-
condition, but where the return type is suﬃciently obvious it may be omitted
for the sake of brevity.
Most algorithms in this book require parameters, and because we assign no
explicit type to those parameters the type is inferred from the contexts in which
it is used, and the operations performed upon it. Additionally, the name of
the parameter usually acts as the biggest clue to its type. For instance n is a
pseudo-name for a number and so you can assume unless otherwise stated that
n translates to an integer that has the same number of bits as a WORD on a
32 bit machine, similarly l is a pseudo-name for a list where a list is a resizeable
array (e.g. a vector).
The last major point of reference is that we always explicitly end a language
construct.
For instance if we wish to close the scope of a for loop we will
explicitly state end for rather than leaving the interpretation of when scopes
are closed to the reader. While implicit scope closure works well in simple code,
in complex cases it can lead to ambiguity.
The pseudocode style that we use within this book is rather straightforward.
All algorithms start with a simple algorithm signature, e.g.
1) algorithm AlgorithmName(arg1, arg2, ..., argN)
2) ...
n) end AlgorithmName
Immediately after the algorithm signature we list any Pre or Post condi-
tions.
1) algorithm AlgorithmName(n)
2)
Pre: n is the value to compute the factorial of
3)
n ≥0
4)
Post: the factorial of n has been computed
5)
// ...
n) end AlgorithmName
The example above describes an algorithm by the name of AlgorithmName,
which takes a single numeric parameter n. The pre and post conditions follow
the algorithm signature; you should always enforce the pre-conditions of an
algorithm when porting them to your language of choice.
Normally what is listed as a pre-conidition is critical to the algorithms opera-
tion. This may cover things like the actual parameter not being null, or that the
collection passed in must contain at least n items. The post-condition mainly
describes the eﬀect of the algorithms operation. An example of a post-condition
might be “The list has been sorted in ascending order”
Because everything we describe is language independent you will need to
make your own mind up on how to best handle pre-conditions. For example,
in the C# target we have implemented, we consider non-conformance to pre-
conditions to be exceptional cases. We provide a message in the exception to
tell the caller why the algorithm has failed to execute normally.
CHAPTER 1. INTRODUCTION
6
1.4
Tips for working through the examples
As with most books you get out what you put in and so we recommend that in
order to get the most out of this book you work through each algorithm with a
pen and paper to track things like variable names, recursive calls etc.
The best way to work through algorithms is to set up a table, and in that
table give each variable its own column and continuously update these columns.
This will help you keep track of and visualise the mutations that are occurring
throughout the algorithm.
Often while working through algorithms in such
a way you can intuitively map relationships between data structures rather
than trying to work out a few values on paper and the rest in your head. We
suggest you put everything on paper irrespective of how trivial some variables
and calculations may be so that you always have a point of reference.
When dealing with recursive algorithm traces we recommend you do the
same as the above, but also have a table that records function calls and who
they return to. This approach is a far cleaner way than drawing out an elaborate
map of function calls with arrows to one another, which gets large quickly and
simply makes things more complex to follow. Track everything in a simple and
systematic way to make your time studying the implementations far easier.
1.5
Book outline
We have split this book into two parts:
Part 1: Provides discussion and pseudo-implementations of common and uncom-
mon data structures; and
Part 2: Provides algorithms of varying purposes from sorting to string operations.
The reader doesn’t have to read the book sequentially from beginning to
end: chapters can be read independently from one another. We suggest that
in part 1 you read each chapter in its entirety, but in part 2 you can get away
with just reading the section of a chapter that describes the algorithm you are
interested in.
Each of the chapters on data structures present initially the algorithms con-
cerned with:
1. Insertion
2. Deletion
3. Searching
The previous list represents what we believe in the vast majority of cases to
be the most important for each respective data structure.
For all readers we recommend that before looking at any algorithm you
quickly look at Appendix E which contains a table listing the various symbols
used within our algorithms and their meaning. One keyword that we would like
to point out here is yield. You can think of yield in the same light as return.
The return keyword causes the method to exit and returns control to the caller,
whereas yield returns each value to the caller. With yield control only returns
to the caller when all values to return to the caller have been exhausted.
CHAPTER 1. INTRODUCTION
7
1.6
Testing
All the data structures and algorithms have been tested using a minimised test
driven development style on paper to ﬂesh out the pseudocode algorithm. We
then transcribe these tests into unit tests satisfying them one by one. When
all the test cases have been progressively satisﬁed we consider that algorithm
suitably tested.
For the most part algorithms have fairly obvious cases which need to be
satisﬁed. Some however have many areas which can prove to be more complex
to satisfy. With such algorithms we will point out the test cases which are tricky
and the corresponding portions of pseudocode within the algorithm that satisfy
that respective case.
As you become more familiar with the actual problem you will be able to
intuitively identify areas which may cause problems for your algorithms imple-
mentation. This in some cases will yield an overwhelming list of concerns which
will hinder your ability to design an algorithm greatly. When you are bom-
barded with such a vast amount of concerns look at the overall problem again
and sub-divide the problem into smaller problems. Solving the smaller problems
and then composing them is a far easier task than clouding your mind with too
many little details.
The only type of testing that we use in the implementation of all that is
provided in this book are unit tests. Because unit tests contribute such a core
piece of creating somewhat more stable software we invite the reader to view
Appendix D which describes testing in more depth.
1.7
Where can I get the code?
This book doesn’t provide any code speciﬁcally aligned with it, however we do
actively maintain an open source project1 that houses a C# implementation of
all the pseudocode listed. The project is named Data Structures and Algorithms
(DSA) and can be found at http://codeplex.com/dsa.
1.8
Final messages
We have just a few ﬁnal messages to the reader that we hope you digest before
you embark on reading this book:
1. Understand how the algorithm works ﬁrst in an abstract sense; and
2. Always work through the algorithms on paper to understand how they
achieve their outcome
If you always follow these key points, you will get the most out of this book.
1All readers are encouraged to provide suggestions, feature requests, and bugs so we can
further improve our implementations.
Part I
Data Structures
8
Chapter 2
Linked Lists
Linked lists can be thought of from a high level perspective as being a series
of nodes. Each node has at least a single pointer to the next node, and in the
last node’s case a null pointer representing that there are no more nodes in the
linked list.
In DSA our implementations of linked lists always maintain head and tail
pointers so that insertion at either the head or tail of the list is a constant
time operation. Random insertion is excluded from this and will be a linear
operation. As such, linked lists in DSA have the following characteristics:
1. Insertion is O(1)
2. Deletion is O(n)
3. Searching is O(n)
Out of the three operations the one that stands out is that of insertion. In
DSA we chose to always maintain pointers (or more aptly references) to the
node(s) at the head and tail of the linked list and so performing a traditional
insertion to either the front or back of the linked list is an O(1) operation. An
exception to this rule is performing an insertion before a node that is neither
the head nor tail in a singly linked list. When the node we are inserting before
is somewhere in the middle of the linked list (known as random insertion) the
complexity is O(n). In order to add before the designated node we need to
traverse the linked list to ﬁnd that node’s current predecessor. This traversal
yields an O(n) run time.
This data structure is trivial, but linked lists have a few key points which at
times make them very attractive:
1. the list is dynamically resized, thus it incurs no copy penalty like an array
or vector would eventually incur; and
2. insertion is O(1).
2.1
Singly Linked List
Singly linked lists are one of the most primitive data structures you will ﬁnd in
this book. Each node that makes up a singly linked list consists of a value, and
a reference to the next node (if any) in the list.
9
CHAPTER 2. LINKED LISTS
10
Figure 2.1: Singly linked list node
Figure 2.2: A singly linked list populated with integers
2.1.1
Insertion
In general when people talk about insertion with respect to linked lists of any
form they implicitly refer to the adding of a node to the tail of the list. When
you use an API like that of DSA and you see a general purpose method that
adds a node to the list, you can assume that you are adding the node to the tail
of the list not the head.
Adding a node to a singly linked list has only two cases:
1. head = ∅in which case the node we are adding is now both the head and
tail of the list; or
2. we simply need to append our node onto the end of the list updating the
tail reference appropriately.
1) algorithm Add(value)
2)
Pre: value is the value to add to the list
3)
Post: value has been placed at the tail of the list
4)
n ←node(value)
5)
if head = ∅
6)
head ←n
7)
tail ←n
8)
else
9)
tail.Next ←n
10)
tail ←n
11)
end if
12) end Add
As an example of the previous algorithm consider adding the following se-
quence of integers to the list: 1, 45, 60, and 12, the resulting list is that of
Figure 2.2.
2.1.2
Searching
Searching a linked list is straightforward: we simply traverse the list checking
the value we are looking for with the value of each node in the linked list. The
algorithm listed in this section is very similar to that used for traversal in §2.1.4.
CHAPTER 2. LINKED LISTS
11
1) algorithm Contains(head, value)
2)
Pre: head is the head node in the list
3)
value is the value to search for
4)
Post: the item is either in the linked list, true; otherwise false
5)
n ←head
6)
while n ̸= ∅and n.Value ̸= value
7)
n ←n.Next
8)
end while
9)
if n = ∅
10)
return false
11)
end if
12)
return true
13) end Contains
2.1.3
Deletion
Deleting a node from a linked list is straightforward but there are a few cases
we need to account for:
1. the list is empty; or
2. the node to remove is the only node in the linked list; or
3. we are removing the head node; or
4. we are removing the tail node; or
5. the node to remove is somewhere in between the head and tail; or
6. the item to remove doesn’t exist in the linked list
The algorithm whose cases we have described will remove a node from any-
where within a list irrespective of whether the node is the head etc. If you know
that items will only ever be removed from the head or tail of the list then you
can create much more concise algorithms. In the case of always removing from
the front of the linked list deletion becomes an O(1) operation.
CHAPTER 2. LINKED LISTS
12
1) algorithm Remove(head, value)
2)
Pre: head is the head node in the list
3)
value is the value to remove from the list
4)
Post: value is removed from the list, true; otherwise false
5)
if head = ∅
6)
// case 1
7)
return false
8)
end if
9)
n ←head
10)
if n.Value = value
11)
if head = tail
12)
// case 2
13)
head ←∅
14)
tail ←∅
15)
else
16)
// case 3
17)
head ←head.Next
18)
end if
19)
return true
20)
end if
21)
while n.Next ̸= ∅and n.Next.Value ̸= value
22)
n ←n.Next
23)
end while
24)
if n.Next ̸= ∅
25)
if n.Next = tail
26)
// case 4
27)
tail ←n
28)
end if
29)
// this is only case 5 if the conditional on line 25 was false
30)
n.Next ←n.Next.Next
31)
return true
32)
end if
33)
// case 6
34)
return false
35) end Remove
2.1.4
Traversing the list
Traversing a singly linked list is the same as that of traversing a doubly linked
list (deﬁned in §2.2). You start at the head of the list and continue until you
come across a node that is ∅. The two cases are as follows:
1. node = ∅, we have exhausted all nodes in the linked list; or
2. we must update the node reference to be node.Next.
The algorithm described is a very simple one that makes use of a simple
while loop to check the ﬁrst case.
CHAPTER 2. LINKED LISTS
13
1) algorithm Traverse(head)
2)
Pre: head is the head node in the list
3)
Post: the items in the list have been traversed
4)
n ←head
5)
while n ̸= 0
6)
yield n.Value
7)
n ←n.Next
8)
end while
9) end Traverse
2.1.5
Traversing the list in reverse order
Traversing a singly linked list in a forward manner (i.e. left to right) is simple
as demonstrated in §2.1.4. However, what if we wanted to traverse the nodes in
the linked list in reverse order for some reason? The algorithm to perform such
a traversal is very simple, and just like demonstrated in §2.1.3 we will need to
acquire a reference to the predecessor of a node, even though the fundamental
characteristics of the nodes that make up a singly linked list make this an
expensive operation. For each node, ﬁnding its predecessor is an O(n) operation,
so over the course of traversing the whole list backwards the cost becomes O(n2).
Figure 2.3 depicts the following algorithm being applied to a linked list with
the integers 5, 10, 1, and 40.
1) algorithm ReverseTraversal(head, tail)
2)
Pre: head and tail belong to the same list
3)
Post: the items in the list have been traversed in reverse order
4)
if tail ̸= ∅
5)
curr ←tail
6)
while curr ̸= head
7)
prev ←head
8)
while prev.Next ̸= curr
9)
prev ←prev.Next
10)
end while
11)
yield curr.Value
12)
curr ←prev
13)
end while
14)
yield curr.Value
15)
end if
16) end ReverseTraversal
This algorithm is only of real interest when we are using singly linked lists,
as you will soon see that doubly linked lists (deﬁned in §2.2) make reverse list
traversal simple and eﬃcient, as shown in §2.2.3.
2.2
Doubly Linked List
Doubly linked lists are very similar to singly linked lists. The only diﬀerence is
that each node has a reference to both the next and previous nodes in the list.
CHAPTER 2. LINKED LISTS
14
Figure 2.3: Reverse traveral of a singly linked list
Figure 2.4: Doubly linked list node
CHAPTER 2. LINKED LISTS
15
The following algorithms for the doubly linked list are exactly the same as
those listed previously for the singly linked list:
1. Searching (deﬁned in §2.1.2)
2. Traversal (deﬁned in §2.1.4)
2.2.1
Insertion
The only major diﬀerence between the algorithm in §2.1.1 is that we need to
remember to bind the previous pointer of n to the previous tail node if n was
not the ﬁrst node to be inserted into the list.
1) algorithm Add(value)
2)
Pre: value is the value to add to the list
3)
Post: value has been placed at the tail of the list
4)
n ←node(value)
5)
if head = ∅
6)
head ←n
7)
tail ←n
8)
else
9)
n.Previous ←tail
10)
tail.Next ←n
11)
tail ←n
12)
end if
13) end Add
Figure 2.5 shows the doubly linked list after adding the sequence of integers
deﬁned in §2.1.1.
Figure 2.5: Doubly linked list populated with integers
2.2.2
Deletion
As you may of guessed the cases that we use for deletion in a doubly linked
list are exactly the same as those deﬁned in §2.1.3. Like insertion we have the
added task of binding an additional reference (Previous) to the correct value.
CHAPTER 2. LINKED LISTS
16
1) algorithm Remove(head, value)
2)
Pre: head is the head node in the list
3)
value is the value to remove from the list
4)
Post: value is removed from the list, true; otherwise false
5)
if head = ∅
6)
return false
7)
end if
8)
if value = head.Value
9)
if head = tail
10)
head ←∅
11)
tail ←∅
12)
else
13)
head ←head.Next
14)
head.Previous ←∅
15)
end if
16)
return true
17)
end if
18)
n ←head.Next
19)
while n ̸= ∅and value ̸= n.Value
20)
n ←n.Next
21)
end while
22)
if n = tail
23)
tail ←tail.Previous
24)
tail.Next ←∅
25)
return true
26)
else if n ̸= ∅
27)
n.Previous.Next ←n.Next
28)
n.Next.Previous ←n.Previous
29)
return true
30)
end if
31)
return false
32) end Remove
2.2.3
Reverse Traversal
Singly linked lists have a forward only design, which is why the reverse traversal
algorithm deﬁned in §2.1.5 required some creative invention. Doubly linked lists
make reverse traversal as simple as forward traversal (deﬁned in §2.1.4) except
that we start at the tail node and update the pointers in the opposite direction.
Figure 2.6 shows the reverse traversal algorithm in action.
CHAPTER 2. LINKED LISTS
17
Figure 2.6: Doubly linked list reverse traversal
1) algorithm ReverseTraversal(tail)
2)
Pre: tail is the tail node of the list to traverse
3)
Post: the list has been traversed in reverse order
4)
n ←tail
5)
while n ̸= ∅
6)
yield n.Value
7)
n ←n.Previous
8)
end while
9) end ReverseTraversal
2.3
Summary
Linked lists are good to use when you have an unknown number of items to
store. Using a data structure like an array would require you to specify the size
up front; exceeding that size involves invoking a resizing algorithm which has
a linear run time. You should also use linked lists when you will only remove
nodes at either the head or tail of the list to maintain a constant run time.
This requires maintaining pointers to the nodes at the head and tail of the list
but the memory overhead will pay for itself if this is an operation you will be
performing many times.
What linked lists are not very good for is random insertion, accessing nodes
by index, and searching. At the expense of a little memory (in most cases 4
bytes would suﬃce), and a few more read/writes you could maintain a count
variable that tracks how many items are contained in the list so that accessing
such a primitive property is a constant operation - you just need to update
count during the insertion and deletion algorithms.
Singly linked lists should be used when you are only performing basic in-
sertions. In general doubly linked lists are more accommodating for non-trivial
operations on a linked list.
We recommend the use of a doubly linked list when you require forwards
and backwards traversal. For the most cases this requirement is present. For
example, consider a token stream that you want to parse in a recursive descent
fashion. Sometimes you will have to backtrack in order to create the correct
parse tree.
In this scenario a doubly linked list is best as its design makes
bi-directional traversal much simpler and quicker than that of a singly linked
CHAPTER 2. LINKED LISTS
18
list.
Chapter 3
Binary Search Tree
Binary search trees (BSTs) are very simple to understand. We start with a root
node with value x, where the left subtree of x contains nodes with values < x
and the right subtree contains nodes whose values are ≥x. Each node follows
the same rules with respect to nodes in their left and right subtrees.
BSTs are of interest because they have operations which are favourably fast:
insertion, look up, and deletion can all be done in O(log n) time. It is important
to note that the O(log n) times for these operations can only be attained if
the BST is reasonably balanced; for a tree data structure with self balancing
properties see AVL tree deﬁned in §7).
In the following examples you can assume, unless used as a parameter alias
that root is a reference to the root node of the tree.
23
14
31
7
17
9
Figure 3.1: Simple unbalanced binary search tree
19
CHAPTER 3. BINARY SEARCH TREE
20
3.1
Insertion
As mentioned previously insertion is an O(log n) operation provided that the
tree is moderately balanced.
1) algorithm Insert(value)
2)
Pre: value has passed custom type checks for type T
3)
Post: value has been placed in the correct location in the tree
4)
if root = ∅
5)
root ←node(value)
6)
else
7)
InsertNode(root, value)
8)
end if
9) end Insert
1) algorithm InsertNode(current, value)
2)
Pre: current is the node to start from
3)
Post: value has been placed in the correct location in the tree
4)
if value < current.Value
5)
if current.Left = ∅
6)
current.Left ←node(value)
7)
else
8)
InsertNode(current.Left, value)
9)
end if
10)
else
11)
if current.Right = ∅
12)
current.Right ←node(value)
13)
else
14)
InsertNode(current.Right, value)
15)
end if
16)
end if
17) end InsertNode
The insertion algorithm is split for a good reason. The ﬁrst algorithm (non-
recursive) checks a very core base case - whether or not the tree is empty. If
the tree is empty then we simply create our root node and ﬁnish. In all other
cases we invoke the recursive InsertNode algorithm which simply guides us to
the ﬁrst appropriate place in the tree to put value. Note that at each stage we
perform a binary chop: we either choose to recurse into the left subtree or the
right by comparing the new value with that of the current node. For any totally
ordered type, no value can simultaneously satisfy the conditions to place it in
both subtrees.
CHAPTER 3. BINARY SEARCH TREE
21
3.2
Searching
Searching a BST is even simpler than insertion. The pseudocode is self-explanatory
but we will look brieﬂy at the premise of the algorithm nonetheless.
We have talked previously about insertion, we go either left or right with the
right subtree containing values that are ≥x where x is the value of the node
we are inserting. When searching the rules are made a little more atomic and
at any one time we have four cases to consider:
1. the root = ∅in which case value is not in the BST; or
2. root.Value = value in which case value is in the BST; or
3. value < root.Value, we must inspect the left subtree of root for value; or
4. value > root.Value, we must inspect the right subtree of root for value.
1) algorithm Contains(root, value)
2)
Pre: root is the root node of the tree, value is what we would like to locate
3)
Post: value is either located or not
4)
if root = ∅
5)
return false
6)
end if
7)
if root.Value = value
8)
return true
9)
else if value < root.Value
10)
return Contains(root.Left, value)
11)
else
12)
return Contains(root.Right, value)
13)
end if
14) end Contains
CHAPTER 3. BINARY SEARCH TREE
22
3.3
Deletion
Removing a node from a BST is fairly straightforward, with four cases to con-
sider:
1. the value to remove is a leaf node; or
2. the value to remove has a right subtree, but no left subtree; or
3. the value to remove has a left subtree, but no right subtree; or
4. the value to remove has both a left and right subtree in which case we
promote the largest value in the left subtree.
There is also an implicit ﬁfth case whereby the node to be removed is the
only node in the tree. This case is already covered by the ﬁrst, but should be
noted as a possibility nonetheless.
Of course in a BST a value may occur more than once. In such a case the
ﬁrst occurrence of that value in the BST will be removed.
23
14
31
7
9
#1: Leaf Node
#2: Right subtree
      no left subtree
#3: Left subtree
      no right subtree
#4: Right subtree
      and left subtree
Figure 3.2: binary search tree deletion cases
The Remove algorithm given below relies on two further helper algorithms
named FindParent, and FindNode which are described in §3.4 and §3.5 re-
spectively.
CHAPTER 3. BINARY SEARCH TREE
23
1) algorithm Remove(value)
2)
Pre: value is the value of the node to remove, root is the root node of the BST
3)
Count is the number of items in the BST
3)
Post: node with value is removed if found in which case yields true, otherwise false
4)
nodeToRemove ←FindNode(value)
5)
if nodeToRemove = ∅
6)
return false // value not in BST
7)
end if
8)
parent ←FindParent(value)
9)
if Count = 1
10)
root ←∅// we are removing the only node in the BST
11)
else if nodeToRemove.Left = ∅and nodeToRemove.Right = null
12)
// case #1
13)
if nodeToRemove.Value < parent.Value
14)
parent.Left ←∅
15)
else
16)
parent.Right ←∅
17)
end if
18)
else if nodeToRemove.Left = ∅and nodeToRemove.Right ̸= ∅
19)
// case # 2
20)
if nodeToRemove.Value < parent.Value
21)
parent.Left ←nodeToRemove.Right
22)
else
23)
parent.Right ←nodeToRemove.Right
24)
end if
25)
else if nodeToRemove.Left ̸= ∅and nodeToRemove.Right = ∅
26)
// case #3
27)
if nodeToRemove.Value < parent.Value
28)
parent.Left ←nodeToRemove.Left
29)
else
30)
parent.Right ←nodeToRemove.Left
31)
end if
32)
else
33)
// case #4
34)
largestV alue ←nodeToRemove.Left
35)
while largestV alue.Right ̸= ∅
36)
// ﬁnd the largest value in the left subtree of nodeToRemove
37)
largestV alue ←largestV alue.Right
38)
end while
39)
// set the parents’ Right pointer of largestV alue to ∅
40)
FindParent(largestV alue.Value).Right ←∅
41)
nodeToRemove.Value ←largestV alue.Value
42)
end if
43)
Count ←Count −1
44)
return true
45) end Remove
CHAPTER 3. BINARY SEARCH TREE
24
3.4
Finding the parent of a given node
The purpose of this algorithm is simple - to return a reference (or pointer) to
the parent node of the one with the given value. We have found that such an
algorithm is very useful, especially when performing extensive tree transforma-
tions.
1) algorithm FindParent(value, root)
2)
Pre: value is the value of the node we want to ﬁnd the parent of
3)
root is the root node of the BST and is ! = ∅
4)
Post: a reference to the parent node of value if found; otherwise ∅
5)
if value = root.Value
6)
return ∅
7)
end if
8)
if value < root.Value
9)
if root.Left = ∅
10)
return ∅
11)
else if root.Left.Value = value
12)
return root
13)
else
14)
return FindParent(value, root.Left)
15)
end if
16)
else
17)
if root.Right = ∅
18)
return ∅
19)
else if root.Right.Value = value
20)
return root
21)
else
22)
return FindParent(value, root.Right)
23)
end if
24)
end if
25) end FindParent
A special case in the above algorithm is when the speciﬁed value does not
exist in the BST, in which case we return ∅. Callers to this algorithm must take
account of this possibility unless they are already certain that a node with the
speciﬁed value exists.
3.5
Attaining a reference to a node
This algorithm is very similar to §3.4, but instead of returning a reference to the
parent of the node with the speciﬁed value, it returns a reference to the node
itself. Again, ∅is returned if the value isn’t found.
CHAPTER 3. BINARY SEARCH TREE
25
1) algorithm FindNode(root, value)
2)
Pre: value is the value of the node we want to ﬁnd the parent of
3)
root is the root node of the BST
4)
Post: a reference to the node of value if found; otherwise ∅
5)
if root = ∅
6)
return ∅
7)
end if
8)
if root.Value = value
9)
return root
10)
else if value < root.Value
11)
return FindNode(root.Left, value)
12)
else
13)
return FindNode(root.Right, value)
14)
end if
15) end FindNode
Astute readers will have noticed that the FindNode algorithm is exactly the
same as the Contains algorithm (deﬁned in §3.2) with the modiﬁcation that
we are returning a reference to a node not true or false. Given FindNode,
the easiest way of implementing Contains is to call FindNode and compare the
return value with ∅.
3.6
Finding the smallest and largest values in
the binary search tree
To ﬁnd the smallest value in a BST you simply traverse the nodes in the left
subtree of the BST always going left upon each encounter with a node, termi-
nating when you ﬁnd a node with no left subtree. The opposite is the case when
ﬁnding the largest value in the BST. Both algorithms are incredibly simple, and
are listed simply for completeness.
The base case in both FindMin, and FindMax algorithms is when the Left
(FindMin), or Right (FindMax) node references are ∅in which case we have
reached the last node.
1) algorithm FindMin(root)
2)
Pre: root is the root node of the BST
3)
root ̸= ∅
4)
Post: the smallest value in the BST is located
5)
if root.Left = ∅
6)
return root.Value
7)
end if
8)
FindMin(root.Left)
9) end FindMin
CHAPTER 3. BINARY SEARCH TREE
26
1) algorithm FindMax(root)
2)
Pre: root is the root node of the BST
3)
root ̸= ∅
4)
Post: the largest value in the BST is located
5)
if root.Right = ∅
6)
return root.Value
7)
end if
8)
FindMax(root.Right)
9) end FindMax
3.7
Tree Traversals
There are various strategies which can be employed to traverse the items in a
tree; the choice of strategy depends on which node visitation order you require.
In this section we will touch on the traversals that DSA provides on all data
structures that derive from BinarySearchTree.
3.7.1
Preorder
When using the preorder algorithm, you visit the root ﬁrst, then traverse the left
subtree and ﬁnally traverse the right subtree. An example of preorder traversal
is shown in Figure 3.3.
1) algorithm Preorder(root)
2)
Pre: root is the root node of the BST
3)
Post: the nodes in the BST have been visited in preorder
4)
if root ̸= ∅
5)
yield root.Value
6)
Preorder(root.Left)
7)
Preorder(root.Right)
8)
end if
9) end Preorder
3.7.2
Postorder
This algorithm is very similar to that described in §3.7.1, however the value
of the node is yielded after traversing both subtrees. An example of postorder
traversal is shown in Figure 3.4.
1) algorithm Postorder(root)
2)
Pre: root is the root node of the BST
3)
Post: the nodes in the BST have been visited in postorder
4)
if root ̸= ∅
5)
Postorder(root.Left)
6)
Postorder(root.Right)
7)
yield root.Value
8)
end if
9) end Postorder
CHAPTER 3. BINARY SEARCH TREE
27
23
14
31
7
17
9
23
14
31
7
9
23
14
31
7
9
23
14
31
7
9
23
14
31
7
9
23
14
31
7
9
(a)
(b)
(c)
(d)
(e)
(f)
17
17
17
17
17
Figure 3.3: Preorder visit binary search tree example
CHAPTER 3. BINARY SEARCH TREE
28
23
14
31
7
17
9
23
14
31
7
9
23
14
31
7
9
23
14
31
7
9
23
14
31
7
9
23
14
31
7
9
(a)
(b)
(c)
(d)
(e)
(f)
17
17
17
17
17
Figure 3.4: Postorder visit binary search tree example
CHAPTER 3. BINARY SEARCH TREE
29
3.7.3
Inorder
Another variation of the algorithms deﬁned in §3.7.1 and §3.7.2 is that of inorder
traversal where the value of the current node is yielded in between traversing
the left subtree and the right subtree. An example of inorder traversal is shown
in Figure 3.5.
23
14
31
7
17
9
23
14
31
7
9
23
14
31
7
9
23
14
31
7
9
23
14
31
7
9
23
14
31
7
9
(a)
(b)
(c)
(d)
(e)
(f)
17
17
17
17
17
Figure 3.5: Inorder visit binary search tree example
1) algorithm Inorder(root)
2)
Pre: root is the root node of the BST
3)
Post: the nodes in the BST have been visited in inorder
4)
if root ̸= ∅
5)
Inorder(root.Left)
6)
yield root.Value
7)
Inorder(root.Right)
8)
end if
9) end Inorder
One of the beauties of inorder traversal is that values are yielded in their
comparison order. In other words, when traversing a populated BST with the
inorder strategy, the yielded sequence would have property xi ≤xi+1∀i.
CHAPTER 3. BINARY SEARCH TREE
30
3.7.4
Breadth First
Traversing a tree in breadth ﬁrst order yields the values of all nodes of a par-
ticular depth in the tree before any deeper ones. In other words, given a depth
d we would visit the values of all nodes at d in a left to right fashion, then we
would proceed to d + 1 and so on until we hade no more nodes to visit. An
example of breadth ﬁrst traversal is shown in Figure 3.6.
Traditionally breadth ﬁrst traversal is implemented using a list (vector, re-
sizeable array, etc) to store the values of the nodes visited in breadth ﬁrst order
and then a queue to store those nodes that have yet to be visited.
23
14
31
7
17
9
23
14
31
7
9
23
14
31
7
9
23
14
31
7
9
23
14
31
7
9
23
14
31
7
9
(a)
(b)
(c)
(d)
(e)
(f)
17
17
17
17
17
Figure 3.6: Breadth First visit binary search tree example
CHAPTER 3. BINARY SEARCH TREE
31
1) algorithm BreadthFirst(root)
2)
Pre: root is the root node of the BST
3)
Post: the nodes in the BST have been visited in breadth ﬁrst order
4)
q ←queue
5)
while root ̸= ∅
6)
yield root.Value
7)
if root.Left ̸= ∅
8)
q.Enqueue(root.Left)
9)
end if
10)
if root.Right ̸= ∅
11)
q.Enqueue(root.Right)
12)
end if
13)
if !q.IsEmpty()
14)
root ←q.Dequeue()
15)
else
16)
root ←∅
17)
end if
18)
end while
19) end BreadthFirst
3.8
Summary
A binary search tree is a good solution when you need to represent types that are
ordered according to some custom rules inherent to that type. With logarithmic
insertion, lookup, and deletion it is very eﬀecient. Traversal remains linear, but
there are many ways in which you can visit the nodes of a tree.
Trees are
recursive data structures, so typically you will ﬁnd that many algorithms that
operate on a tree are recursive.
The run times presented in this chapter are based on a pretty big assumption
- that the binary search tree’s left and right subtrees are reasonably balanced.
We can only attain logarithmic run times for the algorithms presented earlier
when this is true. A binary search tree does not enforce such a property, and
the run times for these operations on a pathologically unbalanced tree become
linear: such a tree is eﬀectively just a linked list. Later in §7 we will examine
an AVL tree that enforces self-balancing properties to help attain logarithmic
run times.
Chapter 4
Heap
A heap can be thought of as a simple tree data structure, however a heap usually
employs one of two strategies:
1. min heap; or
2. max heap
Each strategy determines the properties of the tree and its values. If you
were to choose the min heap strategy then each parent node would have a value
that is ≤than its children. For example, the node at the root of the tree will
have the smallest value in the tree.
The opposite is true for the max heap
strategy. In this book you should assume that a heap employs the min heap
strategy unless otherwise stated.
Unlike other tree data structures like the one deﬁned in §3 a heap is generally
implemented as an array rather than a series of nodes which each have refer-
ences to other nodes. The nodes are conceptually the same, however, having at
most two children. Figure 4.1 shows how the tree (not a heap data structure)
(12 7(3 2) 6(9 )) would be represented as an array. The array in Figure 4.1 is a
result of simply adding values in a top-to-bottom, left-to-right fashion. Figure
4.2 shows arrows to the direct left and right child of each value in the array.
This chapter is very much centred around the notion of representing a tree as
an array and because this property is key to understanding this chapter Figure
4.3 shows a step by step process to represent a tree data structure as an array.
In Figure 4.3 you can assume that the default capacity of our array is eight.
Using just an array is often not suﬃcient as we have to be up front about the
size of the array to use for the heap. Often the run time behaviour of a program
can be unpredictable when it comes to the size of its internal data structures,
so we need to choose a more dynamic data structure that contains the following
properties:
1. we can specify an initial size of the array for scenarios where we know the
upper storage limit required; and
2. the data structure encapsulates resizing algorithms to grow the array as
required at run time
32
CHAPTER 4. HEAP
33
Figure 4.1: Array representation of a simple tree data structure
Figure 4.2: Direct children of the nodes in an array representation of a tree data
structure
1. Vector
2. ArrayList
3. List
Figure 4.1 does not specify how we would handle adding null references to
the heap. This varies from case to case; sometimes null values are prohibited
entirely; in other cases we may treat them as being smaller than any non-null
value, or indeed greater than any non-null value. You will have to resolve this
ambiguity yourself having studied your requirements. For the sake of clarity we
will avoid the issue by prohibiting null values.
Because we are using an array we need some way to calculate the index of a
parent node, and the children of a node. The required expressions for this are
deﬁned as follows for a node at index:
1. (index −1)/2 (parent index)
2. 2 ∗index + 1 (left child)
3. 2 ∗index + 2 (right child)
In Figure 4.4 a) represents the calculation of the right child of 12 (2 ∗0 + 2);
and b) calculates the index of the parent of 3 ((3 −1)/2).
4.1
Insertion
Designing an algorithm for heap insertion is simple, but we must ensure that
heap order is preserved after each insertion. Generally this is a post-insertion
operation. Inserting a value into the next free slot in an array is simple: we just
need to keep track of the next free index in the array as a counter, and increment
it after each insertion. Inserting our value into the heap is the ﬁrst part of the
algorithm; the second is validating heap order. In the case of min-heap ordering
this requires us to swap the values of a parent and its child if the value of the
child is < the value of its parent. We must do this for each subtree containing
the value we just inserted.
CHAPTER 4. HEAP
34
Figure 4.3: Converting a tree data structure to its array counterpart
CHAPTER 4. HEAP
35
Figure 4.4: Calculating node properties
The run time eﬃciency for heap insertion is O(log n). The run time is a
by product of verifying heap order as the ﬁrst part of the algorithm (the actual
insertion into the array) is O(1).
Figure 4.5 shows the steps of inserting the values 3, 9, 12, 7, and 1 into a
min-heap.
CHAPTER 4. HEAP
36
Figure 4.5: Inserting values into a min-heap
CHAPTER 4. HEAP
37
1) algorithm Add(value)
2)
Pre: value is the value to add to the heap
3)
Count is the number of items in the heap
4)
Post: the value has been added to the heap
5)
heap[Count] ←value
6)
Count ←Count +1
7)
MinHeapify()
8) end Add
1) algorithm MinHeapify()
2)
Pre: Count is the number of items in the heap
3)
heap is the array used to store the heap items
4)
Post: the heap has preserved min heap ordering
5)
i ←Count −1
6)
while i > 0 and heap[i] < heap[(i −1)/2]
7)
Swap(heap[i], heap[(i −1)/2]
8)
i ←(i −1)/2
9)
end while
10) end MinHeapify
The design of the MaxHeapify algorithm is very similar to that of the Min-
Heapify algorithm, the only diﬀerence is that the < operator in the second
condition of entering the while loop is changed to >.
4.2
Deletion
Just as for insertion, deleting an item involves ensuring that heap ordering is
preserved. The algorithm for deletion has three steps:
1. ﬁnd the index of the value to delete
2. put the last value in the heap at the index location of the item to delete
3. verify heap ordering for each subtree which used to include the value
CHAPTER 4. HEAP
38
1) algorithm Remove(value)
2)
Pre: value is the value to remove from the heap
3)
left, and right are updated alias’ for 2 ∗index + 1, and 2 ∗index + 2 respectively
4)
Count is the number of items in the heap
5)
heap is the array used to store the heap items
6)
Post: value is located in the heap and removed, true; otherwise false
7)
// step 1
8)
index ←FindIndex(heap, value)
9)
if index < 0
10)
return false
11)
end if
12)
Count ←Count −1
13)
// step 2
14)
heap[index] ←heap[Count]
15)
// step 3
16)
while left < Count and heap[index] > heap[left] or heap[index] > heap[right]
17)
// promote smallest key from subtree
18)
if heap[left] < heap[right]
19)
Swap(heap, left, index)
20)
index ←left
21)
else
22)
Swap(heap, right, index)
23)
index ←right
24)
end if
25)
end while
26)
return true
27) end Remove
Figure 4.6 shows the Remove algorithm visually, removing 1 from a heap
containing the values 1, 3, 9, 12, and 13. In Figure 4.6 you can assume that we
have speciﬁed that the backing array of the heap should have an initial capacity
of eight.
Please note that in our deletion algorithm that we don’t default the removed
value in the heap array. If you are using a heap for reference types, i.e. objects
that are allocated on a heap you will want to free that memory. This is important
in both unmanaged, and managed languages. In the latter we will want to null
that empty hole so that the garbage collector can reclaim that memory. If we
were to not null that hole then the object could still be reached and thus won’t
be garbage collected.
4.3
Searching
Searching a heap is merely a matter of traversing the items in the heap array
sequentially, so this operation has a run time complexity of O(n). The search
can be thought of as one that uses a breadth ﬁrst traversal as deﬁned in §3.7.4
to visit the nodes within the heap to check for the presence of a speciﬁed item.
CHAPTER 4. HEAP
39
Figure 4.6: Deleting an item from a heap
CHAPTER 4. HEAP
40
1) algorithm Contains(value)
2)
Pre: value is the value to search the heap for
3)
Count is the number of items in the heap
4)
heap is the array used to store the heap items
5)
Post: value is located in the heap, in which case true; otherwise false
6)
i ←0
7)
while i < Count and heap[i] ̸= value
8)
i ←i + 1
9)
end while
10)
if i < Count
11)
return true
12)
else
13)
return false
14)
end if
15) end Contains
The problem with the previous algorithm is that we don’t take advantage
of the properties in which all values of a heap hold, that is the property of the
heap strategy being used. For instance if we had a heap that didn’t contain the
value 4 we would have to exhaust the whole backing heap array before we could
determine that it wasn’t present in the heap. Factoring in what we know about
the heap we can optimise the search algorithm by including logic which makes
use of the properties presented by a certain heap strategy.
Optimising to deterministically state that a value is in the heap is not that
straightforward, however the problem is a very interesting one. As an example
consider a min-heap that doesn’t contain the value 5. We can only rule that the
value is not in the heap if 5 > the parent of the current node being inspected
and < the current node being inspected ∀nodes at the current level we are
traversing.
If this is the case then 5 cannot be in the heap and so we can
provide an answer without traversing the rest of the heap. If this property is
not satisﬁed for any level of nodes that we are inspecting then the algorithm
will indeed fall back to inspecting all the nodes in the heap. The optimisation
that we present can be very common and so we feel that the extra logic within
the loop is justiﬁed to prevent the expensive worse case run time.
The following algorithm is speciﬁcally designed for a min-heap. To tailor the
algorithm for a max-heap the two comparison operations in the else if condition
within the inner while loop should be ﬂipped.
CHAPTER 4. HEAP
41
1) algorithm Contains(value)
2)
Pre: value is the value to search the heap for
3)
Count is the number of items in the heap
4)
heap is the array used to store the heap items
5)
Post: value is located in the heap, in which case true; otherwise false
6)
start ←0
7)
nodes ←1
8)
while start < Count
9)
start ←nodes −1
10)
end ←nodes + start
11)
count ←0
12)
while start < Count and start < end
13)
if value = heap[start]
14)
return true
15)
else if value > Parent(heap[start]) and value < heap[start]
16)
count ←count + 1
17)
end if
18)
start ←start + 1
19)
end while
20)
if count = nodes
21)
return false
22)
end if
23)
nodes ←nodes ∗2
24)
end while
25)
return false
26) end Contains
The new Contains algorithm determines if the value is not in the heap by
checking whether count = nodes. In such an event where this is true then we
can conﬁrm that ∀nodes n at level i : value > Parent(n), value < n thus there
is no possible way that value is in the heap. As an example consider Figure 4.7.
If we are searching for the value 10 within the min-heap displayed it is obvious
that we don’t need to search the whole heap to determine 9 is not present. We
can verify this after traversing the nodes in the second level of the heap as the
previous expression deﬁned holds true.
4.4
Traversal
As mentioned in §4.3 traversal of a heap is usually done like that of any other
array data structure which our heap implementation is based upon. As a result
you traverse the array starting at the initial array index (0 in most languages)
and then visit each value within the array until you have reached the upper
bound of the heap. You will note that in the search algorithm that we use Count
as this upper bound rather than the actual physical bound of the allocated
array. Count is used to partition the conceptual heap from the actual array
implementation of the heap: we only care about the items in the heap, not the
whole array—the latter may contain various other bits of data as a result of
heap mutation.
CHAPTER 4. HEAP
42
Figure 4.7: Determining 10 is not in the heap after inspecting the nodes of Level
2
Figure 4.8: Living and dead space in the heap backing array
If you have followed the advice we gave in the deletion algorithm then a
heap that has been mutated several times will contain some form of default
value for items no longer in the heap.
Potentially you will have at most
LengthOf(heapArray) −Count garbage values in the backing heap array data
structure. The garbage values of course vary from platform to platform. To
make things simple the garbage value of a reference type will be simple ∅and 0
for a value type.
Figure 4.8 shows a heap that you can assume has been mutated many times.
For this example we can further assume that at some point the items in indexes
3 −5 actually contained references to live objects of type T.
In Figure 4.8
subscript is used to disambiguate separate objects of T.
From what you have read thus far you will most likely have picked up that
traversing the heap in any other order would be of little beneﬁt.
The heap
property only holds for the subtree of each node and so traversing a heap in
any other fashion requires some creative intervention. Heaps are not usually
traversed in any other way than the one prescribed previously.
4.5
Summary
Heaps are most commonly used to implement priority queues (see §6.2 for a
sample implementation) and to facilitate heap sort. As discussed in both the
insertion §4.1 and deletion §4.2 sections a heap maintains heap order according
to the selected ordering strategy. These strategies are referred to as min-heap,
CHAPTER 4. HEAP
43
and max heap. The former strategy enforces that the value of a parent node is
less than that of each of its children, the latter enforces that the value of the
parent is greater than that of each of its children.
When you come across a heap and you are not told what strategy it enforces
you should assume that it uses the min-heap strategy.
If the heap can be
conﬁgured otherwise, e.g. to use max-heap then this will often require you to
state this explicitly. The heap abides progressively to a strategy during the
invocation of the insertion, and deletion algorithms. The cost of such a policy is
that upon each insertion and deletion we invoke algorithms that have logarithmic
run time complexities. While the cost of maintaining the strategy might not
seem overly expensive it does still come at a price. We will also have to factor
in the cost of dynamic array expansion at some stage. This will occur if the
number of items within the heap outgrows the space allocated in the heap’s
backing array. It may be in your best interest to research a good initial starting
size for your heap array. This will assist in minimising the impact of dynamic
array resizing.
Chapter 5
Sets
A set contains a number of values, in no particular order. The values within
the set are distinct from one another.
Generally set implementations tend to check that a value is not in the set
before adding it, avoiding the issue of repeated values from ever occurring.
This section does not cover set theory in depth; rather it demonstrates brieﬂy
the ways in which the values of sets can be deﬁned, and common operations that
may be performed upon them.
The notation A = {4, 7, 9, 12, 0} deﬁnes a set A whose values are listed within
the curly braces.
Given the set A deﬁned previously we can say that 4 is a member of A
denoted by 4 ∈A, and that 99 is not a member of A denoted by 99 /
∈A.
Often deﬁning a set by manually stating its members is tiresome, and more
importantly the set may contain a large number of values. A more concise way
of deﬁning a set and its members is by providing a series of properties that the
values of the set must satisfy. For example, from the deﬁnition A = {x|x >
0, x % 2 = 0} the set A contains only positive integers that are even. x is an
alias to the current value we are inspecting and to the right hand side of | are
the properties that x must satisfy to be in the set A. In this example, x must
be > 0, and the remainder of the arithmetic expression x/2 must be 0. You will
be able to note from the previous deﬁnition of the set A that the set can contain
an inﬁnite number of values, and that the values of the set A will be all even
integers that are a member of the natural numbers set N, where N = {1, 2, 3, ...}.
Finally in this brief introduction to sets we will cover set intersection and
union, both of which are very common operations (amongst many others) per-
formed on sets. The union set can be deﬁned as follows A ∪B = {x | x ∈
A or x ∈B}, and intersection A ∩B = {x | x ∈A and x ∈B}. Figure 5.1
demonstrates set intersection and union graphically.
Given the set deﬁnitions A = {1, 2, 3}, and B = {6, 2, 9} the union of the two
sets is A∪B = {1, 2, 3, 6, 9}, and the intersection of the two sets is A∩B = {2}.
Both set union and intersection are sometimes provided within the frame-
work associated with mainstream languages.
This is the case in .NET 3.51
where such algorithms exist as extension methods deﬁned in the type Sys-
tem.Linq.Enumerable2, as a result DSA does not provide implementations of
1http://www.microsoft.com/NET/
2http://msdn.microsoft.com/en-us/library/system.linq.enumerable_members.aspx
44
CHAPTER 5. SETS
45
Figure 5.1: a) A ∩B; b) A ∪B
these algorithms. Most of the algorithms deﬁned in System.Linq.Enumerable
deal mainly with sequences rather than sets exclusively.
Set union can be implemented as a simple traversal of both sets adding each
item of the two sets to a new union set.
1) algorithm Union(set1, set2)
2)
Pre: set1, and set2 ̸= ∅
3)
union is a set
3)
Post: A union of set1, and set2 has been created
4)
foreach item in set1
5)
union.Add(item)
6)
end foreach
7)
foreach item in set2
8)
union.Add(item)
9)
end foreach
10)
return union
11) end Union
The run time of our Union algorithm is O(m + n) where m is the number
of items in the ﬁrst set and n is the number of items in the second set. This
runtime applies only to sets that exhibit O(1) insertions.
Set intersection is also trivial to implement. The only major thing worth
pointing out about our algorithm is that we traverse the set containing the
fewest items. We can do this because if we have exhausted all the items in the
smaller of the two sets then there are no more items that are members of both
sets, thus we have no more items to add to the intersection set.
CHAPTER 5. SETS
46
1) algorithm Intersection(set1, set2)
2)
Pre: set1, and set2 ̸= ∅
3)
intersection, and smallerSet are sets
3)
Post: An intersection of set1, and set2 has been created
4)
if set1.Count < set2.Count
5)
smallerSet ←set1
6)
else
7)
smallerSet ←set2
8)
end if
9)
foreach item in smallerSet
10)
if set1.Contains(item) and set2.Contains(item)
11)
intersection.Add(item)
12)
end if
13)
end foreach
14)
return intersection
15) end Intersection
The run time of our Intersection algorithm is O(n) where n is the number
of items in the smaller of the two sets. Just like our Union algorithm a linear
runtime can only be attained when operating on a set with O(1) insertion.
5.1
Unordered
Sets in the general sense do not enforce the explicit ordering of their mem-
bers. For example the members of B = {6, 2, 9} conform to no ordering scheme
because it is not required.
Most libraries provide implementations of unordered sets and so DSA does
not; we simply mention it here to disambiguate between an unordered set and
ordered set.
We will only look at insertion for an unordered set and cover brieﬂy why a
hash table is an eﬃcient data structure to use for its implementation.
5.1.1
Insertion
An unordered set can be eﬃciently implemented using a hash table as its backing
data structure. As mentioned previously we only add an item to a set if that
item is not already in the set, so the backing data structure we use must have
a quick look up and insertion run time complexity.
A hash map generally provides the following:
1. O(1) for insertion
2. approaching O(1) for look up
The above depends on how good the hashing algorithm of the hash table
is, but most hash tables employ incredibly eﬃcient general purpose hashing
algorithms and so the run time complexities for the hash table in your library
of choice should be very similar in terms of eﬃciency.
CHAPTER 5. SETS
47
5.2
Ordered
An ordered set is similar to an unordered set in the sense that its members are
distinct, but an ordered set enforces some predeﬁned comparison on each of its
members to produce a set whose members are ordered appropriately.
In DSA 0.5 and earlier we used a binary search tree (deﬁned in §3) as the
internal backing data structure for our ordered set. From versions 0.6 onwards
we replaced the binary search tree with an AVL tree primarily because AVL is
balanced.
The ordered set has its order realised by performing an inorder traversal
upon its backing tree data structure which yields the correct ordered sequence
of set members.
Because an ordered set in DSA is simply a wrapper for an AVL tree that
additionally ensures that the tree contains unique items you should read §7 to
learn more about the run time complexities associated with its operations.
5.3
Summary
Sets provide a way of having a collection of unique objects, either ordered or
unordered.
When implementing a set (either ordered or unordered) it is key to select
the correct backing data structure. As we discussed in §5.1.1 because we check
ﬁrst if the item is already contained within the set before adding it we need
this check to be as quick as possible. For unordered sets we can rely on the use
of a hash table and use the key of an item to determine whether or not it is
already contained within the set. Using a hash table this check results in a near
constant run time complexity. Ordered sets cost a little more for this check,
however the logarithmic growth that we incur by using a binary search tree as
its backing data structure is acceptable.
Another key property of sets implemented using the approach we describe is
that both have favourably fast look-up times. Just like the check before inser-
tion, for a hash table this run time complexity should be near constant. Ordered
sets as described in 3 perform a binary chop at each stage when searching for
the existence of an item yielding a logarithmic run time.
We can use sets to facilitate many algorithms that would otherwise be a little
less clear in their implementation. For example in §11.4 we use an unordered
set to assist in the construction of an algorithm that determines the number of
repeated words within a string.
Chapter 6
Queues
Queues are an essential data structure that are found in vast amounts of soft-
ware from user mode to kernel mode applications that are core to the system.
Fundamentally they honour a ﬁrst in ﬁrst out (FIFO) strategy, that is the item
ﬁrst put into the queue will be the ﬁrst served, the second item added to the
queue will be the second to be served and so on.
A traditional queue only allows you to access the item at the front of the
queue; when you add an item to the queue that item is placed at the back of
the queue.
Historically queues always have the following three core methods:
Enqueue: places an item at the back of the queue;
Dequeue: retrieves the item at the front of the queue, and removes it from the
queue;
Peek: 1 retrieves the item at the front of the queue without removing it from
the queue
As an example to demonstrate the behaviour of a queue we will walk through
a scenario whereby we invoke each of the previously mentioned methods observ-
ing the mutations upon the queue data structure. The following list describes
the operations performed upon the queue in Figure 6.1:
1. Enqueue(10)
2. Enqueue(12)
3. Enqueue(9)
4. Enqueue(8)
5. Enqueue(3)
6. Dequeue()
7. Peek()
1This operation is sometimes referred to as Front
48
CHAPTER 6. QUEUES
49
8. Enqueue(33)
9. Peek()
10. Dequeue()
6.1
A standard queue
A queue is implicitly like that described prior to this section. In DSA we don’t
provide a standard queue because queues are so popular and such a core data
structure that you will ﬁnd pretty much every mainstream library provides a
queue data structure that you can use with your language of choice. In this
section we will discuss how you can, if required, implement an eﬃcient queue
data structure.
The main property of a queue is that we have access to the item at the
front of the queue. The queue data structure can be eﬃciently implemented
using a singly linked list (deﬁned in §2.1). A singly linked list provides O(1)
insertion and deletion run time complexities. The reason we have an O(1) run
time complexity for deletion is because we only ever remove items from the front
of queues (with the Dequeue operation). Since we always have a pointer to the
item at the head of a singly linked list, removal is simply a case of returning
the value of the old head node, and then modifying the head pointer to be the
next node of the old head node. The run time complexity for searching a queue
remains the same as that of a singly linked list: O(n).
6.2
Priority Queue
Unlike a standard queue where items are ordered in terms of who arrived ﬁrst,
a priority queue determines the order of its items by using a form of custom
comparer to see which item has the highest priority. Other than the items in a
priority queue being ordered by priority it remains the same as a normal queue:
you can only access the item at the front of the queue.
A sensible implementation of a priority queue is to use a heap data structure
(deﬁned in §4). Using a heap we can look at the ﬁrst item in the queue by simply
returning the item at index 0 within the heap array. A heap provides us with the
ability to construct a priority queue where the items with the highest priority
are either those with the smallest value, or those with the largest.
6.3
Double Ended Queue
Unlike the queues we have talked about previously in this chapter a double
ended queue allows you to access the items at both the front, and back of the
queue. A double ended queue is commonly known as a deque which is the name
we will here on in refer to it as.
A deque applies no prioritization strategy to its items like a priority queue
does, items are added in order to either the front of back of the deque. The
former properties of the deque are denoted by the programmer utilising the data
structures exposed interface.
CHAPTER 6. QUEUES
50
Figure 6.1: Queue mutations
CHAPTER 6. QUEUES
51
Deque’s provide front and back speciﬁc versions of common queue operations,
e.g. you may want to enqueue an item to the front of the queue rather than
the back in which case you would use a method with a name along the lines
of EnqueueFront. The following list identiﬁes operations that are commonly
supported by deque’s:
• EnqueueFront
• EnqueueBack
• DequeueFront
• DequeueBack
• PeekFront
• PeekBack
Figure 6.2 shows a deque after the invocation of the following methods (in-
order):
1. EnqueueBack(12)
2. EnqueueFront(1)
3. EnqueueBack(23)
4. EnqueueFront(908)
5. DequeueFront()
6. DequeueBack()
The operations have a one-to-one translation in terms of behaviour with
those of a normal queue, or priority queue. In some cases the set of algorithms
that add an item to the back of the deque may be named as they are with
normal queues, e.g. EnqueueBack may simply be called Enqueue an so on. Some
frameworks also specify explicit behaviour’s that data structures must adhere to.
This is certainly the case in .NET where most collections implement an interface
which requires the data structure to expose a standard Add method. In such
a scenario you can safely assume that the Add method will simply enqueue an
item to the back of the deque.
With respect to algorithmic run time complexities a deque is the same as
a normal queue.
That is enqueueing an item to the back of a the queue is
O(1), additionally enqueuing an item to the front of the queue is also an O(1)
operation.
A deque is a wrapper data structure that uses either an array, or a doubly
linked list. Using an array as the backing data structure would require the pro-
grammer to be explicit about the size of the array up front, this would provide
an obvious advantage if the programmer could deterministically state the maxi-
mum number of items the deque would contain at any one time. Unfortunately
in most cases this doesn’t hold, as a result the backing array will inherently
incur the expense of invoking a resizing algorithm which would most likely be
an O(n) operation. Such an approach would also leave the library developer
CHAPTER 6. QUEUES
52
Figure 6.2: Deque data structure after several mutations
CHAPTER 6. QUEUES
53
to look at array minimization techniques as well, it could be that after several
invocations of the resizing algorithm and various mutations on the deque later
that we have an array taking up a considerable amount of memory yet we are
only using a few small percentage of that memory.
An algorithm described
would also be O(n) yet its invocation would be harder to gauge strategically.
To bypass all the aforementioned issues a deque typically uses a doubly
linked list as its baking data structure. While a node that has two pointers
consumes more memory than its array item counterpart it makes redundant the
need for expensive resizing algorithms as the data structure increases in size
dynamically. With a language that targets a garbage collected virtual machine
memory reclamation is an opaque process as the nodes that are no longer ref-
erenced become unreachable and are thus marked for collection upon the next
invocation of the garbage collection algorithm. With C++ or any other lan-
guage that uses explicit memory allocation and deallocation it will be up to the
programmer to decide when the memory that stores the object can be freed.
6.4
Summary
With normal queues we have seen that those who arrive ﬁrst are dealt with ﬁrst;
that is they are dealt with in a ﬁrst-in-ﬁrst-out (FIFO) order. Queues can be
ever so useful; for example the Windows CPU scheduler uses a diﬀerent queue
for each priority of process to determine which should be the next process to
utilise the CPU for a speciﬁed time quantum. Normal queues have constant
insertion and deletion run times. Searching a queue is fairly unusual—typically
you are only interested in the item at the front of the queue. Despite that,
searching is usually exposed on queues and typically the run time is linear.
In this chapter we have also seen priority queues where those at the front
of the queue have the highest priority and those near the back have the lowest.
One implementation of a priority queue is to use a heap data structure as its
backing store, so the run times for insertion, deletion, and searching are the
same as those for a heap (deﬁned in §4).
Queues are a very natural data structure, and while they are fairly primitive
they can make many problems a lot simpler.
For example the breadth ﬁrst
search deﬁned in §3.7.4 makes extensive use of queues.
Chapter 7
AVL Tree
In the early 60’s G.M. Adelson-Velsky and E.M. Landis invented the ﬁrst self-
balancing binary search tree data structure, calling it AVL Tree.
An AVL tree is a binary search tree (BST, deﬁned in §3) with a self-balancing
condition stating that the diﬀerence between the height of the left and right
subtrees cannot be no more than one, see Figure 7.1. This condition, restored
after each tree modiﬁcation, forces the general shape of an AVL tree. Before
continuing, let us focus on why balance is so important.
Consider a binary
search tree obtained by starting with an empty tree and inserting some values
in the following order 1,2,3,4,5.
The BST in Figure 7.2 represents the worst case scenario in which the run-
ning time of all common operations such as search, insertion and deletion are
O(n). By applying a balance condition we ensure that the worst case running
time of each common operation is O(log n). The height of an AVL tree with n
nodes is O(log n) regardless of the order in which values are inserted.
The AVL balance condition, known also as the node balance factor represents
an additional piece of information stored for each node. This is combined with
a technique that eﬃciently restores the balance condition for the tree. In an
AVL tree the inventors make use of a well-known technique called tree rotation.
h
h+1
Figure 7.1: The left and right subtrees of an AVL tree diﬀer in height by at
most 1
54
CHAPTER 7. AVL TREE
55
1
2
3
4
5
Figure 7.2: Unbalanced binary search tree
2
4
5
1
3
4
5
3
2
1
a)
b)
Figure 7.3: Avl trees, insertion order: -a)1,2,3,4,5 -b)1,5,4,3,2
CHAPTER 7. AVL TREE
56
7.1
Tree Rotations
A tree rotation is a constant time operation on a binary search tree that changes
the shape of a tree while preserving standard BST properties. There are left and
right rotations both of them decrease the height of a BST by moving smaller
subtrees down and larger subtrees up.
14
24
11
8
2
8
14
24
2
11
Right
Rotation
Left
Rotation
Figure 7.4: Tree left and right rotations
CHAPTER 7. AVL TREE
57
1) algorithm LeftRotation(node)
2)
Pre: node.Right ! = ∅
3)
Post: node.Right is the new root of the subtree,
4)
node has become node.Right’s left child and,
5)
BST properties are preserved
6)
RightNode ←node.Right
7)
node.Right ←RightNode.Left
8)
RightNode.Left ←node
9) end LeftRotation
1) algorithm RightRotation(node)
2)
Pre: node.Left ! = ∅
3)
Post: node.Left is the new root of the subtree,
4)
node has become node.Left’s right child and,
5)
BST properties are preserved
6)
LeftNode ←node.Left
7)
node.Left ←LeftNode.Right
8)
LeftNode.Right ←node
9) end RightRotation
The right and left rotation algorithms are symmetric.
Only pointers are
changed by a rotation resulting in an O(1) runtime complexity; the other ﬁelds
present in the nodes are not changed.
7.2
Tree Rebalancing
The algorithm that we present in this section veriﬁes that the left and right
subtrees diﬀer at most in height by 1. If this property is not present then we
perform the correct rotation.
Notice that we use two new algorithms that represent double rotations.
These algorithms are named LeftAndRightRotation, and RightAndLeftRotation.
The algorithms are self documenting in their names, e.g. LeftAndRightRotation
ﬁrst performs a left rotation and then subsequently a right rotation.
CHAPTER 7. AVL TREE
58
1) algorithm CheckBalance(current)
2)
Pre: current is the node to start from balancing
3)
Post: current height has been updated while tree balance is if needed
4)
restored through rotations
5)
if current.Left = ∅and current.Right = ∅
6)
current.Height = -1;
7)
else
8)
current.Height = Max(Height(current.Left),Height(current.Right)) + 1
9)
end if
10)
if Height(current.Left) - Height(current.Right) > 1
11)
if Height(current.Left.Left) - Height(current.Left.Right) > 0
12)
RightRotation(current)
13)
else
14)
LeftAndRightRotation(current)
15)
end if
16)
else if Height(current.Left) - Height(current.Right) < −1
17)
if Height(current.Right.Left) - Height(current.Right.Right) < 0
18)
LeftRotation(current)
19)
else
20)
RightAndLeftRotation(current)
21)
end if
22)
end if
23) end CheckBalance
7.3
Insertion
AVL insertion operates ﬁrst by inserting the given value the same way as BST
insertion and then by applying rebalancing techniques if necessary. The latter
is only performed if the AVL property no longer holds, that is the left and right
subtrees height diﬀer by more than 1. Each time we insert a node into an AVL
tree:
1. We go down the tree to ﬁnd the correct point at which to insert the node,
in the same manner as for BST insertion; then
2. we travel up the tree from the inserted node and check that the node
balancing property has not been violated; if the property hasn’t been
violated then we need not rebalance the tree, the opposite is true if the
balancing property has been violated.
CHAPTER 7. AVL TREE
59
1) algorithm Insert(value)
2)
Pre: value has passed custom type checks for type T
3)
Post: value has been placed in the correct location in the tree
4)
if root = ∅
5)
root ←node(value)
6)
else
7)
InsertNode(root, value)
8)
end if
9) end Insert
1) algorithm InsertNode(current, value)
2)
Pre: current is the node to start from
3)
Post: value has been placed in the correct location in the tree while
4)
preserving tree balance
5)
if value < current.Value
6)
if current.Left = ∅
7)
current.Left ←node(value)
8)
else
9)
InsertNode(current.Left, value)
10)
end if
11)
else
12)
if current.Right = ∅
13)
current.Right ←node(value)
14)
else
15)
InsertNode(current.Right, value)
16)
end if
17)
end if
18)
CheckBalance(current)
19) end InsertNode
7.4
Deletion
Our balancing algorithm is like the one presented for our BST (deﬁned in §3.3).
The major diﬀerence is that we have to ensure that the tree still adheres to the
AVL balance property after the removal of the node. If the tree doesn’t need
to be rebalanced and the value we are removing is contained within the tree
then no further step are required. However, when the value is in the tree and
its removal upsets the AVL balance property then we must perform the correct
rotation(s).
CHAPTER 7. AVL TREE
60
1) algorithm Remove(value)
2)
Pre: value is the value of the node to remove, root is the root node
3)
of the Avl
4)
Post: node with value is removed and tree rebalanced if found in which
5)
case yields true, otherwise false
6)
nodeToRemove ←root
7)
parent ←∅
8)
Stackpath ←root
9)
while nodeToRemove ̸= ∅and nodeToRemove.V alue = V alue
10)
parent = nodeToRemove
11)
if value < nodeToRemove.Value
12)
nodeToRemove ←nodeToRemove.Left
13)
else
14)
nodeToRemove ←nodeToRemove.Right
15)
end if
16)
path.Push(nodeToRemove)
17)
end while
18)
if nodeToRemove = ∅
19)
return false // value not in Avl
20)
end if
21)
parent ←FindParent(value)
22)
if count = 1 // count keeps track of the # of nodes in the Avl
23)
root ←∅// we are removing the only node in the Avl
24)
else if nodeToRemove.Left = ∅and nodeToRemove.Right = null
25)
// case #1
26)
if nodeToRemove.Value < parent.Value
27)
parent.Left ←∅
28)
else
29)
parent.Right ←∅
30)
end if
31)
else if nodeToRemove.Left = ∅and nodeToRemove.Right ̸= ∅
32)
// case # 2
33)
if nodeToRemove.Value < parent.Value
34)
parent.Left ←nodeToRemove.Right
35)
else
36)
parent.Right ←nodeToRemove.Right
37)
end if
38)
else if nodeToRemove.Left ̸= ∅and nodeToRemove.Right = ∅
39)
// case #3
40)
if nodeToRemove.Value < parent.Value
41)
parent.Left ←nodeToRemove.Left
42)
else
43)
parent.Right ←nodeToRemove.Left
44)
end if
45)
else
46)
// case #4
47)
largestV alue ←nodeToRemove.Left
48)
while largestV alue.Right ̸= ∅
49)
// ﬁnd the largest value in the left subtree of nodeToRemove
50)
largestV alue ←largestV alue.Right
CHAPTER 7. AVL TREE
61
51)
end while
52)
// set the parents’ Right pointer of largestV alue to ∅
53)
FindParent(largestV alue.Value).Right ←∅
54)
nodeToRemove.Value ←largestV alue.Value
55)
end if
56)
while path.Count > 0
57)
CheckBalance(path.Pop()) // we trackback to the root node check balance
58)
end while
59)
count ←count −1
60)
return true
61) end Remove
7.5
Summary
The AVL tree is a sophisticated self balancing tree. It can be thought of as
the smarter, younger brother of the binary search tree. Unlike its older brother
the AVL tree avoids worst case linear complexity runtimes for its operations.
The AVL tree guarantees via the enforcement of balancing algorithms that the
left and right subtrees diﬀer in height by at most 1 which yields at most a
logarithmic runtime complexity.
Part II
Algorithms
62
Chapter 8
Sorting
All the sorting algorithms in this chapter use data structures of a speciﬁc type
to demonstrate sorting, e.g.
a 32 bit integer is often used as its associated
operations (e.g. <, >, etc) are clear in their behaviour.
The algorithms discussed can easily be translated into generic sorting algo-
rithms within your respective language of choice.
8.1
Bubble Sort
One of the most simple forms of sorting is that of comparing each item with
every other item in some list, however as the description may imply this form
of sorting is not particularly eﬀecient O(n2). In it’s most simple form bubble
sort can be implemented as two loops.
1) algorithm BubbleSort(list)
2)
Pre: list ̸= ∅
3)
Post: list has been sorted into values of ascending order
4)
for i ←0 to list.Count −1
5)
for j ←0 to list.Count −1
6)
if list[i] < list[j]
7)
Swap(list[i], list[j])
8)
end if
9)
end for
10)
end for
11)
return list
12) end BubbleSort
8.2
Merge Sort
Merge sort is an algorithm that has a fairly eﬃcient space time complexity -
O(n log n) and is fairly trivial to implement. The algorithm is based on splitting
a list, into two similar sized lists (left, and right) and sorting each list and then
merging the sorted lists back together.
Note: the function MergeOrdered simply takes two ordered lists and makes
them one.
63
CHAPTER 8. SORTING
64
54
2
74
75
4
0
1
2
3
4
54
2
74
75
4
0
1
2
3
4
54
2
75
74
4
0
1
2
3
4
54
75
2
74
4
0
1
2
3
4
75
54
2
74
4
0
1
2
3
4
75
54
2
74
4
0
1
2
3
4
75
54
2
74
4
0
1
2
3
4
75
54
74
2
4
0
1
2
3
4
75
74
54
2
4
0
1
2
3
4
75
74
54
2
4
0
1
2
3
4
75
74
54
4
2
0
1
2
3
4
75
74
54
4
2
0
1
2
3
4
75
74
54
4
2
0
1
2
3
4
75
74
54
4
2
0
1
2
3
4
75
74
54
4
2
0
1
2
3
4
Figure 8.1: Bubble Sort Iterations
1) algorithm Mergesort(list)
2)
Pre: list ̸= ∅
3)
Post: list has been sorted into values of ascending order
4)
if list.Count = 1 // already sorted
5)
return list
6)
end if
7)
m ←list.Count / 2
8)
left ←list(m)
9)
right ←list(list.Count −m)
10)
for i ←0 to left.Count−1
11)
left[i] ←list[i]
12)
end for
13)
for i ←0 to right.Count−1
14)
right[i] ←list[i]
15)
end for
16)
left ←Mergesort(left)
17)
right ←Mergesort(right)
18)
return MergeOrdered(left, right)
19) end Mergesort
CHAPTER 8. SORTING
65
54
2
74
75
4
75
4
54
2
74
4
75
74
54
2
2
5
4
Divide
54
2
75
4
74
54
2
75
74
54
4
2
Impera
(Merge)
Figure 8.2: Merge Sort Divide et Impera Approach
8.3
Quick Sort
Quick sort is one of the most popular sorting algorithms based on divide et
impera strategy, resulting in an O(n log n) complexity. The algorithm starts by
picking an item, called pivot, and moving all smaller items before it, while all
greater elements after it. This is the main quick sort operation, called partition,
recursively repeated on lesser and greater sub lists until their size is one or zero
- in which case the list is implicitly sorted.
Choosing an appropriate pivot, as for example the median element is funda-
mental for avoiding the drastically reduced performance of O(n2).
CHAPTER 8. SORTING
66
54
2
74
75
4
Pivot
54
2
74
75
4
Pivot
75
2
74
54
4
Pivot
75
54
74
2
4
Pivot
75
74
54
2
4
Pivot
2
4
Pivot
4
2
Pivot
75
74
Pivot
75
74
75
74
54
4
2
Pivot
Figure 8.3: Quick Sort Example (pivot median strategy)
1) algorithm QuickSort(list)
2)
Pre: list ̸= ∅
3)
Post: list has been sorted into values of ascending order
4)
if list.Count = 1 // already sorted
5)
return list
6)
end if
7)
pivot ←MedianValue(list)
8)
for i ←0 to list.Count−1
9)
if list[i] = pivot
10)
equal.Insert(list[i])
11)
end if
12)
if list[i] < pivot
13)
less.Insert(list[i])
14)
end if
15)
if list[i] > pivot
16)
greater.Insert(list[i])
17)
end if
18)
end for
19)
return Concatenate(QuickSort(less), equal, QuickSort(greater))
20) end Quicksort
CHAPTER 8. SORTING
67
8.4
Insertion Sort
Insertion sort is a somewhat interesting algorithm with an expensive runtime of
O(n2). It can be best thought of as a sorting scheme similar to that of sorting
a hand of playing cards, i.e. you take one card and then look at the rest with
the intent of building up an ordered set of cards in your hand.
54
2
74
75
4
54
2
74
75
4
54
2
74
75
4
74
54
2
75
74
4
2
75
54
75
74
4
2
54
75
74
54
4
2
4
Figure 8.4: Insertion Sort Iterations
1) algorithm Insertionsort(list)
2)
Pre:
list ̸= ∅
3)
Post: list has been sorted into values of ascending order
4)
unsorted ←1
5)
while unsorted < list.Count
6)
hold ←list[unsorted]
7)
i ←unsorted −1
8)
while i ≥0 and hold < list[i]
9)
list[i + 1] ←list[i]
10)
i ←i −1
11)
end while
12)
list[i + 1] ←hold
13)
unsorted ←unsorted + 1
14)
end while
15)
return list
16) end Insertionsort
CHAPTER 8. SORTING
68
8.5
Shell Sort
Put simply shell sort can be thought of as a more eﬃcient variation of insertion
sort as described in §8.4, it achieves this mainly by comparing items of varying
distances apart resulting in a run time complexity of O(n log2 n).
Shell sort is fairly straight forward but may seem somewhat confusing at
ﬁrst as it diﬀers from other sorting algorithms in the way it selects items to
compare. Figure 8.5 shows shell sort being ran on an array of integers, the red
coloured square is the current value we are holding.
1) algorithm ShellSort(list)
2)
Pre: list ̸= ∅
3)
Post: list has been sorted into values of ascending order
4)
increment ←list.Count / 2
5)
while increment ̸= 0
6)
current ←increment
7)
while current < list.Count
8)
hold ←list[current]
9)
i ←current −increment
10)
while i ≥0 and hold < list[i]
11)
list[i + increment] ←list[i]
12)
i−= increment
13)
end while
14)
list[i + increment] ←hold
15)
current ←current + 1
16)
end while
17)
increment / = 2
18)
end while
19)
return list
20) end ShellSort
8.6
Radix Sort
Unlike the sorting algorithms described previously radix sort uses buckets to
sort items, each bucket holds items with a particular property called a key.
Normally a bucket is a queue, each time radix sort is performed these buckets
are emptied starting the smallest key bucket to the largest. When looking at
items within a list to sort we do so by isolating a speciﬁc key, e.g. in the example
we are about to show we have a maximum of three keys for all items, that is
the highest key we need to look at is hundreds. Because we are dealing with, in
this example base 10 numbers we have at any one point 10 possible key values
0..9 each of which has their own bucket. Before we show you this ﬁrst simple
version of radix sort let us clarify what we mean by isolating keys. Given the
number 102 if we look at the ﬁrst key, the ones then we can see we have two of
them, progressing to the next key - tens we can see that the number has zero
of them, ﬁnally we can see that the number has a single hundred. The number
used as an example has in total three keys:
CHAPTER 8. SORTING
69
Figure 8.5: Shell sort
CHAPTER 8. SORTING
70
1. Ones
2. Tens
3. Hundreds
For further clariﬁcation what if we wanted to determine how many thousands
the number 102 has? Clearly there are none, but often looking at a number as
ﬁnal like we often do it is not so obvious so when asked the question how many
thousands does 102 have you should simply pad the number with a zero in that
location, e.g. 0102 here it is more obvious that the key value at the thousands
location is zero.
The last thing to identify before we actually show you a simple implemen-
tation of radix sort that works on only positive integers, and requires you to
specify the maximum key size in the list is that we need a way to isolate a
speciﬁc key at any one time. The solution is actually very simple, but its not
often you want to isolate a key in a number so we will spell it out clearly
here. A key can be accessed from any integer with the following expression:
key ←(number / keyToAccess) % 10. As a simple example lets say that we
want to access the tens key of the number 1290, the tens column is key 10 and
so after substitution yields key ←(1290 / 10) % 10
=
9. The next key to
look at for a number can be attained by multiplying the last key by ten working
left to right in a sequential manner. The value of key is used in the following
algorithm to work out the index of an array of queues to enqueue the item into.
1) algorithm Radix(list, maxKeySize)
2)
Pre: list ̸= ∅
3)
maxKeySize ≥0 and represents the largest key size in the list
4)
Post: list has been sorted
5)
queues ←Queue[10]
6)
indexOfKey ←1
7)
fori ←0 to maxKeySize −1
8)
foreach item in list
9)
queues[GetQueueIndex(item, indexOfKey)].Enqueue(item)
10)
end foreach
11)
list ←CollapseQueues(queues)
12)
ClearQueues(queues)
13)
indexOfKey ←indexOfKey ∗10
14)
end for
15)
return list
16) end Radix
Figure 8.6 shows the members of queues from the algorithm described above
operating on the list whose members are 90, 12, 8, 791, 123, and 61, the key we
are interested in for each number is highlighted. Omitted queues in Figure 8.6
mean that they contain no items.
8.7
Summary
Throughout this chapter we have seen many diﬀerent algorithms for sorting
lists, some are very eﬃcient (e.g. quick sort deﬁned in §8.3), some are not (e.g.
CHAPTER 8. SORTING
71
Figure 8.6: Radix sort base 10 algorithm
bubble sort deﬁned in §8.1).
Selecting the correct sorting algorithm is usually denoted purely by eﬃciency,
e.g. you would always choose merge sort over shell sort and so on. There are
also other factors to look at though and these are based on the actual imple-
mentation. Some algorithms are very nicely expressed in a recursive fashion,
however these algorithms ought to be pretty eﬃcient, e.g. implementing a linear,
quadratic, or slower algorithm using recursion would be a very bad idea.
If you want to learn more about why you should be very, very careful when
implementing recursive algorithms see Appendix C.
Chapter 9
Numeric
Unless stated otherwise the alias n denotes a standard 32 bit integer.
9.1
Primality Test
A simple algorithm that determines whether or not a given integer is a prime
number, e.g. 2, 5, 7, and 13 are all prime numbers, however 6 is not as it can
be the result of the product of two numbers that are < 6.
In an attempt to slow down the inner loop the √n is used as the upper
bound.
1) algorithm IsPrime(n)
2)
Post: n is determined to be a prime or not
3)
for i ←2 to n do
4)
for j ←1 to sqrt(n) do
5)
if i ∗j = n
6)
return false
7)
end if
8)
end for
9)
end for
10) end IsPrime
9.2
Base conversions
DSA contains a number of algorithms that convert a base 10 number to its
equivalent binary, octal or hexadecimal form. For example 7810 has a binary
representation of 10011102.
Table 9.1 shows the algorithm trace when the number to convert to binary
is 74210.
72
CHAPTER 9. NUMERIC
73
1) algorithm ToBinary(n)
2)
Pre: n ≥0
3)
Post: n has been converted into its base 2 representation
4)
while n > 0
5)
list.Add(n % 2)
6)
n ←n/2
7)
end while
8)
return Reverse(list)
9) end ToBinary
n
list
742
{ 0 }
371
{ 0, 1 }
185
{ 0, 1, 1 }
92
{ 0, 1, 1, 0 }
46
{ 0, 1, 1, 0, 1 }
23
{ 0, 1, 1, 0, 1, 1 }
11
{ 0, 1, 1, 0, 1, 1, 1 }
5
{ 0, 1, 1, 0, 1, 1, 1, 1 }
2
{ 0, 1, 1, 0, 1, 1, 1, 1, 0 }
1
{ 0, 1, 1, 0, 1, 1, 1, 1, 0, 1 }
Table 9.1: Algorithm trace of ToBinary
9.3
Attaining the greatest common denomina-
tor of two numbers
A fairly routine problem in mathematics is that of ﬁnding the greatest common
denominator of two integers, what we are essentially after is the greatest number
which is a multiple of both, e.g. the greatest common denominator of 9, and
15 is 3. One of the most elegant solutions to this problem is based on Euclid’s
algorithm that has a run time complexity of O(n2).
1) algorithm GreatestCommonDenominator(m, n)
2)
Pre: m and n are integers
3)
Post: the greatest common denominator of the two integers is calculated
4)
if n = 0
5)
return m
6)
end if
7)
return GreatestCommonDenominator(n, m % n)
8) end GreatestCommonDenominator
CHAPTER 9. NUMERIC
74
9.4
Computing the maximum value for a num-
ber of a speciﬁc base consisting of N digits
This algorithm computes the maximum value of a number for a given number
of digits, e.g.
using the base 10 system the maximum number we can have
made up of 4 digits is the number 999910. Similarly the maximum number that
consists of 4 digits for a base 2 number is 11112 which is 1510.
The expression by which we can compute this maximum value for N digits
is: BN −1. In the previous expression B is the number base, and N is the
number of digits. As an example if we wanted to determine the maximum value
for a hexadecimal number (base 16) consisting of 6 digits the expression would
be as follows: 166 −1. The maximum value of the previous example would be
represented as FFFFFF16 which yields 1677721510.
In the following algorithm numberBase should be considered restricted to
the values of 2, 8, 9, and 16.
For this reason in our actual implementation
numberBase has an enumeration type. The Base enumeration type is deﬁned
as:
Base = {Binary ←2, Octal ←8, Decimal ←10, Hexadecimal ←16}
The reason we provide the deﬁnition of Base is to give you an idea how this
algorithm can be modelled in a more readable manner rather than using various
checks to determine the correct base to use. For our implementation we cast the
value of numberBase to an integer, as such we extract the value associated with
the relevant option in the Base enumeration. As an example if we were to cast
the option Octal to an integer we would get the value 8. In the algorithm listed
below the cast is implicit so we just use the actual argument numberBase.
1) algorithm MaxValue(numberBase, n)
2)
Pre: numberBase is the number system to use, n is the number of digits
3)
Post: the maximum value for numberBase consisting of n digits is computed
4)
return Power(numberBase, n) −1
5) end MaxValue
9.5
Factorial of a number
Attaining the factorial of a number is a primitive mathematical operation. Many
implementations of the factorial algorithm are recursive as the problem is re-
cursive in nature, however here we present an iterative solution. The iterative
solution is presented because it too is trivial to implement and doesn’t suﬀer
from the use of recursion (for more on recursion see §C).
The factorial of 0 and 1 is 0. The aforementioned acts as a base case that we
will build upon. The factorial of 2 is 2∗the factorial of 1, similarly the factorial
of 3 is 3∗the factorial of 2 and so on. We can indicate that we are after the
factorial of a number using the form N! where N is the number we wish to
attain the factorial of. Our algorithm doesn’t use such notation but it is handy
to know.
CHAPTER 9. NUMERIC
75
1) algorithm Factorial(n)
2)
Pre: n ≥0, n is the number to compute the factorial of
3)
Post: the factorial of n is computed
4)
if n < 2
5)
return 1
6)
end if
7)
factorial ←1
8)
for i ←2 to n
9)
factorial ←factorial ∗i
10)
end for
11)
return factorial
12) end Factorial
9.6
Summary
In this chapter we have presented several numeric algorithms, most of which
are simply here because they were fun to design. Perhaps the message that
the reader should gain from this chapter is that algorithms can be applied to
several domains to make work in that respective domain attainable. Numeric
algorithms in particular drive some of the most advanced systems on the planet
computing such data as weather forecasts.
Chapter 10
Searching
10.1
Sequential Search
A simple algorithm that search for a speciﬁc item inside a list.
It operates
looping on each element O(n) until a match occurs or the end is reached.
1) algorithm SequentialSearch(list, item)
2)
Pre:
list ̸= ∅
3)
Post: return index of item if found, otherwise −1
4)
index ←0
5)
while index < list.Count and list[index] ̸= item
6)
index ←index + 1
7)
end while
8)
if index < list.Count and list[index] = item
9)
return index
10)
end if
11)
return −1
12) end SequentialSearch
10.2
Probability Search
Probability search is a statistical sequential searching algorithm. In addition to
searching for an item, it takes into account its frequency by swapping it with
it’s predecessor in the list. The algorithm complexity still remains at O(n) but
in a non-uniform items search the more frequent items are in the ﬁrst positions,
reducing list scanning time.
Figure 10.1 shows the resulting state of a list after searching for two items,
notice how the searched items have had their search probability increased after
each search operation respectively.
76
CHAPTER 10. SEARCHING
77
Figure 10.1: a) Search(12), b) Search(101)
1) algorithm ProbabilitySearch(list, item)
2)
Pre:
list ̸= ∅
3)
Post: a boolean indicating where the item is found or not;
in the former case swap founded item with its predecessor
4)
index ←0
5)
while index < list.Count and list[index] ̸= item
6)
index ←index + 1
7)
end while
8)
if index ≥list.Count or list[index] ̸= item
9)
return false
10)
end if
11)
if index > 0
12)
Swap(list[index], list[index −1])
13)
end if
14)
return true
15) end ProbabilitySearch
10.3
Summary
In this chapter we have presented a few novel searching algorithms. We have
presented more eﬃcient searching algorithms earlier on, like for instance the
logarithmic searching algorithm that AVL and BST tree’s use (deﬁned in §3.2).
We decided not to cover a searching algorithm known as binary chop (another
name for binary search, binary chop usually refers to its array counterpart) as
CHAPTER 10. SEARCHING
78
the reader has already seen such an algorithm in §3.
Searching algorithms and their eﬃciency largely depends on the underlying
data structure being used to store the data. For instance it is quicker to deter-
mine whether an item is in a hash table than it is an array, similarly it is quicker
to search a BST than it is a linked list. If you are going to search for data fairly
often then we strongly advise that you sit down and research the data structures
available to you. In most cases using a list or any other primarily linear data
structure is down to lack of knowledge. Model your data and then research the
data structures that best ﬁt your scenario.
Chapter 11
Strings
Strings have their own chapter in this text purely because string operations
and transformations are incredibly frequent within programs. The algorithms
presented are based on problems the authors have come across previously, or
were formulated to satisfy curiosity.
11.1
Reversing the order of words in a sentence
Deﬁning algorithms for primitive string operations is simple, e.g. extracting a
sub-string of a string, however some algorithms that require more inventiveness
can be a little more tricky.
The algorithm presented here does not simply reverse the characters in a
string, rather it reverses the order of words within a string. This algorithm
works on the principal that words are all delimited by white space, and using a
few markers to deﬁne where words start and end we can easily reverse them.
79
CHAPTER 11. STRINGS
80
1) algorithm ReverseWords(value)
2)
Pre:
value ̸= ∅, sb is a string buﬀer
3)
Post: the words in value have been reversed
4)
last ←value.Length −1
5)
start ←last
6)
while last ≥0
7)
// skip whitespace
8)
while start ≥0 and value[start] = whitespace
9)
start ←start −1
10)
end while
11)
last ←start
12)
// march down to the index before the beginning of the word
13)
while start ≥0 and start ̸= whitespace
14)
start ←start −1
15)
end while
16)
// append chars from start + 1 to length + 1 to string buﬀer sb
17)
for i ←start + 1 to last
18)
sb.Append(value[i])
19)
end for
20)
// if this isn’t the last word in the string add some whitespace after the word in the buﬀer
21)
if start > 0
22)
sb.Append(‘ ’)
23)
end if
24)
last ←start −1
25)
start ←last
26)
end while
27)
// check if we have added one too many whitespace to sb
28)
if sb[sb.Length −1] = whitespace
29)
// cut the whitespace
30)
sb.Length ←sb.Length −1
31)
end if
32)
return sb
33) end ReverseWords
11.2
Detecting a palindrome
Although not a frequent algorithm that will be applied in real-life scenarios
detecting a palindrome is a fun, and as it turns out pretty trivial algorithm to
design.
The algorithm that we present has a O(n) run time complexity. Our algo-
rithm uses two pointers at opposite ends of string we are checking is a palindrome
or not. These pointers march in towards each other always checking that each
character they point to is the same with respect to value. Figure 11.1 shows the
IsPalindrome algorithm in operation on the string “Was it Eliot’s toilet I saw?”
If you remove all punctuation, and white space from the aforementioned string
you will ﬁnd that it is a valid palindrome.
CHAPTER 11. STRINGS
81
Figure 11.1: left and right pointers marching in towards one another
1) algorithm IsPalindrome(value)
2)
Pre:
value ̸= ∅
3)
Post: value is determined to be a palindrome or not
4)
word ←value.Strip().ToUpperCase()
5)
left ←0
6)
right ←word.Length −1
7)
while word[left] = word[right] and left < right
8)
left ←left + 1
9)
right ←right −1
10)
end while
11)
return word[left] = word[right]
12) end IsPalindrome
In the IsPalindrome algorithm we call a method by the name of Strip. This
algorithm discards punctuation in the string, including white space. As a result
word contains a heavily compacted representation of the original string, each
character of which is in its uppercase representation.
Palindromes discard white space, punctuation, and case making these changes
allows us to design a simple algorithm while making our algorithm fairly robust
with respect to the palindromes it will detect.
11.3
Counting the number of words in a string
Counting the number of words in a string can seem pretty trivial at ﬁrst, however
there are a few cases that we need to be aware of:
1. tracking when we are in a string
2. updating the word count at the correct place
3. skipping white space that delimits the words
As an example consider the string “Ben ate hay” Clearly this string contains
three words, each of which distinguished via white space. All of the previously
listed points can be managed by using three variables:
1. index
2. wordCount
3. inWord
CHAPTER 11. STRINGS
82
Figure 11.2: String with three words
Figure 11.3: String with varying number of white space delimiting the words
Of the previously listed index keeps track of the current index we are at in
the string, wordCount is an integer that keeps track of the number of words we
have encountered, and ﬁnally inWord is a Boolean ﬂag that denotes whether
or not at the present time we are within a word. If we are not currently hitting
white space we are in a word, the opposite is true if at the present index we are
hitting white space.
What denotes a word? In our algorithm each word is separated by one or
more occurrences of white space. We don’t take into account any particular
splitting symbols you may use, e.g. in .NET String.Split1 can take a char (or
array of characters) that determines a delimiter to use to split the characters
within the string into chunks of strings, resulting in an array of sub-strings.
In Figure 11.2 we present a string indexed as an array. Typically the pattern
is the same for most words, delimited by a single occurrence of white space.
Figure 11.3 shows the same string, with the same number of words but with
varying white space splitting them.
1http://msdn.microsoft.com/en-us/library/system.string.split.aspx
CHAPTER 11. STRINGS
83
1) algorithm WordCount(value)
2)
Pre:
value ̸= ∅
3)
Post: the number of words contained within value is determined
4)
inWord ←true
5)
wordCount ←0
6)
index ←0
7)
// skip initial white space
8)
while value[index] = whitespace and index < value.Length −1
9)
index ←index + 1
10)
end while
11)
// was the string just whitespace?
12)
if index = value.Length and value[index] = whitespace
13)
return 0
14)
end if
15)
while index < value.Length
16)
if value[index] = whitespace
17)
// skip all whitespace
18)
while value[index] = whitespace and index < value.Length −1
19)
index ←index + 1
20)
end while
21)
inWord ←false
22)
wordCount ←wordCount + 1
23)
else
24)
inWord ←true
25)
end if
26)
index ←index + 1
27)
end while
28)
// last word may have not been followed by whitespace
29)
if inWord
30)
wordCount ←wordCount + 1
31)
end if
32)
return wordCount
33) end WordCount
11.4
Determining the number of repeated words
within a string
With the help of an unordered set, and an algorithm that can split the words
within a string using a speciﬁed delimiter this algorithm is straightforward to
implement. If we split all the words using a single occurrence of white space
as our delimiter we get all the words within the string back as elements of
an array. Then if we iterate through these words adding them to a set which
contains only unique strings we can attain the number of unique words from the
string. All that is left to do is subtract the unique word count from the total
number of stings contained in the array returned from the split operation. The
split operation that we refer to is the same as that mentioned in §11.3.
CHAPTER 11. STRINGS
84
Figure 11.4: a) Undesired uniques set; b) desired uniques set
1) algorithm RepeatedWordCount(value)
2)
Pre:
value ̸= ∅
3)
Post: the number of repeated words in value is returned
4)
words ←value.Split(’ ’)
5)
uniques ←Set
6)
foreach word in words
7)
uniques.Add(word.Strip())
8)
end foreach
9)
return words.Length −uniques.Count
10) end RepeatedWordCount
You will notice in the RepeatedWordCount algorithm that we use the Strip
method we referred to earlier in §11.1. This simply removes any punctuation
from a word. The reason we perform this operation on each word is so that
we can build a more accurate unique string collection, e.g. “test”, and “test!”
are the same word minus the punctuation. Figure 11.4 shows the undesired and
desired sets for the unique set respectively.
11.5
Determining the ﬁrst matching character
between two strings
The algorithm to determine whether any character of a string matches any of the
characters in another string is pretty trivial. Put simply, we can parse the strings
considered using a double loop and check, discarding punctuation, the equality
between any characters thus returning a non-negative index that represents the
location of the ﬁrst character in the match (Figure 11.5); otherwise we return
-1 if no match occurs. This approach exhibit a run time complexity of O(n2).
CHAPTER 11. STRINGS
85
t
s
e
t
0
1
2
3
4
s
r
e
t
p
0
1
2
3
4
5
6
Word
Match
i
t
s
e
t
0
1
2
3
4
s
r
e
t
p
0
1
2
3
4
5
6
i
index
t
s
e
t
0
1
2
3
4
s
r
e
t
p
0
1
2
3
4
5
6
i
index
index
a)
b)
c)
Figure 11.5: a) First Step; b) Second Step c) Match Occurred
1) algorithm Any(word,match)
2)
Pre: word, match ̸= ∅
3)
Post: index representing match location if occured, −1 otherwise
4)
for i ←0 to word.Length −1
5)
while word[i] = whitespace
6)
i ←i + 1
7)
end while
8)
for index ←0 to match.Length −1
9)
while match[index] = whitespace
10)
index ←index + 1
11)
end while
12)
if match[index] = word[i]
13)
return index
14)
end if
15)
end for
16)
end for
17)
return −1
18) end Any
11.6
Summary
We hope that the reader has seen how fun algorithms on string data types
are. Strings are probably the most common data type (and data structure -
remember we are dealing with an array) that you will work with so its important
that you learn to be creative with them. We for one ﬁnd strings fascinating. A
simple Google search on string nuances between languages and encodings will
provide you with a great number of problems. Now that we have spurred you
along a little with our introductory algorithms you can devise some of your own.
Appendix A
Algorithm Walkthrough
Learning how to design good algorithms can be assisted greatly by using a
structured approach to tracing its behaviour. In most cases tracing an algorithm
only requires a single table. In most cases tracing is not enough, you will also
want to use a diagram of the data structure your algorithm operates on. This
diagram will be used to visualise the problem more eﬀectively. Seeing things
visually can help you understand the problem quicker, and better.
The trace table will store information about the variables used in your algo-
rithm. The values within this table are constantly updated when the algorithm
mutates them. Such an approach allows you to attain a history of the various
values each variable has held. You may also be able to infer patterns from the
values each variable has contained so that you can make your algorithm more
eﬃcient.
We have found this approach both simple, and powerful. By combining a
visual representation of the problem as well as having a history of past values
generated by the algorithm it can make understanding, and solving problems
much easier.
In this chapter we will show you how to work through both iterative, and
recursive algorithms using the technique outlined.
A.1
Iterative algorithms
We will trace the IsPalindrome algorithm (deﬁned in §11.2) as our example
iterative walkthrough. Before we even look at the variables the algorithm uses,
ﬁrst we will look at the actual data structure the algorithm operates on. It
should be pretty obvious that we are operating on a string, but how is this
represented? A string is essentially a block of contiguous memory that consists
of some char data types, one after the other. Each character in the string can
be accessed via an index much like you would do when accessing items within
an array. The picture should be presenting itself - a string can be thought of as
an array of characters.
For our example we will use IsPalindrome to operate on the string “Never
odd or even” Now we know how the string data structure is represented, and
the value of the string we will operate on let’s go ahead and draw it as shown
in Figure A.1.
86
APPENDIX A. ALGORITHM WALKTHROUGH
87
Figure A.1: Visualising the data structure we are operating on
value
word
left
right
Table A.1: A column for each variable we wish to track
The IsPalindrome algorithm uses the following list of variables in some form
throughout its execution:
1. value
2. word
3. left
4. right
Having identiﬁed the values of the variables we need to keep track of we
simply create a column for each in a table as shown in Table A.1.
Now, using the IsPalindrome algorithm execute each statement updating
the variable values in the table appropriately. Table A.2 shows the ﬁnal table
values for each variable used in IsPalindrome respectively.
While this approach may look a little bloated in print, on paper it is much
more compact. Where we have the strings in the table you should annotate
these strings with array indexes to aid the algorithm walkthrough.
There is one other point that we should clarify at this time - whether to
include variables that change only a few times, or not at all in the trace table.
In Table A.2 we have included both the value, and word variables because it
was convenient to do so. You may ﬁnd that you want to promote these values
to a larger diagram (like that in Figure A.1) and only use the trace table for
variables whose values change during the algorithm. We recommend that you
promote the core data structure being operated on to a larger diagram outside
of the table so that you can interrogate it more easily.
value
word
left
right
“Never odd or even”
“NEVERODDOREVEN”
0
13
1
12
2
11
3
10
4
9
5
8
6
7
7
6
Table A.2: Algorithm trace for IsPalindrome
APPENDIX A. ALGORITHM WALKTHROUGH
88
We cannot stress enough how important such traces are when designing
your algorithm. You can use these trace tables to verify algorithm correctness.
At the cost of a simple table, and quick sketch of the data structure you are
operating on you can devise correct algorithms quicker. Visualising the problem
domain and keeping track of changing data makes problems a lot easier to solve.
Moreover you always have a point of reference which you can look back on.
A.2
Recursive Algorithms
For the most part working through recursive algorithms is as simple as walking
through an iterative algorithm. One of the things that we need to keep track
of though is which method call returns to who. Most recursive algorithms are
much simple to follow when you draw out the recursive calls rather than using
a table based approach. In this section we will use a recursive implementation
of an algorithm that computes a number from the Fiboncacci sequence.
1) algorithm Fibonacci(n)
2)
Pre: n is the number in the ﬁbonacci sequence to compute
3)
Post: the ﬁbonacci sequence number n has been computed
4)
if n < 1
5)
return 0
6)
else if n < 2
7)
return 1
8)
end if
9)
return Fibonacci(n −1) + Fibonacci(n −2)
10) end Fibonacci
Before we jump into showing you a diagrammtic representation of the algo-
rithm calls for the Fibonacci algorithm we will brieﬂy talk about the cases of
the algorithm. The algorithm has three cases in total:
1. n < 1
2. n < 2
3. n ≥2
The ﬁrst two items in the preceeding list are the base cases of the algorithm.
Until we hit one of our base cases in our recursive method call tree we won’t
return anything. The third item from the list is our recursive case.
With each call to the recursive case we etch ever closer to one of our base
cases. Figure A.2 shows a diagrammtic representation of the recursive call chain.
In Figure A.2 the order in which the methods are called are labelled. Figure
A.3 shows the call chain annotated with the return values of each method call
as well as the order in which methods return to their callers. In Figure A.3 the
return values are represented as annotations to the red arrows.
It is important to note that each recursive call only ever returns to its caller
upon hitting one of the two base cases. When you do eventually hit a base case
that branch of recursive calls ceases. Upon hitting a base case you go back to
APPENDIX A. ALGORITHM WALKTHROUGH
89
Figure A.2: Call chain for Fibonacci algorithm
Figure A.3: Return chain for Fibonacci algorithm
APPENDIX A. ALGORITHM WALKTHROUGH
90
the caller and continue execution of that method. Execution in the caller is
contiued at the next statement, or expression after the recursive call was made.
In the Fibonacci algorithms’ recursive case we make two recursive calls.
When the ﬁrst recursive call (Fibonacci(n −1)) returns to the caller we then
execute the the second recursive call (Fibonacci(n −2)). After both recursive
calls have returned to their caller, the caller can then subesequently return to
its caller and so on.
Recursive algorithms are much easier to demonstrate diagrammatically as
Figure A.2 demonstrates. When you come across a recursive algorithm draw
method call diagrams to understand how the algorithm works at a high level.
A.3
Summary
Understanding algorithms can be hard at times, particularly from an implemen-
tation perspective. In order to understand an algorithm try and work through
it using trace tables. In cases where the algorithm is also recursive sketch the
recursive calls out so you can visualise the call/return chain.
In the vast majority of cases implementing an algorithm is simple provided
that you know how the algorithm works. Mastering how an algorithm works
from a high level is key for devising a well designed solution to the problem in
hand.
Appendix B
Translation Walkthrough
The conversion from pseudo to an actual imperative language is usually very
straight forward, to clarify an example is provided. In this example we will
convert the algorithm in §9.1 to the C# language.
1) public static bool IsPrime(int number)
2) {
3)
if (number < 2)
4)
{
5)
return false;
6)
}
7)
int innerLoopBound = (int)Math.Floor(Math.Sqrt(number));
8)
for (int i = 1; i < number; i++)
9)
{
10)
for(int j = 1; j <= innerLoopBound; j++)
11)
{
12)
if (i ∗j == number)
13)
{
14)
return false;
15)
}
16)
}
17)
}
18)
return true;
19) }
For the most part the conversion is a straight forward process, however you
may have to inject various calls to other utility algorithms to ascertain the
correct result.
A consideration to take note of is that many algorithms have fairly strict
preconditions, of which there may be several - in these scenarios you will need
to inject the correct code to handle such situations to preserve the correctness of
the algorithm. Most of the preconditions can be suitably handled by throwing
the correct exception.
91
APPENDIX B. TRANSLATION WALKTHROUGH
92
B.1
Summary
As you can see from the example used in this chapter we have tried to make the
translation of our pseudo code algorithms to mainstream imperative languages
as simple as possible.
Whenever you encounter a keyword within our pseudo code examples that
you are unfamiliar with just browse to Appendix E which descirbes each key-
word.
Appendix C
Recursive Vs. Iterative
Solutions
One of the most succinct properties of modern programming languages like
C++, C#, and Java (as well as many others) is that these languages allow
you to deﬁne methods that reference themselves, such methods are said to be
recursive. One of the biggest advantages recursive methods bring to the table is
that they usually result in more readable, and compact solutions to problems.
A recursive method then is one that is deﬁned in terms of itself. Generally
a recursive algorithms has two main properties:
1. One or more base cases; and
2. A recursive case
For now we will brieﬂy cover these two aspects of recursive algorithms. With
each recursive call we should be making progress to our base case otherwise we
are going to run into trouble. The trouble we speak of manifests itself typically
as a stack overﬂow, we will describe why later.
Now that we have brieﬂy described what a recursive algorithm is and why
you might want to use such an approach for your algorithms we will now talk
about iterative solutions. An iterative solution uses no recursion whatsoever.
An iterative solution relies only on the use of loops (e.g. for, while, do-while,
etc). The down side to iterative algorithms is that they tend not to be as clear
as to their recursive counterparts with respect to their operation. The major
advantage of iterative solutions is speed. Most production software you will
ﬁnd uses little or no recursive algorithms whatsoever. The latter property can
sometimes be a companies prerequisite to checking in code, e.g. upon checking
in a static analysis tool may verify that the code the developer is checking in
contains no recursive algorithms. Normally it is systems level code that has this
zero tolerance policy for recursive algorithms.
Using recursion should always be reserved for fast algorithms, you should
avoid it for the following algorithm run time deﬁciencies:
1. O(n2)
2. O(n3)
93
APPENDIX C. RECURSIVE VS. ITERATIVE SOLUTIONS
94
3. O(2n)
If you use recursion for algorithms with any of the above run time eﬃciency’s
you are inviting trouble. The growth rate of these algorithms is high and in
most cases such algorithms will lean very heavily on techniques like divide and
conquer.
While constantly splitting problems into smaller problems is good
practice, in these cases you are going to be spawning a lot of method calls. All
this overhead (method calls don’t come that cheap) will soon pile up and either
cause your algorithm to run a lot slower than expected, or worse, you will run
out of stack space. When you exceed the allotted stack space for a thread the
process will be shutdown by the operating system. This is the case irrespective
of the platform you use, e.g. .NET, or native C++ etc. You can ask for a bigger
stack size, but you typically only want to do this if you have a very good reason
to do so.
C.1
Activation Records
An activation record is created every time you invoke a method. Put simply
an activation record is something that is put on the stack to support method
invocation. Activation records take a small amount of time to create, and are
pretty lightweight.
Normally an activation record for a method call is as follows (this is very
general):
• The actual parameters of the method are pushed onto the stack
• The return address is pushed onto the stack
• The top-of-stack index is incremented by the total amount of memory
required by the local variables within the method
• A jump is made to the method
In many recursive algorithms operating on large data structures, or algo-
rithms that are ineﬃcient you will run out of stack space quickly. Consider an
algorithm that when invoked given a speciﬁc value it creates many recursive
calls. In such a case a big chunk of the stack will be consumed. We will have to
wait until the activation records start to be unwound after the nested methods
in the call chain exit and return to their respective caller. When a method exits
it’s activation record is unwound. Unwinding an activation record results in
several steps:
1. The top-of-stack index is decremented by the total amount of memory
consumed by the method
2. The return address is popped oﬀthe stack
3. The top-of-stack index is decremented by the total amount of memory
consumed by the actual parameters
APPENDIX C. RECURSIVE VS. ITERATIVE SOLUTIONS
95
While activation records are an eﬃcient way to support method calls they
can build up very quickly.
Recursive algorithms can exhaust the stack size
allocated to the thread fairly fast given the chance.
Just about now we should be dusting the cobwebs oﬀthe age old example of
an iterative vs. recursive solution in the form of the Fibonacci algorithm. This
is a famous example as it highlights both the beauty and pitfalls of a recursive
algorithm. The iterative solution is not as pretty, nor self documenting but it
does the job a lot quicker. If we were to give the Fibonacci algorithm an input
of say 60 then we would have to wait a while to get the value back because it
has an O(gn) run time. The iterative version on the other hand has a O(n)
run time. Don’t let this put you oﬀrecursion. This example is mainly used
to shock programmers into thinking about the ramiﬁcations of recursion rather
than warning them oﬀ.
C.2
Some problems are recursive in nature
Something that you may come across is that some data structures and algo-
rithms are actually recursive in nature. A perfect example of this is a tree data
structure. A common tree node usually contains a value, along with two point-
ers to two other nodes of the same node type. As you can see tree is recursive
in its makeup wit each node possibly pointing to two other nodes.
When using recursive algorithms on tree’s it makes sense as you are simply
adhering to the inherent design of the data structure you are operating on. Of
course it is not all good news, after all we are still bound by the limitations we
have mentioned previously in this chapter.
We can also look at sorting algorithms like merge sort, and quick sort. Both
of these algorithms are recursive in their design and so it makes sense to model
them recursively.
C.3
Summary
Recursion is a powerful tool, and one that all programmers should know of.
Often software projects will take a trade between readability, and eﬃciency in
which case recursion is great provided you don’t go and use it to implement
an algorithm with a quadratic run time or higher. Of course this is not a rule
of thumb, this is just us throwing caution to the wind. Defensive coding will
always prevail.
Many times recursion has a natural home in recursive data structures and
algorithms which are recursive in nature. Using recursion in such scenarios is
perfectly acceptable. Using recursion for something like linked list traversal is
a little overkill. Its iterative counterpart is probably less lines of code than its
recursive counterpart.
Because we can only talk about the implications of using recursion from an
abstract point of view you should consult your compiler and run time environ-
ment for more details. It may be the case that your compiler recognises things
like tail recursion and can optimise them. This isn’t unheard of, in fact most
commercial compilers will do this. The amount of optimisation compilers can
APPENDIX C. RECURSIVE VS. ITERATIVE SOLUTIONS
96
do though is somewhat limited by the fact that you are still using recursion.
You, as the developer have to accept certain accountability’s for performance.
Appendix D
Testing
Testing is an essential part of software development. Testing has often been
discarded by many developers in the belief that the burden of proof of their
software is on those within the company who hold test centric roles.
This
couldn’t be further from the truth. As a developer you should at least provide
a suite of unit tests that verify certain boundary conditions of your software.
A great thing about testing is that you build up progressively a safety net. If
you add or tweak algorithms and then run your suite of tests you will be quickly
alerted to any cases that you have broken with your recent changes. Such a suite
of tests in any sizeable project is absolutely essential to maintaining a fairly high
bar when it comes to quality. Of course in order to attain such a standard you
need to think carefully about the tests that you construct.
Unit testing which will be the subject of the vast majority of this chapter
are widely available on most platforms. Most modern languages like C++, C#,
and Java oﬀer an impressive catalogue of testing frameworks that you can use
for unit testing.
The following list identiﬁes testing frameworks which are popular:
JUnit: Targeted at Jav., http://www.junit.org/
NUnit: Can be used with languages that target Microsoft’s Common Language
Runtime. http://www.nunit.org/index.php
Boost Test Library: Targeted at C++. The test library that ships with the incredibly popular
Boost libraries. http://www.boost.org. A direct link to the libraries doc-
umentation http://www.boost.org/doc/libs/1_36_0/libs/test/doc/
html/index.html
CppUnit: Targeted at C++. http://cppunit.sourceforge.net/
Don’t worry if you think that the list is very sparse, there are far more on
oﬀer than those that we have listed. The ones listed are the testing frameworks
that we believe are the most popular for C++, C#, and Java.
D.1
What constitutes a unit test?
A unit test should focus on a single atomic property of the subject being tested.
Do not try and test many things at once, this will result in a suite of somewhat
97
APPENDIX D. TESTING
98
unstructured tests. As an example if you were wanting to write a test that
veriﬁed that a particular value V is returned from a speciﬁc input I then your
test should do the smallest amount of work possible to verify that V is correct
given I. A unit test should be simple and self describing.
As well as a unit test being relatively atomic you should also make sure that
your unit tests execute quickly. If you can imagine in the future when you may
have a test suite consisting of thousands of tests you want those tests to execute
as quickly as possible. Failure to attain such a goal will most likely result in
the suite of tests not being ran that often by the developers on your team. This
can occur for a number of reasons but the main one would be that it becomes
incredibly tedious waiting several minutes to run tests on a developers local
machine.
Building up a test suite can help greatly in a team scenario, particularly
when using a continuous build server. In such a scenario you can have the suite
of tests devised by the developers and testers ran as part of the build process.
Employing such strategies can help you catch niggling little error cases early
rather than via your customer base. There is nothing more embarrassing for a
developer than to have a very trivial bug in their code reported to them from a
customer.
D.2
When should I write my tests?
A source of great debate would be an understatement to personify such a ques-
tion as this. In recent years a test driven approach to development has become
very popular. Such an approach is known as test driven development, or more
commonly the acronym TDD.
One of the founding principles of TDD is to write the unit test ﬁrst, watch
it fail and then make it pass.
The premise being that you only ever write
enough code at any one time to satisfy the state based assertions made in a unit
test. We have found this approach to provide a more structured intent to the
implementation of algorithms. At any one stage you only have a single goal, to
make the failing test pass. Because TDD makes you write the tests up front you
never ﬁnd yourself in a situation where you forget, or can’t be bothered to write
tests for your code. This is often the case when you write your tests after you
have coded up your implementation. We, as the authors of this book ourselves
use TDD as our preferred method.
As we have already mentioned that TDD is our favoured approach to testing
it would be somewhat of an injustice to not list, and describe the mantra that
is often associate with it:
Red: Signiﬁes that the test has failed.
Green: The failing test now passes.
Refactor: Can we restructure our program so it makes more sense, and easier to
maintain?
The ﬁrst point of the above list always occurs at least once (more if you count
the build error) in TDD initially. Your task at this stage is solely to make the
test pass, that is to make the respective test green. The last item is based around
APPENDIX D. TESTING
99
the restructuring of your program to make it as readable and maintainable as
possible. The last point is very important as TDD is a progressive methodology
to building a solution. If you adhere to progressive revisions of your algorithm
restructuring when appropriate you will ﬁnd that using TDD you can implement
very cleanly structured types and so on.
D.3
How seriously should I view my test suite?
Your tests are a major part of your project ecosystem and so they should be
treated with the same amount of respect as your production code. This ranges
from correct, and clean code formatting, to the testing code being stored within
a source control repository.
Employing a methodology like TDD, or testing after implementing you will
ﬁnd that you spend a great amount of time writing tests and thus they should
be treated no diﬀerently to your production code. All tests should be clearly
named, and fully documented as to their intent.
D.4
The three A’s
Now that you have a sense of the importance of your test suite you will inevitably
want to know how to actually structure each block of imperatives within a single
unit test. A popular approach - the three A’s is described in the following list:
Assemble: Create the objects you require in order to perform the state based asser-
tions.
Act: Invoke the respective operations on the objects you have assembled to
mutate the state to that desired for your assertions.
Assert: Specify what you expect to hold after the previous two steps.
The following example shows a simple test method that employs the three
A’s:
public void MyTest()
{
// assemble
Type t = new Type();
// act
t.MethodA();
// assert
Assert.IsTrue(t.BoolExpr)
}
D.5
The structuring of tests
Structuring tests can be viewed upon as being the same as structuring pro-
duction code, e.g. all unit tests for a Person type may be contained within
APPENDIX D. TESTING
100
a PersonTest type. Typically all tests are abstracted from production code.
That is that the tests are disjoint from the production code, you may have two
dynamic link libraries (dll); the ﬁrst containing the production code, the second
containing your test code.
We can also use things like inheritance etc when deﬁning classes of tests.
The point being that the test code is very much like your production code and
you should apply the same amount of thought to its structure as you would do
the production code.
D.6
Code Coverage
Something that you can get as a product of unit testing are code coverage
statistics. Code coverage is merely an indicator as to the portions of production
code that your units tests cover. Using TDD it is likely that your code coverage
will be very high, although it will vary depending on how easy it is to use TDD
within your project.
D.7
Summary
Testing is key to the creation of a moderately stable product. Moreover unit
testing can be used to create a safety blanket when adding and removing features
providing an early warning for breaking changes within your production code.
Appendix E
Symbol Deﬁnitions
Throughout the pseudocode listings you will ﬁnd several symbols used, describes
the meaning of each of those symbols.
Symbol
Description
←
Assignment.
=
Equality.
≤
Less than or equal to.
<
Less than.*
≥
Greater than or equal to.
>
Greater than.*
̸=
Inequality.
∅
Null.
and
Logical and.
or
Logical or.
whitespace
Single occurrence of whitespace.
yield
Like return but builds a sequence.
Table E.1: Pseudo symbol deﬁnitions
* This symbol has a direct translation with the vast majority of imperative
counterparts.
101


ID: https://www.aupress.ca/app/uploads/OER-202301_Wang_2023-Introduction-to-Computer-Programming-with-Python.pdf
Document: INTRODUCTION 
TO COMPUTER 
PROGRAMMING  
WITH PYTHON
Harris Wang
Introduction 
to 
Computer 
Programming 

with 
Python
This page intentionally left blank
Introduction 
to 
Computer 
Programming 

with 
Python
Harris Wang
Copyright © 2023 Athabasca University
1 University Drive, Athabasca, AB Canada
DOI: https://doi.org/10.15215/remix/9781998944088.01
Published by Remix, an imprint of Athabasca University 
Press. For more information, please visit aupress.ca or 
email OERpublishing@athabascau.ca.
Cover design by Lisa Mentz
Images that appear in this text are created by the author.
Library and Archives Canada Cataloguing in Publication
Title: Introduction to computer programming with Python 
/ Harris Wang.
Names: Wang, Harris, author.
Identifiers: Canadiana (print) 20230509916 | Canadiana 
(ebook) 20230509924 | ISBN 9781998944071 (softcover) | 
ISBN 9781998944088 (PDF) | ISBN 9781998944095 (EPUB)
Subjects: LCSH: Python (Computer program language)—­
Textbooks. | LCGFT: Textbooks.
Classification: LCC QA76.73.P98 W36 2023 | DDC 
005.13/3—­
dc23
Introduction to Computer Programming with Python 
by Harris Wang is licensed under a Creative Commons 
Attribution-­
NonCommercial-­
ShareAlike 4.0 International 
License, except where otherwise noted. This license 
allows users to copy and redistribute the material in 
any medium or format and to remix, transform, and 
build upon the material as long as the original source is 
properly credited, the work is not used for commercial 
purposes, and the new creation is licensed under the 
same terms.
Remix name, Remix logo, and Remix book covers are not 
subject to the Creative Commons license and may not be 
reproduced without the prior and express written consent 
of Athabasca University.
Contents
	Chapter 1	 Introduction	
1
	 	
Learning Objectives	
1
	
1.1	 A Brief History of Computers	
1
	
1.2	 Fundamentals of Computing and Modern Computers	
5
Number Systems and the Foundation of Computing	
6
Computability and Computational Complexity	
9
The Construction of Modern Computers	
11
Analog Computers	
11
Digital Computers	
12
Mechanic-­
Based Components	
13
Vacuum Tube–­
Based Components	
14
Transistors	
14
Integrated Circuits and Very Large-­
Scale Integrated Circuits	
14
	
1.3	 Programming and Programming Languages	
15
	
1.4	 Python Programming Language	
17
The Development and Implementation of Python	
17
Advantages of Python	
18
Resources for Python and Python Education	
19
	
1.5	 Getting Ready to Learn Programming in Python	
20
Installing and Setting Up the Python Programming Environment	
21
Installing Python	
21
Setting Up a Virtual Environment for a Python Project	
24
Installing Jupyter Notebook	
26
Installing Visual Studio Code	
27
Additional Tools Supporting Software Development in Python	
27
Buildbot	
27
Trac	
28
Roundup	
28
	
vi	
Contents
	
1.6	 Getting a Taste of Programming with Python	
28
Program Interactively with Python Interactive Shell	
28
Program with VS Code IDE	
30
Use Jupyter Notebook Within VS Code to Program Interactively	
32
Write Documentation in Markdown	
33
Headings	
33
Paragraphs	
34
New Lines	
34
Italic, Bold, and Strikethrough Texts	
34
Horizontal Rules	
35
Keyboard Keys	
35
Unordered Lists	
35
Ordered Lists	
36
Definition Lists	
36
Links	
37
Links to Internal Sections	
37
Images	
38
Blockquotes	
38
Tables	
39
Inline Program / Script Code	
39
Code Block	
40
Mathematical Formulas and Expressions	
40
To-­
Do List	
42
Escape Sequence for Special Characters	
42
Programming Interactively with Jupyter Notebook 
Within VS Code	
42
Run Python Programs Outside IDE	
48
Make the Python Program File Executable	
50
Errors in Programs	
52
	
1.7	 Essentials of Problem Solving and Software Development	
54
Design Algorithms to Solve Problems	
54
Phases of Software System Development	
56
Phase 1. Understand the Project	
57
Phase 2. Analyze the Requirements to Identify 
Computer-­
Solvable Problems and Tasks	
57
Phase 3. Design the System	
58
Phase 4. Implement the System	
58
Phase 5. Test the System	
58
Phase 6. Maintain the System	
58
	
Contents	
vii
	
1.8	 Manage Your Working Files for Software Development 
Projects	
58
Set Up Git on Your Computer and Version-­
Control Locally	
59
Set Up an Account on GitHub and Version-­
Control with Remote 
Repositories	
62
	 	
Chapter Summary	
67
	 	
Exercises	
69
	 	
Projects	
71
	Chapter 2	 Essential Building Blocks of Computer 
Programs	
73
	 	
Learning Objectives	
73
	
2.1	 Primary Constructs of Computer Programs in Python	
74
Vocabulary of the Programming Language	
74
Rules of Naming Identifiers	
76
Python Naming Conventions	
79
Names with Leading and/or Trailing Underscores	
79
Rules of Scope Resolution for Identifiers	
81
Simple Data Types	
82
Signed Integers (int)	
83
Float (float)	
87
Boolean (bool)	
88
Complex (complex)	
89
Compound Data Types	
89
String (str)	
90
List	
95
Tuple	
97
Set	
98
Dictionary	
99
Object	
99
Variables and Constants	
101
Variables	
101
Built-­
In Constants	
104
Operators	
106
Arithmetic Operators	
106
Comparison Operators	
108
Logical Operators	
109
Bitwise Operators	
111
Assignment Operators	
112
Identity Operators	
115
	 viii	
Contents
Sequence Operators	
115
Membership Operator	
116
Built-­
In Functions	
117
Expressions	
135
	
2.2	 Higher-­
Level Constructs of Python Programs	
137
Structure of Python Programs	
137
Documentation and Comments	
139
Simple Statements	
141
Expression Statement	
141
Assignment Statement	
143
print Statement	
146
input Statement	
149
assert Statement	
150
pass Statement	
151
del Statement 
151
return Statement	
152
open Statement	
152
yield Statement	
153
raise Statement	
154
break Statement	
155
continue Statement	
155
import Statement	
156
global Statement	
156
nonlocal Statement	
157
help Statement	
158
Compound Statements	
159
Code Blocks	
159
Rules of Indentation	
160
Rules of Spacing	
160
if Statement	
161
if-­
else Statement	
162
if-­
elif Statement	
163
if-­
elif-­
else Statement	
165
while Statement	
165
for Statement	
166
def Statement	
167
class Statement	
168
try-­
except Statement	
168
with Statement	
169
	 	
Chapter Summary	
170
	
Contents	
ix
	 	
Exercises	
171
	 	
Projects	
172
	Chapter 3	 Flow Control of Statements	
175
	 	
Learning Objectives	
175
	
3.1	 Selective with the if Statement	
175
	
3.2	 Single-branch selective with if Statement	
176
	
3.3	 Multiple-Branch Selective with if-elif-… and if-elif-…-else 
Statements	
177
	
3.4	 Iterate with for Statement	
180
Using break and continue Statements and an else Clause 
Within Loops	
184
Common Coding Mistakes with the for Loop	
185
	
3.5	 Iterate with the while Statement	
185
Common Coding Mistakes with a while Loop	
190
	
3.6	 Iterate with for Versus while	
190
	 	
Chapter Summary	
195
	 	
Exercises	
195
	 	
Projects	
196
	Chapter 4	 Handle Errors and Exceptions in 
Programs	
201
	 	
Learning Objectives	
201
	
4.1	 Errors in Your Programs	
202
Exception	
203
ArithmeticError	
204
OverflowError	
204
ZeroDivisionError	
204
FloatingPointError	
205
AssertionError	
205
AttributeError	
205
BufferError	
206
EOFError	
206
GeneratorExit	
206
ImportError	
206
IndexError	
207
KeyError	
207
KeyboardInterrupt	
207
MemoryError	
207
	
x	
Contents
ModuleNotFoundError	
207
NameError	
208
NotImplementedError	
208
OSError	
208
BlockingIOError	
208
ChildProcessError	
208
ConnectionError	
208
BrokenPipeError	
209
ConnectionAbortedError	
209
ConnectionRefusedError	
209
ConnectionResetError	
209
FileExistsError	
209
FileNotFoundError	
209
IsADirectoryError	
209
NotADirectoryError	
209
PermissionError	
209
ProcessLookupError	
210
TimeoutError	
210
RecursionError	
210
ReferenceError	
210
RuntimeError	
210
StopIteration	
210
StopAsyncIteration	
210
SyntaxError	
210
IndentationError	
211
TabError	
211
SystemError	
211
SystemExit	
211
TypeError	
211
UnboundLocalError	
212
UnicodeError	
212
UnicodeEncodeError	
212
UnicodeDecodeError	
212
UnicodeTranslateError	
212
ValueError	
212
	
4.2	 Handling Runtime Errors and Exceptions	
216
	 	
Chapter Summary	
219
	 	
Exercises	
220
	
Contents	
xi
	Chapter 5	 Use Sequences, Sets, Dictionaries, and 
Text Files	
221
	 	
Learning Objectives	
221
	
5.1	 Strings
222
Methods of Built-­
In Class str	
222
Built-­
In Functions and Operators for Strings	
232
Constructing and Formatting Strings	
234
Regular Expressions	
242
	
5.2	 Lists
251
	
5.3	 Tuples
258
	
5.4	 Sets
261
	
5.5	 Dictionaries	
266
	
5.6	 List, Set, and Dictionary Comprehension	
271
List Comprehension	
272
Set Comprehension	
273
Dictionary Comprehension	
274
	
5.7	 Text Files	
274
Opening and Closing a File	
275
Write or Append to a File	
278
Reading from a File	
280
Update Existing Content of a Text File	
284
Deleting Portion of a Text File	
286
	 	
Chapter Summary	
289
	 	
Exercises	
291
	 	
Projects	
292
	Chapter 6	 Define and Use Functions	
295
	 	
Learning Objectives	
295
	
6.1	 Defining and Using Functions in Python	
296
	
6.2	 Parameters and Arguments in Functions	
299
	
6.3	 Recursive Functions	
304
	
6.4	 Anonymous Functions: lambda Expressions	
308
	
6.5	 Special Functions: Mapping, Filtering, and Reducing	
310
Mapping	
310
Filtering	
311
Reducing	
312
	
6.6	 Generators: Turning a Function into a Generator of Iterables	 312
	
6.7	 Closures: Turning a Function into a Closure	
316
	
6.8	 Decorators: Using Function as a Decorator in Python	
317
	 xii	
Contents
	
6.9	 Properties of Functions	
320
	 	
Chapter Summary	
322
	 	
Exercises	
322
	 	
Projects	
323
	Chapter 7	 Object-­
Oriented Programming with 
Python	
325
	 	
Learning Objectives	
325
	
7.1	 Introduction to Object-­
Oriented Programming (OOP)	
326
Abstraction	
326
Information Hiding or Data Encapsulation	
326
Inheritance	
327
	
7.2	 Defining and Using Classes in Python	
327
Inheritance: Subclass and Superclass	
333
Public, Private, and Protected Members of a Class	
334
Class Methods	
336
Static Methods	
337
Class Attributes	
338
	
7.3	 Advanced Topics in OOP with Python	
340
Dunder Methods in Class Definition	
340
Using Class as Decorator	
346
Built-­
In Property() Function and Property Decorator	
348
Creating a New Class Dynamically and Modify a Defined 
Class or Instance	
352
Keeping Objects in Permanent Storage	
356
	 	
Chapter Summary	
358
	 	
Exercises	
359
	 	
Project
361
	Chapter 8	 Modules and Packages	
363
	 	
Learning Objectives	
363
	
8.1	 Creating Modules and Packages	
364
	
8.2	 Using Modules and Packages	
367
	
8.3	 Install and Learn About Modules Developed by Others	
369
	
8.4	 Module for Generating Random Numbers	
377
Functions for Bookkeeping	
379
Functions for Generating Random Integers	
379
Functions for Randomly Generating Float Numbers	
380
Functions for Randomly Selected Item(s) from Sequences	
382
	
8.5	 Module for Mathematical Operations	
385
	
Contents	
xiii
	
8.6	 Modules for Time, Date, and Calendar	
395
The Datetime Module	
395
The Time Module	
405
The Calendar Module	
410
	
8.7	 Modules for Data Representation and Exchange	
415
	
8.8	 Modules for Interfacing Operating Systems and Python 
Interpreter	
418
OS Module for Interacting with the Operating System	
418
The path Submodule from os for Manipulating File Paths	
423
The sys Module for Interaction Between the Python and 
Python Interpreter or Python Virtual Machine (PVM)	
426
	
8.9	 Module for Logging Events During Program Runtime	
434
	
8.10	Modules for Playing and Manipulating Audio and 
Video Files	
436
winsound	
436
PyGame	
439
	
8.11	Modules for Creating and Manipulating Graphics and 
Images	
442
Create Graphics with Tkinter	
443
Manipulate Images with Pillow	
448
	
8.12	Modules for Data Analytics	
451
	 	
Chapter Summary	
455
	 	
Exercises	
456
	 	
Projects	
457
	Chapter 9	 Develop GUI-­
Based Applications	
459
	 	
Learning Objectives	
459
	
9.1	 Terminal-­
Based Applications Versus GUI-­
Based 
Applications	
460
	
9.2	 Designing and Developing GUI-­
Based Applications 
in Python	
461
Tkinter Module	
463
tkinter.ttk—­
Tk-­
Themed Widgets	
475
	 	
Chapter Summary	
482
	 	
Exercises	
483
	 	
Projects	
484
This page intentionally left blank
 https://doi.org/10.15215/remix/9781998944088.01
Chapter 1
Introduction
This chapter prepares you to learn how to program with Python. Preparation 
includes a brief introduction to computers and computing, programming, 
and programming languages, as well as the installation of Python and Python 
interactive programming and integrated development environments (IDEs), 
including Jupyter Notebook for interactive programming and VS Code as a 
required IDE.
Learning Objectives
After completing this chapter, you should be able to
•	 talk about the history of computers.
•	 describe the basic components of modern computers and their roles.
•	 explain the basic principles of modern computers.
•	 discuss the basics of computability and computational complexity.
•	 explain how the construction of modern computers has evolved.
•	 explain what computer systems are made of.
•	 discuss computer programming languages.
•	 describe Python and discuss its development, features, and advantages.
•	 install Python and required Python IDEs on the computer.
•	 get Python and Python IDEs running for the learning activities included 
in this textbook.
1.1 A Brief History of Computers
The history of human tools, devices, or instruments to help us count, compute, 
and think can be traced back to the Stone Age, when our ancestors used knots 
on ropes, marks on bark, stones, and balls of clay. One of the most well-­
known 
	
2	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
and widely used devices for computing in human history is the abacus, shown 
in Figure 1-­
1.
The exact origin of the abacus is unknown, but before the adoption of the 
written Hindu-­
Arabic numeral system, the abacus had already been widely 
used in many countries, including China, Russia, and some European coun­
tries. Abacuses continued to be widely used by almost all accountants in China 
before the adoption of modern computers and calculators.
Today, although abacuses are rarely used in real applications such as 
accounting, their working principles are still used to train people to do men­
tal math, such as in programs like the Universal Concept of Mental Arithmetic 
System (UCMAS; see ucmas​
.ca). UCMAS holds annual competitions worldwide, 
including in Canada.
The invention and development of today’s modern computers can be 
attributed to the invention and development of all previous relevant concepts, 
principles, and technologies. The concept of a digital, programmable computer 
originated with Charles Babbage, an English mathematician, philosopher, 
inventor, and machine engineer. In 1822, he designed a steam-­
driven calcu­
lating machine for automatically computing tables of numbers. Although his 
government-­
funded project failed, the many ideas he developed and used in 
his analytical engine were adopted and used in the world’s first modern pro­
grammable computer, built a century later. That is why Charles Babbage is 
considered to be one of the “fathers of computers.”
In 1847, George Boole, an English mathematician introduced Boolean logic, 
propositional calculus, and Boolean algebra as the laws of thinking, which later 
became the foundation of modern electronic computers and digital devices in gen­
eral. For that reason, George Boole is regarded as a founder of computer science.
In 1890, Herman Hollerith successfully designed and built a punch-­
card-­
based system for the US government to calculate its 1890 census. It saved the 
US government US$5 million by finishing the calculation in one year instead 
of 10 years it would have taken using traditional methods, as in the previous 
census. In 1896, Herman Hollerith established a company called the Tabulating 
Machine Company to make the machines. This company ultimately became IBM.
Figure 1-­
1: A traditional abacus
	
Introduction	
3
 https://doi.org/10.15215/remix/9781998944088.01
The central concept and theory of modern computers were conceived in 
1936 by English mathematician Alan Turing in his “universal machine,” which 
became known as the Turing machine in his honour. He successfully proved 
that his universal machine could calculate anything that is computable. Alan 
Turing is also considered by some to be “a father of computers”—­
or more 
precisely, “a father of computing”—­
for his seminal paper on the theory of 
computation. In the eyes of the general public, Alan Turing is more famous 
for his role in cracking the so-­
called unbreakable codes used by the German 
army during World War II, as presented in The Imitation Game, a well-­
known 
Hollywood movie.
Until 1937, all computing machines or computers were mechanically based, 
using gears, cams, belts, or shafts. John Vincent Atanasoff, an American math­
ematician and physician at Iowa State University, attempted in 1937 to build the 
first electronic computer. He and Clifford Berry, one of his graduate students at 
the time, designed and built a special-­
purpose digital computer, ABC. For that 
reason, he is considered to be “the father of the modern computer.” It was in 
the ABC machine that binary math and Boolean logic were successfully used 
for the first time.
In 1943, across the Atlantic Ocean in England, Colossus Mark I, a prototype 
of a special-­
purpose computer, was built. A year later, in 1944, Colossus Mark II 
was built and used to break the encrypted radiotelegraphy messages transmitted 
by the German army at the end of World War II.
In 1946, the first general-­
purpose digital computer, the Electronic Num­
erical Integrator and Computer (ENIAC), was built by two professors at the 
University of Pennsylvania: John Mauchly and J. Presper Eckert. The computer 
had over 18,000 vacuum tubes and weighed 30 tons. A rumour at the time said 
that whenever the computer was turned on, the lights in some districts of 
Philadelphia would dim.
During the same time, the same group of people at the University of Pennsyl­
vania also designed and built EDVAC (the Electronic Discrete Variable Automatic 
Computer, completed in 1949), BINAC (the Binary Automatic Computer, also 
completed in 1949), and UNIVAC I (the Universal Automatic Computer I, com­
pleted in 1950), which were the first commercial computers made in the US. 
Although the computing power of these computers was not even comparable 
to that of today’s smartphone, their contributions to the development of today’s 
modern computers are enormous. These contributions include the concepts, 
principles, and technology of stored programs, subroutines, and programming 
languages.
Around the same time that ENIAC was built, the Harvard Mark I auto­
matic sequence-­
controlled calculator was also built at Harvard University. It is 
	
4	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
believed that John von Neumann, a mathematician and physicist working at the 
Los Alamos National Laboratory, was the first user of the Harvard Mark I, which 
he used to run programs on the machine to calculate for the Manhattan Project.
In 1944, Von Neumann had an opportunity to join a discussion with J. Pres­
per Eckert and John Mauchly, who were developing ENIAC and EDVAC machines 
at the time. He wrote up a report on the EDVAC, First Draft of a Report, in which 
he described a computer architecture later known as Von Neumann architec­
ture (see Figure 1-­
2). The key idea behind the architecture is a stored-­
program 
computer that includes the following components:
•	 a processing unit that contains an arithmetic logic unit and processor 
registers
•	 a control unit that contains an instruction register and program counter
•	 internal memory that stores data and instructions
•	 external mass storage
•	 input and output mechanisms
The unpublished report was widely circulated. It had great impact on the 
later development of modern computers, although to many people, Turing was 
the originator of this key idea and architecture, and many others, including J. 
Presper Eckert and John Mauchly, made significant contributions to its evo­
lution as well. Regardless, it is Von Neumann architecture that has guided the 
design of modern computers. All computers we use today are essentially still 
Von Neumann computers.
Modern computers can be categorized into three generations based on the 
core hardware technology used. The first generation of computers (1937–­
46) 
used vacuum tubes, the second generation (1947–­
62) used transistors, and the 
third generation (1963–­
present) used integrated circuits (IC).
Central Processing Unit
Control Unit
Arithmetic/Logic Unit
Memory
Input
Output
Storage
Figure 1-­
2: Von Neumann architecture
	
Introduction	
5
 https://doi.org/10.15215/remix/9781998944088.01
Both hardware and software play important roles in computers. On the hard­
ware front, in the first generation of modern computers, magnetic tapes and disks 
were developed and used for storage, and printers appeared and were used for 
output. On the software side, simple operating systems (OSs) were developed and 
used, and over 100 high-­
level programming languages were developed.
During the second generation of computers, the Universal Automatic Com­
puter (UNIVAC I), the first computer for commercial use, was introduced to 
the public (1951). The International Business Machines Corporation (IBM) also 
brought their IBM650 and IBM700 series computers to the computer world 
(1953).
Since 1963, the beginning of the third generation of modern computers, 
advances in hardware have made computers smaller and smaller but much 
more powerful, with a higher speed of CPU and a bigger memory with faster 
throughput.
In 1980, Microsoft developed MS-­
DOS, short for Microsoft Disk Operating 
System, and in 1981, IBM introduced the first personal computer (PC) for home 
and office use. In 1984, Apple brought its Macintosh computer with its icon-­
driven interface to the world, and in the 1990s, Microsoft brought the world the 
Windows operating system. Billions of computer users around the world have 
enjoyed both Microsoft Windows and Apple’s macOS.
More information about the history of computers can be found on the inter­
net by searching for “history of computers,” including the following articles:
https://​
en​
.wikipedia​
.org/​
wiki/​
Computer
https://​
www​
.computerhistory​
.org/​
timeline/​
computers/
https://​
www​
.explainthatstuff​
.com/​
historyofcomputers​
.html
https://​
www​
.britannica​
.com/​
technology/​
computer/​
History​
-of​
-computing
1.2 Fundamentals of Computing and Modern 
Computers
The development of modern computers is the result of the collective efforts of 
many great mathematicians, scientists, and engineers and advances in both 
theories and technologies. This section looks at the theoretical and technical 
fundamentals of computing and modern computers in order to show how 
modern computers work internally.
	
6	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Number Systems and the Foundation of Computing
Initially, computers and computing devices were developed to deal with num­
bers. They later made their way into the realm of text handling and information 
processing. This is done through encoding. When properly coded, all text can be 
represented as numbers—­
codes—­
and all ways of manipulating text can be accom­
plished through operations on those codes. Number systems and operations on 
numbers are really a basic foundation of computing and modern computers.
We all know numbers, and the number system we have known since child­
hood is base-­
10, which is represented using 10 digits from 0 to 9. A base-­
10 
number such as 2539867 can be written as
2 * 106 + 5 * 105 + 3 * 104 + 9 * 103 + 8 * 102 + 6 * 101 + 7 * 100
In general, an n-digit number dn−1dn−2…d1d0 (where n is any positive integer 
and each d ∈ [0, 1, 2, …, 9], where 0 < i < n ) in a base-­
10 number system can 
be rewritten as
dn−1 * 10n−1 + dn−2 * 10n−2 + … + d1 * 101 + d0 * 100
In fact, a number system can be based on any whole number other than 
0 and 1. There is a base-­
7 system for weeks, a base-­
12 system for the Chinese 
zodiac and imperial foot and inch, and a base-­
24 number system for the 24-­
hour 
clock. A long list of different numbering systems that have appeared since pre­
history can be found at https://​
en​
.wikipedia​
.org/​
wiki/​
List​
_of​
_numeral​
_systems.
In general, a base-­
Q number system will require Q unique symbols repre­
senting 0, 1, … Q−1, respectively. The base-­
10 equivalence of an n-digit base-­
Q 
number dn−1dn−2…d1d0 can be represented as
dn−1 * Qn−1 + dn−2 * Q−2 + … + d1 * Q1 + d0 * Q0
The evaluation of the expression above will result in its base-­
10 equivalence. 
This is how we convert a number from base-­
Q to base-­
10.
For Q = 2, the numbers 0 and 1 are used to represent digits; for Q = 3, the 
numbers 0, 1, and 2 are used; for Q = 8, the numbers 0, 1, 2, 3, 4, 5, 6, and 7 are 
used; for Q = 16, the numbers 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a/A, b/B, c/C, d/D, e/E, 
and f/F are used.
The expression above also shows how to convert a number from base-­
10 
to base-­
Q: divide the number by Q repeatedly, and the remainders will be the 
digits. The details of these conversions can be found on the internet.
For a number dn−1dn−2…d1 d0 in a base-­
Q number system, it is often necessary 
to add Q as a subscription of the sequence, as shown below:
dn−1dn−2…d1d0Q or (dn−1dn−2…d1d0)Q
	
Introduction	
7
 https://doi.org/10.15215/remix/9781998944088.01
This explicitly indicates that the number is in a base-­
Q number system. For 
example, number 657 in a base-­
8 number system will be written as 6578 or 
(657)8, especially if the context does not indicate which number system the 
number is in.
All number systems have the same operations that we are already familiar 
with in a base-­
10 system, such as addition, subtraction, multiplication, and 
division. The only difference is that in a base-­
Q number system, a 1 carried to 
or borrowed from a higher digit is equal to Q instead of 10.
For example, in a base-­
2 number system, 101 can be written as 1 * 22 + 0 
* 21 + 1 * 20, and its 10-­
base equivalence is 1 * 4 + 0 + 1 = 5, and for 101 + 110, 
the operation is
101
+ 110
______
1011
110
− 101
______
001
Given the four basic mathematical operations—­
addition, subtraction, multi­
plication, and division—­
it is very simple to prove that multiplication can be done 
by repeated addition, whereas division can be done by repeated subtraction. 
Therefore, if you know how to do addition and subtraction and are able to 
count, you will be able to do multiplication and division as well.
More importantly, because a − b can be rewritten as a + (−b), you may be 
able to eliminate subtraction if you can represent −b without the minus sign. 
In a base-­
Q number system, (a − b) can be conveniently handled through a + 
b′, in which b′ is the Q-complement of b representing (−b).
Given a negative number, −N, in which N is called the magnitude of −N, how 
do you get N′, the Q’s complement to N? It turns out to be very easy.
For a number N written as dndn−1…d0 in a base-­
Q number system, its 
Q-complement N′ is a number, also in a base-­
Q number system, such that N + 
N′ = Qn, and N′ can be easily calculated in the following two steps:
	
1.	 For each di in dn−1dn−2…d0, find ti such that di + ti = Q−1, to 
get tn−1tn−2…t0
	
2.	 Add 1 to tn−1tn−2…t0 to get N’s complement cn−1cn−2…c0
For b in a − b, if b has fewer digits than a, add 0s to the left of b to make up the 
missing digits before working on the above steps. For example, for 768 − 31, 
do 768 + (−31) or 768 + the 10’s complement of 31.
	
8	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
To get 10’s complement of 31, first add one 0 to the front of 3 to get 031, 
then find out the 10’s complement of 031, which is 968 + 1 = 969. Then do 768 
+ 969 to get 1737, and ignore the last carried digit, 1, to get 737, which is the 
result of 768 − 31.
It is easy to see that if C is N’s complement, then N is C’s complement as 
well. Using the notation given above, this can be written as (N′)′ = N.
What about floating-­
point numbers—­
that is, numbers with fractions, such 
as 3.1415926?
In a base-­
Q number system, a floating-­
point number can be represented 
much like integers, as shown below:
dn−1 * Qn−1 + dn−2 * Qn−2 + … + d1Q1 + d−1 * Q−1 + d−2 * Q−2 + … + d−mQ−m
This may give us a hint that a floating-­
point number can be represented by 
two sequences of digits: one for the integer portion and the other for the frac­
tion portion. If floating-­
point numbers are represented this way in computers, 
addition and subtraction could be performed on the two portions separately, 
but with a mechanism to deal with carrying from the fraction to the integer in 
the case of addition, and a mechanism to deal with borrowing from the integer 
to the fraction in the case of subtraction. This would be rather clumsy, and it 
would be even more clumsy when doing multiplication and division.
In reality, floating-­
point numbers are represented in scientific notation, 
such as 1.3 * 102 in a base-­
10 or decimal system, where 1.3 is called the frac­
tion, 2 is called the exponent, and 10 is the radix. In a base-­
2 system, the radix 
would be 2.
In scientific notation, arithmetic operations on floating-­
point numbers 
can be easily done, especially if the fractions of all floating-­
point numbers are 
normalized—­
that is, if the number of digits before the radix point is fixed for 
all floating-­
point numbers. For example, to perform the addition or subtrac­
tion of two floating-­
point numbers, all you need to do is shift the digits of one 
floating-­
point number based on the difference of the two exponents, then per­
form addition or subtraction in the same way as on integers. More surprisingly, 
multiplying and dividing floating-­
point numbers in scientific notation is much 
easier than adding and subtracting. There is no need to shift the digits because
a * rm * b * rn = a * b * rm+n
and
a * rm / b * rn = a / b * rm−n
All you need to build a computer capable of adding, subtracting, multiply­
ing, and dividing in a base-­
Q number system is the ability to add and count, 
	
Introduction	
9
 https://doi.org/10.15215/remix/9781998944088.01
which is needed for multiplication and division. Moreover, counting itself can 
be done by addition when counting up or subtraction when counting down. 
This is very encouraging.
The following discoveries are even more encouraging:
•	 Many mathematical and scientific problems can be represented and 
reformulated based on the basic mathematical operations discussed 
above.
•	 If we can build a computing device capable of doing basic mathematical 
operations, the machine can solve many computing and information 
processing problems.
The remaining question is how to make such a machine work faster. On a 
computing machine with only an addition and counting unit, if each step of an 
operation has to be enabled by a human, the computation would be very slow 
because it would have to wait for the human to input instructions and data. To 
speed things up, the entire problem solving process needs to be automated. This 
requirement has led to the introduction of memory to computing machines to 
store both the operating instructions (the program) and data needed during the 
computation. For the central processing unit (CPU) and memory (RAM) to com­
municate and work together, a communication channel and control unit need to 
be added. For human users to communicate with the computing machine, input 
and output units are also needed. Together these include everything described in 

Von Neumann’s architecture for modern computers.
Computability and Computational Complexity
Now comes the question of how powerful the computing machine described 
above can be. In particular, we should ask,
•	 What problems can or cannot be computed with a computing machine?
•	 How difficult is it to solve a given problem with a computing machine, 
assuming that the machine can take as many steps and use as much 
memory as needed to solve the problem?
Answering the first problem is the study of computability. Answering the second 
question is the study of computational complexity.
A well-­
known computability problem was raised by David Hilbert, a very 
famous German mathematician in the 19th century. The 10th problem in his list 
of 23 important mathematical problems he published in 1900 is the decidability 
problem, which is about finding an algorithm that can determine whether a 
	 10	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Diophantine equation such as xn + yn = zn, where n is an integer and greater 

than 2, has integer solutions. It was proved in 1970 that such an algorithm 
doesn’t exist, meaning that the problem of deciding whether a Diophantine 
equation has integer solutions is unsolvable, or incomputable.
Between the 1930s and 1940s, before the existence of modern computers, 
Alan Turing invented a simple yet powerful abstract machine called the Tur­
ing machine. He proved that the abstract machine could simulate the logic of 
any given algorithm and further determine whether an algorithm is comput­
able. The operation of the machine will halt if the algorithm is incomputable. 

During the same time, computability was also well studied by Alonzo Church 
based on lambda calculus. The two works later intertwined in a formal theory 
of computation known as the Church-­
Turing thesis.
In computer science, the computational complexity of an algorithm devised 
to solve a problem is about the number of resources—­
CPU time and memory, 
in particular—­
needed to run the algorithm on a computer. A problem may be 
solved in different ways using different algorithms with different computational 
complexities. Sometimes it is necessary to find a better algorithm that runs 
faster and/or uses less memory.
The time required to run an algorithm is also related to the size of the 
problem to be solved. For example, finding someone in a classroom would be 
much easier than finding someone in a city. If you denote the size of a problem 
with n, then in computer science, O(f(n))—­
called the big O of f(n)—­
is used to 
describe asymptotically the upper bound of running time: the time complexity 
of an algorithm for solving the problem.
For example, assume you want to sort the numbers in a list. The size of the 
problem will be the number of numbers in the list. One algorithm is called 
selection sort, which begins with selecting the smallest number from the 
list, then selecting the smallest number from the remaining of the list, and 
so on. Assume the size of the list is n. The first time it will need to do n − 1 
comparisons. The second time it will need n − 2 comparisons. When these are 
only two numbers left in the list, only one comparison is needed to finish. So 
the complexity of the algorithm in terms of the total number of comparisons 
needed will be
(n − 1) + (n − 2) + (n − 3) … + 2 + 1 = (n − 1 + 1) / 2 * (n − 1) = n * (n − 1) / 2 
= (n2 − n) / 2 = O(n2)
You may have noted in the big-­
O notation that we have kept only the highest-­
order term and have removed the constant ½ as well. This is because, with the 
big-­
O asymptotic notation, only the scale of complexity increased when the size 
of the problem increases is of interest.
	
Introduction	
11
 https://doi.org/10.15215/remix/9781998944088.01
In computer science, problems can be classified as P (for polynomial), 
NP (for nondeterministic polynomial), NP-­
complete, or NP-­
hard problems. A 
problem is said to be in P if it can be solved using a deterministic algorithm in 
polynomial time—­
that is, if the complexity is a big O of a polynomial. A prob­
lem is said to be in NP if it can be solved with a nondeterministic algorithm in 
polynomial time. A problem is NP-­
complete if a possible solution can be quickly 
verified but there is no known algorithm to find a solution in polynomial time. 
A problem is NP-­
hard if every NP problem can be transformed or reduced to 
it within polynomial time.
In the above, a deterministic algorithm refers to the one in which, given the 
same input, the output would always be the same, whereas a nondeterministic 
algorithm may give different outputs even for the very same input.
The complexity of algorithms, which is closely related to the response and 
processing speed of programs and computer systems, is the concern of good 
programmers, especially when dealing with resource-­
intensive applications. 
It is also an important topic to be studied in senior or graduate courses in 
computing and computer science. When writing a program or just a function 
for assignments or an application, always think about the time and space com­
plexity and ask yourself, Is there a better way to get the job done?
The Construction of Modern Computers
In general, computers can be categorized into two types: analog computers and 
digital computers. The computers in use today are almost all digital computers. 
But analog computers do have their advantages.
ANALOG COMPUTERS
As a computing machine, an analog computer uses the properties of certain 
objects or phenomena to directly analogize the values of variables (such as 
the speed of a vehicle) of a problem to be solved. Examples of the properties 
include the voltage and amperage of electricity, the number of teeth of a gear, 
or even the length of a wood or metal stick.
Analog computing machines were often built for some special purpose, with 
a very wide range of difficulties and complexities. A simple analog computer 
could be built with three gears for addition and subtraction. For addition, using 
both operands to drive the third gear in the same direction will yield the sum 
of the two operands on the third gear, whereas for subtraction, the difference 
can be calculated by driving the two gears in two different directions.
Historically, even as early as 100  BC, complicated analog computing 
machines were built for various applications, from astronomy in ancient Greece 
to the differential machine for solving differential equations in the late 1800s 
	 12	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
and early 1900s. Some of the most complicated analog computing machines in 
modern history include those for flight simulation and gunfire control. Analog 
computing machines continued well into the early age of modern digital com­
puters because the special applications analog computers were developed for 
were still too hard for digital computers in the 1960s or even 1970s.
DIGITAL COMPUTERS
Different from analog computers, digital computers use sequences of digits 
to represent the values of variables involved in the problems to be solved. In 
digital computers, the machine representation of a problem is often abstract, 
with no analogy to the original problem.
Theoretically, in accordance with the earlier discussion about general num­
ber systems, digital computers’ digits can be in any base, from 2 up. Hence a 
digital computer could be base-­
2, base-­
3, … base-­
10, base-­
16, and so on. The 
digital computers we are using today are all base-­
2, or binary, computers, 
although it has been proved that base-­
3 computers would be even more effi­
cient than base-­
2 computers.
This is because it is more convenient and cheaper to build components 
with the two easily distinguishable states needed to represent base-­
2 numbers.
Also, in a binary system, signed numbers can be naturally represented 
using the highest sign bit: 0 for positive numbers and 1 for negative numbers, 
for example. Moreover, the addition and subtraction of signed binary numbers 
can be easily done by using 2’s complements to represent negative numbers.
For example, to do −2−3, we would do
(−2) + (−3)
or
(−00000010)b + (−00000011)b
Next, we need to convert (−00000010)b and (−00000011)b into their 2’s comple­
ment representations. According to the two steps we described in the section 
above, “Number Systems and the Foundation of Computing,” with Q = 2, you 
first get 1’s complement of the magnitude of each negative number above by 
flipping each bit, then adding 1 to 1’s complement, as shown below:
(00000010)b (1’s complement by flipping each bit) → (11111101)b 
(then + 1) → (11111110)b
(00000011)b (1’s complement by flipping each bit) → (11111100)b 
(then + 1) → (11111101)b
	
Introduction	
13
 https://doi.org/10.15215/remix/9781998944088.01
The addition above will become
(11111110)b + (11111101)b
which is equal to
(11111011)b
The 1 on the highest bit of the result means that the result is 2’s comple­
ment representation of a negative number. Interestingly, the magnitude of the 
negative number is the complement of (11111011)b, which is
(11111011)b (1’s complement by flipping each bit) → (00000100)b 
(then + 1) → (000000101)b,
which is 5, meaning that the result of −2−3 is −5.
It is very easy to calculate the 2’s complement of a binary number. Adding a 
negative number can be done by adding its 2’s complement. That is the advan­
tage that the binary system has offered for the construction and development 
of modern digital computers.
As such, in principle, the key component needed in our modern digital 
computers for computing and information processing is a unit to add two 
binary numbers, since the three other basic arithmetic operations can be done 
based on addition, using respective algorithms or routines such as the ones 
mentioned above. In the real implementation and construction of digital com­
puters, all basic arithmetic operations, including bitwise operations on integer 
binary numbers such as the operations needed to find 2’s complements, are 
hardwired into a unit called the arithmetic logic unit (ALU), which is the core 
of the central processing unit (CPU) that you have heard about often.
A digital computer also needs to compute real or floating-­
point numbers as 
well as process graphics. To get these two jobs done more efficiently, modern 
computers also have a floating-­
point unit (FPU) for floating-­
point numbers, 
and a graphics processing unit (GPU) for graphics.
MECHANIC-­
BASED COMPONENTS
Mechanical components such as levels, gears, and wheels can be used to build 
analog computers. In fact, digital computers can also be built with mechanical 
components. The earliest special-­
purpose mechanic-­
based digital computer 
was the difference engine designed by Charles Babbage. A general-­
purpose 
mechanic-­
based digital computer, called the analytical engine, was also first 
proposed by Charles Babbage. In the design, the machine has memory and 
CPU. It would have been programmable and, therefore, would have become a 
general-­
purpose digital computer, if ever actually built.
	 14	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
VACUUM TUBE–­
BASED COMPONENTS
Invented in 1904 by John Ambrose Fleming of England, a vacuum tube is a 
tube made of glass with gas/air removed, with at least two electrodes inserted 
for allowing or controlling the flow of electrons. Vacuum tubes can be made 
to be switches or amplifiers. As switches, the two states of on and off can be 
used to represent the 0 and 1 of binary arithmetic or Boolean logic. When 
the state of output can be controlled by input or inputs, the switch is made to 

be a gate to perform different logical operations. That’s how vacuum tubes could be 

used to implement modern computers; as amplifiers, they found their uses in 
many electronic devices and equipment such as radio, radar, television, and 
telephone systems. It was the vacuum tube that made electronic computers 

and other electronic devices possible for the first time. Vacuum tubes played 
very important roles in the development and construction of all electronic 
devices and systems in the first half of the 20th century.
However, vacuum tubes disappeared from computers and most other elec­
tronic devices soon after transistors were developed at the Bell Laboratories 
by John Bardeen, Walter Brattain, and William Shockley in 1947 because, com­
pared to transistors, vacuum tubes were too big, too heavy, too unreliable and 
consumed too much power to operate. That limited the construction and uses 
of vacuum tube–­
based computers and devices.
TRANSISTORS
Recall that in the construction of computers, the ALU or CPU requires two-­
state 
switches to represent 0 and 1 and logical gates to perform additions and sub­
tractions of binary number systems. Vacuum tubes could be made to construct 
electronic computers, but the computers became too bulky and too heavy to 
be more useful.
INTEGRATED CIRCUITS AND VERY LARGE-­
SCALE INTEGRATED 
CIRCUITS
Integrated circuits (ICs) are chips with many electronic circuits built in, while 
very large-­
scale integrated (VLSI) circuits are those with millions and even bil­
lions of electronic circuits built into very small semiconductor chips. According 
to Moore’s law (attributed to Gordon Moore, the cofounder and former CEO of 
Intel), the number of transistors in a dense integrated circuit doubles about 
every two years. This has been the case over the last few decades since 1975, 
though advancement in VLSI technology has slowed since 2010.
Today, computers are all using VLSI chips. That is why computers have 
become smaller and smaller, while computing power has increased expo­
nentially in accordance with Moore’s law.
	
Introduction	
15
 https://doi.org/10.15215/remix/9781998944088.01
1.3 Programming and Programming Languages
One of the key principles of modern computers is using stored programs, which 
are sequences of instructions telling computers what to do. The task of writing 
programs for computers is called programming.
During the first generation of computers, machine languages and assembly 
languages were used to write programs. Machine languages use sequences of 
0 and 1 to code instructions for computers. Programs in a machine language 
can be directly understood by the CPU of the target computer. The following 
is an example of machine language for the Intel 8088 CPU:
00000011 00000100
10001000 11000011
As you can see, although machine language is friendly to computers, it is 
not friendly to people, because the instruction itself does not tell us what it 
does in a human-­
readable language. To solve this problem, assembly language 
was invented. The two instructions above are written in assembly language as 
follows:
ADD AX, [SI]
MOV BL, AL
The instruction in assembly language is much more friendly to people 
because one can more easily tell what each instruction does. However, assembly 
language is not as friendly to computers. For computers to understand programs 
in assembly language, an assembler is needed to translate the programs into 
code in machine language.
With assembly language, programming is still a difficult task because 
instructions in an assembly language are mostly direct mapping of their 
machine-­
language equivalent and only describe fine and tiny steps of CPU 
operations. It is difficult to program in assembly language to solve real-­
world 
problems.
The idea of using a high-­
level, more human-­
friendly programming lan­
guage was attributed to Konrad Zuse for his work between 1942 and 1945. 
He developed a high-­
level programming language called Plankalkül for a 
non–­
Von Neumann computer called Z4 that he made during the same period 
of time. The language was not implemented and used on Z4 or any other real 
computer during that time, but Konrad Zuse did write a computer chess pro­
gram in the language.
	 16	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The first high-­
level programming language for our modern computers 
(Von Neumann machines) is ALGOL 58, but it was soon surpassed by ALGOL 
60, a structured programming language.
During the second generation of modern computers, more than 100 high-­
level programming languages were developed. The most popular programming 
languages include COBOL, for programming business systems; Fortran (an 
imperative procedural programming language), for scientific calculation; ADA, 
used by the military and National Defense in the US; Lisp (a functional pro­
gramming language), used for symbolic or information processing; and Prolog 
(a logic programming language), for logic programming, especially during the 
first revival of artificial intelligence in the 1980s. There have been thousands of 
programming languages since the invention of the modern computer, according 
to the list at https://​
en​
.wikipedia​
.org/​
wiki/​
List​
_of​
_programming​
_languages.
However, most of these programming languages have never been used 
in real application development. The most popular programming languages 
used today include Python, Kotlin (for Android applications), Java, R (for data 
analysis and machine learning), JavaScript, C++, C#, PHP, Swift (for iOS appli­
cations), Go, and C, which has been a popular language for more than half of 
the century and is considered a foundational language of many other popular 
programming languages.
High-­
level programming languages are friendly to people but not friendly 
to computers. For computers to understand and execute programs written in 
a high-­
level programming language, they must be translated into machine lan­
guage. Based on how programs in high-­
level languages are translated into target 
machine language, high-­
level programming languages are either compiled or 
interpreted. A program written in a compiled programming language such as 
C or C++ needs to be compiled into its target machine’s codes and linked with 
copies of code in static libraries, or linked with references to code in dynamic 
or shared libraries, so that the resulting object can then be executed by the 
target computer.
Programs written in an interpreted programming language can be executed 
directly by the interpreter of the programming language, in view of program­
mers and users. Behind the scenes, however, to speed up the execution of 
programs written in an interpreted programming language, the programs are 
often translated first into some intermediate codes, often called bytecodes. 
The bytecodes are then executed within a so-­
called virtual machine built 

into the interpreter of the programming language.
More readings about the history of computer programming languages can 
be found on the internet by searching for “history of computer programming.” 
The following are some of the articles:
	
Introduction	
17
 https://doi.org/10.15215/remix/9781998944088.01
https://​
en​
.wikipedia​
.org/​
wiki/​
History​
_of​
_programming​
_languages
http://​
www​
.softschools​
.com/​
inventions/​
history/​
computer​
_programming​
_history/​
369/
https://​
www​
.datarecoverylabs​
.com/​
company/​
resources/​
history​
-computer​
-programming​
-languages
https://​
www​
.computerhistory​
.org/​
timeline/​
software​
-languages/
https://​
www​
.thecoderschool​
.com/​
blog/​
the​
-history​
-of​
-coding​
-and​
-computer​
-programming/
A good overview of programming languages can be found at https://​
en​
.wikipedia​
.org/​
wiki/​
Programming​
_language.
It is worth noting that although well-­
formed computer programming lan­
guages only came into existence in the late 1940s, Ada Lovelace, an English 
mathematician who lived between 1815 and 1852, is considered the first com­
puter programmer. When she was commissioned to translate an article based 
on Charles Babbage’s speech about his analytical engine, she wrote extensive 
notes alongside the translation to explain the principles and mechanism of the 
analytical engine. Those notes were later considered to be the first computer 
programs in history. For example, one set of those notes would calculate a 
sequence of Bernoulli numbers if executed on the analytical engine.
1.4 Python Programming Language
Python is an interpreted, high-­
level, general-­
purpose programming language. 
It is one of the most popular programming languages in the world, second only 
to Java. The 2023 rankings for programming language popularity can be found 
at https://​
www​
.hackerrank​
.com/​
blog/​
most​
-popular​
-languages​
-2023/.
The Development and Implementation of Python
Python was originally conceived and developed in the Netherlands by Guido 
van Rossum in the late 1980s. Its first release was Python 0.9.0 in 1991. Python 2.0 

was released in 2000, nine years after the release of Python 0.9.0.
Most of the development of Python was accomplished between 2005 and 
2013, when Guido van Rossum was working at Google, where he spent half of 
his time on the development of the programming language. The latest Python 2 
release is Python 2.7.16, whereas the latest release of Python 3 is Python 3.9.0, 
at the time of writing.
Python is an interpreted programming language rather than a compiled 
programming language. Programs written in Python don’t need to be com­
piled into target machine code. Instead, they only need to be translated into 
	 18	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
bytecodes, then executed by a Python Virtual Machine (PVM), which is built 
into the Python interpreter.
Python language has different implementations with different names. 

CPython, written in C and known simply as Python, is what we will be using, 
and it is the implementation you will get from Python standard distribution at 
python​
.org by default. In addition to CPython, the following are some alterna­
tive implementations of Python:
	
1.	 JPython or Jython, and implementation for running on Java Virtual 
Machine (JVM)
	
2.	 IronPython, an implementation for running on .NET
	
3.	 PyPy, an implementation for working with a just-­
in-­
time (JIT) 
compiler
	
4.	 Stackless Python, an implementation of a branch of CPython 
supporting microthreads
	
5.	 MicroPython, an implementation for running on microcontrollers
These implementations may be of interest only for some special applications.
Advantages of Python
Python was designed with the principle of “programming for everyone.” Programs 
written in Python are clean and easy to read. Yet Python is a general-­
purpose 
programming language and very powerful to code in. Programming in Python 
has the least overhead, especially when compared to Java. Let’s take the famous 
“Hello World!” application as an example. In Java, to create this application, you 
need to write a class with a main method like the following:
class first {
    public static void main(String args[]){
    System.out.println("Hello World!");
    }
}
Then save it to a file and compile the file into Java bytecode by running the 
following command, provided you have a JDK correctly installed:
javac myhelloworld.java
This command will generate a file named first.class. You can then run 
command java first to have “Hello World!” spoken out.
	
Introduction	
19
 https://doi.org/10.15215/remix/9781998944088.01
In Python, however, you only need to write the following code and save to 
a file, say, myhelloworld​
.py:
print("Hello World!")
Then run the following command:
python myhelloworld​
.py
More importantly, Python supports different programming paradigms, 
including structured programming, imperative programming, object-­
oriented 
programming, functional programming, and procedural programming. 

Logic programming is probably the only exception; it is not supported by Python.
Python is very powerful for two reasons. The first reason, as you will see 
later, is that Python has many powerful language constructs and statements to 
represent data and operations on various data. The second reason is that there 
are thousands of third-­
party packages/libraries/modules available for all kinds 
of programming needs in addition to the large standard libraries included 
with every release of Python. For example, Python is widely used for data 
analytics and machine learning with the support of the NumPy, SciPy, Pandas, 

Matplotlib, and TensorFlow libraries.
Resources for Python and Python Education
The ultimate resource for Python and API libraries is the official website of the 
Python software foundation at https://​
www​
.python​
.org/. From that website, you 
will be able to access all the releases of Python and other packages and libraries 
that you may be interested in, in addition to the standard libraries that come 
with the official release of Python.
At the time of writing, the latest release of Python is 3.11.1, but you can 
always check and locate the latest release for your platform at https://​
www​
.python​
.org/​
downloads/. However, for your convenience and for your future 
study and use of Python, we will use a package management system called 
Anaconda to install and manage Python and all tools and libraries that you will 
need for this textbook, as detailed later.
There are plenty of resources on the internet for eager learners to learn 
almost anything, including programming in Python. To learn effectively on the 
internet, however, a learner must be able to choose the right materials from 
thousands—­
even millions—­
of choices, and that has proved to be a very difficult 
task. That’s probably one of the reasons why universities and professors are 
	 20	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
still needed: to set the right learning paths and to select the right resources 
for learners.
On the internet, the most authoritative learning source about the Python 
language is the documentation (https://​
docs​
.python​
.org/​
3/), including language 
references (https://​
docs​
.python​
.org/​
3/​
reference/​
index​
.html) and library refer­
ences (https://​
docs​
.python​
.org/​
3/​
library/​
index​
.html), although they may not be 
articulated for beginners.
For learners who prefer to learn by reading, the following are some of the 
best resources on the web:
•	 https://​
docs​
.python​
.org/​
3/: This resource is from the official Python 
website, so the terms and jargons used should be deemed official at 
least within the Python community. It is a comprehensive section as 
well.
•	 https://​
www​
.w3schools​
.com/​
python/: This is a very popular site that 
offers resources covering many different languages.
•	 https://​
www​
.learnpython​
.org/: This is another good site for learning 
Python. it has many resources on specific topics.
For learners who love to watch videos and lectures, the following are 
recommended:
•	 Python Crash Course for Beginners, at https://​
www​
.youtube​
.com/​
watch​
?v​
=​
JJmcL1N2KQs, by Traversy Media. This video uses VS Code IDE to 
illustrate the program examples so that you can follow along once you 
have the required programming environment set up.
•	 Learn Python—­
Full Course for Beginners, at https://​
www​
.youtube​
.com/​
watch​
?v​
=​
rfscVS0vtbw, by freeCodeCamp​
.org and narrated by Mike 
Dane. This video is one of the best. Please note that the video lecture 
recommends the installation and use of PyCharm IDE. However, the 
installation and use of VS Code IDE is required in this book.
1.5 Getting Ready to Learn Programming in Python
To learn the content covered in the rest of this book, you first need to have the 
following installed on your computer:
	
1.	 A newer version of Python from https://​
www​
.python​
.org/. The 
latest version, at the time of writing, is Python 3.11.1. The standard 
	
Introduction	
21
 https://doi.org/10.15215/remix/9781998944088.01
distribution includes everything you need to interpret and execute 
Python programs, which are also called Python scripts.
	
2.	 A newer version of Jupyter Notebook, from https://​
jupyter​
.org/. 
Jupyter Notebook is a powerful interactive programming 
environment supporting up to 40 programming languages, including 
Python.
	
3.	 A newer version of Visual Studio Code (VS Code) from https://​
code​
.visualstudio​
.com/. VS Code is a free and open-­
source code 
editor developed by Microsoft, and it will be used as an integrated 
development environment (IDE) and to host Jupyter Notebook for 
interactive programming.
In this section, we will learn how to install Python, Jupyter Notebook, and 
Visual Studio Code IDE on our computer. A standard distribution of Python 
includes a large volume of libraries for general programming needs. Special 
applications such as those in data science and machine learning will require 
special libraries to be installed. We will learn about that in later units when 
we need them.
Installing and Setting Up the Python Programming Environment
There are different ways of setting up your Python programming environ­
ment. The method we present below is believed to be more reliable and less 
subject to future changes.
INSTALLING PYTHON
The first package we need to install is Python. The steps are as follows:
	
1.	 To ensure a clean installation of Python, uninstall all old versions of 
Python that may have previously been installed on your computer 
and check the value of the PATH environment variable to delete all 
those, and only those, related to Python. To ensure that all have been 
deleted properly, open a shell terminal such as CMD or PowerShell on 
Windows and check if a Python installation still exists by trying to run 
it. You should be told that Python is not recognized.
	
2.	 Go to https://​
www​
.python​
.org/​
downloads/ and look for the newest 
release of Python for your platform. For example, if you want to install 
Python on your Windows machine, download the latest release for 
Windows. Normally, the website should be able to detect the type of 
system you are using to access the website and show you the right 
	 22	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Python package for you to download. You should, however, be aware 
of what you will be getting from the website.
	
3.	 Run the installer to install it. If installing Python on a Windows 
platform, all you need to do to start the installation is to double-­
click 
the downloaded file or press the run button if it does not start the 
installation automatically.
After the installation has started, a window will pop up, as shown 
here:
Python 3.11.1 (64-­
bit) Setup
Install Python 3.11.1 (64-­
bit)
Select Install Now to install Python with default settings, or choose 
Customize to enable or disable features.
→ Install Now
C:\Users\james\AppData\Local\Programs\Python\Python311
Includes IDLE, pip and documentation
Creates shortcuts and file associations
→ Customize installation
Choose location and features
☑ Use admin privileges when installing py.exe
☑ Add gython.exe to PATH!
Cancel
You can either let it install Python automatically for you by clicking 
“Install Now” or choose “Customize installation.” When you choose 
“Customize installation,” you have the opportunity to choose where 
Python will be installed on your computer and what optional modules 
and features will be installed.
In either case, you must check the box to add Python to the PATH 
environment variable. Choose yes to add Python to the system 
PATH environment variable so that Python and other related 
commands can be found.
Do a customized installation so that you will see what is to be installed 
and where. When doing customized installation, remember to check 
	
Introduction	
23
 https://doi.org/10.15215/remix/9781998944088.01
the box to install pip, Python package manager, and other components 
within the distribution, as shown here:
Python 3.11.1 (64-­
bit) Setup
Optional Features
☑ Documentation
Installs the Python documentation files.
☑ pip
Installs pip, which can download and install other Python packages.
☑ td/tk and IDLE
Installs tkinter and the IDLE development environment.
☑ Python test suite
Installs the standard library test suite.
☑ py launcher    ☑ for all users (requires admin privileges)
Use Programs and Features to remove the 'py' launcher.
Back    Next    Cancel
Check the following advanced options, as shown here:
Python 3.11.1 (64-­
bit) Setup
Advanced Options
❑ Install Python 3.11 for all users
☑ Associate files with Python (requires the 'py' launcher)
☑ Create shortcuts for installed applications
☑ Add Python to environment variables
❑ Precompile standard library
❑ Download debugging symbols
❑ Download debug binaries (requires VS 2017 or later)
Customize install location
d:\Programs\Python\Python311
You will require write permissions for the selected location.
Back    Install    Cancel
	 24	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
To check whether Python has been installed successfully on your 
computer, open a shell terminal and run the following command:
$ python -­
-­
version
If the installation was successful, the version of Python will be 
displayed and should be the same as the one you have downloaded 
from python​
.org.
SETTING UP A VIRTUAL ENVIRONMENT FOR A PYTHON PROJECT
When programming in Python, you will need a Python interpreter and any 
additional libraries required for the project. Libraries required for one project 
are different from those for other projects. To ensure that each project has the 
right programming environment without interfering with others, Python uses a 
technology called a virtual (programming) environment, which can be created 
and activated for each project. When you work in a virtual environment for a 

specific project, all installations of additional libraries will be used only for 
that specific project.
To create and use a virtual environment, take the following steps:
	
1.	 Check whether you have a tool called pipenv installed with your 
Python installation by running the following command on Windows:
where.exe pipenv
or the following command on Linux or Mac:
which pipenv
If it is installed, the command will tell you where it is located on your 
computer, and you can go to step 3.
	
2.	 If the command cannot be located on your system, you will need to 
install it by running the following command on a shell terminal:
pip install pipenv
If you are running the shell terminal as a regular user, pipenv will be 
installed under your home directory, so that you will have to add the 
location to the environment variable PATH. It is better to start a shell 
	
Introduction	
25
 https://doi.org/10.15215/remix/9781998944088.01
terminal as an administrator, then run the above command as root/
administrator to ensure that pipenv will be installed globally and be 
accessible for all users with the already set value for PATH.
	
3.	 Once you are sure that pipenv is installed, create a directory for your 
new project and change the work directory to that directory, say c:\
dev\testproject as an example, by running the following commands in 
sequence:
c:\dev> mkdir testproject
c:\dev> cd testproject
	
4.	 Within the testproject directory, run the following command:
c:\dev\testproject> pipenv install
This will create a virtual environment for your project rooted at c:\de\
firstproject.
	
5.	 To work on the project with the virtual programming environment, 
you need to activate the virtual environment for the project by 
running the following command within the project directory:
c:\dev\testproject> pipenv shell
Once the virtual environment has been activated, the prompt of the 
shell terminal will become something similar to the following:
(testproject-­
UCP5-­
sdH)c:\dev\testproject>
Please note the text within the parentheses. It contains the name 
of the project directory. It means that you are now working in a 
subshell terminal invoked by pipenv.
	
6.	 From now on, any package installed by running the pip command on 
this subshell terminal will be only part of this virtual environment, 
without interfering with installations elsewhere for other projects.
	
7.	 To get out of the virtual environment, simply type “exit” to close the 
subshell, as shown below:
(testproject-­
UCP5-­
sdH)c:\dev\testproject>exit
	 26	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The prompt will become
c:\dev\testproject>
	
8.	 If you want to remove the virtual environment created for a project, 
run the following command within the subshell on the root of the 
project directory:
(testproject-­
UCP5-­
sdH)c:\dev\testproject> pipenv 
-­
-­
 rm
INSTALLING JUPYTER NOTEBOOK
The second package that needs to be installed is Jupyter Notebook. The steps 
are as follows:
	
1.	 After you have successfully installed Python, install Jupyter 
Notebook with pip, the Python package manager that comes with 
the Python installation, by running the following command at a 
shell terminal:
pip install Jupyter
or use the following command if pip itself is not recognized as a 
command, but only installed as a module of Python:
python -­
m pip install jupyter
To see if it has been successfully installed, run the following command 
from a shell terminal:
jupyter-notebook
The command will start a web service on your computer, then launch 
Jupyter Notebook Service within your default web browser.
Start a new notebook by clicking “New” and “Choose Python 3.” You 
can then start the program interactively within the notebook, as 
shown in Figure 1-­
3.
	
Introduction	
27
 https://doi.org/10.15215/remix/9781998944088.01
INSTALLING VISUAL STUDIO CODE
The last package to be installed is Visual Studio Code, a free and open-­
source 
IDE developed by Microsoft that can be used for Python programming. The 
steps are as follows:
	
1.	 Go to https://​
code​
.visualstudio​
.com/, click “Download,” and download 
the installer for your platform.
If you want to see other download options, such as a version for a 
platform other than the one identified by the VS Code website, you can 
scroll down further to check.
	
2.	 Double-­
click “Downloaded Installer” for your platform to run and 
install Visual Studio Code.
To run Visual Studio Code on Windows, click the Start menu, scroll down to 
find Visual Studio Code, and click.
Additional Tools Supporting Software Development in Python
To make software development more efficient, the Python community has 
made the following frameworks or systems available for Python developers.
BUILDBOT
Buildbot is a framework intended to automate all aspects of software develop­
ment. It supports parallel and distributed job execution across multiple 
Figure 1-­
3: Jupyter Notebook in browser
	 28	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
platforms, with version control and job status reporting and automated job 
scheduling when required resources become available. It is hosted at https://​
buildbot​
.net/. An introductory section can be found at http://​
docs​
.buildbot​
.net/​
current/​
tutorial/​
firstrun​
.html.
TRAC
Compared to Buildbot, Trac is a simpler web-­
based software project manage­
ment system that can track issues and bugs. It requires access to a database 
such as SQLite or MySQL. Trac is hosted at https://​
trac​
.edgewall​
.org/, but 

the latest release can be found at https://​
pypi​
.org/​
project/​
Trac/.
ROUNDUP
Compared to Trac, Roundup is an even simpler tool to track issues in a software 
development project. You can do so via the command line, the web, or email. 
The system can be found at https://​
pypi​
.org/​
project/​
roundup/.
1.6 Getting a Taste of Programming with Python
In this section, you will see how to solve simple problems or do simple tasks 
with Python. At this time, you do not need to understand every piece of code 
because you will learn all those details later.
Program Interactively with Python Interactive Shell
Programming for computers is writing instructions for computers to execute. 
Interactive programming is programming in an environment in which you 
can interact with a computer, the interpreter of the programming language, 
more precisely, instruction by instruction. The opposite of interactive pro­
gramming is batch programming, in which you will need to write a complete 
program and then feed the entire program to a language engine such as an 
interpreter, language runtime, or virtual machine in order to execute it. In 
interactive programming, a piece can be a single statement or a group of 
statements, but not a complete program. One of the advantages of inter­
active programming is immediate feedback on the code pieces from the 

interpreter.
The simplest interactive programming environment for Python is the Python 
interactive shell. It can be quickly started by running command Python at a 
command prompt such as within a Windows PowerShell, as shown here:
PS S:\Dev> python
	
Introduction	
29
 https://doi.org/10.15215/remix/9781998944088.01
The started interactive Python programming environment should look 
like this:
PS S:\Dev> python
Python 3.11.1 (tags/v3.11.1:a7a450f, Dec 6 2022, 
19:50:39) [M.06 v.1934 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more 
information.
>>>
Here, >>> is the prompt of the Python interactive shell, waiting for your 
input, which will then be evaluated by the interpreter. This is how you program 
interactively within this environment.
As the de facto standard, our first program in the interactive Python pro­
gramming environment is to say “Hello World!” as shown here:
PS S:\Dev> python
Python 3.11.1 (tags/v3.11.1:a7a450f, Dec 6 2022, 
19:58:39) [MSC v.1934 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more 
information.
>>> print("Hello World!")
Hello World!
>>>
As can be seen above, this program in Python needs only one statement 
made of one line of code, whereas in C/C++ or Java, it would need a dozen 
lines of code.
Please note that in the previous example, the characters behind the Python 
prompt >>> are Python statements you need to type, and the rest are output 
from Python interpreter or Python Virtual Machine (PVM).
Our next sample program within the Python interactive shell is to assign 
8 to variable x and assign 9 to variable y, then print out the sum of x and y, as 
shown here:
PS S:\Dev> python
Python 3.11.1 (tags/v3.11.1:a7a450f, Dec 6 2022, 
19:58:39) [MSC v.1934 64 bit (AMD64)] on win32
Type .help., "copyright", "credits" or "license" for more 
information.
	 30	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> print("Hello World!")
Hello World!
>>> x = 8 # assign 8 to variable x
>>> y = 9 # assign 9 to variable y
>>> print(f'{x} + {y} = {x+y}')
8 + 9 = 17
>>>
Within this interactive programming environment, you can type any Python 
expression directly behind >>>, and it will then be evaluated. An example is 
shown here:
PS S:\Dev> python
Python 3.11.1 (tags/v3.11.1:a7a450f, Dec 6 2022, 
19:58:39) [MSC v.1934 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more 
information.
>>> 1350-­
789*3/26
1258.9615384615386
>>>
You may have realized that the interactive Python programming environ­
ment can be used as a powerful scientific or financial calculator, with all the 
functions you need, as long as you know where to find the functions and how 
to import and use them to write formulas.
Throughout the textbook, we will occasionally give examples in Python 
interactive shell when it is more convenient and proper in context. However, 
our preferred interactive programming environment is Jupyter Notebook within 
VS Code IDE, as you will see later in this section.
Program with VS Code IDE
Interactive programming environments like Python Shell and Jupyter 
Notebook are good for testing Python statements, code blocks, and some 
real programming tasks such as data analytics, where interactive program­
ming is more suitable. However, writing programs that contain thousands 
of lines of code in a Python interactive shell or Jupyter Notebook is 

inconvenient.
As previously mentioned, we will be using VS Code as our IDE. Our first 
small project is to write a program that takes an integer from the user input 
	
Introduction	
31
 https://doi.org/10.15215/remix/9781998944088.01
and tells whether it is a prime number or not. The first step to do this is to start 

VS Code from the Windows Start menu or desktop. In Windows or iOS, you may 
type “VS Code” in the search bar to launch the application.
To create a Python program file within VS Code, choose “New File” from 
File, and then save the file as xyz​
.py, where xyz is your preferred name 
for the small project. Here, we use “primetest​
.py.” VS Code will ask you to 
choose a folder for the program, and you may create one and then select it 
to open after the file is created. The program in VS Code will look like the 
one in Figure 1-­
4.
At this time, you are not required to fully understand the program, but if you 
are interested, you may type the code line by line into your VS Code and run it 
by clicking the play button at the top-­
right corner of the VS Code window, just 
to get a taste of programming in VS Code with Python.
Please note that if you have multiple Python program files open in VS Code 
and want to run a particular one within the IDE, you will need to click the 
file to make it active; then, within the editing area, click the right button of 

the mouse to pop up a menu and select run for your particular program. This 
is even more important if you have multiple editing tabs open for different 
programs.
Figure 1-­
4: Python program in VS Code
	 32	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Use Jupyter Notebook Within VS Code to Program Interactively
You may recall that Jupyter Notebook can be launched and run in a web browser, 
but for the purposes of this text, Jupyter Notebook will be run and used within 
VS Code to program interactively to allow you to benefit from many of the 
features that VS Code has.
Because Jupyter Notebook is natively supported within Visual Studio Code 
(as long as Jupyter Notebook is installed in your Python environment), all you 
need to do to get Jupyter Notebook running within VS Code is to open or create 
a notebook file, with extension ipynb in VS Code.
There are two ways to create a Jupyter Notebook file. One is to press 
Ctrl+Shift+P to search for the command “create new blank Jupyter Notebook,” 
then click the command. A new blank Jupyter Notebook will be created within 
VS Code.
Alternatively, we can also simply create a new text file, and then save the 
file as xyz.ipynb, where xyz is a name you prefer and ipynb is the file’s exten­
sion. Please note that to ensure the file type is ipynb, you have to select Jupyter 
(.ipynb) or all files (*.*) from the “Save as Type” list.
In either case, you may be asked to install an extension for Jupyter Notebook 
support. Click yes when you are asked to. You may also be asked to install Python 
if you have not done so yet or if the installation path has not been added to the 
environment variable. Click yes too to make sure you have Python properly 
installed on your computer.
Once a new Jupyter Notebook is created, you can then use it to program 
interactively within VS Code and enjoy many of the smart features of VS Code, 
such as those offered by IntelliCode.
Another advantage of using Jupyter Notebook within VS Code is that you 
can export a notebook as an HTML, PDF, or Python Script file. If you use Mark­
down cells to document your coding in code cells, you can produce a very nice 
document as a PDF or in HTML.
Later on, you will be required to create a Jupyter Notebook for each chapter or 
section, if there are many coding examples to work on in a section. You will use 
the Jupyter Notebook to interactively program all sample codes in that chapter 
or section or to test your own code to reinforce your learning. For chapter x, 
the Jupyter Notebook should be named chapter-­
x.ipynb, and for section x.y, the 
notebook should be named section-­
x.y.ipynb.
In the next section, we will provide a brief introduction to Markdown lan­
guage that you can use to document your work either within Markdown cells of 
Jupyter Notebook or within a Markdown file, a file with md as the file extension.
	
Introduction	
33
 https://doi.org/10.15215/remix/9781998944088.01
Write Documentation in Markdown
Markdown is a simple and straightforward markup language with a plaintext-­
formatting syntax. It was created by John Gruber and Aaron Swartz in 2004. 
With Markdown, you can write a document in an easy-­
to-­
write and easy-­
to-­
read 
format, then convert it to HTML. Within VS Code IDE, a Markdown file, with 
md as the extension, can be converted to PDF as well as HTML. Moreover, 
documentation written in Markdown cells of a Jupyter Notebook can be auto­
matically converted into docstrings when the Jupyter Notebook is exported 
into a Python script file, and when the notebook is exported into PDF, scripts 
in code cells will be nicely embedded into documentation written in Mark­
down cells. Together with markup syntax for program code, Markdown cells 

within Jupyter Notebook running in VS Code provide a much more user-­
friendly 
way to include program code in rich and formatted documents.
The Markdown language has been extended since its initial release by John 
Gruber. You will be introduced to both the basic syntax and some extended 
syntax (but only those supported by Jupyter Notebook within VS Code) to serve 
our purposes in this book.
HEADINGS
In Markdown documents, headings are simply led by one or more hash symbols. 
As we have seen in previous sections, a Level 1 heading is led by a single hash 
symbol, a Level 2 heading is led by two hash symbols, and a Level 3 heading 
is led by three hash symbols. You can have up to six levels of headings in a 
document, as shown below:
# This is a Level 1 heading
This is a Level 1 heading
## This is a Level 2 heading
This is a Level 2 heading
### This is a Level 3 heading
This is a Level 3 heading
#### This is a Level 4 heading
This is a Level 4 heading
##### This is a Level 5 heading
This is a Level 5 heading
	 34	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
###### This is a Level 6 heading
This is a Level 6 heading
Please note the space between the formatting symbol or symbols and the text to 
be formatted. A single space should be placed between the formatting symbol 
and the text being formatted in Markdown.
PARAGRAPHS
In Markdown, paragraphs are separated with one or more blank lines.
This is a paragraph.
This is another paragraph.
This is a paragraph.
This is another paragraph.
NEW LINES
In Markdown, to break a line like you would with <br/> in HTML, use more 
than one single space to break the line.
This line will break.  This line starts on a new line.
This line will break.
This line starts on a new line.
ITALIC, BOLD, AND STRIKETHROUGH TEXTS
To format text to be italic in Markdown, simply lead it with a * or underscore 
_ and use another * or _ to indicate the end of the text; to make text bold, use 
** or __; to make text both bold and italic, use ***; to have a line strikethrough 
the text, use ~~. The following are examples:
_ Italic_
Italic
** Bold **
Bold
	
Introduction	
35
 https://doi.org/10.15215/remix/9781998944088.01
*** both italic and bold ***
Italic and bold
~~ strikethrough ~~
Strikethrough
HORIZONTAL RULES
To add a horizontal line within a document, like <hr /> in HTML, use three 
hyphens -­
-­
-­
. Most of the time, this has the same effect in Word.
-­
-­
-­
KEYBOARD KEYS
In computing documentation, we often need to explain what key is used on the 
keyboard. To represent a key on the keyboard, we use HTML kbd tags directly, 
as shown below:
<kbd> Ctrl </kbd> <kbd> A </kbd>
Ctrl+A
<kbd> Ctrl+Shift+F3 </kbd>
Ctrl+Shift+F3
UNORDERED LISTS
With Markdown, writing an unordered list is rather straightforward, as shown 
below:
* first list item
* second list item
 * first item of sublist
 * second item of sublist
* third list item
The rendered result will be the following:
	 36	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
	 •	 first list item
	 •	 second list item
	 -­
	first item of sublist
	 -­
	second item of sublist
	 •	 third list item
We can also use -­
 in place of *.
ORDERED LISTS
To write an ordered list in Markdown is straightforward too, as shown below:
1. first list item
2. second list item
 * first item of sublist
 * second item of sublist
3. third list item
The rendered result will be
	
1.	 first list item
	
2.	 second list item
	
-­
	 first item of sublist
	
-­
	 second item of sublist
	
3.	 third list item
DEFINITION LISTS
The simple Markdown syntax for a definition list does not work in Jupyter 
Notebook within VS Code. However, we can use HTML <dl> tags directly to 
make such a list, as shown below:
<dl>
<dt> Python </dt>
<dd> It is a popular programming language, widely used in 
AI and Data Science. </dd>
<dt> AI </dt>
<dd> Short for Artificial Intelligence.
It is the study of how to design and develop smart 
artifacts.</dd>
</dl>
	
Introduction	
37
 https://doi.org/10.15215/remix/9781998944088.01
The rendered result will be:
Python
It is a popular programming language, widely used in AI and Data 
Science.
AI
Short for Artificial Intelligence. It is the study of how to design and 
develop smart artifacts.
LINKS
To add a link with Markdown, put the anchor name in a square bracket, and 
put the URL in a pair of parentheses, as shown below:
[Markdown Home]​
(https://​
www​
.markdownguide​
.org/)
The rendered result will be the following text, which will take the user to 
https://​
www​
.markdownguide​
.org/ when clicked:
Markdown Home
As in Word and some other editors, legitimate URLs are usually automatically 
linked without any markup tags. In Markdown, if you don’t want a URL to be 
automatically linked, you can enclose it with a pair of backticks, just treating 
it as program code, as shown below:
`https://​
www​
.markdownguide​
.org/`
LINKS TO INTERNAL SECTIONS
A specific ID can be added to each header. Such IDs can be used as internal 
anchors in a link, as shown below:
[Assignment 1] (#assignment_1)
Assignment 1
	 38	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
IMAGES
To add an image to your documentation, use a syntax similar to that used for 
adding links, but with an exclamation mark at the front of the open square 
bracket, as shown below:
![Markdown logo](AU_and_50_logo.png)
The image will be rendered as
BLOCKQUOTES
To include a blockquote in your documentation, use an angle bracket at the 
start of each line, as shown in the following example:
> COVID-­
19 UPDATES
>
> EXAMS
>
> HELP & SUPPORT
>
> FACULTY OF BUSINESS STUDENTS
>
> FACULTY OF SCIENCE STUDENTS
COVID-­
19 UPDATES
EXAMS
HELP & SUPPORT
FACULTY OF BUSINESS STUDENTS
FACULTY OF SCIENCE STUDENTS
	
Introduction	
39
 https://doi.org/10.15215/remix/9781998944088.01
TABLES
To create a table in Markdown, use the pipe character | to divide columns and a 
sequence of dashes/hyphens to separate the header of a table, as shown below:
    | Markdown symbol | Description | HTML equivalent  |
 
    | :-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
| :-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
: | -­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
: |
 
    | # | Level 1 heading | h1 |
 
    | ## | Level 2 heading | h2 |
The table will be rendered as
Markdown symbol
Description
HTML equivalent
#
Level 1 heading
h1
##
Level 2 heading
h2
Please note the colons used in the formatting syntax. A single colon to the 
left of dashes means to align all the text in the column to the left, a single colon 
to the right of dashes means to align all the text in the column to the right, and 
adding a colon to both sides means to align the text at centre. You can also use 
other Markdown syntax on the text in the table, such as italic, bold, and so on.
INLINE PROGRAM / SCRIPT CODE
When writing a report on a software project, you may need to include code 
samples in the report. To include a code sample within a single sentence, 
enclose the code within a pair of backticks `, as shown below:
The ` range(start, end, step) ` function is used to 
produce a sequence of integer numbers.
The rendered result will be:
The range(start, end, step) function is used to produce a sequence of 
integer numbers.
	 40	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
CODE BLOCK
In Markdown, a block of program code can be marked up using a pair of triple 
backticks ```, as shown below:
```Python
for i in range(1, 10):
for j in range(1, i + 1):
print(f'{i} * {j} = {i * k}')
```
The rendered result will be:
for i in range(1, 10):
  for j in range(1, i + 1):
    print(f'{i} * {j} = {i * k}')
Please note that the name of the programming language right behind the 
opening triple backticks is optional, though with the name, the code will be 
automatically highlighted in a way specific for the language.
MATHEMATICAL FORMULAS AND EXPRESSIONS
With Markdown in Jupyter Notebook, you can embed LaTeX representation 
mathematical formulas directly within your text. LaTeX is a typesetting system 
used for scientific publications. It would take you some time to learn the com­
plete system. The following examples show you how to represent mathematical 
formulas in your documentation.
1.  $\hat{Y} = \hat{\beta}_{0} + \sum \limits _{j=1} ^{p} 
X_{j}\hat{\beta}_{j} $
2.  $\frac{n!}{k!(n-­
k)!}$
3.  $\binom{n}{k}$
4.  $\frac{\frac{x}{1}}{x -­
 y}$
5.  $\sqrt{k}$
6.  $\sqrt[n]{k}$
7.  $\sum_{i = 1}^{10} t_i$
8.  $\int_0^\infty \mathrm{e}^{-­
x},\mathrm{d}x$
9.  $f(x) = x^2 + 2, if\ x = 2$
10. $\oint_C x^3\, dx + 4y^2\, dy$
11. $2 = \left(
\frac{\left(3 -­
 x\right) \times 2}{3 -­
 x}
	
Introduction	
41
 https://doi.org/10.15215/remix/9781998944088.01
\right)$
12. $\sum_{m = 1}^\infty\sum_{n = 1}^\infty\frac{m^2\, n}
{3^m\left(m\, 3^n + n\, 3^m\right)}$
13. $\phi_n(\kappa) =
\frac{1}{4\pi^2\kappa^2} \int_0^\infty
\frac{\sin(\kappa R)}{\kappa R}
\frac{\partial}{\partial R}
\left[R^2\frac{\partial D_n(R)}{\partial R}\right]\,dR$
The rendered result of the above Markdown code is shown in Figure 1-­
5. You 
can get the same result if you export the notebook file to PDF or HTML format.
Figure 1-­
5: Rendered result of the Markdown code
	 42	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
TO-­
DO LIST
You may wish to have a to-­
do list in your learning notebook. With Markdown, you 
can get that accomplished as follows:
-­
 [ ] a bigger project
 -­
 [x] first subtask
 -­
 [x] follow-­
up subtask
 -­
 [ ] final subtask
-­
 [ ] a separate task
The rendered result will look like this:
•	 ☐ a bigger project
–­
	 ☑ first subtask
–­
	 ☑ follow-­
up subtask
–­
	 ☐ final subtask
•	 ☐ a separate task
ESCAPE SEQUENCE FOR SPECIAL CHARACTERS
Because, as we have seen, some characters have special meaning in Mark­
down syntax, we need to use the backslash to allow these characters to keep 
their normal meaning. These characters include the backslash \, backtick `, 

asterisk *, underscore _, the pound hash symbol #, plus sign +, hyphen/
dash -­
, period ., and exclamation mark !, as well as curly braces {}, square 
brackets [], and parentheses (). For example, if we want to have * in our 
documentation, we need to use \* instead of a simple *. This is especially 
necessary since confusion may arise from using these symbols without the 
backslash. Otherwise, you can use a special character directly, such as in 
the following example:
# A heading with a plus sign \+
This will be rendered as:
A heading with a plus sign +
Programming Interactively with Jupyter Notebook Within 
VS Code
Earlier in this section, we learned how to program interactively within a 
Python Shell launched within a CMD or PowerShell window, and how to 
	
Introduction	
43
 https://doi.org/10.15215/remix/9781998944088.01
start Jupyter Notebook within VS Code. In this section, we will find out how 
to use Jupyter Notebook within VS Code to program interactively as well as 
how to document your work and learning journey in both code cells and 
Markdown cells of Jupyter Notebook within VS Code.
Compared to the Python interactive shell, Jupyter Notebook is a much 
better and more powerful environment for interactive programming and has 
the following advantages:
	
1.	 Everything you typed and the output from the Python interpreter are 
kept in a notebook file so that you can go back and review your work 
whenever needed. In the Python interactive shell, however, everything 
within the shell will be lost as soon as you exit from it.
	
2.	 Within a programming cell of Jupyter Notebook, you can write and 
edit as many Python statements as you want, and the interpreter 
will wait until you hit Shift+Enter to run all the statements within 
the active cell, whereas the simplest interactive programming 
environments run only one statement at a time.
	
3.	 You can go back to a previous programming cell and edit the code 
in it, and then rerun the code as you wish, which you cannot do in a 
Python Shell.
Again, our first example to program interactively in Jupyter Notebook is to 
say Hello World! But before we begin, we need to create a new Jupyter Note­
book named section-­
1.6.ipynb for this section. If you are using this book for 
a course, we recommend that on your desktop, you create a folder using the 
course name or number, and then create this and all the Jupyter Notebook files 
within this folder or subfolders to better organize all the files for the course. 
For the purposes of this textbook, we will give this folder the name “comp218.” 

In the example shown here, the notebook file section-­
1.6.ipynb is under a 
subfolder named “VS Code.”
With Jupyter Notebook in VS Code, you can use Markdown cells to present 
your ideas and thoughts about the program you are to write, and use code cells 
to write program code and Python documentation on your code. In this first 
example, we first write the following in a Markdown cell:
# First program in Jupyter Notebook within VS Code
As is tradition in teaching computer programming, our 
first program in Jupyter Notebook is to say Hello World!.
	 44	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
## How to start a program
As always, a program should begin with a brief 
description of the program, including what it does, 
who wrote it and when, and how it works and/or should 
be used. This is especially necessary for independent 
program files such as the Python script files you will 
be developing using VS Code IDE. Within a code cell of 
Jupyter Notebook, brief documentation is still needed 
if the code within the cell is complicated either 
grammatically or logically. You do not need to document 
if the code is only a scribble for testing.
In Python, brief documentation at the beginning of a 
program file is enclosed with a pair of triple single/
double quotation marks, such as
"""
brief documentation
"""
or
'''
brief documentation
'''
This is called a docstring. Different from comments made 
on program code using a single hash symbol #, docstrings 
are meant to be formal documentation of the code that can 
be retrieved from an object.
We then write the following in a code cell:
    """
    This simple program is just to say Hello world!
    Everything between the two triple quotation marks is
    treated as documentation about the program.
    """
 
    print('Hello world!')   # a single statement of the 
program -­
 inline comment
	
Introduction	
45
 https://doi.org/10.15215/remix/9781998944088.01
This results in the notebook printing, outside of the code cell, the following:
Hello world!
In Jupyter Notebook, there are two types of cells for input. One is the code 
cell for you to write actual program code in. The other is the Markdown cell for 
you to write more detailed notes or reports about your work within the notebook 
using the Markdown language we have introduced in the previous section.
When a new cell is created in a Jupyter Notebook within VS Code, by click­
ing the plus sign + on the left side of the notebook window, you will get a code 
cell by default. To change a code cell to a Markdown cell, click the M↓ button 
at the top of the cell; to change a Markdown cell back to code cell, click the {} 
button at the top of the cell.
Please note that when using Jupyter Notebook within a web browser, to 
switch a code cell to Markdown cell you will need to click “Code” at the top of 
the cell, and then choose “Markdown” from the pop-­
up menu.
In the Jupyter Notebook example above, two cells are used. The first is a 
Markdown cell, in which we explain in more detail what we are going to do for 
our first Python program and how we will do it, whereas the second cell is a 
code cell, in which actual Python code is written, together with docstring and 
inline comments, for the program.
In the simple program above, a pair of triple quotation marks is used to 
enclose some string literals, called docstrings, as the formal documentation 
for the program or module. In addition to each program file or each module 
file, a docstring is also recommended, and even required, for each func­
tion, class, and method. Docstrings should be placed at the very beginning 
of a program file, module file, or right after the header of the definition of 

a class, function, or method. The docstrings will be retrieved and stored as 
the __doc__ attribute of that respective object and can be displayed when help 
is called on that object. Python also has a utility program called pydoc that 
can be used to generate documentation from Python modules by retrieving 
all the docstrings.
Right after the docstring is a print statement that will print out Hello World! 
when the program is executed by pressing Shift+Enter while the cell is still 
active. A cell is active if there is a vertical blue bar on the left side of the cell. 
To execute statements inside an active cell, we can also click the play button 
(the thick right-­
facing arrow) at the top of the cell.
Our next sample program is to assign integers to two variables and then print 
the sum, difference, product, quotient, integer quotient, remainder, power, and 
root. The Python statements to accomplish these operations are as follows:
	 46	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
#Operators and expressions in Python
In the next cell we will show the use of operators and 
expressions in Python.
#Operators
+ operator for addition
-­
 operator for subtraction
* operator for multiplication
/ operator for division
% operator for modulus
** operator for exponentiation
// operator for floor division
We then write the following in a code cell:
i = 5 # assign 5 to variable i. Everything behind the 
hash mark is comment
j = 3 # assign 3 to variable j
print(f"{i} + {j} = {i + j}") # print i + j
print(f"{i} -­
 {j} = {i -­
 j}") # print i -­
 j
print(f"{i} x {j} = {i * j}") # print i * j
print(f"{i} / {j} = {i / j}") # print i / j (/ is division)
print(f"{i} // {j} = {i // j}") # print i // j (// is 
quotient)
print(f"{i} % {j} = {i % j}") # print i % j (% is modulus)
print(f"{i} ** {j} = {i ** j}") # print the result of i 
power of j
print(f"root {j} of {i} = {i ** (1/j)}") # print the 
result of root j of i
This prints the following:
5 + 3 = 8
5 − 3 = 2
5 x 3 = 15
5 / 3 = 1.6666666666666667
5 // 3 = 1
5 % 3 = 2
5 ** 3 = 125
root 3 of 5 = 1.7099759466766968
	
Introduction	
47
 https://doi.org/10.15215/remix/9781998944088.01
As you can see, in this interactive programming environment, you can write 
and edit many Python statements within a single cell. You may simply write some 
statements to accomplish certain calculation or data analysis tasks that cannot 
be done even on an advanced scientific finance calculator.
This next example in Jupyter Notebook within VS Code calculates the sum 
and the product of 1, 2, 3, … 100:
"""
This is to calculate the sum of 1,2,…,100.
"""
 
s=0
for i in range(100):
    s+=i+1
print(f"Sum of 1,2…,100 is {s})
 
"""
This is to calculate the product of 1,2,…,100
"""
 
p=1
for i in range(100):
    p*=i+1
print(f"The product of 1,2,…,100 is {p}")
This prints the following:
Sum of 1,2,…,100 is 5050
The product of 1,2,…,100 is 9332621544394415268169923885626670
049071596826438162146859296389521759999322991560894146
397615651828625369792082722375825118521091686400000000
0000000000000000
Our next sample program in Jupyter Notebook within VS Code creates a 
simple data visualization to showcase how Python can be used for that purpose.
The data for x-axis are a list of letter grade in a grading system; the data for 
y-axis contain a list of numbers representing how many students received each 
corresponding grade in a class. The purpose of visualization is to see how the 
grades are distributed within the class.
	 48	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
import matplotlib.pyplot as plt
 
x = ['D','C-','C','C+','B-','B','B+','A','A','A+']
y = [6,9,12,19,23,28,15,13,7,5]
plt.bar(x,y)
plt.title('A showcase')
plt.xlabel('Letter Grade')
plt.ylabel('# of Students')
plt.show()
Here we use a module called Matplotlib to visualize the data by plotting 
graphs. The result of the program as shown in Figure 1-­
6.
D
C-
C
C+
B-
B
B+
A
A+
0
5
10
15
20
25
Letter Grade
A Showcase
 # of students
Figure 1-­
6: Graph produced by a Python script in Jupyter Notebook
As you can see, with only 11 lines of code, you can produce a nice graph to 
visualize the data in Python.
Run Python Programs Outside IDE
The VS Code IDE we used in previous sections is good for developing programs 
or applications, but it is impractical to start an IDE each time you need to run 
a Python program.
So how can we run a Python program or scripts stored in a file? In a previous 
section, we wrote a program called primetest​
.py. To run the program without 
invoking VS Code, we need to take the following steps:
	
1.	 Start Windows PowerShell or Windows Command Prompt by typing 
“terminal” in the search field on the Windows taskbar if you are on 
	
Introduction	
49
 https://doi.org/10.15215/remix/9781998944088.01
other platforms such as Linux. A shell terminal will come up; type the 
following:
PS S:\Dev\Learn_Python>
	
2.	 Within the terminal, go to the directory where the Python program 
file is located.
	
3.	 Change the working directory to that folder by typing the following 
PowerShell command:
cd  S:\Dev\Learn_Python\samples\
	
4.	 Run the Python program file by typing the following command at the 
PowerShell prompt:
python .\primetest​
.py
the result is shown below:
PS S:\Dev\Learn_Python> cd .\samples\
PS S:\Dev\Learn_Python\samples> python .\primetest​
.py
give me an integer that is greater then 1, and I 
will tell you if it is a prime: 23
23 is a prime
PS S:\Dev\Learn_Python\samples>
Note that to run a Python program from a terminal, two conditions must be met: 
(1) The location of the Python interpreter (python.exe) must be in the PATH 
system variable, so that Windows is able to find it. (2) The Python program 
file should be in the current working directory of the terminal. If that is not 
the case, you must either change your current working directory to where the 
Python program file is located or specify the path to the program file. Assume 
we change the current working directory from the one shown at the end of 

the list above to the one shown here using the command cd:
PS S:\Dev\Learn_Python>
	 50	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Because now the primetest​
.py program is one-­
level down from the cur­
rent working directory at .\samples, where the leading dot (.) refers to the 
current directory, to run the program, you will have to specify the path to 
the program, as shown here:
PS S:\Dev\Learn_Python> python .\samples\primetest​
.py
give me an integer that is greater than 1, and I will 
tell you if it is a prime: 91
91 is divisible by 7, so that 91 is not a prime
PS S:\Dev\Learn_Python> python .\semples\primetest​
.py
give me an integer that is greater than 1, and I will 
tell you if it is a prime: 23
23 is a prime
PS S:\Dev\Learn_Python>
Make the Python Program File Executable
Sometimes, we may still consider it inconvenient to run a Python program file 
from a terminal by feeding the file to the Python interpreter and rather prefer to 
make the program executable on its own so that it can be run by clicking the file 
within Windows File Explorer. Luckily, a tool called pyinstaller can be installed 
and used to do that. To install it, you need to run PowerShell or another shell 
terminal as an administrator. Within the terminal, run the command shown 
here to install pyinstaller using the pip tool:
PS S:\Dev\Learn_Python> pip install pyinstaller
Requirement already satisfied: pyinstaller in s:\python\
python311\lib\site-­
packages (5.7.0)
Requirement already satisfied: setuptools>=42.0.0 in s:\
python\python311\lib\site-­
packages (from pyinstaller) 
(67.4.0)
Requirement already satisfied: altgraph in s:\python\
python311\lib\site-­
packages (from pyinstaller) (0.17.3)
Requirement already satisfied: pyinstaller-­
hooks-­
contrib>=2021.4 in s:\python\python311\lib\site-­
packages 
(from pyinstaller) (2022.15)
Requirement already satisfied: pefile>=2022.5.30 in s:\
python\python311\lib\site-­
packages (from pyinstaller) 
(2023.2.7)
	
Introduction	
51
 https://doi.org/10.15215/remix/9781998944088.01
Requirement already satisfied: pywin32-­
ctypes>=0.2.0 in 
s:\python\python311\lib\site-­
packages (from pyinstaller) 
(0.2.0)
PS S:\Dev\Learn_Python>
Before you can use the pyinstaller tool to make the conversion, you will 
need to copy the Python library into Windows’ system32 directory, as shown 
below:
PS C:\WINDOWS\system32> cp S:\Python\Python311\python311.
dll .
PS C:\WINDOWS\system32>
Now you can simply run the command pyinstaller <Python program file 
name> to make the conversion, as shown here.
PS S:\Dev\Learn_Python\samples> pyinstaller 
.\primetest​
.py
1435 INFO: PyInstaller: 5.7.0
1435 INFO: Python: 3.11.1
1445 INFO: Platform: Windows-­
10-­
10.0.22621-­
SPO
1445 INFO: wrote S:\Dev\Learn_Python\samples\primetest.
spec
1460 INFO: UPX is not available.
1460 INFO: Extending PYTHONPATH with paths ['S:\\Dev\\\
Learn_Python\\samples']
pygame 2.3.0 (SDL 2.24.2, Python 3.11.1)
Hello from the pygame community. https://​
www​
.pygame​
.org/​
contribute​
.html
5243 INFO: checking Analysis
5254 INFO: Building because inputs changed
5254 INFO: Initializing module dependency graph…
5254 INFO: Caching module graph hooks…
5285 WARNING: Several hooks defined for module 'numpy'.
The created executable is under .\build\primetest, named primetest.exe.
Please note, however, that the executable file requires the Python DLL 
library in order to run, so that you can either (1) make the DLL library 
searchable and accessible by Windows OS or whatever OS you are using, 
if you have many executables generated from Python program files, or 

	 52	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
(2) copy the Python DLL to where the executable file is located. In this case, 
since we are using Python3.11, the library is named python311.dll—­
which is 
located within the installation directory of Python3.11, which is s:\python\
python311—­
we can simply copy the DLL file to .\build\primetest for a test, 
as shown below:
-­
a-­
-­
-­
    2022-­
12-­
06  8:12 PM        1463681    NEWS.txt
-­
a-­
-­
-­
    2022-­
12-­
06  8:10 PM         101752    python.exe
-­
a-­
-­
-­
    2022-­
12-­
06  8:10 PM          65912    python3.dll
-­
a-­
-­
-­
    2022-­
12-­
06  8:10 PM        5761912    python311.dll
-­
a-­
-­
-­
    2022-­
12-­
06  8:10 PM         100216    pythonw.exe
-­
a-­
-­
-­
    2022-­
12-­
06  8:10 PM
         49488    vcruntime140_1.dll
-­
a-­
-­
-­
    2022-­
12-­
06  8:10 PM
         109392    vcruntime140_1.dll
 
PS S:\Dev\Learn_Python\samples> cp S:\Python\Python311\
python3.dll .\build\primetest\
PS S:\Dev\Learn_Python\samples>
Once you have done all the steps above, you can run the program like all 
other apps on your computer, as shown here:
PS S:\Dev\Learn_Python\samples> .\build\primetest\
primetest.exe
give me an integer that is greater than 1, and I will 
tell you if it is a prime: 31
31 is a prime
PS S:\Dev\Learn_Python\samples>
Errors in Programs
Errors in programs are hardly avoidable, and you should be prepared to see 
a lot of errors in your programs, especially at the beginning. The nice thing 
about programming within an IDE such as Visual Studio Code is that the IDE can 
point out many syntax errors and coach you to code along the way by showing 
you a list of allowable words or statements that you may want to use in that 
context, although you will have to decide which one to use for your program 
by highlighting the words that are problematic.
	
Introduction	
53
 https://doi.org/10.15215/remix/9781998944088.01
Syntax errors often include the following:
	
1.	 Missing, misspelled, or misplaced keywords such as for, while, if, 
elif, else, with, class, def, and so on. Remember that Python language 
is case-­
sensitive so for and For are totally different words to Python 
Virtual Machine (PVM).
	
2.	 Missing or misspelled operators such as >=, <=, +=, -­
=, *=, /=, and 
so on.
	
3.	 Missing symbols, such as a colon, comma, square or curly bracket, or 
parenthesis.
	
4.	 Mismatched parentheses, double quotation marks, single quotation 
marks, curly brackets, and square brackets.
	
5.	 Incorrect indentation because Python uses indentation to form code 
blocks.
	
6.	 Empty code blocks. If you do not know what to write in a code block, 
you can simply use a pass statement as a placeholder, as shown in the 
following examples.
"""
This function will find the best student in a class based 
on their over performance, but at this time we don't know 
how.
"""
 
def findBest():
 pass   # the pass statement is used to hold the place 
for a code block
The second type of errors you may encounter are runtime errors. While syntax 
errors may be easily avoided when programming within VS Code IDE, run­
time errors can only be found during runtime. Examples of runtime errors 

include dividing a number with 0 and using a variable that has not been 
defined or that has no value before it is used. The discussion of error and 
exception handling, covered in Chapter 4, is mostly about runtime errors.
The following are some common runtime errors in Python programs:
	
1.	 ZeroDivisionError, when dividing something by 0.
	
2.	 TypeError, when an operation is performed on incompatible data 
types.
	 54	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
	
3.	 ValueError, when an incorrect value is used in a function call or 
expression.
	
4.	 NameError, when an identifier is used that has not been defined. In 
Python, define means that it has been assigned a value, even if the 
value is None.
	
5.	 IndexError, when the index used to access a sequence is out of 
boundary.
	
6.	 KeyError, when an incorrect key is used to access a dictionary value.
	
7.	 AttributeError, when an object attribute is sued that does not exist.
	
8.	 FileNotFoundError, when a file that one is trying to open to read 
does not exist. It is OK to open a file to write that does not exist. The 
operation will create a new file in that case.
In addition to syntax and runtime errors, you can also have logical errors in 
your programs. These errors can be found only by you or users of the program. 
An example of logical errors is when you are supposed to add two numbers, 
but you subtract one from the other instead.
Throughout the text, you will learn and gradually gain the ability to make 
your programs logically correct and to identify logical errors in your programs.
1.7 Essentials of Problem Solving and Software 
Development
Before you learn how to program in Python, you need to gain a basic under­
standing of the steps taken by computers to solve a problem and the steps taken 
by programmers to develop a software system for real-­
world application. The 
former, steps taken by computers to solve a problem, is called an algorithm. 
The latter, steps taken by programmers to develop an information system for 
real-­
world application, is in the area of system analysis and design.
Design Algorithms to Solve Problems
An algorithm is a sequence of instructions showing steps to solve a problem or 
get something done. The recipe for cooking a dish is an example of an algorithm 
from our everyday lives. Unlike algorithms for people to follow, algorithms for 
computers must show definitive steps of explicit operation.
Consider a very simple task for a computer to complete: give a computer 
two numbers and ask the computer to find the sum and print out the result. 
The algorithm can be described as follows:
	
Introduction	
55
 https://doi.org/10.15215/remix/9781998944088.01
[algorithm 1] Get two numbers from user, calculate, and print out 
the sum.
Step 1. Get the first number to n1.
Step 2. Get the second number to n2.
Step 3. Calculate the sum of n1 and n2, and store the result to s.
Step 4. Print out s.
[end of algorithm 1]
Describing the steps of operations as shown above is just one way to present 
algorithms. In computing and software development, algorithms can also be, 
and more often are, presented using pseudocode or a flowchart.
Pseudocode is a language that is easier for humans to understand but that 
is written like a computer program. There is no widely standard vocabulary 
and grammar for pseudocode. However, within an organization or even a 
class, the same pseudocode language should be used for collaboration and 
communication.
The above algorithm can be described in pseudocode as follows:
Start
Input from user → n1 # get an input from user and 
assign it to n1
Input from user → n2 # get another input from user 
and assign it to n2
n1 + n2 → s # n1 + n2 and assign the sum to s
print(s)
End
This simple algorithm can also be described using a flowchart, as in Figure 1-­
7.
In problem solving and computing, conditional operations and repetitive 
operations are often needed. An example is to calculate the sum of number 1, 

2,…10000. One might think that the sum could be calculated by writing 

1 + 2 + 3 + … + 10000, but that is wrong because that mathematical expression 
cannot be precisely understood by computers. The correct algorithm should be:
[algorithm 2] Calculate the sum of all positive integers that are no 
greater than 10000.
Step 1. 1 → i, 0 → s
Step 2. s + i → s, i +1 → i
Step 3. If i <= 10000 go to step 2 # loop back and make repetition 
under condition
	 56	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Step 4. Print s
[end of algorithm 2]
In pseudocode, the algorithm can be described as follows:
Start
Initialization: i = 1, s = 0
Repeat
   s = s + i
   i = i + 1
Until i > 10000
End
The algorithm can be depicted using a flowchart, as in Figure 1-­
8.
When programming to solve a problem, first develop an algorithm describ­
ing the steps of how the problem can be solved using computers, even if it is 
not explicitly and formally formulated as above.
Phases of Software System Development
Algorithm design and representation are essential when programming for 
computers to solve a problem or complete a task, but it is only part of software 
Start
Input n1
Input n2
S = n1 + n2
Print s
Stop
Figure 1-­
7: Flowchart of a simple algorithm
	
Introduction	
57
 https://doi.org/10.15215/remix/9781998944088.01
system development. Developing a software system to satisfy the requirements 
of a client requires several phases.
PHASE 1. UNDERSTAND THE PROJECT
When developing a software system at the request of a client or customer, the 
first thing to do is to understand what the client really needs so that you can get 
a clear definition of the problems to be solved and the tasks to be completed 
by the software system.
PHASE 2. ANALYZE THE REQUIREMENTS TO IDENTIFY 
COMPUTER-­
SOLVABLE PROBLEMS AND TASKS
This phase is very important in turning people problems into computer problems, 
problems that can be solved by computers. Your clients and customers often have 
limited knowledge of what computers can do, and their requirements may be 
clear for humans, but not directly doable for computers. Requirement analysis 
will turn client’s requirements into problems and tasks suitable for computers to 
solve or complete. This often involves a strategy called divide and conquer, which 
means dividing big problems or tasks into smaller ones to solve. This strategy is 
widely used not only in computing but also in other disciplines and practices. Your 
understanding of the application domain and your knowledge of all aspects of 
computing are very important during this phase of software system development.
Start
i = 1
s = 0
s = s + i
i = i + 1
i <= 10000
Print s
Stop
yes
Figure 1-­
8: Flowchart of an algorithm
	 58	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
PHASE 3. DESIGN THE SYSTEM
System design involves the identification of modules and their connections. 
Module identification can be based on an understanding of the project and 
analysis of the requirements. The problems and tasks identified in phase 2 
should be clustered into different modules of the system, though the same 
problem or task may exist in different modules. The next important thing 
at the system design phase is to design algorithms for each of the identified 
problems and tasks. Your knowledge and skill in system design, problem 
solving, and mathematical and logical thinking play important roles at this 
phase.
PHASE 4. IMPLEMENT THE SYSTEM
System implementation is programming, which turns the algorithms into 
computer programs. Your knowledge of the language chosen to implement 
the system is vital. Implementation involves programming to solve the prob­
lems and complete the tasks identified at phase 2, based on the structure 

of the system and algorithms designed at phase 3, as well as integration of all 
the subsystems and modules to make them work together.
PHASE 5. TEST THE SYSTEM
The system implemented at phase 4 may not correctly reflect what the client 
wants and may have errors and bugs. A thorough test is needed to find the 
bugs and close up the gaps between what has been implemented and what 

the client really wants.
PHASE 6. MAINTAIN THE SYSTEM
After the system has been fully tested and accepted by the client, the system 
will be delivered to the client. But that is not the end of the project. Maintaining 
the system is often an even bigger task after the release and delivery of the 
software because there is no guarantee that all bugs were found during the test, 

no guarantee that the implementation genuinely reflects the needs of the 
client, and no guarantee that the client will not come up with a “better” idea 
or requirements after the fact.
1.8 Manage Your Working Files for Software 
Development Projects
When working on a software development project, you need to deal with many 
files and make many changes to the files. Later, you might realize that some 
changes to a file are incorrect or do not improve the file, so you might want to 
	
Introduction	
59
 https://doi.org/10.15215/remix/9781998944088.01
go back and use a previous version of the file. It may not be a big issue if you 
are only dealing with one or just several files, but it will be very difficult when 
many files are involved in a project. That is why a version-­
control system is 
needed. Use a version-­
control system called Git to manage all your working 
files on the exercises and projects included in this text.
Originally developed by Linus Torvalds, Git is an open-­
source-­
distributed 
version-­
control system for tracking changes in any set of files, including Jupyter 
Notebook files with the extension ipynb.
In this section, you will learn
	
1.	 how to install and set up Git on your computer and use it to version-­
control your project files locally.
	
2.	 how to set up an account at GitHub and version-­
control your project 
files using Git and remote repositories on GitHub.
	
3.	 how to use Git and GitHub within VS Code to version-­
control your 
project files.
Set Up Git on Your Computer and Version-­
Control Locally
Git can be freely downloaded from https://​
git​
-scm​
.com/​
downloads and installed 
on your computer. After installing Git, you can create a local Git repository on 
your computer by running the git init command within a shell window such 
as CMD or PowerShell on Windows. A preferred one is Git-­
Bash shell, which 
comes with Git. It can be started within Windows File Explorer.
For example, if you want to start a project called Learn_Python, you can 
create a folder called Learn_Python on your desktop within Windows File 
Explorer, then right-­
click the folder icon, and choose from the pop-­
up menu. 
A Git-­
Bash window will open with Learn_Python as the current working dir­
ectory, as shown here:
james@trustshop MINGW64 /s/Dev/Learn_Python
$
Within this Git-­
Bash shell window, you can run the following command to 
initialize:
$ git init
You have to run this Git command once to create a local repository for a 
project. It will create an empty Git repository on your local computer, which is 
a directory named .git with specific subdirectories and files that Git will use to 
	 60	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
version-­
control your project files. It will also create a master/main branch for 
the project. Other branches can be created if the project is divided into smaller 
ones to be worked on in parallel and then later merged.
Before running the command, you can set up an environment variable 
called $GIT_DIR to determine where the local repository will be placed on 
your computer. If $GIT_DIR is not set, the local Git repository—­
that is, the 
.git subdirectory—­
will be created right under the current working directory; 
if $GIT_DIR is set in a different location of your choosing, .git will be created 
right under $GIT_DIR. The common location of .git for a project is right under 
the project directory.
For the system to know who has made changes to the files and how to 
communicate with them, the following two commands need to run to config 
the Git that you installed on your computer:
$ git config -­
global user​
.name "Jon Doe"
$ git config -­
global user.email "Jon​
.Doe​
@gmail​
.com"
These commands will configure the user’s name and email address. Please 
keep in mind that this username is different from the username that you will 
use to sign up for your account with GitHub later in this section.
When changes have been made to a file and you want Git to manage the 
changes to the file, the first step is to stage the file by running the following 
command:
$ git add <file/files>
This is called “staging changes to the file,” which is the first step Git takes 
to version-­
control files.
For example, if you want to stage changes to all Python program files under 
the current project directory, run the following command:
$ git add *.py
To stage changes to all files and even subdirectories under the current 
working directory, run the following command:
$ git add .
The next step Git will take to version-­
control your project files is called 
commit. It is done by running the following command:
	
Introduction	
61
 https://doi.org/10.15215/remix/9781998944088.01
$ git commit -­
m "A brief message about this commitment"
Now changes to the files have been committed to the local repository. 
Please note that the stuff inside the quotation marks behind option -­
m are the 
comments or notes about the changes. If you run Git commit without option 
-­
m, a text editor will pop up to let you enter comments.
You can check the status of your Git system by running the following 
command:
$ git status
On branch master
No commits yet
Changes to be committed:
(use "git rm -­
-­
cached <file>…" to unstage)
   new file: start​
.py
This shows that the file start​
.py has been staged but not committed yet. You 
can still use the git rm command to unstage the file (remove it from the staged 
list).
In the above, we basically described a process of making changes to a file, 
staging the files for the changes, and committing the changes to the repository. 
You may, and most likely want to, reverse the process to undo some changes.
To a file that has been staged but not committed, use the following com­
mand to unstage it:
$ git rm -­
cached <file>
or
$ git reset HEAD <file>
To a file that has not been staged, use the following command to discard 
the changes to the file:
$ git checkout -­
-­
 file
To revert a commit that has been made, run the following command:
$ git revert HEAD
	 62	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
To restore a file to one that is n versions back in the master branch of the 
repository, run the following command:
$ git restore -­
source master~n <file>
There are some other Git commands available for various needs of version 
control, and each has many options providing powerful functionalities. A list of 
these commands can be found at https://​
git​
-scm​
.com/​
docs/​
git​
#​
_git​
_commands. 
You can also get the GitHub-­
Git cheat sheet at https://​
training​
.github​
.com/​
downloads/​
github​
-git​
-cheat​
-sheet/.
For Git, files that have been staged or committed for changes are called 
tracked, and those that have not been staged or committed are called untracked. 
In software development, some files, such as those objects and executable 
files derived from code files, do not need to be tracked for changes, so they 
should be ignored by Git. To tell Git what files under a project directory can be 

ignored, especially when running the command to stage all, you can add the 

file names or ignore patterns to a special file called .gitignore right under 

the project directory. You need to manage the list in the .gitignore file by edi­
ting the file using a text editor. Details of ignored file patterns can be found 

from Git documentation at https://​
git​
-scm​
.com/​
docs/​
gitignore. For our pur­
poses, it may be sufficient to just describe the files based on what you already 
know, such as a file name or file names with a wildcard such as *.log.
Note that unlike other version-­
control systems, Git does not work with files 
for different versions, but works only with the changes that led to the current 
version of the file. For each file, Git will only keep one copy of the file for its 
current version in its repository and keep only the changes that led to the cur­
rent version for all older versions.
Set Up an Account on GitHub and Version-­
Control with Remote 
Repositories
With Git, you can also use remote repositories on GitHub, which is a web-­
based 
system that you can use to create, access, and manage your remote repositories 
on a GitHub server. The benefits of working on a remote repository like GitHub 
for a software development project are twofold: the first is that you do not need 
to worry about the possible loss of your computer or the corruption of the file 
system; the second is that a team of programmers can work on a project at the 
same time efficiently and globally.
To use the remote repository on GitHub, first create an account with GitHub​
.com. GitHub offers students use of their repositories free of charge but also 
provides a pack of paid professional tools for software development.
	
Introduction	
63
 https://doi.org/10.15215/remix/9781998944088.01
Once you have signed into GitHub​
.com, you can create a repository for 
each of your projects under your account. Once created, each repository 
will have a unique URL where project files can be synchronized between the 
local repository and the remote repository, which can be cloned/downloaded. 

A repository on GitHub can be either public or private. A private repository can 
be accessed only by the owner, whereas a public repository can be accessed by 
everyone on the internet. Because you will be using the remote repository for 
your assignment projects, you should choose private so that your assignment 
work will not be shared with any others. You can create public repositories for 
projects that are substantially different from projects in the assignments and 
interesting enough for others to collaborate with you on the projects.
Now you know how to create both a local repository and a remote repository, 
and you’ve learned how to use Git commands to move project files to and from 
the local repository.
To continue work on a remote repository for the version-­
control of project 
files, you need to tell the computer where the remote repository is by using 
the following Git command:
$ git remote add <remote repository name> URL
Git supports several network protocols to communicate between your local 
computer and remote repository servers such as GitHub, including SSH and 
HTTPS. Because using SSH requires additional setup on your computer, we rec­
ommend HTTPS. The following is an example of adding the remote repository 
previously created for Jupyter Notebooks to our local notebook repository for 
Jupyter Notebooks:
$ git remote add notebooks https://​
github​
.com/​
jamesatau/​
comp218​
-­
notebooks​
.git
You can also use the following to delete a remote repository:
$ git remote remove <remote repository name>
And you can use
$ git remote rename <remote repository old name> <remote 
repository new name>
to rename a remote repository.
	 64	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
You can also make changes to the URL of an existing repository, as shown 
in the following example:
$ git remote set-­
url origin https://​
github​
.com/​
jamesatau/​
allgitcases​
.git
To view which remote repository is configured for the current project, use 
the following Git command:
$ git remote -­
v
The command below initializes a git repository and adds remote notebooks:
$ git init
Initialized empty Git repository in S:/Dev/Learn_Python/.
git/
 
james@trustshop MINGW64 /s/Dev/Learn_Python (master)
$ git remote add notebooks https://​
github​
.com/​
jamesatau/​
comp218​
-­
notebooks​
.git
 
james@trustshop MINGW64 /s/Dev/Learn_Python (master)
The text below shows a git command to display the remote connections 
configured after running the commands above:
$ git remote -­
v
notebooks   https://​
github​
.com/​
jamesatau/​
comp218​

-­
notebooks​
.git (fetch)
notebooks   https://​
github​
.com/​
jamesatau/​
comp218​

-­
notebooks​
.git (posh)
 
james@trustshop MINGW64 /s/Dev/Learn_Python (master)
$
Between the local repository and the remote repository, project files can 
go in two directions. Moving files from the local to the remote repository is 
referred to as a push; moving files from the remote to the local repository is a 
pull or fetch. Between pull and fetch, pull is the default mode of moving files 
	
Introduction	
65
 https://doi.org/10.15215/remix/9781998944088.01
from remote to local, and fetch provides additional power, such as is needed 
when moving files from several repositories at the same time.
Please note that pull or push operations are not just transferring files. Key 
points of the operation are merging the changes to files in the target repository 
and versioning. Git has special commands for those key operations, but those 
operations often run behind the scenes without anyone noticing.
After you have added a remote repository to your project, you can push 
the already committed changes to the local repository by running the git 
push command in a shell terminal within the project directory, as shown 
here:
$ git push -­
-­
set-­
upstream notebooks master
Enumerating objects: 3, done.
Counting objects: 100% (3/3), done.
Delta compression using up to 6 threads
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 545 bytes | 272.00 KiB/s, 
done.
Total 3 (delta 0), reused 0 (delta 0), pack-­
reused 0
remote:
remote: Create a pull request for 'master' on GitHub by 
visiting:
remote:   https://​
github​
.com/​
jamesatau/​
comp21B​
-­
notebooks/​
pull/​
new/​
master
remote:
To https://​
github​
.com/​
jamesatau/​
comp218​
-­
notebooks​
.git
* [new branch] master -­
> master
branch 'master' set up to track 'notebooks/master'.
 
james@trustshop MINGW64 /s/Dev/Learn_Python (master)
$ git push notebooks
Everything up-­
to-­
date
 
james@trustshop MINGW64 /s/Dev/Learn_Python (master)
$
Sometimes you might be interested in a project in a repository and would 
like to make a local copy of the entire project. The operation of copying an 
entire project in a remote repository onto a local computer is called cloning. 
For example, say there is a repository called learn-­
python3 in GitHub containing 
	 66	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
sample code, and you want to download all the code to play with it. You can do 
that by doing the following:
	
1.	 Open a terminal on a file folder in which the project is to be 
placed—­
say, the desktop.
	
2.	 From GitHub​
.com, copy the HTTPS URL from the “Code” dropdown menu 
of the learn-­
python3 repository and run the following Git command:
$ git clone https://​
github​
.com/​
michaelliao/​
learn​
-­
python3​
.git
You will then have all the code samples on your computer.
To work with Git and GitHub, you can use Git GUI, a GUI-­
based system, by 
invoking Git GUI on the project folder within Windows File Explorer.
Another way, our preferred way to use Git and GitHub for versioning on 
both local and remote repositories, is to operate within VS Code, which has 
native support for Git and GitHub, as long as Git is properly installed on the 
local computer, as shown earlier in this section.
	
1.	 Create a new folder on your local drive for a project.
	
2.	 Open the folder from VS Code. The new folder can also be created 
when you open the file folder in VS Code.
	
3.	 Initialize the local repository for the project by running git initialize 
in VS Code command palette by pressing Ctrl+Shift+P. Type “git” and 
click “git initialize.” You will be asked to do the following:
	
a.	 Choose a local workspace folder to initialize.
	
b.	 Set the email address of the programmer/developer/author.
	
c.	 Set the name of the programmer/developer/author.
Now the local repository is ready for versioning your project files 
locally.
	
4.	 Create or copy project files under the project folder.
	
5.	 Click the source control icon on the left navigation bar, type a brief 
message about the changes to the files or project, and press Ctrl+Enter 
or click the commit icon above.
	
6.	 To push the changes to the project files and the project to the remote 
repository in GitHub, click the Git Sync icon at the bottom-­
left of the 
VS Code window.
	
Introduction	
67
 https://doi.org/10.15215/remix/9781998944088.01
	
a.	 If this is the first time you are pushing the project to your GitHub 
account, the command palette dialogue will pop up and ask you 
to choose whether to publish the project into a public repository 
or private repository under your account. The project folder name 
will be used as the repository name by default, but you can use a 
different name.
	
b.	 You may be asked to sign into your GitHub account if you have not 
accessed GitHub from VS Code before.
	
c.	 You may also be asked to either use the existing username 
and email associated with your GitHub account or provide a 
different email and/or username to identify yourself as the author 
of the project being pushed.
If you have already created a repository for the project on GitHub, you can 
copy the URL of the repository and add the remote repository to the project 
in VS Code by running git add remote in the command palette. You will also 
be asked to provide a name for the remote repository after entering the URL.
Chapter Summary
•	 The first chapter has introduced you to computers and programming 
languages and guided you in setting up the programming environment.
•	 The introduction to modern computers included a brief history as well 
as a description of the fundamental architecture of modern computers. 
Knowing who made significant contributions to the development of 
computers, what contributions they made, and how they made those 
contributions can be very inspiring.
•	 The computers we use today are called Von Neumann machines 
because they are based on Von Neumann architecture, which consists 
of a control unit, an arithmetic logic unit (ALU), registers, and a 
memory unit (collectively called CPU) plus inputs and outputs. That’s 
why Von Neumann is often credited as one of the fathers of modern 
computers.
•	 The key features of modern computers are that they are digital, 
programmable, and automatic, with stored programs, although these 
features were already in the design of the analytical engine by British 
mathematician Charles Baggage in the 1800s. Hence Charles Babbage is 
also credited as a father of modern computers, although his machines 
were not electronic.
	 68	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
•	 Binary or Boolean algebra is one of the important theories behind 
today’s modern computers. It can be proved that computing with a 
ternary number system would be more efficient, but it would be more 
costly to make computing components to build computing machines 
based on a ternary number system than on a binary number system.
•	 Signed numbers, including both integers and real numbers, need to 
and can be represented by a sequence of digits, using the highest bit to 
represent the sign (0 for positive, 1 for negative). A certain number of 
digits are assigned for decimals.
•	 To apply arithmetic operations more easily and efficiently on 
computers, 2’s complements are used to represent signed numbers. 
With 2’s complements, the addition of signed numbers can be easily 
done.
•	 How do you know what modern computers are and are not capable of? 
Alan Turing, independently from Alonzo Church, laid the foundational 
work on computability with his Turing machine. Because of that, Alan 
Turing is credited as a father of modern computing.
•	 There is also the question of how difficult it is to solve a problem 
with computers, which is the study of computational complexity. The 
computational complexity of a problem is often measured in terms 
of the total number of basic computations, such as addition and 
multiplication, which can be converted into the time needed to solve 
the problem on specific computers. The space required to solve a 
problem can be a concern as well, but most of the time, when people 
are talking about computational complexity, they are talking about the 
steps or time required to solve the problem.
•	 Problems to be solved on computers are often divided into three classes 
of problems: P, NP-­
complete, and NP, in which P is short for polynomial 
and NP is short for nondeterministic polynomial.
•	 If, on a deterministic and sequential machine like a computer, for 
a problem of size n, if the time or number of steps needed to find 
the solution is a polynomial function of n, the problem is said to be 
in the P class. If a problem can be solved in polynomial time on a 
nondeterministic machine, the problem is in the NP class. A problem 
is said to be NP-­
complete if proposed answers can be verified in 
polynomial time, and if an algorithm can solve it in polynomial time, 
the algorithm can also be used to solve all other NP problems.
•	 Programs are the computers’ soul. The task of writing programs for 
computers is called programming. Languages in which programs can 
be written for computers are programming languages.
	
Introduction	
69
 https://doi.org/10.15215/remix/9781998944088.01
•	 Programming languages play important roles in building soul into 
computers. Programming languages can be machine languages, 
assembly languages, and high-­
level languages.
•	 Ada Lovelace, who wrote code for Charles Babbage’s analytical engine, 
was credited as the first programmer of modern computers. The Ada 
programming language was named in her honour.
•	 An algorithm describes the steps a computer needs to take to solve a 
problem or complete a task.
•	 Pseudocode and flowcharts are two ways of describing algorithms.
•	 System analysis and design are the steps taken to design and develop an 
information system for real-­
world application.
•	 The official website for the Python programming language is at www​
.python​
.org. Use the Anaconda package to install Python, Jupyter 
Notebook, Visual Studio Code IDE, and other tools for your study of 
programming with Python.
•	 Python interactive shell and Jupyter Notebook are recommended for 
learning Python programming interactively.
•	 Create a Jupyter Notebook for each chapter and/or section, and 
work through all the examples within that part of the course in that 
notebook to keep a record of your learning activities for review and 
evaluation.
•	 Visual Studio Code (VS Code) is the IDE recommended for you to 
complete the projects and programming projects in the assignments.
Exercises
	
1.	 Convert the following numbers in their respective bases into their 
binary equivalence:
(78)10
(1F)16
(27)8
(121)10
(3E)16
(33)8
(29)10
(CD)16
(52)8
	
2.	 Complete the following binary operations:
10111 + 1101
1101010 − 101101
10101 + 1110
10101 − 1111
1101 * 101
111011 / 11
	 70	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
	
3.	 Complete a thorough review of computer history by reading library 
books and online articles. Compile a table showing the significant 
developments of theories and technologies of modern computers in 
Europe and a similar table for America. For each development, the 
table should show the time, a description of the development, the 
key players/contributors, and its impact on the later development of 
modern computers.
	
4.	 Investigate the classification and development of computer 
programming languages and explain the features of the 
following programming languages:
	
a.	 Machine code
	
b.	 Assembly languages
	
c.	 High-­
level programming languages
	
d.	 Procedural programming languages
	
e.	 Structured programming languages
	
f.	 Imperative programming languages
	
g.	 Functional programming languages
	
h.	 Logic programming languages
	
i.	 Object-­
oriented programming languages
	
5.	 Create a new folder called comp218, open it with VS Code, then create 
a new file and rename it comp218start.ipynb, which is recognized by 
VS Code as Jupyter Notebook. Start working in the cells and use it as 
a calculator to see what expressions and statements you can perform 
correctly with Python, based on what you have learned so far. Please 
note that you may wish to choose a Python interpreter in order to run 
the code or make sure the notebook is working properly.
	
6.	 In a cell of a newly created notebook comp218start.ipynb, type the 
following code and then press Shift+Enter to run it to see what you 
will get:
In [ ]:
first_name = 'John'
last_name = 'Doe'
full_name = first_name + ' ' +last_name
print(full_name)
	
7.	 In a new cell of notebook comp218start.ipynb, type the following code 
and then press Shift+Enter to run the code to see what you will get.
In [ ]:
for i in range(11):
 p = (2**i)
  print(f'{bin(p)}')
	
Introduction	
71
 https://doi.org/10.15215/remix/9781998944088.01
	
8.	 Write an algorithm in pseudocode describing the steps to make a pizza.
	
9.	 Write an algorithm in pseudocode describing the steps to cook rice.
	
10.	 Write an algorithm in a flowchart describing the steps you usually take in 
the morning, from getting up until leaving home to go to work or school.
Projects
	
1.	 Research the history of computers online, then write a summary 
about each of the following:
	
a.	 The computing machines designed and developed in history that 
are significant to the development of today’s computers
	
b.	 The people in history who have made significant contributions to 
the development of computers
	
c.	 The concepts, theories, designs, and technologies in history that 
are important to the development of modern computers
	
2.	 Research the history of programming languages online, then write a 
summary for each of the following:
	
a.	 Machine languages that have been important to the development 
of computer systems
	
b.	 The differences between machine languages, assembly languages, 
and high-­
level programming languages
	
c.	 The essence (what defines it and differentiates it from others) 
of structural programming, the pros and cons of structural 
programming, and some well-­
known programming languages that 
support structural programming
	
d.	 The essence of imperative programming, the pros and cons of 
imperative programming, and some well-­
known programming 
languages that support imperative programming
	
e.	 The essence of declarative programming, the pros and cons of 
declarative programming, and some well-­
known programming 
languages that support declarative programming
	
f.	 The essence of functional programming, the pros and cons of 
functional programming, and some well-­
known programming 
languages that support functional programming
	
g.	 The essence of logical programming, the pros and cons of logical 
programming, and some well-­
known programming languages that 
support logical programming
	
h.	 The essence of object-­
oriented programming, the pros and cons of 
object-­
oriented programming, and some well-­
known programming 
languages that support object-­
oriented programming
This page intentionally left blank
 https://doi.org/10.15215/remix/9781998944088.01
Chapter 2
Essential Building Blocks 
of Computer Programs
This chapter introduces the fundamental elements and building blocks of com­
puter programs in the Python language. These fundamental building blocks 
include the words, keywords, and reserved words that can be used in Python 
programs. You will also learn the primary data types and data models, the 
operators, and some built-­
in functions that can be applied to the data and data 
models in Python, as well as some important statements or sentences that can 
be used to instruct computers.
Learning Objectives
After completing this chapter, you should be able to
•	 make and use names correctly to identify various items in your Python 
programs.
•	 use different types of data and data models correctly.
•	 use the proper operators for different types of data and data models.
•	 correctly compose expressions using variables, data, operators, and the 
built-­
in functions of Python.
•	 write an assignment statement to assign values to variables.
•	 write augmented assignment statements.
•	 write input statements correctly to get input from users.
•	 write correct statements using print.
	 74	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
2.1 Primary Constructs of Computer Programs in 
Python
Computer programs tell computers how to complete specific tasks. These 
specific tasks may be as small as what you would do on a calculator or as big 
as mission control for space exploration. Believe it or not, computer programs 
for all these different tasks are composed of the same types of statements on 
the same types of primary data. The difference is in how the data are struc­
tured and how the statements are organized. In computing, the study of the 
first “how” is the subject of data structures, whereas the study of the second 
“how” is the subject of algorithms. In computing, there are dedicated courses 
providing in-­
depth coverage on data structures and algorithms. While studying 
introductory computer programming, keep in mind the importance of data and 
algorithms in solving problems and try to identify the data involved and describe 
the algorithms needed to solve a problem using the methods introduced in 1.7.
Vocabulary of the Programming Language
Vocabulary is the foundation of any language. In computer languages, identifi­
ers are an important part of the vocabulary used to write computer programs. 
As in all programming languages, identifiers in Python are used to identify 
variables, functions and methods, classes, objects, and modules. They are 
called identifiers because, for computers, the only purpose of these names is 
to identify specific locations of computer memory that hold or can be used to 
hold specific data or code blocks.
Figure 2-­
1 illustrates how a variable named “grade” is identified as the mem­
ory location that holds the integer 98. Please note that we use 98 in the diagram 
for illustration purposes, although, in fact, both data and program codes are 
stored as sequences of binary (0s and 1s).
grade
98
Figure 2-­
1: The variable “grade” and its memory location
Although an identifier in computer programs does not need to be mean­
ingful to humans, it must be unique in a given context, which is often called 
namespace. In Python, a namespace is a mapping from names to objects and 
is implemented as a Python dictionary.
	
Essential Building Blocks of Computer Programs	
75
 https://doi.org/10.15215/remix/9781998944088.01
In a program, different identifiers may be used to refer to the same memory 
location and hold the same data or program code, as shown in Figure 2-­
2. This 
is accomplished through the following Python code:
In [ ]:
x = 'John'
y = x
Out [ ]:
John
To check what x and y hold, we use the print statement as follows:
In [ ]:
print('x holds ', x, ', y holds', y)
Out [ ]:
x holds John, y holds John
X
Y
‘John’
Figure 2-­
2: X and Y point to the same memory location
If we change one identifier to refer to something else, the value referred 
to by the other identifier will remain the same, as shown in Figure 2-­
3. This is 
done with the following code:
In [ ]:
x = 'Smith'
print('x holds ', x, ', y holds ', y)
Out [ ]:
x holds Smith, y holds John
X
Y
‘Smith’
‘John’
Figure 2-­
3: Now X and Y point to different memory locations
	 76	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Please note that in the examples above and other examples in the remainder 
of the textbook, the box behind In [ ] represents a code cell in Jupyter Notebook, 
whereas everything behind Out [ ] is the output from the code contained in the 
code cell when you press Shift+Enter or click the play button.
RULES OF NAMING IDENTIFIERS
In addition to uniqueness, identifiers used in Python programs must be named 
according to the following rules:
	
1.	 An identifier can be a combination of letters (a–­
z, or A–­
Z), numbers 
(0–­
9), and underscores (_).­
	
2.	 It must begin with a letter (a–­
z or A–­
Z) or underscore (_).
	
3.	 In Python, identifiers are case-­
sensitive, so x and X are different 
identifiers.
	
4.	 Identifiers can be of any length.
	
5.	 User-­
defined identifiers cannot be the same as words reserved by the 
Python language.
According to these rules, the following are legitimate user-­
defined identifiers 
in Python:
AB, zf, cd, hz, d_2, c5E, falling, to_be
Whereas the following are not:
1d, d/, f-, g.d
In Python, identifiers shown in Table 2-­
1 are reserved and hence called 
reserved words or keywords, with predefined special meaning in the language, 
which means that you must not use them to name your variables, functions/
methods, classes, or modules.
Table 2-­
1: Reserved words in the Python programming language
Reserved 
word
Special meaning
Reserved 
word
Special meaning
and
logical and
if
conditional statement
as
used together with import 
and with to create new 
alia
import
to import modules
	
Essential Building Blocks of Computer Programs	
77
 https://doi.org/10.15215/remix/9781998944088.01
Reserved 
word
Special meaning
Reserved 
word
Special meaning
assert
to make an assertion for 
handling possible errors
in
membership test
break
to get out of some code 
blocks such as during 
iteration
is
identity test
class
to define class
lambda
to create a lambda function
continue
to omit the rest of the code 
block and continue the 
loop
not
logic negation
def
to define functions
or
logical or
del
to delete an object
pass
to pass the code block
elif
used together with if to 
create a conditional 
statement
print
to output
else
used together with if to 
create a conditional 
statement
raise
to raise an exception 
intentionally
except
used together with try to 
handle errors
return
to return values from a 
function in function 
definition
exec
to execute some 
dynamically generated 
code in a string or object
try
used for exception handling
finally
used together with try and 
except to handle errors
while
to make loop/iteration 
statements
for
to create a loop
with
to introduce context for a 
code block
from
used together with import
yield
used in place of return, 
to turn a function into a 
generator
global
to access a global variable 
from inside of a function
In addition to the reserved words in Table 2-­
1, you should also avoid using 
names that have been used by Python for built-­
in types and built-­
in functions, 
Table 2-­
1: Reserved words in the Python programming language 
(continued)
	 78	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
classes, and modules. These names are collectively called built-­
in names. It is 
grammatically fine to use built-­
in names as user-­
defined identifiers, but using 
them may cause confusion.
Furthermore, Python also uses the underscore _ as an identifier for a very 
special variable to hold the result of the last evaluation when Python is running 
in interactive mode, as shown in the following example:
>>> sum ([1,2,3,4,5,6])
21
>>> sum (list(range(1000)))
499500
>>> _
499500
>>> |
This use of _ as a special variable can also be seen in Jupyter Notebook, as 
shown in the following example:
In [ ]:
pow(9, 3)
Out [ ]:
729
In [ ]:
_
Out [ ]:
729
When Python is not running in interactive mode, _ has no predefined meaning, 
however. Even within Jupyter Notebook, the value of _ is often unpredictable 
unless explicitly assigned.
Syntactically, the special variable _ can be used in the same way as others, 
especially when the value is to be thrown away and not used, as shown below:
In [ ]:
p, n = 1, 10   # assign 1 to variable p, and assign 10 
to variable n
for _ in range(n):   # note that _ is not used 
elsewhere
  p *= 2
print(f'2^{n} = {p}')   # format the output with 
f-string
Out [ ]:
2^10 = 1024
	
Essential Building Blocks of Computer Programs	
79
 https://doi.org/10.15215/remix/9781998944088.01
PYTHON NAMING CONVENTIONS
Although identifiers used in Python programs don’t have to be meaningful 
to humans, you should always try to use more meaningful identifiers in your 
programs because it is not only easy for you to tell what the identifiers are used 
for but also easier for other programmers to understand your programs when 
you work in a team or want to share your code with others.
For the same reason, you should also follow common practices and widely 
accepted coding conventions when programming. In terms of composing 
identifiers these conventions include:
	
1.	 Lower case identifiers are usually used for variables and function 
names.
	
2.	 Capitalized identifiers are used for class names.
	
3.	 Upper case identifiers are used for constants, such as PI = 3.1415926, 
E = 2.7182, and so on.
	
4.	 When an identifier has multiple words, the underscore _ is used to 
separate the words. So we use your_name instead of yourname, use to_
be instead of tobe. Some programmers prefer not to use an underscore, 
but to capitalize each word, except for the first word, when an 
identifier is used as a variable or the name of a function or method.
Along with the programming technologies, these practices and conventions 
have developed over the years and may further evolve in the future. A good 
Python programmer should follow the developments and trends of the Python 
programming community.
NAMES WITH LEADING AND/OR TRAILING UNDERSCORES
As mentioned above, identifiers for variables, function/method names, 
and class names may begin and/or end with a single underscore, double 
underscores, or even triple underscores, and those names may have special 
meanings.
When a name has both leading and trailing double underscores, such as 
__init__, it is called a dunder (double-­
underscore) name. Some dunder names 
have been given special meanings in Python Virtual Machine (PVM) or a Python 
interpreter. They are either reserved as special variables holding special data 
or as special function/method names.
The following are some special dunder names used as special values or 
special variables holding special data.
	 80	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
__MAIN__
Used as a special value. When a Python program/script file runs as the main 
program other than a module, the special variable __name__ will be assigned 
special value __main__.
__NAME__
Used as a special variable in a Python program to hold special value indicating 
how the program file is called or used. If the program file is used as the main 
program, __name__ will hold __main__. If it is used as a module, __name__ 
will hold the name of the module.
__PACKAGE__
Used as a special variable to hold the package’s name if a module imported is 
a package. Otherwise, __package__ will hold an empty string.
__SPEC__
Used as a special variable to hold the module specification used when the 
module is imported. If the Python program file is not used as a module, it will 
hold the special value None.
__PATH__
Used as a special variable to hold the path to the module in a package. If the 
module is not within a package, __path__ is not defined.
__FILE__
Used as a special variable to hold the name of a Python program file.
__CACHED__
A special variable often used together with the special variable __file__, refer­
ring to a precompiled bytecode. If the precompiled bytecode is not from a 
program file, __file__ is not defined.
__LOADER__
Used as a special variable to hold the object that loads or imports the module 
so that you would know who is using the module.
__DOC__
Used as a special variable to hold the documentation of a module or Python 
program if it is used as the main program, documentation of a class, or function 
or method of a class.
	
Essential Building Blocks of Computer Programs	
81
 https://doi.org/10.15215/remix/9781998944088.01
Dunder names used for special functions and methods will be discussed in 
Chapter 6 and Chapter 7.
RULES OF SCOPE RESOLUTION FOR IDENTIFIERS
Big programs for complicated applications often use hundreds or even thou­
sands of identifiers to name variables, functions, classes, and other objects. 
When so many names are used, it is unavoidable that some names will be 
used more than once. How can we ensure in a program that each name can 
be mapped to an object without confusion and ambiguity? The answer is to 
follow the LEGB rule, in which L, E, G, and B refer to different scopes from 
small to big: L is for local, referring to the inside of a function or class; E is 
for enclosed, referring to the inside of a function enclosing another function; 
G is for global, referring to the space outside of all classes and function in a 
Python program file; and B is for built-­
in, referring to all the names defined 
within Python’s built-­
in module. The relationships of LEGB scopes are illus­
trated in Figure 2-­
4.
Built-in names
Global names
Enclosed names: Inside an 
enclosure
Local names: Inside a
function or class
Figure 2-­
4: LEGB rules for scope resolution for names
The illustration above should be viewed in reference to a name used within 
a function or class. To resolve the name or to link it to a specific object, apply 
the following LEGB rules:
	
1.	 Look at the names defined locally (L) within the function/method or 
class. If not defined, proceed to the next rule.
	
2.	 Check whether the name has been defined in the enclosure (E) 
function (note that enclosures are not often used, so this is just for 
discussion right now). If not, proceed to the next rule.
	
3.	 Check whether it has been defined globally (G).
	
4.	 Check whether it is a built-­
in (B) name of Python.
The following sample shows how matching local and global names are resolved:
	 82	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
g_name = 'John'   # global name g_name
l_name = 'Smith'   # global name l_name
def display_names():   # define a function
  l_name = input('What is your name:')   # get input
  print(f'Local name is {l_name}')   # l_name is 
defined again
  print(f'Global name is {g_name}')   # g_name is 
global
display_names()
Out [ ]:
What is your name: Kevin
local name is Kevin
Global name is John
You may have noted in the example above that variable l_name is defined 
both locally in definition of the function display_names() and globally. When it 
is used within the function, its local definition is used; variable g_name, on the 
other hand, is only defined globally, and when it is used within the function, 
it is resolved to its global definition.
In addition to the LEGB rules, please keep in mind the following:
	
1.	 A local name defined in a function will not be seen anywhere outside 
the function.
	
2.	 A local name defined in a class can be seen outside the class or its 
objects if the name is not a private member of the class, with an 
explicit reference to the name with dot notation. For example, a 
name X defined in class C can be accessed using C.X, or O.X if O 
is an object of C.
	
3.	 A name Nx globally defined in a Python script file named M1​
.py can 
be seen inside another Python script file by either importing the 
name explicitly from M or by importing M1 as a whole and using dot 
notation M1.Nx to access Nx.
Simple Data Types
Computers solve problems and accomplish various tasks by processing infor­
mation. This information is represented in the form of data. It is important to 

know what data we can use or process and what operations we can apply 

to different types of data. In Python, there are simple data types and compound 
data types. The latter are also called models of data.
Simple data types include numbers, strings, and Boolean values. Numbers 
are used to represent numerical information, strings are used to represent 
	
Essential Building Blocks of Computer Programs	
83
 https://doi.org/10.15215/remix/9781998944088.01
literal information, and Boolean values are used to represent the result of tests, 
either True or False.
In Python, numbers can be signed integers, float numbers, and complex 
numbers. They all can be values of variables, as we shall see in the next section.
Although a string can be used conveniently as simple data, it has all the 
properties and supported operations of a compound data type. As such, it will 
be discussed in full detail later in this section.
SIGNED INTEGERS (INT)
Signed integers in Python are …−2, −1, 0, 1, 2…, as examples. In Python 3, 

signed integers can be of arbitrary size, at least theoretically, as long as com­
puter memory is not exhausted. In implementation, however, the biggest 
integer is defined by sys.maxsize, a variable named maxsize in a module called 
sys, which specifies the maximum number of bytes that can be used to rep­
resent an integer number. The notation of sys.maxsize here means maxsize, 
defined in module sys.
Operations on integer numbers include the following:
addition (x + y)
subtraction (x − y)
multiplication (x * y)
division (x / y)
negation (−x)
exponentiation (x ** y)
modular (x % y)
integer division (x // y)
You should be able to use the above operations, which you should already 
be familiar with, as well as the following bitwise operations you may never 
have heard about:
bitwise or (x | y)
>>> 1 | 4
5
bitwise exclusive or, often called XOR (x ^ y)
>>> 1 ^ 2
3
bitwise and (x & y)
>>> 1 & 5
1
	 84	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
shifted left (x << n)
>>> 2 << 3
16
shifted right (x >> n)
>>> 256 >> 5
8
invert (~x)
>>> ~128
-­
129
The following are a few more samples from the Python interactive shell 
that show how these operators are used:
>>> 12 + 23
35
>>> 35 -­
 12
23
>>> -­
123
-­
123
>>> 123 * 567
69741
>>> 69741/123   # the result is a real or float-­
point 
number
567.0
>>> 69741//123   # get the quotient of two integers
567
>>> 69741%12   # operation % will get the remainder
9
The next few examples are about bitwise operations. The first two operations 
on the first line show the binary form of the two numbers. In Python, you can 
have two or multiple statements on a single line, but you are not encouraged 
to do so.
>>> bin(123); bin(567)   # how to have two or more 
statements on one line
'0b1111011'
'0b1000110111'
>>> bin(123 | 567)   # it will be 0001111011 | 1000110111
'0b1001111111'
	
Essential Building Blocks of Computer Programs	
85
 https://doi.org/10.15215/remix/9781998944088.01
>>> bin(123 ^ 567)   # it will be 0001111011 ^ 1000110111
'0b1001001100'
>>> bin(123 & 567)   # it will be 0001111011 & 1000110111
'0b110011'
>>> bin(123 << 5)   # it will be 1111011 << 5
'0b111101100000'
>>> bin(123 >> 5)   # it will be 1111011 >> 5
'0b11'
>>> bin(~123)
'-­
0b1111100'
There are also many built-­
in functions available for operations on integers. 
All the built-­
in functions of Python will be discussed in detail below.
In addition, the following methods are also available to use for operations 
on integer objects.
N.BIT_LENGTH()
This returns the number of necessary bits representing the integer in binary, 
excluding the sign and leading zeros.
>>> n = -­
29
>>> print(f'Binary string of {n} is {bin(n)}')
binary string of -­
29 is -­
0b11101
>>> print(f'# of significant bits of {bin(n)} is 
{n.bit_length()}')
# of significant bits of -­
0b11101 is 5
N.TO_BYTES(LENGTH, BYTEORDER, *, SIGNED=FALSE)
This returns an array of bytes representing an integer, where length is the 
length of bytes used to represent the number. byteorder can take Big-­
Endian 
or Little-­
Endian byte order, depending on whether higher-­
order bytes (also 
called most significant) bytes come first or lower-­
order bytes come first, and 
an optional signed argument is used to tell whether 2’s complement should be 
used to represent the integer.
>>> n = 256
>>> n.to_bytes(2, byteorder = 'big') # big means higher 
bytes first
b'\x01\x00'
	 86	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Recall that modern computers use 2’s complements to represent negative 
numbers. So if the integer n is negative while signed remains False, an Over­
flowError will be raised, as shown below:
>>> n = -­
23567
>>> n.to_bytes(3, 'big')
 
OverflowError Traceback (most recent call last)
<ipython-­
input-­
4-­
66989275e22d> in <module>
1 n = -­
23567
-­
-­
-­
-­
> 2 n.to_bytes(3, 'big')
OverflowError: can't convert negative int to unsigned
So a correct call of the method would be
>>> n = -­
23567
>>> n.to_bytes(3, 'big', signed = True)
 
b'\xff\xa3\xf1'
INT.FROM_BYTES(BYTES, BYTEORDER, *, SIGNED = FALSE)
This classmethod returns the integer represented by the given array of bytes.
>>> n = 256
>>> bin(n)
'0b100000000'
>>> # convert '0b100000000' in Big Endian to int
>>> int.from_bytes(n.to_bytes(2, byteorder = 'big'), 
'big')
256
>>> # convert '0b100000000' in Little Endian to int
>>> n.from_bytes(n.to_bytes(2, byteorder = 'big'), 
'little')
1
Note that when two bytes are used to represent integer 256, 0b100000000 will 
be expanded to 00000001 00000000. In Big Endian, it represents 256, but in Little 
Endian, 00000001 becomes the less significant byte, while 00000000 becomes the 
most significant byte, and the corresponding number for 256 becomes 00000000 
00000001.
	
Essential Building Blocks of Computer Programs	
87
 https://doi.org/10.15215/remix/9781998944088.01
For more advanced operations on integers, there are some special modules 
such as the standard math module, math; the free open-­
source mathematics 
software system SAGE; (https://​
www​
.sagemath​
.org/); SymPy (https://​
www​
.sympy​
.org/​
en/​
index​
.html); and, for operations in number theory, eulerlib 
(https://​
pypi​
.org/​
project/​
eulerlib/).
FLOAT (FLOAT)
Float numbers are numbers with decimals, in the form of 12.5 in decimal 
notation or 1.25e1 in scientific notation, for example. Operations on float 
numbers include addition (+), subtraction (−), multiplication (*), division (/), 
and exponentiation (**), as shown below:
In [ ]:
x = 12.5 * 32.7 / 23.9 -­
 53.6 + 28.9 ** 2.7
print(f"x = {x}")   # prefix f tells to format the 
string
Out [ ]:
x = 8762.31728619258
In the example above, the equal sign (=) is an assignment operator in Python 
(and almost all other programming languages as well). We will explain all 
operators fully later in this section.
Python can handle very big integers and floating-­
point numbers. When a 
number is too big, it becomes difficult to count and check for accuracy. To solve 
that problem, Python allows using the underscore to separate the numbers, 
in the similar way that accounting and finance use a comma. The following 
is an example:
>>> 123_456_789_987.56+234_456_678_789
357913468776.56
Using an underscore to separate the digits has made it much easier to tell 
how big the number is.
R.AS_INTEGER_RATIO()
This returns a pair of integers whose ratio is exactly equal to the original float 
r and with a positive denominator. It will raise OverflowError on infinities and 
a ValueError on NaNs.
>>> r.as_integer_ratio()
(7093169413108531, 562949953421312)
	 88	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
R.IS_INTEGER()
This returns True if r is finite with integral value, and False otherwise.
>>> r.is_integer()
False
R.HEX()
This returns a representation of a floating-­
point number as a hexadecimal 
string. For finite floating-­
point numbers, this representation will always include 
a leading 0x and a trailing p and exponent.
>>> r.hex()
'0x1.9333333333333p+3'
FLOAT.FROMHEX(S)
This returns the float represented by a hexadecimal string s. The string s may 
have leading and trailing whitespace.
>>> float.fromhex('0x1.9333333333333p+3')
12.6
BOOLEAN (BOOL)
Boolean data have only two values: True and False. They are used to repre­
sent the result of a test or an evaluation of logical expressions, as we will see. 
Technically, Python does not need a special Boolean data type, since it treats 
0 and None as Boolean False, and treats everything else as Boolean True, as 
shown below:
In [ ]:
b = None   # assign None to variable b. None in Python 
represents 'no value'
print(f"b = {b}")   # print out what b holds
if not b:   # if (not b) is True then print
  print("Print this out when b is None!")
Out [ ]:
b = None
Print this out when b is None!
However, having a Boolean data type with two Boolean values of True and 
False does clearly remind Python programmers, especially beginners, that 
there are special types of data and expressions called Boolean data and Bool­
ean expressions.
	
Essential Building Blocks of Computer Programs	
89
 https://doi.org/10.15215/remix/9781998944088.01
COMPLEX (COMPLEX)
If you have never heard about complex numbers, quickly search the internet 
for complex numbers and read some articles or watch some videos.
Briefly, a complex number is a representation of a point on a plane with 
X and Y axes that take the form of x + yj, in which x and y are float numbers 
that represent and define the location of a point on the plane. Examples of 
complex numbers are 1 + 1j, 3 − 6j, 2.5 − 8.9j, and so on.
The same operations on float numbers can also be applied to complex 
numbers, as shown below:
In [ ]:
x = 3.5 + 6.7j   # assign a complex number to x
y = 12.3 -­
 23.9j   # assign another complex number to y
z = x + y   # assign the sum of x and y to z
print(x, '+', y, '=', z)   # print out the value of the 
variable
print(x, '-­
', y, '=', x -­
 y)   # the difference between 
x and y
print(x, '*', y, '=', x * y)   # the product of x and y
print(x, '/', y, '=', x / y)   # the result of x 
divided by y
Out [ ]:
(3.5 + 6.7j) + (12.3 -­
 23.9j) = (15.8 -­
 17.2j) (3.5 + 6.7j) -­
 (12.3 -­
 23.9j) 
= (-­
8.8 + 30.599999999999998j) (3.5 + 6.7j) * (12.3 -­
 23.9j) = 
(203.18 -­
 1.2399999999999807j) (3.5 + 6.7j) / (12.3 -­
 23.9j) = 
(-­
0.16204844290657439 + 0.229840830449827j)
Compound Data Types
In previous sections, we saw data in pieces. Sometimes it is more convenient, 
more effective, and even necessary to use some data together to represent 
certain kinds of information. Examples are when we refer to the days of the 
week, months of the year, and so on. Courses in universities are often iden­
tified using compound data, a tuple made of a course number and course 
title or name.
In Python, compound data types provide means of structuring data. They 
are also referred to as data structures.
Compound data types in Python can be categorized into sequence and nonse­
quence data types. Items in sequence compound data are ordered and indexed. 
Sequence compound data types include string, list, and tuple. Items in a nonse­
quence compound data are not ordered. Nonsequence compound data include 
set and dictionary.
	 90	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
STRING (STR)
Sequences are a group of data in order, and a string is a good example of a sequence.
Like numbers, strings are very important in all programming languages. It 
is hard to imagine what a number means without its context. For that reason, 
in most programming languages, strings are also considered a primary data 
type in terms of their importance and the role that they play.
In Python, strings are sequences of characters, symbols, and numbers 
enclosed in a pair of double quotation marks or a pair of single quotation marks. 
Table 2-­
2 is a list of ASCII characters that can be used in strings. The following 
are some examples of strings:
In [ ]:
s1 = "this is my first string in double quotes"
s2 = 'string in single quotes'
print('s1 = ', s1)   # print out s1 = the value of 
variable s1
print('s2 = ', s2)   # print out s2 = the value of 
variable s2
Out [ ]:
s1 = this is my first string in double quotes
s2 = string in single quotes
When a string is too long and needs to span more than one line, a pair of 
triple quotation marks can be used, as shown in the following example:
In [ ]:
long_string = """ASCII stands for American Standard 
Code for Information Interchange.
Computers can only understand numbers, so an ASCII code 
is the numerical representation of a character such 
as "a" or "@" or an action of some sort.
ASCII was developed a long time ago, and now the 
nonprinting characters are rarely used for their 
original purpose. Below is the ASCII character table. 
The first 32 characters are nonprinting characters. 
ASCII was designed for use with teletypes, so the 
descriptions in ASCII are somewhat obscure.
If someone says they want your CV in ASCII format, 
all this means is they want "plain" text with no 
formatting such as tabs, bold or underscoring—­
the raw 
format that any computer can understand.
This is usually so they can easily import the file into 
their own applications without issues. Notepad.exe 
creates ASCII text, and MS Word lets you save a file 
as "text only."
"""
print('long_string =', long_string)
	
Essential Building Blocks of Computer Programs	
91
 https://doi.org/10.15215/remix/9781998944088.01
Out [ ]:
long_string = ASCII stands for American Standard Code for Information 
Interchange. Computers can only understand numbers, so an ASCII code 
is the numerical representation of a character such as "a" or "@" or an 
action of some sort. ASCII was developed a long time ago and now the 
nonprinting characters are rarely used for their original purpose. Below 
is the ASCII character table. The first 32 characters are nonprinting 
characters. ASCII was designed for use with teletypes and so the 
descriptions in ASCII are somewhat obscure. If someone says they want 
your CV in ASCII format, all this means is they want "plain" text with no 
formatting such as tabs, bold or underscoring—­
the raw format that any 
computer can understand. This is usually so they can easily import the 
file into their own applications without issues. Notepad.exe creates 
ASCII text, and MS Word lets you save a file as "text only."
This can be very useful in cases such as when you want to print out instruc­
tions for users to use with an application you developed.
Otherwise, you would need to use backslash at the end of each line except 
the last one to escape the invisible newline ASCII character, as shown below:
In [ ]:
s0 = 'Demo only. This string is not too long \
to be put on one line.'
print(f's0 = {s0}')
Out [ ]:
s0 = Demo only. This string is not too long to be put on one line.
This is OK if the string only spans across two or three lines. It will look 
clumsy if the string spans across a dozen lines.
In the example above, we use backslash \ to escape or cancel the invisible 
newline ASCII character. In Python and almost all programming languages, 
some characters have special meanings, or we may want to assign special 
meaning to a character. To include such a character in a string, you need to 
use a backslash to escape from its original meaning. The following are some 
examples:
In [ ]:
print("This string will be put \n on two lines")
# \n will start a new line
print("This string will add \t a tab -­
 a big space")
# \t will add a tab -­
 big space
Out [ ]:
This string will be put
on two lines
This string will add    a tab -­
 a big space
	 92	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In the examples above, putting a backslash in front of n assigns the com­
bination \n a special meaning, which is to add a new line to the string; putting 
a backslash in front of t assigns the combination \t a special meaning, which 
is to add a tab (a number of whitespaces) to the string. The next example uses 
backslash to escape the quotation from its original meaning defined in Python.
In [ ]:
print("This is \"President\" quoted")
# \" puts quotation marks in a string
Out [ ]:
This is "President" quoted
Table 2-­
2: ASCII table showing the codes of characters
Dec
Char
Dec
Char
Dec
Char
Dec
Char
0
NUL (null)
32
SPACE
64
@
96
`
1
SOH (start of heading)
33
!
65
A
97
a
2
STX (start of text)
34
"
66
B
98
b
3
ETX (end of text)
35
#
67
C
99
c
4
EOT (end of 
transmission)
36
$
68
D
100
d
5
ENQ (enquiry)
37
%
69
E
101
e
6
ACK (acknowledge)
38
&
70
F
102
f
7
BEL (bell)
39
'
71
G
103
g
8
BS (backspace)
40
(
72
v
104
h
9
TAB (horizontal tab)
41
)
73
I
105
i
10
LF (NL line feed, new 
line)
42
*
74
J
106
j
11
VT (vertical tab)
43
+
75
K
107
k
12
FF (NP form feed, new 
page)
44
,
76
L
108
l
13
CR (carriage return)
45
-­
77
M
109
m
14
SO (shift out)
46
.
78
N
110
n
	
Essential Building Blocks of Computer Programs	
93
 https://doi.org/10.15215/remix/9781998944088.01
Dec
Char
Dec
Char
Dec
Char
Dec
Char
15
SI (shift in)
47
/
79
O
111
o
16
DLE (data link escape)
48
0
80
P
112
p
17
DC1 (device control 1)
49
1
81
Q
113
q
18
DC2 (device control 2)
50
2
82
R
114
r
19
DC3 (device control 3)
51
3
83
S
115
s
20
DC4 (device control 4)
52
4
84
T
116
t
21
NAK (negative 
acknowledge)
53
5
85
U
117
u
22
SYN (synchronous 
idle)
54
6
86
V
118
v
23
ETB (end of trans. 
block)
55
7
87
W
119
w
24
CAN (cancel)
56
8
88
X
120
x
25
EM (end of medium)
57
9
89
Y
121
y
26
SUB (substitute)
58
:
90
Z
122
z
27
ESC (escape)
59
;
91
[
123
{
28
FS (file separator)
60
<
92
\
124
|
29
GS (group separator)
61
=
93
]
125
}
30
RS (record separator)
62
>
94
^
126
~
31
US (unit separator)
63
?
95
_
127
DEL
These 128 ASCII characters, including both printable and unprintable ones, 
are defined for communication in English between humans and machines. 
There is an extended set of ASCII characters defined for communication in 
other Western languages such as German, French, and others.
To enable communication between human and machines in languages 
such as Chinese, Unicode was designed. Details about Unicode can be found at 
https://​
unicode​
.org/. For information on how Unicode is used in Python, read 
the article at https://​
docs​
.python​
.org/​
3/​
howto/​
unicode​
.html.
Table 2-­
2: ASCII table showing the codes of characters (continued)
	 94	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In earlier versions of Python, if you want to use a non-­
ASCII character 
encoded in Unicode in a string, you need to know the code, assuming it is 
NNNN, and use escape sequence \uNNNN within the string to represent 
the non-­
ASCII character. You can also use built-­
in function chr(M) to get 
a one-­
character string encoded in Unicode, where M is code of the char­
acter in the Unicode table. The reverse built-­
in function order(Unicode 
character) is used to get the code of the Unicode character in the Unicode 

table.
In Python 3.0, however, the default encoding of Python programs was 
changed to UTF-­
8, which includes Unicode, so you can simply include any 
Unicode character in a string and PVM will recognize and handle it correctly, 
as shown in the following example:
In [ ]:
print("秦时明月汉时关 can be directly included in a 
string")
print(f"though you can still use chr(31206) for 
{chr(31206)}, chr(27721) for {chr(27721)}")
Out [ ]:
秦时明月汉时关 can be directly included in a string
though you can still use chr(31206) for 秦, chr(27721) for 汉
When representing strings, some prefixes or flags can be put in front 

of the opening quotation mark. These flags are also called prefixes, used before 
the opening quote of a string. These prefixes are listed in Table 2-­
3 with their 
meaning and some coding samples.
Table 2-­
3: Prefixes used for string formatting and construction
Flag
What it does
Code sample in Jupyter Notebook
F, f
F/f for formatting. Causes the 
evaluation of expressions 
enclosed within {}.
In:
name="John"
s0 = f"Your name is {name}."
print(s0)
Out:
Your name is John.
R, r
R/r for raw string. Nothing in 
the string is evaluated, not 
even \".
In:
name = "John"
s0 = r"Your name is\t {name} 
\""
print(s0)
Out:
Your name is \t {name} \"
	
Essential Building Blocks of Computer Programs	
95
 https://doi.org/10.15215/remix/9781998944088.01
Flag
What it does
Code sample in Jupyter Notebook
U, u
U/u for Unicode, indicating 
Unicode literals in a string. 
It has no effect in Python 
3 since Python 3’s default 
coding is UTF-­
8, which 
includes Unicode.
In:
print(u"秦时明月汉时关", end=":")
print("秦时明月汉时关")
Out:
秦时明月汉时关:秦时明月汉时关
B, b
B/b for byte. Literals in the 
string become byte literals, 
and anything outside of 
ASCII table must be escaped 
with backslash.
In:
print(b"2005-­
05-­
26-­
10458.68")
Out:
b"2005-­
05-­
26-­
10458.68"
LIST
List is a very useful compound data type built into Python. A list of elements, 
which can be different types of data, is enclosed in square brackets. The fol­
lowing are some examples of lists:
[1, 2, 3, 4, 5]
['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']
In Python, an element in a list can be any type of data or object, to use 
a more common computer-­
science term. So an element can be a list too, 
such as,
[[1,2,3],[4, 5, 6]]
Assume that
week = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 
'Friday', 'Saturday', 'Sunday']
The term week[0] refers to the first element of the list, and week[1] refers to the 

second element of the list, where 0 and 1 are called index. An index can be 
negative as well, meaning an item counted from the end of the list. For example, 
week[-­
1] will be Sunday, the first item from the end; week[-­
2] will be Saturday, 
the second item from the end.
Table 2-­
3: Prefixes used for string formatting and construction 
(continued)
	 96	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
To get a sublist of a list L we use notation L[s: e], where s is the starting point 
in the list, e is the ending point within the list, and the sublist will include all 
items from s till e but excluding the item at e. For example, to get all weekdays 
from the list week, we use week[0,5], as shown below:
In [ ]:
week = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 
'Friday', 'Saturday', 'Sunday']
week[0:5]
Out [ ]:
['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']
Negative indexing becomes convenient when a list, or any sequence, is too 
long to count from the beginning. In the example above, it is much easier to 
count from the end to find out that the weekdays stop right before Saturday, 
whose index is −2, as shown below:
In [ ]:
week = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 
'Friday', 'Saturday', 'Sunday']
week[0:-­
2]
Out [ ]:
['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']
Within the notation of L[s:e], s or e or both may be missing. When s is 
missed, it means the sublist is indexed from the beginning of the list; when e 
is missed, it means the sublist is indexed from the end of the list. So week[:] 
will include all the items of the list week, as shown below:
In [ ]:
week[:]
Out [ ]:
['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
Multiple lists can be joined together with operator +. Assume we have the 
following two lists:
weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 
'Friday']
weekend = ['Saturday', 'Sunday']
We can then combine weekdays and weekend into one list and assign the 
new list to week using operator +, as shown below:
	
Essential Building Blocks of Computer Programs	
97
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
weekdays = ['Monday', 'Tuesday', 'Wednesday', 
'Thursday', 'Friday']
weekend = ['Saturday', 'Sunday']
week = weekdays + weekend
print(week)
Out [ ]:
['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
A copy of a list can be easily made by sublisting all its members, as shown below:
week0 = week[:]
We can create a list from a string using the built-­
in function list():
In [ ]:
l0 = list("How are you?")
print(l0)
Out [ ]:
['H', 'o', 'w', ' ', 'a', 'r', 'e', ' ', 'y', 'o', 'u', '?']
We can also create a list using the built-­
in function list() and range():
In [ ]:
l1 = list(range(10))
l2 = list(range(10, 20))
print(l1, l2)
Out [ ]:
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
We can use the built-­
in function len() to find out how many elements are 
in the list:
In [ ]:
print(len(week))
Out [ ]:
4
TUPLE
Tuple is another type of sequence, but members of a tuple are enclosed in 
parentheses. The following are some sample tuples:
(12, 35)
('Canada', 'Ottawa')
('China', 'Beijing')
	 98	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
You can create a tuple from a list by using the tuple() function. For example,
TPL = TUPLE(WEEK)
This will create a tuple, as shown below:
('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 
'Saturday', 'Sunday')
Similarly, you can create a list from a tuple, as shown below:
week = list(tpl)
Members of a tuple can be accessed in the same way as lists because the 
members are also indexed. For example, tpl[0] refers to Monday.
Moreover, most of the operations used on lists can be applied to tuples, 
except those that make changes to the member items, because tuples are 
immutable.
Why are tuples immutable? You may consider it like this: A tuple is used 
to represent a specific object, such as a point on a line, or even a shape. If any 
member of the tuple is changed, it will refer to a different object. This is the 
same for numbers and strings, which are also immutable. If you change any digit 
of a number, or any character of a string, the number or string will be different.
SET
In Python, a set is a collection of elements or objects enclosed in a pair of 
curly brackets. Like sets in mathematics, members in a set are unordered and 
unindexed. The following are two examples of sets:
grades = {'A', 'A+', 'A−', 'B', 'B+', 'B−', 'C', 'C+', 
'C−', 'D', 'D+', 'D−'}
My_friends = {'John', 'Jack', 'Jim', 'Jerry', 'Jeromy'}
You can use built-­
in function set() to build a set from a list or tuple:
week_set = set(('Monday', 'Tuesday', 'Wednesday', 
'Thursday', 'Friday', 'Saturday', 'Sunday'))
Built-­
in functions set(), list(), tuple(), float(), int(), str() are also called con­
structors or converters, because they are used to construct or convert to one 
respective type of data from another type.
	
Essential Building Blocks of Computer Programs	
99
 https://doi.org/10.15215/remix/9781998944088.01
You can use membership operator in to test if an object is a member of a 
set. For example,
'John' in My_friends
will give you a True value because John is a member of set My_friends con­
structed above.
You can use built-­
in function len() to get the size of a set—­
that is, how many 
members are in the set. So len(grades) will be 12.
DICTIONARY
In Python, a dictionary is a collection of comma-­
separated key-­
value pairs 
enclosed in curly brackets and separated by a colon :. The members of a dic­
tionary are unordered and unindexed. The following is an example:
In [ ]:
weekday = {'Mon':'Monday', 'Tue':'Tuesday', 
'Wed':'Wednesday', 'Thu':'Thursday', 'Fri':'Friday'}
print(weekday['Mon'], ' of ', weekday)
Out [ ]:
Monday of {'Mon': 'Monday', 'Tue': 'Tuesday', 'Wed': 'Wednesday', 'Thu': 
'Thursday', 'Fri': 'Friday'}
Because the keys are used to retrieve the values, each key must be unique 
within a dictionary. For example, we use Weekday['Mon'] to retrieve its corres­
ponding value, Monday.
In this case, you can also use integer numbers as keys, as shown below:
In [ ]:
weekday = {1:'Monday', 2:'Tuesday', 3:'Wednesday', 
4:'Thursday', 5:'Friday'}
print(weekday[1], ' of ', weekday)
Out [ ]:
Monday of {1: 'Monday', 2: 'Tuesday', 3: 'Wednesday', 4: 'Thursday', 5: 
'Friday'}
OBJECT
Although you can code almost any application in Python without object-­
oriented 
thinking, you should be aware that Python fully supports object-­
oriented pro­
gramming. In fact, Python treats everything as an object, including classes, 
functions, and modules. For example, numbers are treated as objects in the 
following statements:
	100	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
print((2.35).hex())
print((23).bit_length())
Out [ ]:
0x1.2cccccccccccdp+1
5
There are some special types of objects in Python, as shown in Table 2-­
4.
Table 2-­
4: Types of objects in Python
Name
Meaning
Example of usage
type
Because in Python everything 
is an object, so are classes, 
whose class is type, which is 
again an object as well as a 
special object.
It has no real usage in 
programming but is rather a 
philosophical and ideological 
concept.
None
An object representing “no 
value.” It is the only object of 
data type NoneType. For a 
logical expression, None is the 
same as 0, null, empty string, 
and False.
In:
if not None:
  print('there is no 
value')
Out:
There is no value
file
A file object can be created 
by calling the file() or open() 
methods, which allow us to 
use, access, and manipulate 
all accessible files.
f = open("resume.xml", "r")
function
In Python, functions are first-­
class objects and can be 
passed as arguments in 
another function call.
sort(method, data_list)
module
A special type of object that all 
modules belong to.
It is more a philosophical and 
ideological concept.
class
A type of all classes.
It is more a philosophical and 
ideological concept.
class Instance
An individual object of a given 
class.
It is more a philosophical and 
ideological concept.
method
A method of a given class.
It is more a philosophical and 
ideological concept.
code
A code object is the internal 
representation of a piece of 
runnable Python code.
It is used in internal Python 
program running.
	
Essential Building Blocks of Computer Programs	
101
 https://doi.org/10.15215/remix/9781998944088.01
Name
Meaning
Example of usage
frame
A table containing all the local 
variables.
It is used in function calling.
traceback
A special object for exception 
handling.
It provides an interface to 
extract, format, and print stack 
traces of Python programs, 
especially when an exception 
is raised.
ellipsis
A single object called ellipsis, a 
built-­
in name in Python 3.
It is rarely used except in slicing.
Variables and Constants
Data values, variables, and constants are important constructs of any pro­
gramming language. We have presented all standard simple or primary data 
types and compound data types and their values in the previous section. In the 
following section, we will study variables and constants.
VARIABLES
A variable is a name that identifies a location in computer memory to store 
data. A variable must conform to the rules of naming discussed earlier in this 
section, and it also must not be used for other purposes within the same con­
text of the program. For example, you cannot use reserved words or keywords 
as variables.
An important operation on a variable is to assign a value to it or put a value 
into the memory location identified by the variable. In Python, this is done by 
using the assignment operator =.
For example, the following statement assigns COMP 218 to the variable course, 
assigns Smith to the variable student, and assigns 99 to the variable grade:
In [ ]:
course = 'COMP 218'
student = 'Smith'
grade = 99
print("course is {}, student is {}, grade is {}".
format(course, student, grade))
Out [ ]:
course is COMP 218, student is Smith, grade is 99
Table 2-­
4: Types of objects in Python (continued)
	102	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Unlike other programming languages, in Python, there is no need to declare 
its type before a variable is introduced and used in your program for the first 
time. Its type is determined by the value assigned to it. In the above example, 
the type of grade is integer, because 99 is an integer.
In [ ]:
type(grade)
Out [ ]:
int
You may convert the value of a variable into another type using specific 
built-­
in functions, such as int(), float(), str(), etc.
In [ ]:
marks = 90.8   # assign float mark to variable marks
int_mark = int(marks)   # convert into integer mark and 
assign it to variable int_mark
print(int_mark)
Out [ ]:
90
CODING PRACTICE
Task 1
In a Jupyter Notebook cell, type the following code and run it by hitting 
Shift+Enter to see what you will get:
pi = 3.1415
r = 6
area = pi * r ** 2
print(F"The type of pi is {type(pi)}, and its value is 
{pi}")
print("The type of r is ", type(r), ", its value is ", r)
print("The type of area is {:^10}".
format(str(type(area))), end='')
print(", and its value is {:^12}.".format(area))
Task 2
In a new cell of Jupyter Notebook, write and run the following state­
ments, which calculate the circumference of a circle with radius r = 10, 
and print the result:
	
Essential Building Blocks of Computer Programs	
103
 https://doi.org/10.15215/remix/9781998944088.01
pi = 3.1415
r = 10
circumference = 2 * pi * r
print("The circumference of a circle with radius {:d} is 
{:f}".format(r, circumference))
Please note that in Jupyter Notebook, if you need a new cell, simply click 
the plus sign button under the notebook menu.
Please also note that the type of variable area is the same as the type of 
variable pi, but not of variable r. We can check what type the result will be when 
a different arithmetic operator is applied to a pair of numbers of the same or 
different types, as shown in Tables 2-­
5a and 2-­
5b:
Table 2-­
5a: Semantics of operator +, -­
, *
+, -­
, *
integer
float
complex
integer
integer
float
complex
float
float
float
complex
complex
complex
complex
complex
Table 2-­
5b: Semantics of / (division) operator
/
integer
float
complex
integer
float
float
complex
float
float
float
complex
complex
complex
complex
complex
The following coding example in Jupyter Notebook confirms that the result 
will be a complex number when an integer is divided by a complex number:
In [ ]:
i = 12
cx = 23 + 35j
icx = i / cx
print(icx, type(icx))
Out [ ]:
(0.1573546180159635-­
0.2394526795895097j) <class 'complex'>
You may copy and modify the code above to check other combinations in 
Jupyter Notebook.
	104	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
BUILT-­
IN CONSTANTS
We have seen some values of various data types. Some values have special 
meanings in Python. We call them constants. The following table lists all the 
constants you may see and use when programming with Python.
Table 2-­
6: Python built-­
in constants
Constant 
name
Meaning
Code sample in Python 
interactive mode
True
Logical true
>>> x = True
>>> if x:
… print(f"x is {x}")
… 
x is True
False
Logical false
>>> x = False
>>> if not x:
… print(f"x is {x}")
… 
x is False
None
No value assigned
>>> x = None
>>> if not x:
… print(f"{x} is treated 
as False")
… 
None is treated as False
Ellipsis
Same as …, often used in slicing 
multiple dimensional arrays
>>> Ellipsis == …
True
>>> Ellipsis is …
__debug__
Contains True if Python is started 
without the -­
O option
C:\Users\comp218>python 
-­
O
Python 3.7.2
>>> __debug__
False
quit
Contains information displayed 
when Python quits and 
terminates
>>> quit
Use quit() or 
Ctrl+Z+Enter to exit
exit
Contains information displayed 
when Python quits and 
terminates
>>> exit
Use exit() or 
Ctrl+Z+Enter to exit
	
Essential Building Blocks of Computer Programs	
105
 https://doi.org/10.15215/remix/9781998944088.01
Constant 
name
Meaning
Code sample in Python 
interactive mode
copyright
Contains copyright information
>>> copyright
Copyright (c) 2001–­
2018 
Python Software 
Foundation.
All Rights Reserved.
Copyright (c) 2000 
BeOpen.com.
All Rights Reserved.
Copyright (c) 1995–­
2001 
Corporation for 
National Research 
Initiatives.
All Rights Reserved.
Copyright (c) 1991–­
1995 
Stichting Mathematisch 
Centrum, Amsterdam.
All Rights Reserved.
credits
Contains credit information
>>> credits
Thanks to CWI, CNRI, 
BeOpen.com, Zope 
Corporation and a 
cast of thousands 
for supporting Python 
development. See 
www.python.org for more 
information.
license
Contains licensing information
>>> license
Type license() to see the 
full license text
__name__
When a Python file is started, 
some special variables are 
initialized with specific values, 
and __name__ is one such 
variable. This variable will have 
value __main__ if the Python file 
is started as the main program; 
otherwise, it will contain the 
module name or the function or 
class name if that is imported 
from the module.
C:\comp218> python prime.
py
.
…
>>> __name__
__main__
More information about these constants can be found at https://​
docs​
.python​
.org/​
3/​
library/​
constants​
.html.
Table 2-­
6: Python built-­
in constants (continued)
	106	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Operators
As we learned in previous sections, data are used to represent information, 
while variables and constants are used to refer to data stored in computer 
memory. In the following sections, we will learn about operators and built-­
in 
functions that can be used to process and manipulate data.
ARITHMETIC OPERATORS
Arithmetic operators are used on numbers. These operators are well-­
known. 
Table 2-­
7 provides a list of these operators, their meaning, and code samples you 
may take and practise in Python interactive mode. Please copy only the expres­
sions or statements behind >>>, which is the Python prompt for your input.
Table 2-­
7: Arithmetic operators
Operator
Operation
Code samples in Python 
interactive mode
+
Add two operands
or unary plus
+ operator can be redefined in a 
class for its objects defining 
__add__
>>> x = 10
>>> y = 20
>>> x + y
30
>>> +y
20
−
Subtract right operand from the 
left or unary minus
>>> x, y = 10, 20
>>> x -­
 y
-­
10
>>> -­
y
-­
20
*
Multiply two operands
>>> x, y = 10, 20
>>> y * x
200
/
Divide left operand by the right one 
(always results into float)
>>> x, y = 10, 20
>>> y / x
2.0
//
Floor division—­
division that results 
into integer number by omitting 
all the decimals
>>> x, y = 32, 7
>>> x, y
(32, 7)
>>> x // y
4
%
Modulus—­
remainder of the 
division of left operand by the 
right
>>> x, y = 32, 7
>>> x, y
(32, 7)
>>> x % y
4
	
Essential Building Blocks of Computer Programs	
107
 https://doi.org/10.15215/remix/9781998944088.01
Operator
Operation
Code samples in Python 
interactive mode
**
Exponent—­
left operand raised to 
the power of right
>>> x, y = 32, 7
>>> x, y
(32, 7)
>>> x ** y
34359738368
When two or more of these arithmetic operators are used in an expression, 
the precedence rules you learned in high school or university math courses 
apply. In brief, the precedence rules for all the operators are as follows:
	
1.	 Exponent operation (*) has the highest precedence.
	
2.	 Unary negation (−) is the next.
	
3.	 Multiplication (*), division (/), floor division (//), and modulus operation 
(%) have the same precedence and will be evaluated next unary 
negation.
	
4.	 Addition (+) and subtraction (−) are next, with the same 
precedence.
	
5.	 Comparison operators are next, with the same precedence.
	
6.	 The three logical operators (not, and, or) are next, with not having the 
highest precedence among the three, followed by and, then or.
	
7.	 When operators with equal precedence are present, the expression 
will be evaluated from left to right, hence left association.
	
8.	 Parentheses can be used to change the order of evaluation.
The following are some examples of how expressions are evaluated.
>>> 12 + 3 * 21
75
In the expression 12 + 3 * 21, because * has higher precedence than +, 3 * 
21 is evaluated first to get 63, and then 12 + 63 is evaluated to get 75.
>>> ((23 + 32) // 6 -­
 5 * 7 / 10) * 2 ** 3
44.0
In this example, because ** has the highest precedence, 2 ** 3 is evaluated 
first, to get
Table 2-­
7: Arithmetic operators (continued)
	108	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
((23 + 32) // 6 -­
 5 * 7 / 10) * 8
In this intermediate result, because of parentheses, we will need to evaluate 
((23 + 32) // 6 − 5 * 7 / 10) first, and in this subexpression, because of parentheses, 
23 + 32 will be evaluated first to get 55//6 − 5 * 7 /10. According to the precedence 
rules, this subexpression will be evaluated to 9 − 35 / 10, and then 9 − 3.5 = 5.5. 
Then the expression above will be
5.5 * 8
which is evaluated to be 44.0.
COMPARISON OPERATORS
Comparison operators are used to compare two objects. It is easy to understand 
how they work on numbers and even strings. When a comparison is applied 

to lists or tuples, the comparison will be applied to pairs of items, one from 
each list or tuple, and the final result is True if there are more Trues; otherwise 
it will be False, as shown in the example below:
In [ ]:
l1 = ['apple', 'orange', 'peach']
l2 = ['tomato', 'pepper', 'cabbage']
l1 < l2
Out [ ]:
True
Table 2-­
8 explains all the comparison operators, with samples.
Table 2-­
8: Python comparison operators
Operator
Operation
Code sample in Python 
interactive mode
>
Greater than—­
True if left operand 
is greater than the right
>>> x, y = 23, 53
>>> x > y
False
>>> l1 = ('apple', 
'orange', 'peach')
>>> l2 = ('tomato', 
'pepper', 'cabbage')
>>> l2 > l1
True
	
Essential Building Blocks of Computer Programs	
109
 https://doi.org/10.15215/remix/9781998944088.01
Operator
Operation
Code sample in Python 
interactive mode
<
Less than—­
True if left operand is 
less than the right
>>> x, y = 23, 53
>>> x, y
(23, 53)
>>> x < y
True
>>> s1 = "Albert"
>>> s2 = "Jeremy"
>>> s1 < s2
True
==
Equal to—­
True if both operands 
are equal
>>> x, y = 23, 53
>>> x, y
(23, 53)
>>> x == y
False
!=
Not equal to—­
True if operands are 
not equal
>>> x, y = 23, 53
>>> x, y
(23, 53)
>>> x != y
True
>=
Greater than or equal to—­
True if 
left operand is greater than or 
equal to the right
>>> x, y = 23, 53
>>> x, y
(23, 53)
>>> x >= y
True
<=
Less than or equal to—­
True if left 
operand is less than or equal to 
the right
>>> x, y = 23, 53
>>> x, y
(23, 53)
>>> x <= y
True
LOGICAL OPERATORS
Logical operators are used to form logical expressions. Any expression whose 
value is a Boolean True or False is a logical expression. These will include 
expressions made of comparison operators discussed above. Table 2-­
9 sum­
marize the details of these logical variables.
Table 2-­
8: Python comparison operators (continued)
	110	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Table 2-­
9: Python logical operators
Operator
Meaning
Code sample in Python 
interactive mode
and
A and B
True if both A and B are true
>>> (x, y) = (23, 53)
>>> (m, n) = (12, 9.6)
>>> x, y, m, n
(23, 53, 12, 9.6)
>>> x > y and m > n
False
or
A or B
True if either A or B is true
>>> (x, y) = (23, 53)
>>> (m, n) = (12, 9.6)
>>> x, y, m, n
(23, 53, 12, 9.6)
>>> x > y or m > n
True
not
not A
True if A is false
>>> (x, y) = (23, 53)
>>> x, y
(23, 53)
>>> not x < y
False
Logical expressions are often used in if and while statements, and it is 
important to ensure that the logical expressions used in your programs are 
correctly written. Otherwise, catastrophic results may occur in some real appli­
cations. Common errors in writing logical expressions include:
	
1.	 Using > instead of <, or using < instead of >
	
2.	 Using >= instead of >, or using > instead >=
	
3.	 Using <= instead of <, or using < instead <=
For example, suppose you are writing a program to control the furnace at home, 
and you want to heat the home to 25 degrees Celsius. The code for this should be
if t < 25 : heating()
However, if instead you wrote,
if t > 25 : heating()
the consequence would be either the home will not heat at all (if the initial 
temperature is below 25 when the program starts) or it will overheat (if the 
initial temperature is greater than 25).
	
Essential Building Blocks of Computer Programs	
111
 https://doi.org/10.15215/remix/9781998944088.01
BITWISE OPERATORS
We know that data in computer memory are represented as sequences of bits, 
which are either 1 or 0. Bitwise operators are used to operate bit sequences bit 
by bit. These bitwise operations may look strange to you, but you will appre­
ciate these operations when you need them. Table 2-­
10 provides a summary 
of bitwise operators. Please note that built-­
in function bin() converts data 
into their binary equivalents and returns a string of their binary expressions, 
with a leading 0b.
Table 2-­
10: Python bitwise operators
Operator
Meaning
Code sample in Python 
interactive mode
&
Bitwise and
>>> m, n = 12, 15
>>> bin(m), bin(n)
('0b1100', '0b1111')
>>> bin(m & n)
'0b1100'
|
Bitwise or
>>> bin(m), bin(n)
('0b1100', '0b1111')
>>> bin(m | n)
'0b1111'
~
Bitwise not
>>> ~ m
-­
13
>>> bin(~ m)
'-­
0b1101'
^
Bitwise XOR
>>> bin(m), bin(n)
('0b1100', '0b1111')
>>> bin(m ^ n)
'0b11'
>> 
Bitwise right shift
>>> bin(m)
'0b1100'
>>> bin(m>>2)
'0b11'
<< 
Bitwise left shift
>>> bin(m)
'0b1100'
>>> bin(m<<2)
'0b110000'
	112	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
ASSIGNMENT OPERATORS
In Python, and all programming languages, the assignment operation is one 
of the most important operations because assignment operations store data 
in variables for later use.
In previous sections, we have seen many examples of using the assignment 
operator =, the equal sign. However, Python provides many augmented assign­
ment operators. Table 2-­
11 lists all the assignment operators you can use in 
your Python programs.
Table 2-­
11: Python assignment operators
Operator
Operation
Code samples in Python 
interactive mode
x = e
Expression e is evaluated, and the 
value is assigned to variable x.
Note that in Python and in 
previous code samples, 
assignments can be made to 
more than one variable with one 
statement.
>>> m, n = 23, 12
>>> m, n
(23, 12)
>>> x = m + n
>>> x
35
x += e
Expression x + e is evaluated, 
and the value is assigned to 
variable x.
x = x + e
>>> x, m, n = 35, 23, 12
>>> x, m, n
(35, 23, 12)
>>> x += m + n
>>> x
70
>>> x, m, n
(70, 23, 12)
x = e
Expression x − e is evaluated, 
and the value is assigned to 
variable x.
x = x − e
>>> x, m, n = (70, 23, 
12)
>>> x, m, n
(70, 23, 12)
>>> x -­
= m + n
>>> x, m, n
(35, 23, 12)
x *= e
Expression x * e is evaluated, 
and the value is assigned to 
variable x.
x = x * e
>>> x, m, n = (35, 23, 
12)
>>> x, m, n
(35, 23, 12)
>>> x *= m + n
>>> x, m, n
(1225, 23, 12)
	
Essential Building Blocks of Computer Programs	
113
 https://doi.org/10.15215/remix/9781998944088.01
Operator
Operation
Code samples in Python 
interactive mode
x /= e
Expression x / e is evaluated, 
and the value is assigned to 
variable x.
x = x / e
>>> x, m, n = (1225, 23, 
12)
>>> x, m, n
(1225, 23, 12)
>>> x /= m + n
>>> x, m, n
(35.0, 23, 12)
x %= e
Expression x % e is evaluated, 
and the value is assigned to 
variable x.
x = x % e
>>> x, m, n = (28, 23, 
12)
>>> x, m, n
(28, 23, 12)
>>> x %= m + n
>>> x, m, n
(28, 23, 12)
x //= e
Expression x // e is evaluated, 
and the value is assigned to 
variable x.
x = x // e
>>> x, m, n = 989, 23, 12
>>> x, m, n
(989, 23, 12)
>>> x //= m + n
>>> x, m, n
(28, 23, 12)
x **= e
Expression x ** e is evaluated, 
and the value is assigned to 
variable x.
x = x ** e
>>> x, m, n = 98, 3, 2
>>> x **= m + n
>>> x, m, n
(9039207968, 3, 2)
x &= e
Expression x & e is evaluated, 
and the value is assigned to 
variable x.
x = x & e
>>> x, m, n = 9, 3, 2
>>> bin(x), bin(m), 
bin(n)
('0b1001', '0b11', 
'0b10')
>>> x &= m * n
>>> bin(x), bin(m), 
bin(n)
('0b0', '0b11', '0b10')
x |= e
Expression x | e is evaluated, 
and the value is assigned to 
variable x.
x = x | e
>>> x, m, n = 9, 3, 2
>>> bin(x), bin(m), 
bin(n)
('0b1001', '0b11', 
'0b10')
>>> x |= m * n
>>> bin(x), bin(m), 
bin(n)
('0b1111', '0b11', 
'0b10')
Table 2-­
11: Python assignment operators (continued)
(continued on next page)
	114	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Operator
Operation
Code samples in Python 
interactive mode
x ^= e
Expression x ^ e is evaluated, 
and the value is assigned to 
variable x.
x = x ^ e
>>> x, m, n = 9, 3, 2
>>> bin(x), bin(m), 
bin(n)
('0b1001', '0b11', 
'0b10')
>>> x ^= m * n
>>> bin(x), bin(m), 
bin(n)
('0b1111', '0b11', 
'0b10')
x >>= e
Expression x >> e is evaluated, 
and the value is assigned to 
variable x.
x = x >> e
>>> x, m, n = 9, 3, 2
>>> bin(x), bin(m), 
bin(n)
('0b1001', '0b11', 
'0b10')
>>> x >>= m * n
>>> bin(x), bin(m), 
bin(n)
('0b0', '0b11', '0b10')
x <<= e
Expression x << e is evaluated, 
and the value is assigned to 
variable x.
x = x << e
>>> x, m, n = 9, 3, 2
>>> bin(x), bin(m), 
bin(n)
('0b1001', '0b11', 
'0b10')
>>> x <<= m * n
>>> bin(x), bin(m), 
bin(n)
('0b1001000000', '0b11', 
'0b10')
CODING PRACTICE
Type the following code to a scratch file in VS Code or a code cell in 
Jupyter Notebook and run. Explain why bin(8 << 2) is equal to bin(8 * 4).
print(bin(8))
print(bin(8 << 2), bin(8 * 4))
Table 2-­
11: Python assignment operators (continued)
	
Essential Building Blocks of Computer Programs	
115
 https://doi.org/10.15215/remix/9781998944088.01
IDENTITY OPERATORS
Identity operators are used to test if two operands, usually two identifiers, 
are identical, which in most implementations of Python means that they are 
referring to the same memory block of the computer. The examples Table 2-­
12 
tell you more about this. Note that in the example, the built-­
in function id(o) is 
used to get the id of object o.
Table 2-­
12: Python identity operators
Operator
Meaning
Example
is
True if the operands are identical 
(refer to the same object)
Note that 3 and 2 + 1 have the 
same id, and so does 6 // 2, but 
not 6 / 2 because 6 / 2 = 3.0, 
which is different from 3.
>>> x = list(range(3))
>>> y = list(range(3))
>>> x, y
([0, 1, 2], [0, 1, 2])
>>> id(x), id(y)
(10049456, 10049016)
>>> x is y
False
>>> id(3)
258398416
>>> id(2 + 1)
258398416
is not
True if the operands are not 
identical (do not refer to the 
same object).
Note that when assigning variable 
y to variable x, the operation 
points x to the same memory 
block y is pointing to (so that the 
two have the id) and shares the 
same memory block. However, 
when a new assignment is 
made to x or y, the two will have 
different ids, unless they both 
hold the same integer or string.
>>> x = list(range(3))
>>> x = y
>>> id(x), id(y)
(10049016, 10049016)
>>> x is y
True
>>> y = list(range(3))
>>> id(x),id(y)
(10090256, 10090336)
>>> x, y
([0, 1, 2], [0, 1, 2])
>>> x is not y
True
SEQUENCE OPERATORS
In 2.1, we learned that sequences include strings, lists, and tuples because 
elements in strings, lists, and tuples are ordered and indexed. Sets and dic­
tionaries are not sequences because elements in dictionaries and sets are not 
ordered, or not in sequence.
Sequence operators are made available for operations on strings, lists and 
tuples, as shown in Table 2-­
13.
	116	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Table 2-­
13: Python sequence operators
Operator
Operation
Code sample in Python 
interactive mode
*
Repeat a sequence such as string, 
list or tuple multiple times
>>> "Python " * 3
'Python Python Python '
>>> [1, 2, 3] * 5
[1, 2, 3, 1, 2, 3, 1, 2, 
3, 1, 2, 3, 1, 2, 3]
+
Join two sequences
>>> [1, 2, 3] + [5, 6, 7]
[1, 2, 3, 5, 6, 7]
[n]
Slice out a single member of the 
sequence
>>> name = 'John'
>>> name[1]
'o'
[n:m]
Slice a sequence start from n to m.
>>> name
'John'
>>> name[1:3]
'oh'
MEMBERSHIP OPERATOR
Membership operators are used to test whether an element is a member of a 
sequence. There are three membership operators in Python, and two of them 
are shown in Table 2-­
14.
Table 2-­
14: Python membership operators
Operator
Operation
Code sample in Python 
interactive mode
v in s
True if value v is found in 
sequence s
>>> l = list(range(10))
>>> l
[0, 1, 2, 3, 4, 5, 6, 7, 
8, 9]
>>> 3 in l
True
>>> 2 + 1 in l
True
>>> 'x' in "Welcome to 
COMP218"
False
	
Essential Building Blocks of Computer Programs	
117
 https://doi.org/10.15215/remix/9781998944088.01
Operator
Operation
Code sample in Python 
interactive mode
v not in s
Checks whether value/variable is 
not found in the sequence
>>> l
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> 30 in l
False
>>> 30 not in l
True
The third membership operator is used to access members of objects, mod­
ules, or packages. It is the dot (.) operator. The example in Table 2-­
15 shows 
how to access a function in module math.
Table 2-­
15: Dot operator
Operator
Operation
Code sample in Python 
interactive mode
p.q
q is a member of p where p and 
q refer to an object (variable, 
constant, function or method 
name), package, or module 
name
>>> import math
>>> type(math)
<class 'module'>
>>> type(math.sqrt)
<class 'builtin_function_
or_method'>
>>> math.sqrt(35)
5.916079783099616
Built-­
In Functions
As with operators, built-­
in functions are also important in processing and 
testing data in programs. As the name implies, built-­
in functions are built into 
Python Virtual Machine (PVM). A built-­
in function can be used directly without 
importing any module or noting what it belongs to.
Built-­
in functions, and functions or methods in general, can be put into two 
categories. One is based on the data they return, whereas the other is based 
on the operations performed, although sometimes the returned data from 
a built-­
in function in the second category may still be useful in subsequent 
executions of the program.
We will first explain built-­
in functions in the first category, followed by 
built-­
in functions in the second category. To best understand these functions, 
read through these built-­
in functions and test the sample code in a Python 
interactive shell or Jupyter Notebook.
Table 2-­
14: Python membership operators (continued)
	118	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
ABS(X)
This returns the absolute value of x, which can be any number.
>>> abs(-­
99)
99
>>> abs(-­
b110010)   # a binary number
50
>>> abs(-­
0o32560)   # an octal number
13680
>>> abs(0xdef21a)   # a hexadecimal(16) number
13610970
INT(S, BASE = 10)
This converts a number s in a specific base to an integer in base-­
10. The default 
base is 10. If the base is explicitly given, s must be a string containing a legit­
imate literal for the base.
>>> int(19.9)
19
>>> int("22", 8)   # in the quote must be a legitimate 
literal for base-­
8
18
>>> int('0x123', base = 16)   # a number in base-­
16
291
POW(X, P)
This returns the value of x to the power of p.
>>> pow(2.9, 12.8)
829266.980472172
FLOAT(S)
This converts s to float. s can be a number, or a string of numbers.
>>> float('18.23')
18.23
>>> float(19)
19.0
	
Essential Building Blocks of Computer Programs	
119
 https://doi.org/10.15215/remix/9781998944088.01
MAX(ITERABLE, *[, DEFAULT = OBJ, KEY = FUNC])
MAX(ARG1, ARG2, *ARGS, *[, KEY = FUNC])
These find and return the biggest element from an iterable such as a list, tuple 
or string, or from two or more arguments. The default keyword-­
only argument 
specifies what will be returned if the iterable is empty. The key keyword-­
only 
argument specifies how the maximum is defined if it is out of the ordinary.
>>> max(2, 1, 5, 65, 89)   # variable-­
length list of 
arguments
89
>>> max("this")   # the given sequence is a string
't'
>>> max((2, 3, 5, 1, 78))   # numbers in a tuple
78
>>> max([2, 3, 5, 1, 78])   # numbers in a list
78
MIN(ITERABLE, *[, DEFAULT = OBJ, KEY = FUNC])
MIN(ARG1, ARG2, *ARGS, *[, KEY = FUNC])
These find and return the smallest number from an iterable such as a list, tuple 
or string, or from two or more arguments. The default keyword-­
only argument 
specifies what will be returned if the iterable is empty. The key keyword-­
only 
argument specifies how the minimum is defined if it is out of the ordinary.
>>> min(6, 5, 8, 3, 2)
2
>>> min([2, 3, 5, 1, 78])   # numbers in a list
>>> min([], default = 0)   # 0 will be returned because 
the list is empty
0
ROUND(F)
This rounds number f to the closest integer and returns the integer.
>>> round(3.1415926)
3
ORD(C)
This finds and returns the order of a character, as a single char string, in the 
ASCII table.
	120	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> ord('c')
99
SUM(…)
This calculates and returns the sum of numbers in a list, a tuple, or a range() call.
>>> sum([23, 56, 67, 12, 89])
247
>>> sum((23, 56, 67, 12, 89))
247
>>> sum(range(88))
3828
SET(S)
This converts a set from a list or tuple.
>>> set([23, 56, 67, 12, 89])
{23, 56, 67, 12, 89}
DICT()
DICT(ITERABLE)
DICT(A = V,…)
These convert an empty dictionary, construct a dictionary from the iterable of 
(k, v) tuples, and from key=value pairs, respectively.
>>> dict()
{}
>>> dict([(1,'Turing'), (2,'Bool'), (3,'Babbage'), 
(4,'Neumann'), (5,'Knuth')])
{1: 'Turing', 2: 'Bool', 3: 'Babbage', 4: 'Neumann', 5: 
'Knuth'}
>>> dict(a = 1, b = 2, c = 3)
{'a': 1, 'b': 2, 'c': 3}
BIN(N)
This converts a number to its binary equivalence as a string.
>>> bin(98)
'0b1100010'
	
Essential Building Blocks of Computer Programs	
121
 https://doi.org/10.15215/remix/9781998944088.01
HEX(N)
This converts a number to its hex equivalence as a string.
>>> hex(19)
'0x13'
OCT(N)
This converts a number to its oct equivalence as a string.
>>> oct(28)
'0o34'
BOOL(O)
This converts o to Boolean True or False. In Python, 0, '', and None are equiva­
lent to False, everything else is equivalent to True.
>>> bool(1)
True
>>> bool('school')
True
>>> bool(0)
False
TUPLE(S)
This constructs a tuple from a list, a string, or range() call.
>>> tuple("this is tuple")
('t', 'h', 'i', 's', ' ', 'i', 's', ' ', 't', 'u', 'p', 
'l', 'e')
LEN(S)
This returns the length of a sequence.
>>> len(my_tuple)
13
>>> len("I like Python so much!")
22
LIST(S)
This constructs a list from a sequence or range() call.
	122	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> list(range(5))
[0, 1, 2, 3, 4]
RANGE(START, STOP
, STEP)
This returns a sequence of numbers starting from 0 by default, ending right 
before stop and increasing by one step by default.
>>> list(range(1, 9, 2))
[1, 3, 5, 7]
COMPLEX(A, B)
This constructs a complex number from a pair of numbers and returns the 
complex number.
>>> complex(1, 8)
1 + 8j
HASH(S)
This generates a hash for a given string s and returns the hash. One use is for 
transmitting and saving passwords.
>>> hash("Python is a great language for programming")
6145305589036905122
DIVMOD(A, B)
This returns a tuple of the quotient and the remainder of one integer or float 
number divided by another integer or float number.
>>> divmod(23, 5)
(4, 3)
STR(X)
This converts object x literally to a string and returns the converted string.
>>> str([23, 56, 67, 12, 89])
'[23, 56, 67, 12, 89]'
	
Essential Building Blocks of Computer Programs	
123
 https://doi.org/10.15215/remix/9781998944088.01
CHR(N)
This returns the character n with its code in the Unicode table. Note that 0 <= 
n <= 0x10ffff as a legitimate code.
>>> chr(90)
'Z'
>>> chr(99)
'c'
TYPE(O)
TYPE(C, BASES, DICT)
type(o) returns the data type of object o, whereas type(C, bases, dict) will create 
a new type/class whose name is C and whose base classes are in bases, which 

is a tuple, and the dictionary defines the attributes of the new class, with 
assigned values. This gives programmers a way to dynamically define 

classes.
>>> type(list(range(9)))
<class 'list'>
In [ ]:
X = type('X', (object), dict(a = 1, b = 3))   # create 
a new class named X
x = X()   # create an instance of X
print(f'x.a = {x.a}, x.b = {x.b}')
x.a, x.b = 23, 35   # assign values to x's attribute a 
and b
print(f'x.a = {x.a}, x.b = {x.b}')
Out [ ]:
x.a = 1, x.b = 3
x.a = 23, x.b = 35
ALL(ITERABLE)
This returns True if all the elements of iterable are true.
>>> all(range(9))
False
 
>>> all(range(1,9))
True
	124	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
ANY(ITERABLE)
This returns True if any of the arguments true.
>>> any(range(9))
True
>>> any([0,0,0,0])
False
DIR()
DIR(O)
dir() returns a list of names in the current namespace. dir(o) returns a list of 
the attributes of object o.
>>> dir()
['__annotations__', '__builtins__', '__doc__', '__
loader__', '__name__', '__package__', '__spec__']
 
>>> dir(math)
['__doc__', '__loader__', '__name__', '__package__', 
'__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 
'atan2', 'atanh', 'ceil', 'copysign', 'cos', 'cosh', 
'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 
'factorial', 'floor', 'fmod', 'frexp', 'fsum', 
'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 
'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 
'log1p', 'log2', 'modf', 'nan', 'pi', 'pow', 'radians', 
'remainder', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 
'trunc']
NEXT(IT)
This returns the next element of an iterable such as list, string, tuple, and so on.
>>> l=iter(list(range(3,99)))
>>> next(l)
3
>>> next(l)
4
ASCII(O)
This returns a string containing a printable ASCII representation of an object.
	
Essential Building Blocks of Computer Programs	
125
 https://doi.org/10.15215/remix/9781998944088.01
>>> ascii(math)
"< module 'math' (built-­
in)>"
>>> ascii(int)
"<class 'int'>"
ID(O)
This returns object o’s “identity,” which is a unique integer within a given con­
text, usually the address of the object in memory.
>>> i = 10
>>> id(i)   # return the id of variable i
263313728
>>> i *= 98
>>> id(i)   # id is different, but still the same i
2809440
SORTED(S)
This returns a new sorted list of elements in iterable s.
>>> il = [12, 0, 9, 32, 8, 5, 3, 99] # il is a list of 
integers
>>> sorted(il)   # default is to sort in ascending order
[0, 3, 5, 8, 9, 12, 32, 99]
>>> sorted(il, reverse = 1)   # sorted in descending order
[99, 32, 12, 9, 8, 5, 3, 0]
REVERSED(S)
This returns a reversed iterator.
>>> il = [0, 3, 5, 8, 9, 12, 32, 99]
>>> list(reversed(il))
[99, 32, 12, 9, 8, 5, 3, 0]
>>> list(reversed(range(9))) # range(9) return a sequence 
of 0,1,…9
[8, 7, 6, 5, 4, 3, 2, 1, 0]
ENUMERATE(S, START = 0)
This returns a list of tuples from a sequence in which the elements are counted 
and each element is paired with its count to form a tuple.
	126	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> list(enumerate("this is"))   # default value for 
optional argument start is 0
[(0, 't'), (1, 'h'), (2, '€'), (3, 's'), (4, ' '), (5, 
'€'), (6, 's')]
>>> list(enumerate("this is", 2))   # now counting start 
from 2
[(2, 't'), (3, 'h'), (4, '€'), (5, 's'), (6, ' '), (7, 
'€'), (8, 's')]
>>>
EVAL(S, GLOBALS = NONE, LOCALS = NONE, /)
This evaluates the expression in s as a string or a compiled Python code in s 
and returns the value. Global and local namespaces can be specified for the 
expression or code object using the keyword arguments.
>>> eval("1 / (1 + (1 / math.e) ** 12)")
0.9999938558253978
EXEC(S)
This executes the statement in string s and provides a way to dynamically 
execute the Python code.
>>> exec("print('Hello World!')")
Hello World!
In [ ]:
def cubbie(n):
  return n * n * n
src = "print(cubbie(23))"
exec(src)
Out [ ]:
12167
ZIP(*ITERABLES)
This returns a list of tuples by taking one element from each of the iterables 
to make a tuple until reaching the end of the shortest iterable, and then 
returning the tuple. In Python, *p notation means p takes multiple argu­
ments. In this case, multiple iterables such as lists, tuples, or strings are 

expected.
	
Essential Building Blocks of Computer Programs	
127
 https://doi.org/10.15215/remix/9781998944088.01
>>> grade_n = [50, 70, 80, 90, 100]
>>> grade_c = ['F', 'D', 'C','B', 'A']
>>> list(zip(grade_n, grade_c))
[(50, 'F'), (70, 'D'), (80, 'C'), (90, 'B'), (100, 'A')]
In [ ]:
chars = [chr(i) for i in range(32,97)] # a list of chars
asc_table = zip(range(32,97), chars)
for coding in asc_table:
  print(coding)
Out [ ]:
(32, ' ') (33, '!') (34, '"') (35, '#') (36, '$') (37, '%') (38, '&') (39, "'")(40, '(') (41, ')') 
(42, '*') (43, '+') (44, ',') (45, '-­
') (46, '.') (47, '/') (48, '0') (49, '1') (50, '2') (51, 
'3') (52, '4') (53, '5') (54, '6') (55, '7') (56, '8') (57, '9') (58, ':') (59, ';') (60, '<') 
(61, '=') (62, '>') (63, '?') (64, '@') (65, 'A') (66, 'B') (67, 'C') (68, 'D') (69, 'E') 
(70, 'F') (71, 'G') (72, 'H') (73, 'I') (74, 'J') (75, 'K') (76, 'L
') (77, 'M') (78, 'N') 
(79, 'O') (80, 'P') (81, 'Q') (82, 'R') (83, 'S') (84, 'T') (85, 'U') (86, 'V') (87, 'W') 
(88, 'X') (89, 'Y') (90, 'Z') (91, '[') (92, '\\') (93, ']') (94, '^') (95, '_') (96, '`')
The code sample above prints a portion of ASCII table showing the codes 
from 32 to 96 and their corresponding characters. It is only to show how zip 
function is used. There is a much simpler way to print such a table using just 
one for loop.
MAP(F, *ITERABLES)
This applies function f to every item of an iterable and returns the resulted 
iterator.
>>> import math
>>> list(map(math.sqrt, range(17))
[0.0, 1.0, 1.4142135623730951, 1.7320508075688772, 2.0, 
2.23606797749979, 2.449489742783178]
>>> list(map(sum, ([1, 2, 3], [4, 5, 6], [7, 8, 9, 10])))
[6, 15, 34]
GETATTR(O, ATTR)
This returns the value of object o’s attribute attr, the same as o.attr.
>>> getattr(math, 'sqrt')
<built-­
in function sqrt>
>>> getattr(math, 'e')
2.718281828459045
	128	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
HASATTR(O, ATTR)
This tests if object o has attribute attr and returns True if it does.
>>> hasattr(math, 'e')
True
>>> hasattr(math, 'sqrt')
True
>>> hasattr(math, 'power')
False
SETATTR(O, A, V)
This sets or adds an attribute a to object o and assigns value v to the attribute.
>>> class Student:   # defining a class named Student. By 
convention, class names should be capitalized
…pass   # this defines a class without any attribute
…
>>> s1 = Student()   # create an instance of Student
>>> setattr(s1, 'name', 'John')   # add an attribute 
called name, and assign 'John' to it
>>> s1​
.name
'John'
>>> hasattr(s1, 'name')
True
DELATTR(O, A)
This deletes attribute a from object o.
>>> delattr(s1, 'name') # delete attribute name from 
object s1
>>> hasattr(s1, 'name') # check if s1 has attribute name
False
ISINSTANCE(O, C)
This returns True if o is an instance of class c or a subclass of c.
>>> class Student:
…pass
…
>>> s1 = Student()
	
Essential Building Blocks of Computer Programs	
129
 https://doi.org/10.15215/remix/9781998944088.01
>>> isinstance(s1, Student)
True
ISSUBCLASS(C, C)
This returns True if class c is a subclass of C.
>>> class Graduate(student):
…pass
…
>>> issubclass(Graduate, Student)
True
REPR(O)
This returns a string representation of object o.
>>> repr(Graduate)
"<class "__main__.graduate'>'
FILTER(F, ITERATOR)
This returns an iterator containing only the elements of the iterable for which 
the function returns true.
>>> def even(n):
…return not n%2 # return True if n can be divided by 2
…
>>> list(filter(even, range(9)))   # odd numbers will be 
taken out
[0, 2, 4, 6, 8]
CALLABLE(O)
This returns True if o is a callable object such as a defined function.
>>> callable(even)   # it will return True since even is 
defined
True
LOCALS()
This updates and returns a dictionary of local names/symbols.
	130	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> locals()
{'__name__': '__main__', '__doc__': None, '__package__': 
None, '__loader__': <class '_frozen_importlib.
BuiltinImporter'>, '__spec__': None, '__annotations__': 
{}, '__builtins__': <module 'builtins' (built-­
in)>, 
'math': <module 'math' (built-­
in)>, 'l': <list_iterator 
object at 0x00370230>, 'student': <class '__main__.
student'>, 's1': <__main__.student object at 0x00CE3DB0>, 
'graduate': <class '__main__.graduate'>, 'even': 
<function even at 0x0029F7C8>}
VARS()
VARS(O)
vars() returns the same as locals(), whereas vars(o) returns the _dict_ attribute 
of object o.
>>> setattr(s1, 'name', 'John')
>>> vars(s1)
{'name': 'John'}
GLOBALS()
This updates and returns a dictionary of global names/symbols in the current scope.
>>> globals()
{'__name__': '__main__', '__doc__': None, '__package__': 
None, '__loader__': <class '_frozen_importlib.
BuiltinImporter'>, '__spec__': None, '__annotations__': 
{}, '__builtins__': <module 'builtins' (built-­
in)>, 
'math': <module 'math' (built-­
in)>, 'student': <class 
'__main__.student'>, 's1': <__main__.student object at 
0x00CE3DB0>, 'graduate': <class '__main__.graduate'>, 
'even': <function even at 0x0029F7C8>}
BYTEARRAY([SOURCE[, ENCODING[, ERRORS]]])
This returns a bytearray object which is an array of the given bytes.
>>> s = "Hello Python lover!"
>>> barry = bytearray(s, 'utf-­
8')
>>> print(barry)
bytearray(b'Hello Python lover!')
	
Essential Building Blocks of Computer Programs	
131
 https://doi.org/10.15215/remix/9781998944088.01
BYTES([SOURCE[, ENCODING[, ERRORS]]])
>>> bs = bytes(s, 'utf-­
8')
>>> print(bs)
b'Hello Python lover!'
BREAKPOINT(*ARGS, **KWS)
This function break the program and takes it into debug mode, calls sys.
breakpointhook(), and passes a list of arguments (args) and a list of keyword 
arguments (**kws) to the system function.
@CLASSMETHOD
The at sign @ is called a decorator in Python. This particular decorator is used to 
declare a method as class method, which receives the class as its first argument.
# define a class Person
class Person:
    # define a class attribute
    species = "human"
    # define an instance method
    def __init__(self, name, age):
        self​
.name = name
        self.age = age
    # define a class method using the @classmethod 
decorator
    @classmethod
    def from_birth_year(cls, name, birth_year):
        # calculate the age from the birth year
        age = 2023 -­
 birth_year
        # return a new instance of Person with the given 
name and age
        return cls(name, age)
# create an instance of Person using the class method
p1 = Person.from_birth_year("Alice", 1995)
# print the instance attributes
print​
(p1​
.name) # output: Alice
print(p1.age) # output: 28
print(p1.species) # output: human
	132	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The code above was taken from a code cell in Jupyter Notebook. The output 
is as follows when you hit the Ctrl+Enter key to run the code:
Alice
28
Human
COMPILE(SOURCE, FILENAME, MODE, FLAGS = 0, DONT_INHERIT 
= FALSE, OPTIMIZE = −1)
This is used to compile the source into a code that can be executed using eval() 
or exec().
FORMAT(VALUE[, FORMAT_SPEC])
This is used to convert a value to a “formatted” representation, as controlled 
by format_spec.
>>> print("Modern computers have over {h:3d} years of 
history".format(h = 80))
Modern computers have over 80 years of history
FROZENSET([ITERABLE])
This returns a new frozenset object, with the option to display it with elements 
taken from an iterable. frozenset is also a built-­
in class.
>>> l = list(range(10))
>>> print(frozenset(l))
frozenset({0, 1, 2, 3, 4, 5, 6, 7, 8, 9}) # {…} is 
a set
HELP([OBJECT])
This invokes the built-­
in help system on the object.
>>> help(frozenset)
Using help on class frozenset in module builtins displays the following:
class frozenset(object)
 |  frozenset() -­
> empty frozenset object
 |  frozenset(iterable) -­
> frozenset object
 |
	
Essential Building Blocks of Computer Programs	
133
 https://doi.org/10.15215/remix/9781998944088.01
 |  Build an immutable unordered collection of unique 
elements.
 |…
.
INPUT([PROMPT])
This is used to read a line from input, convert it to a string with trailing newline 
characters stripped, and return the string. The optional prompt argument will 
be displayed without a trailing newline character so that the cursor will just 
wait at the end of the prompt for input.
>>> s = input("please give me an integer:")
please give me an integer:
ITER(OBJECT[, SENTINEL])
This returns an iterator object. If the second argument doesn’t exist, the first 
argument must be a collection object.
>>> for c in range(6): print(next(l))
…
P
y
t
h
o
n
MEMORYVIEW(OBJ)
This returns a “memory view” object of obj. Note that obj must be a bytes-­
like 
object.
>>> mv = memoryview(b"Hello Python Lover")
>>> print(mv)
<memory at 0x000001B932AD4A00>
OBJECT
This returns a new featureless object, a base for all classes.
>>> O = object
>>> print(O)
<class 'object'>
	134	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
OPEN(FILE, MODE = 'R', BUFFERING = −1, ENCODING = NONE, 
ERRORS = NONE, NEWLINE = NONE, CLOSEFD = TRUE, 
OPENER = NONE)
This opens the file in the desired mode and returns a corresponding file object. 
The default mode is read.
>>> f = open('scoresheet.txt', 'w')
The example opens a file named scoresheet.txt for writing and assigns the 
handle to f.
PRINT(*OBJECTS, SEP = ' ', END = '\N', FILE = SYS.STDOUT, 
FLUSH = FALSE)
This prints objects to the text stream file, separated by separator and followed by 
end. sep, end, file, and flush, if present, must be given as keyword arguments.
>>> print("Hello Python Lover!")
Hello Python Lover!
PROPERTY(FGET = NONE, FSET = NONE, FDEL = NONE, 
DOC = NONE)
This returns a property attribute. fget, sfet, and fdel take functions for getting, 
setting, and deleting an attribute value.
SLICE(STOP)
SLICE(START, STOP[, STEP])
These return a slice object representing the set of indices specified by 
range(start, stop, step).
>>> s = "Hello Python Lover!"
>>> slicing = slice(3)   # slicing the first 3 items out 
of an object
>>> print(s[slicing])   # this will take the first three 
characters from the s
Hel
@STATICMETHOD
This function decorator is used to declare a method as static. A static method 
can be called on the class or an instance.
	
Essential Building Blocks of Computer Programs	
135
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
class FTool():
    @staticmethod
    def percentage(a, b):
        return a/b
r = FTool.percentage(13, 265)
print(f"{13}/{256} is {r}")
Out [ ]:
13/256 is 0.04905660377358491
SUPER([TYPE[, OBJECT-­
OR-­
TYPE]])
This returns a proxy object that delegates method calls to a parent or sibling 
type class. It is used for accessing inherited methods that have been overridden 
in a class.
In [ ]:
class FTool():
    @staticmethod
    def percentage(a, b):
        return a/b
print(super(FTool))
Out [ ]:
<super: <class 'FTool'>, NULL>
The superclass is NULL because FTool is not a subclass of any class except 
object, which doesn’t count.
Expressions
Expressions are important program constructs. An expression is made up of 
data items, variables, constants, and function calls joined by proper operators. 
The precedencies of the operators are as follows:
	
1.	 Within arithmetic operators, other operators take precedence over 
addition and subtraction.
	
2.	 Arithmetic operators take precedence over comparison operators.
	
3.	 Membership operators, identity operators, and comparison operators 
take precedence over logic operators.
	
4.	 Among logic operators, the order of precedence, from high to low, is 
not > and > or.
	136	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
CODING ALERT
Python language is case-­
sensitive. Be sure to use the right case when 
typing!
Expressions are used almost everywhere in a program and will be evaluated 
to a value or object in a general term. According to the type of the value or object 
from evaluation, an expression can be any of the following.
ARITHMETIC EXPRESSIONS
An arithmetic expression’s value is always one of the following: an integer, 
float, or complex. An arithmetic expression can be made of data, variables, 
function calls, and arithmetic operators. When mixed data types appeared in 
an expression, the value type of the expression will be the most general data 
type. For example, the value of 3 + 5.6 will be a float number.
STRING EXPRESSIONS
The string expression’s value is a string. String expressions are made of strings, 
string operators, functions and methods that return a string.
BOOLEAN EXPRESSIONS
The Boolean expression’s value is either True or False. Boolean expressions 
can be made of data, comparison operators, and logical operators. Note that 
although Python has True and False defined as logical true and false, it treats 
0, None, empty string, empty list, empty tuple, set, and dictionary as False and 
treats everything else as True.
OTHER EXPRESSIONS
The values of some expressions may be a list, tuple, set, dictionary or even a 
complex object. For example, some functions and methods can return a list or 
an object of a user-­
defined class, and the operator + can be used to combine 
two strings or lists together.
The following are some examples of expressions in Python:
12 + 35.6 -­
 36 * 3 + x   # integer and float numbers can 
be mixed
235 + x ** k   # 235 plus x to the power of k
2 < j and j in list_x   # 2 is less than j and j is a 
member of list x
	
Essential Building Blocks of Computer Programs	
137
 https://doi.org/10.15215/remix/9781998944088.01
Expressions are often used on the right-­
side of an assignment operator, 
such as
total = a1 + a2 + a3
i *= j + 2   # the same as i = i * (j + 2)
CODING ALERT
In Python, # is used to add end-­
of-­
line comments. Anything behind # is 
ignored by PVM.
CODING PRACTICE
Within VS Code, create a new Jupyter Notebook and rename it 
section-­
2.1, or double-­
click the notebook name on the left-­
hand file 
navigation area to open the notebook if you have already created one. 
In a cell, type the following code and hit Shift+Enter to run the code. 
Then manually evaluate the expression within the curly braces of the 
print statement and compare your result to the one given by the code. 
Explain why the results are different.
x, y = 10.23, 5.2
m, n = 27, 8
print(f'{x * y + 27 // n}')
2.2 Higher-­
Level Constructs of Python Programs
The constructs you learned in section 2.1 are small and meant to be used as 
parts of bigger ones. The big constructs of programs are called statements, 
which give explicit instructions to computers to act upon.
Structure of Python Programs
Before diving into the details of writing statements in Python, this section will 
first look at the general structure of a Python program and the coding style 
widely agreed upon among the Python community, which will make it so the 
programs that you write are readable to others.
For a simple application, a single Python file (with py as its extension) may 
be enough to contain all the program code needed to implement the application; 
	138	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
for a more complex application, however, several or even hundreds of Python 
files may be needed. Of these files, there will be only one Python file defin­
ing the starting point of the program that implements the application, while 
all other files are used as modules to be imported into the main Python file, 
either directly or indirectly. So essentially, the relationships of all the Python 
files used for an application can be depicted as a tree in which the root is the 
main Python file.
The modules used directly or indirectly by the main Python program may 
be from the standard libraries installed with Python or from those installed 
later using the conda or pip command as needed.
Regarding coding style, see PEP 8: Style Guide for Python Code (https://​
pep8​
.org/), which describes in great detail how Python code should be writ­
ten. Read it thoroughly and review it whenever you are unsure. Below are 
the highlights:
	
1.	 A Python program/script file should begin with a docstring as the 
main documentation of the program file, stating the application 
and functionality of the program, as well as the author and revision 
history.
	
2.	 In a script file, use double blank lines to separate the actual program 
code from the documentation section at the beginning of the file.
	
3.	 Also use double blank lines to separate top-­
level function and class 
definitions.
	
4.	 Use a single blank line to surround the definition of a method in a 
class definition.
import
import
import
import
import
import
Main PY
ﬁle
Module 1
Module 2
Module m
Module 11
Module 21
Module m1
Figure 2-­
5: Illustration of the structure of files for a Python application
	
Essential Building Blocks of Computer Programs	
139
 https://doi.org/10.15215/remix/9781998944088.01
	
5.	 Pay attention to indentation, especially when an expression, a simple 
statement, or the header of a compound statement is too long and 
needs to cross multiple lines.
	
a.	 When an expression or a statement needs a closing brace, bracket, 
or parenthesis mark to complete it, there is no need to escape (\) 
newline at the end of an unfinished line.
	
b.	 When a string needs to cross multiple lines, newline must be 
escaped by putting a backslash at the end of each unfinished 
line.
	
c.	 The four-­
space rule is optional. The next line can be started 
wherever it makes more sense, such as in the column next to the 
opening delimiter.
In addition to the rules of coding, it’s important to maintain a consistent coding 
style and to make sure that the programs not only are easy to read and under­
stand but also look neat and nice.
Documentation and Comments
As mentioned above, some lines of documentation, called docstring, are needed 
at the very beginning of each Python script/program file to state the purpose and 
functionality of the program, who made it and when, and notes for you and others 
who may read the program.
The following sample program calculates the area of a circle for a given 
radius. It shows how docstring is used in the program file.
1
"""
2
This program is used to calculate the area of a circle. It 
will take an input as
3
a radius, then calculate and print out the area.
4
5
File name: circle.py
6
Author: John Doe
7
Date: March 30, 2019
8
Version: 1.0
9
"""
10
11
12
radius = int(input("tell me the radius:"))   # take input 
from user
13
area = 3.14 * radius ** 2   # calculate the area
14
print(f"The area of a circle with radius {radius} is 
{area}")   # print
15
	140	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Please note the triple quotation marks on line 1 and line 9. The triple quota­
tion marks on line 1 mark the start of the docstring, whereas the triple quotation 
marks on line 10 mark the end of the docstring. The quotation marks can 
be single or double, but they must be the same. You can also add docstrings 
for functions, classes, class methods, or other code blocks in the program as 
needed, but the opening triple quotation marks and ending triple quotation 
marks must be indented the same amount as the code block. You will see how 
this should be done in later chapters, with examples.
Please also note the comments starting with a # at the end of lines 13, 14, 
and 15. They are called end-­
of-­
line comments or block notes. An end-­
of-­
line 
comment is usually used to explain what the code on the line does. Everything 
behind the # mark on that line is ignored by Python Virtual Machine (PVM) 
and intended for only humans to read. An end-­
of-­
line comment can also be 
started at the beginning of a line.
The difference between docstrings and end-­
of-­
line comments is that doc­
strings are formal documentation of the program or module and are accessible 
through the built-­
in help() function, with the _doc_ variable automatically 
attached to each module, function, class and method, whereas end-­
of-­
line 
comments are not. As well, utility tools such as pydoc are available for gen­
erating formal documentation for a program or module from the docstrings 
within each Python file. The revised version of program circle​
.py is shown 
below, in which we defined a function named area, with docstrings added to 
the function and the program.
1
"""
2
The purpose: revised circle.py program with more 
docstrings, to demonstrate how docstrings and
3
inline documentation is used in Python programs.
4
5
This program is designed to calculate the area of a circle. 
It takes an input from the user for the radius and
6
calculates and prints out the area.
7
8
File name: circle-­
v2.py
9
Author: John Doe
10
Date: March 30, 2019
11
Version: 1.0
12
"""
13
14
def area(r):
15
"""To calculate the area of a circle for a given 
radius."""
16
  return 3.14 * r ** 2   # calculate the area
	
Essential Building Blocks of Computer Programs	
141
 https://doi.org/10.15215/remix/9781998944088.01
17
"""Add docstring after return statements?"""
18
19
radius = int(input("tell me the radius:"))   # take input 
from user
20
print(f"The area of a circle with radius {radius} is 
{area(radius)}")   # printout
21
22
"""I want to add more docstrings."""
The following are some general rules for program documentation:
	
1.	 A docstring should also be written for every function, class, and public 
method right after the header of the definition. Docstrings must be 
indented the same amount as the suite of function or class definition.
	
2.	 Limit the maximum line length to 79 or 72 characters if the line is part 
of a docstring.
	
3.	 Use inline comments whenever necessary.
	
4.	 Some code may need more than one line of comments, which makes 
it a block comment. A block comment should be written right before 
the code and indented to the same level as the code below.
CODING TRICK
Document! Document! Document!
Documentation is necessary not only for users but for the programmer 
who made the program. The programmer may think they know every­
thing about the program, but time can blur their memory.
Simple Statements
Normally, a simple statement is contained within a single logical line, though 
Python allows several simple statements to appear on one line separated by 
semicolons. There will be examples of this later.
EXPRESSION STATEMENT
Simply put, expression statements in Python programs are just expressions in 
mathematical terms. Any expression can be used as a statement, and PVM will 
evaluate every expression statement, but the result is only displayed in Python 
interactive mode, as shown in the following code sample in the Python Shell:
	142	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Code sample in Python interactive mode
1
2
>>> 2 * 3.14 * 15
3
94.2
4
>>> 3.14 * 15 ** 2
5
706.5
6
>>>
7
8
So if you are using Python in interactive mode, you can simply type expressions 
without using the print statement to see the result of the calculation, just like 
a powerful calculator.
We can also have expression statements in Jupyter Notebook, but when 
there are several expression statements in the same cell, it will only show the 
result of the last expression, as shown in the following example:
In [ ]:
2 * 3.14 * 15
3.14 * 15 ** 2
Out [ ]:
706.5
We mentioned earlier in this subsection that you can also put several simple 
statements on the same line, but you must separate them with semicolons. This 
is shown in the following examples:
Code sample in Python interactive mode
1
2
>>> 2 * 3.14 * 15; 3.14 * 15 ** 2
3
94.2
4
706.5
5
>>> 
6
7
8
The expression statement above can also be given in Jupyter Notebook, as 
shown below. In Jupyter Notebook, however, you have to press Shift+Enter or 
click the play button to run the scripts in an active cell:
	
Essential Building Blocks of Computer Programs	
143
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
2 * 3.14 * 15; 3.14 * 15 ** 2
Out [ ]:
706.5
Again, in Jupyter Notebook, even if multiple expression statements are 
on the same line, only the result of the last expression statement will be 
displayed.
ASSIGNMENT STATEMENT
The assignment statement is one of the most important statements and is used 
most often in programs because it is a common requirement to keep the result 
of computing or information processing in the computer memory for future 
uses. It does so by assigning the result to a variable.
In section 2.1, we saw a list of assignment operators. Formally, an assign­
ment statement is made of a variable on the left and an expression on the right 
of an assignment operator, either = or an augmented one such as +=. We have 
already seen some examples of assignment statements before, but the following 
code sample includes a few more examples:
In [ ]:
d = 15
r = d / 2
x = d * 3.14
a = r * r * 3.14
print(f"diameter = {d}; radius = {r}; circumference = 
{x}; area is {a}")
Out [ ]:
diameter = 15; radius = 7.5; circumference = 47.1; area is 176.625
AUGMENTED ASSIGNMENT
In programming, we often take the value of a variable, perform an operation 
on it, then put the result back to the variable. That is when augmented assign­
ment comes into play.
In section 2.1, we saw several augmented assignment operators. In general, 
for an assignment in the form of
x = x <operator> v
the augmented assignment can be used in the following form:
x <operator>= v
	144	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The following are some examples of augmented assignments:
In [ ]:
y = 10
n = 5
print(f"y is {y}; n is {n}")
y *= n   # y * n is assigned to y; it is equivalent to 
y = y * n
print(f"y is {y}; n is {n}")
n += 2
y /= n
print(f"y is {y}; n is {n}")
Out [ ]:
y is 10; n is 5
y is 50; n is 5
y is 7.142857142857143; n is 7
To understand these augmented assignment statements, we need to consider 
the memory location referred to by a variable, such as y with respect to time. Take 
y *= n as an example. At time t0 before the actual assignment starts, the value 

of y (data stored in the memory referred to by y, which is 10 at time t0) is taken out, 
and multiplied by n, whose value is 5 at time t0; then time t1—­
the result, which 
is 50 (from 10 * 5)—­
is stored in the memory location referred to by variable y.
CODING ALERT
The number of value items must be enough for the variables to be 
assigned.
MULTIPLE ASSIGNMENTS
Also, for convenience and efficiency, you can assign values to multiple variables 
in a single assignment statement. There are several ways of doing multiple 
assignments, as shown in the following examples:
In [ ]:
x, y = 1, 2   # assign 1 to x, assign 2 to y
(x, y) = (1, 2)   # it is the same as x, y = 1, 2
x, y = [1, 2]   # it is the same as x, y = 1, 2
k, *l = [1, 2, 3, 5]   # this will assign 1 to k, and 
assign the rest to l as list, because of *l
x, *y, z = [1, 2, 3, 5, 6, 7]   # this will assign 1 to 
x, 7 to z, [2, 3, 5, 6] to y
print(f"x = {x}; y = {y}; z = {z}")
Out [ ]:
x = 1; y = [2, 3, 5, 6]; z = 7
	
Essential Building Blocks of Computer Programs	
145
 https://doi.org/10.15215/remix/9781998944088.01
In the last example above, *l, *y tells PVM that variable l and y can take a 
variable-­
length list of values.
CONDITIONAL ASSIGNMENTS
Additionally, in Python, you may even assign different values to a variable under 
different conditions, as shown in the following example:
Code sample in Python interactive mode
1
>>> marks = 90
2
>>> gr = 'pass' if marks >= 60 else 'fail'   # note that 
elif clause does not work on the conditional assignment
3
>>> gr
4
'pass'
5
>>> marks = 50
6
>>> gr = 'pass' if marks >= 60 else 'fail'
7
>>> gr
8
'fail'
As you will see throughout the text, there are many fancy ways of making state­
ments in Python, and that’s why Python is a very powerful language. Indeed, 
the full power of a programming language can only be materialized by the 
best programmers.
ANNOTATED ASSIGNMENT STATEMENT
We know that variables in Python are dynamically typed. Sometimes, however, 
it is nice to indicate what type of data is expected for a variable. In Python, this 
is done by annotating the variable using a colon followed by the name of the 
data type, as shown in the following example:
marks: float = 86.5   # variable marks will hold a float 
number
However, Python will not complain if other types of data are assigned, as 
shown below:
>>> marks: float = "Python"
>>> marks
'Python'
>>>
To annotate the type of value returned from a function, you need to use -­
> fol­
lowed by the data type, right before the colon, as shown in the following example:
	146	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
def literal_grade(marks:float) -­
> str:
  return 'fail' if marks < 60 else 'pass'
print(literal_grade(88))
Out [ ]:
pass
In this example, marks:float determines that a float number is expected for 
marks when calling the function, and -­
> str dictates that a string is to be returned.
It must be made clear that the actual type of a variable is still determined 
by the value it holds, and annotation added to a variable or function doesn’t 
really change the type of the variable or the value returned from a function. 
So annotations are more for programmers as reminders.
PRINT STATEMENT
The print statement is another one of the most important statements. It 

is used to output (to a terminal by default) so that a program can tell human 
users the result of calculations or information processing, the value of an 
object, or the status of the program. The following are some examples of 
print statements:
In [ ]:
print("this is my first print statement.")
print("it will take about ", round(300/110), "hours to 
drive from Edmonton to Calgary")
Out [ ]:
this is my first print statement.
it will take about 3 hours to drive from Edmonton to Calgary
The print statement can evaluate multiple arguments and print out the val­
ues. If the arguments are all constant strings, there will be no need to separate 
them into multiple arguments. Separate arguments are needed only when some 
arguments are expressions, like the round(300/110) in the above example. If 
you do not like separations, introduced in release 3.0, Python provides a neat 
way to include expressions all in a single pair of quotation marks, as shown in 
the following example:
In [ ]:
print(f"it will take about {round(300/110)} hours to 
drive from Edmonton to Calgary")
Out [ ]:
it will take about 3 hours to drive from Edmonton to Calgary
	
Essential Building Blocks of Computer Programs	
147
 https://doi.org/10.15215/remix/9781998944088.01
Please note the f—­
which is a flag or prefix—­
before the opening quotation 
mark and the curly brackets around the expression. Without the f flag, every­
thing will be taken literally as part of the string, without evaluation.
If you want one portion of the string to be put on one line and the other 
portion on the next line, you may insert \n between the two portions in the 
string, as below:
In [ ]:
print(f"it will take about {round(300/110)} hours \nto 
drive from Edmonton to Calgary")
Out [ ]:
it will take about 3 hours
to drive from Edmonton to Calgary
In addition to \n, other escape sequences that we discussed previously may 
also be included in a string.
There may be times that you want to include an escape sequence such as 
\n in a string as is. To achieve that effect, you either use the r flag before the 
opening double quotation mark or use another backslash \ before the escape 
sequence to cancel the first backslash (escape), as shown in the following 
example:
In [ ]:
print(r"there will be no escape \n to newline")   # 
using the r flag
print("there will be no escape \\n to newline")   # 
using double backslash
Out [ ]:
there will be no escape \n to newline
there will be no escape \n to newline
Without the r flag, the sentence will be printed on two lines, as shown in the 
following example:
In [ ]:
print("there will be no escape \nto newline")
Out [ ]:
there will be no escape
to newline
Normally, a \n (newline) will be automatically appended to the output from 
each print statement by default, so that the output from the next print state­
ment will print on a new line. If you want the output from a print statement 
to end with something else rather than a new line, you may use the end key­
word argument to specify how the output should be ended. In the following 

	148	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
example, output from the first print statement will be ended with a whitespace, 
so that outputs from the two print statements will be on the same line:
In [ ]:
print("this is my first print statement.", end=" ")
print("it will take about ", round(300/110), "hours to 
drive from Edmonton to Calgary")
Out [ ]:
this is my first print statement. it will take about 3 hours to drive from 
Edmonton to Calgary
Formally, a print statement may take the following form when used:
print(value0, value1, value2,…, sep=' ', end = '\n', file 
= sys.stdout, flush = False)
where value0, value1,… are values to be printed to a file stream; optional 
keyword argument sep defines what is used to separate value0, value1,…; 
optional keyword argument end tells how the output from the print statement 
should end; optional keyword argument file defines what file stream the 
output should be printed on; and optional keyword argument flush tells how 
the output should be flushed. The meanings and purposes of these optional 
keyword arguments are explained in Table 2-­
16.
Table 2-­
16: Key arguments of the print statement
Keyword argument
Values that can be taken
Default value
sep
it takes a string as its argument and 
inserts it between values
a space
end
it also takes a string as argument but 
appends it to the last value of the 
output stream
a new line
file
it is a file handle such as that returned 
by an open statement
sys.stdout
flush
it takes a Boolean value (True or 
False) indicating whether to forcibly 
flush the output stream
False
Please note that a program may need to output different types of data 
not only correctly but also nicely. In 5.1, we will learn how to construct well-­
formulated strings from various types of data.
	
Essential Building Blocks of Computer Programs	
149
 https://doi.org/10.15215/remix/9781998944088.01
INPUT STATEMENT
The input statement is another important one you must learn and use correctly 
and effectively. Contrary to the print statement, the input statement is used to 
get information from users through the keyboard, as shown in the following 
example in Jupyter Notebook:
In [ ]:
your_age = input("Please tell me your age:")
print("Now I know your age is", your_age)
Out [ ]:
Please tell me your age: 39
Now I know your age is 39
Please note that everything taken from users through the input statement is 
treated as a string. If you are expecting a number, such as an integer, you must 
convert the string into its respective data type, as shown in the following example:
In [ ]:
your_age = input("Please tell me your age:")
your_age = int(your_age)
print(f"In 50 years your age will be {your_age + 50}")
Out [ ]:
Please tell me your age: 39
In 50 years, your age will be 89
As you may have guessed already, the input statement takes one argument as 
a prompt to tell users what to do and what the program is expecting from the user.
If you want to provide more detailed instructions in the prompt to the user, 
you may use the triple quotation marks to include multiple lines of instruction 
as prompt:
In [ ]:
sl = input("""Your choices
A: to get the average mark
M: to get the mean of all marks
H: to get the highest mark
L: to get the lowest mark
Q: to exit the program
Please select___""")
Out [ ]:
Your choices
A: to get average the mark
M: to get the mean of all marks
H: to get the highest mark
L: to get the lowest mark
Q: to exit the program
Please select___
	150	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
As you can see, this can be a good way to make a menu for some terminal-­
based applications.
ASSERT STATEMENT
The assert statement is used to test if a condition is true in a program. It may 
take one of two forms, as shown in Table 2-­
17.
Table 2-­
17: Semantics of assert statement
Syntax
Meaning
assert <condition>
if <condition> is false, the program will stop and raise 
AssertionError
if <condition> is True, the program will run ahead
assert <condition>,
<error message>
if <condition> is false, the program will stop and raise 
AssertionError, along with <error message>
The assertion statement is very useful in debugging your programs, because 
it can be used to check the value of a variable or a certain condition of the pro­
gram. If the condition is not met as expected, the program would stop and let 
you check what’s going on, as shown in the following examples:
In [ ]:
def average_incomes(incomes):
  assert len(incomes) != 0, "Error: need at least one 
income"
  return sum(incomes) / len(incomes)
incomes = [35892, 13487, 56852, 135278, 87542]
print("Average of incomes is",average_incomes(incomes))
incomes = []
print("Average of incomes is",average_incomes(incomes))
Out [ ]:
Average of incomes is 65810.2
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
AssertionError Traceback (most recent call last)
<ipython-­
input-­
2-­
201cb13363c6> in <module>
6 print("Average of incomes is",average_incomes(incomes))
7 incomes = [] -­
-­
8 print("Average of incomes is","average_incomes(incomes))
<ipython-­
input-­
2-­
201cb13363c6> in average_incomes(incomes)
1 def average_incomes(incomes):
-­
-­
 2 assert len(incomes) != 0, "Error: there must be at least one income"
3 return sum(incomes)/len(incomes)
4
5 incomes = [35892, 13487, 56852, 135278, 87542]
AssertionError: Error: there must be at least one income
	
Essential Building Blocks of Computer Programs	
151
 https://doi.org/10.15215/remix/9781998944088.01
PASS STATEMENT
As the name implies, this statement does nothing. It is used as a placeholder 
in places where you don’t have the actual code yet. As an example, assume you 
have the class Student in your design for a project, but the implementation 
details of the class, except the name, are yet to be worked out. You can use the 
pass statement to hold the place of the details, as shown below:
In [ ]:
class Student():
  pass
s1 = Student()
s2 = Student()
With the pass statement in place, this piece of code can run as part of a big 
program without raising an exception.
Note that a pass statement won’t let you get out of a loop. You will need to 
use the break statement to get out of a loop.
DEL STATEMENT
This statement is used to delete an object. Because Python treats everything 
as an object, you can use this statement to delete everything you’ve defined.
In [ ]:
grade = 99
print(f"grade = {grade}")
del grade
print(f"grade = {grade}")
Out [ ]:
grade = 99
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
NameError Traceback (most recent call last)
<ipython-­
input-­
9-­
2b1bea6f987e> in <module>
3
4 del grade
-­
-­
 5 print(f"grade = {grade}")
NameError: name 'grade' is not defined
Deleting an object will free up the memory locations occupied by the object. 
Computer memory is a precious resource in computing. Python objects, even 
objects of built-­
in data types—­
such as list, tuple, set, and dictionary—­
can take 
up a great deal of memory. Deleting the objects that are no longer used will 
free up memory and make it available for other objects and other applications.
	152	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
RETURN STATEMENT
The return statement is one of the most important statements in Python (and 
some other languages as well). It is used to return a value from a function—­
a 
very important construct of all programs. The following is an example:
In [ ]:
def cube(n):
  return n ** 3
print(f'The cube of 23 is {cube(23)}')
Out [ ]:
The cube of 23 is 12167
This function simply takes a number and returns n to the power of 3.
Please note that in Python, the return statement doesn’t have parentheses 
around the value to be returned. Even if you want to return multiple values 
from a function, you only need to use commas to separate the values behind 
the return keyword. The return statement will automatically pack all the values 
in a tuple and then return them.
In the following example, we define a function of a modular operation but 
return the quotient and the remainder at the same time:
In [ ]:
def modular(a, b):
  assert b != 0, 'Zero divisor'
  return a // b, a % b
print(modular(13, 6))
Out [ ]:
(2, 1)
OPEN STATEMENT
The open statement is used to open a file for writing, reading, appending, or 
updating (reading and writing). The following is an example:
f = open("c:\\workbench\\myprimes.txt", 'r')
This opens the file specified by c:\\workbench\\myprimes.txt and creates a 
file object ready for reading. Reading is the default mode when you open a file 
without the second argument. Hence the following statement does the same 
as the above statement:
f = open("c:\\workbench\\myprimes.txt")
	
Essential Building Blocks of Computer Programs	
153
 https://doi.org/10.15215/remix/9781998944088.01
To open a file for writing, w is used for the second argument:
f = open("c:\\workbench\\myprimes.txt", 'w')
When a file is opened for writing, the old data will be overwritten if there is 
already data in the file. To keep the old data and append new data to the file, 
use a for the second argument instead:
f = open("c:\\workbench\\myprimes.txt", 'a')
If you want to create a file only if the file doesn’t exist, use x for the second 
argument, to mean exclusive creation of the file:
f = open("c:\\workbench\\myprimes.txt", 'x')
This would avoid accidentally overwriting a file.
By default, data written to a file opened with w, a, or x is text. The data on 
a file can also be in binary format. To explicitly indicate whether data on a file 
are or should be text or binary, you can use t or b with r, w, a, or x, as shown 
in the following examples:
f3 = open("c:\\workbench\\mykey.dat", 'bw')
f5 = open("c:\\workbench\\mykey.dat", 'br')
YIELD STATEMENT
The yield statement is used in place of the return statement in some special 
circumstances when defining a function. When the yield statement is used 
in defining a function, the function becomes a generator in Python terms, as 
shown in the following example:
In [ ]:
def odds(n):
  for i in range(n):
    yield 2 * i + 1 # yield makes the function a generator
odd_numbers = odds(12)
print(f"type of object odd_numbers is 
{type(odd_numbers)}")
for i in odd_numbers:
  print(i, end = ' ')
Out [ ]:
type of object odd_numbers is <class 'generator'>
1 3 5 7 9 11 13 15 17 19 21 23
	154	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
When we say a function becomes a generator, we mean that an object of 
the generator class is returned from the function.
What is a generator object? For now, you may consider it a dynamic list 
whose members are generated and used dynamically on the fly, without using 
a big bunch of memory to store the whole list. The following is an example 

of a generator:
Object_generator = (x ** 3 for x in range(13))
If we run
for i in Object_generator:
  print(i)
we will see the following members:
0, 1, 8, 27, 64, 125, 216, 343, 512, 729, 1000, 1331, 1728,
However, if we try to get the length of the generator object with the follow­
ing statement:
print(f"{len(object_generator)}")
we will get the following error:
TypeError: object of type 'generator' has no len()
This confirms that an object of type generator has no length.
RAISE STATEMENT
When some errors occur in a Python program, exceptions will be automatically 
raised and the program will stop running, unless the exception is handled 
with the try-­
except statement. Such errors include operations deemed illegal 
by Python. In some cases, an exception needs to be explicitly applied when a 
certain condition is met. In the previous section, we saw how an exception can 
be raised with the assert statement. In the following example, we show how to 
raise an exception with the raise statement.
	
Essential Building Blocks of Computer Programs	
155
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
total = 0
for i in range(39):
  mark = int(input("Tell me a mark:"))
  if mark < 0:
    raise Exception("No negative mark is accepted!")
    total += mark
print(f'average mark is {total / 39}')
Out [ ]:
Tell me a mark: -­
12
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
Exception Traceback (most recent call last)
<ipython-­
input-­
13-­
f4aa3f6c4326> in <module>
3 mark = int(input("Tell me a mark:"))
4 if mark < 0:
-­
-­
 5 raise Exception("No negative mark is accepted!")
6 total += mark
7 print(f'average mark is {total / 39}')
Exception: No negative mark is accepted!
This piece of code is used to calculate the average marks of 39 students, but 
it considers a negative mark unacceptable and will raise an exception.
BREAK STATEMENT
The break statement is used to get out of a loop and continue to the next state­
ment. Here is an example:
In [ ]:
for i in range(10):
  print(i, end = " ")
  if i == 8:
    print(f"\nget out of the loop when i = {i}")
  break
Out [ ]:
0 1 2 3 4 5 6 7 8
get out of the loop when i = 8
CONTINUE STATEMENT
The continue statement is used within a loop code block to continue to the next 
iteration of the loop and ignore the rest of the code block. This statement can 
be very useful if you don’t want to run some statements when some condition 
is met.
	156	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
IMPORT STATEMENT
The import statement is used to import modules into a program file or a specific 
class within the module. The following is an example of how to import the 
standard math module into the program:
In [ ]:
import math
print(f"98 ** 3 = {math.pow(98, 3)}")
Out [ ]:
98 ** 3 = 941192.0
GLOBAL STATEMENT
A global statement simply declares, within a code block such as function or 
class, that some identifiers/names such as variables should be treated as globally 
writable. Without a global statement, a variable defined outside of a function or 
class may be read, but writing to the variable will raise an exception, as shown 
in the following examples:
In [ ]:
gravity = 9.807   # gravity on the earth's surface, 
global variable
r_earth = 6371000   # the earth's mean radius 6371000 
metres
def changed_gravity(m):   # m is the distance from the 
earth
  gravity = gravity * (r_earth/(r_earth+m)) ** 2   # 
decrease gravity by 2
  return gravity
print(f'gravity at 99999 metres above sea level is 
{changed_gravity(99999)} or {gravity}')
Out [ ]:
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
UnboundLocalError Traceback (most recent call last)
<ipython-­
input-­
36-­
7f10379e5fb0> in <module>
6 return gravity
7
-­
-­
 8 print(g_force(99999))
<ipython-­
input-­
36-­
7f10379e5fb0> in g_force(m)
3
4 def changed_gravity(m):
-­
-­
 5 gravity = gravity * (r_earth/(r_earth+m))**2
6 return gravity
7 UnboundLocalError: local variable 'gravity' referenced before assignment
	
Essential Building Blocks of Computer Programs	
157
 https://doi.org/10.15215/remix/9781998944088.01
In the code above, gravity is first introduced outside the function definition. It 

became a global variable by the rule of naming scopes. Inside the definition 
of function changed_gravity, the name was defined again by putting it on the 
left side of the assignment, but only locally by default, according to the rules. 
However, this local variable is used on the right side of the same assignment 
statement. That is how the exception has occurred.
Since what we actually want is to use the globally defined variable gravity 
on both sides of the assignment statement within the function definition, we 
need to explicitly declare that, as shown in the following example revised 
from above:
In [ ]:
gravity = 9.807   # gravity on the earth's surface, 
global variable
r_earth = 6371000   # the earth's mean radius is 
6371000 metres
def changed_gravity(m):   # m is the distance from the 
earth
  global gravity
  gravity = gravity * (r_earth / (r_earth+m)) ** 2
  return gravity
print(f'gravity at 99999 metres above sea level is 
{changed_gravity(99999)} or {gravity}')
Out [ ]:
gravity at 99999 metres above sea level is 9.506238807104731 or 
9.506238807104731
As you can see, the value of global variable gravity has now been changed 
within the function.
NONLOCAL STATEMENT
We have seen global variables and local variables, and how global variables 
are accessible globally, whereas local variables are only accessible within 
a local scope such as a function. There is something between global and 
local called nonlocal. The nonlocal statement can be used to declare a list 
of variables that are not local but refer to variables defined in the nearest 
enclosing scope but excluding global variables. This may happen when 
defining a function within another function, as shown in the following 

example:
	158	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
def outer_logger():
  event = 'Something has happened.'
def inner_logger():
  nonlocal event
  event += "Something else has happened as well."
  print("inner log:", event)
inner_logger()
  print("outer log:", event)
outer_logger()
Out [ ]:
inner log: Something has happened. Something else has happened 
as well.
outer log: Something has happened. Something else has happened as 
well.
HELP STATEMENT
The help statement is used to invoke a helping system and is often used in 
Python interactive mode to get help on modules, statements, functions, or 
methods.
Code sample in Python interactive mode
1
>>> help(str)
2
Help on class str in module builtins:
3
4
 class str(object)
5
 | str(object = '') -­
> str
6
 | str(bytes_or_buffer[, encoding[, errors]]) -­
> str
7
 |
8
 | Create a new string object from the given object. If 
the encoding or
9
 | any errors are specified, then the object must expose a 
data buffer
10
 | that will be decoded using the given encoding and error 
handler.
11
 | Otherwise, returns the result of object.__str__() (if 
defined)
12
 | or repr(object).
13
 | encoding defaults to sys.getdefaultencoding().
14
 | errors defaults to 'strict'.
15
 |
16
 | Methods defined here:
17
 |
	
Essential Building Blocks of Computer Programs	
159
 https://doi.org/10.15215/remix/9781998944088.01
18
 | __add__(self, value, /)
19
 | Return self+value.
20
 |
21
 | __contains__(self, key, /)
22
 | Return key in self.
23
 |
24
 | __eq__(self, value, /)
25
 | Return self==value.
26
 |
27
 | __format__(self, format_spec, /)
28
 | Return a formatted version of the string as described 
by format_spec.
29
 |
30
 |
31
 | __ge__(self, value, /)
32
 -­
-­
 More -­
-­
Compound Statements
In the previous section, we studied individual statements that can be used in 
programming with Python. In this section, we study compound statements 
and ways to make various compound statements in Python.
In Python, a compound statement consists of at least one clause, and each 
clause is made of a header and a suite, or code block. A header starts with a 
keyword such as if, for, while, class, def, try, else, except, finally, and so on 
and ends with a colon :, as described below:
<header>:
    <code block>
What can be on the header line depends on the keyword leading the header. 
You will learn more about this in the following chapters.
CODE BLOCKS
In programs, some statements are grouped and run in sequence as a unit or a 
suite. We call such a group of statements a code block.
Unlike C, C++, Java, and some other languages that use curly brackets to 
make code blocks, Python uses indentation to form code blocks. In Python, a 
program can have multiple code blocks, and code blocks can be nested with 
proper indentation. Statements intended to be in the same code block must 
use the same indentation. The following is an example:
	160	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Code sample
1
 i, s = 1, 1   # the first statement must be started at 
the very beginning
2
3
 while I <= 100:   # this compound statement is in the 
same code block
4
    s *= i   # this is the first statement in the code 
block/suite
5
    i += 1   # this is the second statement in the code 
block/suite
6
7
 print("the product of 1x2x3 … 100 is ", s)
The sample program above has two simple statements on lines 1 and 7, and one 
compound statement on lines 3 to 5. The header of the compound statement 
begins with the keyword while, and its suite is a code block that consists of 
two simple statements. Because statements on lines 1, 3, and 7 are in the same 
code block, they must be indented the same, whereas statements on lines 4 
and 5 must be further indented to form a code block as a suite for the while 
compound statement.
RULES OF INDENTATION
To ensure that your programs are properly indented, follow the following rules:
	
1.	 The first line of code of a program must start at the very first column 
of line, though there can be some blank lines before the first line of 
code, for better readability, if you like.
	
2.	 All lines of code in the same code block must be indented the same.
	
3.	 The suite of a compound statement must be indented further than the 
header of the compound statement.
	
4.	 All code blocks that are at the same level must use the same indentation.
	
5.	 All lines of code in the same suite must use the same indentation.
RULES OF SPACING
The rules of spacing are about how to space out words within a line of script or code 
and how to space lines of scripts. Some of the rules must be followed, while other 
rules are for readability or are merely convention among Python programmers:
	
1.	 There must be at least one space between two words.
	
2.	 As a convention, there should be only one space between two words.
	
Essential Building Blocks of Computer Programs	
161
 https://doi.org/10.15215/remix/9781998944088.01
	
3.	 Also as a convention, there should be one space before each operator 
and one space behind each operator in an expression. So x>y should 
be written as x > y.
	
4.	 For better readability, there should be no space between a unary 
negation operator (−) and the term it negates. So -­
 x should be written 
as -­
x.
	
5.	 Also for readability, in a function call, there should be no space 
between a function name and the list of parameters. So abs (y) 
should be written as abs(y).
	
6.	 The same goes for definitions of functions. There should be no space 
between the function name and the list of arguments.
	
7.	 There should be no blank lines between lines of simple statements if 
they are intended to be in the same code block.
	
8.	 For better readability, there should be a blank line between simple 
statement(s) and compound statements if they are in the same code 
block, as shown in the following sample code:
Code sample
1
i, s = 1, 1   # first statement must be started at the 
very beginning
2
3
while I <= 100:   # this compound statement is in the same 
code block
4
  s *= i   # statement must be indented
5
  i += 1   # second statement in the code block/suite
6
7
print("the product of 1x2x3 … 100 is ", s)
8
Please note the blank line between line 1 and line 3, as well as between 
lines 5 and 7.
IF STATEMENT
An if statement is used to run a block of statements under a condition. The 
header of an if statement begins with the keyword if, followed by a logical 
expression of a condition, and then a colon, as shown below:
if <condition>:
    <suite or code block>
	162	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Here is an example:
Code sample
1
 mark = float(input("Please input your mark:"))
2
3
 if mark >= 0:
4
   print(f"The mark is {mark}.")
5
Note that although Python allows the suite to be on the same line as the header, 
as shown in the following sample, for readability, that is not preferable.
if mark >= 0: print(f"The mark is {mark}.") # allowed but 
not preferred
IF-­
ELSE STATEMENT
In the example above, the if statement can only make one selection. To do 
something in particular if the condition is not met, the else clause can be 
added. The syntax of if-­
else statement is shown below, and the corresponding 
flowchart is shown in Figure 2-­
7.
if <condition>:
  <code block 1>
else:
  <code block 2>
Condition
met?
suite
No
Yes
Figure 2-­
6: Flowchart of an if statement
	
Essential Building Blocks of Computer Programs	
163
 https://doi.org/10.15215/remix/9781998944088.01
The code sample shown above can be rewritten as follows by adding an 
else clause:
Code sample
1
 mark = float(input("please input your mark:"))
2
3
 if mark >= 0:>
4
    print(f"The mark is {mark}.")
5
 else:
6
    print("Incorrect input! A mark cannot be a negative 
number.")
7
IF-­
ELIF STATEMENT
The if-­
else statement can only handle double selections. How can we handle 
multiple selections in Python? For example, in addition to telling whether a 
mark is legitimate or not, we may also want to convert the percentage mark to a 
letter grade. In Python, that can be done with an if-­
elif or if-­
elif-­
else statement. 
The syntax of the if-­
elif statement is shown below:
if <condition 1>:
  < suite 1 >
elif <condition 2>:
  < suite 2 >
elif <condition 3>:
  < suite 3 >
…
Condition
met?
suite 1
suite 2
No
Yes
Figure 2-­
7: Flowchart of the if-­
else statement
	164	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The code that can tell the letter grade from a percentage grade is shown 
below:
Code sample
1
 number_grade = round(float(input("please tell me a 
numeric grade between 0 and 100:")))
2
if number_grade >= 90:
3
  print(f"alpha/letter grade for {number_grade}% is A+")
4
elif number_grade >= 85:
5
  print(f"alpha/letter grade for {number_grade}% is A")
6
elif number_grade >= 80:
7
  print(f"alpha/letter grade for {number_grade}% is A-")
8
elif number_grade >= 76:
9
  print(f"alpha/letter grade for {number_grade}% is B+")
10
elif number_grade >= 73:
11
  print(f"alpha/letter grade for {number_grade}% is B")
12
elif number_grade >= 70:
13
  print(f"alpha/letter grade for {number_grade}% is B-")
14
elif number_grade >= 67:
15
  print(f"alpha/letter grade for {number_grade}% is C+")
16
elif number_grade >= 64:
17
  print(f"alpha/letter grade for {number_grade}% is C")
Condition
met?
suite 1
Condition
met?
suite 2
Condition
met?
suite 2
suite 2
No
Yes
No
Yes
No
Yes
Figure 2-­
8: Flowchart of the if-­
elif-­
elif-­
…
	
Essential Building Blocks of Computer Programs	
165
 https://doi.org/10.15215/remix/9781998944088.01
18
elif number_grade >= 60:
19
  print(f"alpha/letter grade for {number_grade}% is C-")
20
elif number_grade >= 55:
21
  print(f"alpha/letter grade for {number_grade}% is D+")
22
elif number_grade >= 50:
23
  print(f"alpha/letter grade for {number_grade}% is D")
24
elif number_grade >= 0:
25
  print(f"alpha/letter grade for {number_grade}% is F")
26
else:
27
  print("Numeric grade must be a positive integer!")
IF-­
ELIF-­
ELSE STATEMENT
An else clause can be added to the end of an if-­
elif statement in case something 
special needs to be done if all the conditions are not met.
WHILE STATEMENT
The while statement is used to run a block of code repeatedly as long as a given 
condition is met. The syntax of the statement is as follows:
while <condition>:
  < a suite >
Condition 1
met?
suite 1
Condition 2
met?
suite 2
Condition 3
met?
suite 3
suite 4
No
Yes
No
Yes
No
Yes
Figure 2-­
9: Flowchart of an if-­
elif-…elif-­
else statement
	166	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The following is an example:
Code sample
1
 i = 1
2
3
 while i <= 10:
4
    print(f"I am counting to {i}")
5
    i += 1
The loop is ended when not (I <= 10). The while statement is more advantageous 
when used to form a loop if we only know when the loop should end, as shown 
in the following word-­
guessing program:
Code sample
1
 cnt, your_guess = 0, ""
2
3
 while (your_guess.lower()) != "python":
4
    your_guess = input("Guess which programming language 
is my favourite: ")
5
6
    cnt += 1
7
 print(f"Congratulations! You got it in just {cnt} guesses")
FOR STATEMENT
A for statement provides another way to form a loop and is best for when the 
loop runs through an iterable, such as a list, a tuple, a string, a generator, a set, 
or even a dictionary. The syntax of the for statement is as follows:
for <iteration variable(s)> in <iterable>:
  < a suite >
Note that there can be more than one iteration variable if needed, but it is 
more common to have only one iteration variable.
The following is an example:
Code sample: for statement with a string
1
 cnt = 0
2
 my_string = "this is a secret"
3
 for c in my_string:
4
    print(c)
5
    cnt += 1
6
7
	
Essential Building Blocks of Computer Programs	
167
 https://doi.org/10.15215/remix/9781998944088.01
8
 print(f"there are {cnt} characters in ({my_string})")
9
Code sample: for statement with a set
1
 week_set = set(('Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 
'Sun'))
2
 for w in week_set:
3
    print(w)
4
Code sample: for statement with a dictionary
1
 week = {1: 'Mon', 2: 'Tue', 3: 'Wed', 4: 'Thu', 5: 'Fri', 
6: 'Sat', 7: 'Sun'}
2
 for w in week.keys():
3
    print(week[w], " in key and value pair in dictionary")
4
DEF STATEMENT
The def statement is used to define new functions or methods if defined within 
a class definition. The syntax of def statement is as follows:
def <function_name>(<list of arguments>):
  < code block >
where function_name should be a unique identifier within the current scope, 
and the list of arguments can be empty. The details of defining and using func­
tions will be presented in Chapter 6. For now, you need only be concerned with 
the definition of a simple function so that you know how the def statement is 
used. The function is to calculate a given number x to the power of 10, and 
return x*x*x*x*x*x*x*x*x*x:
In [ ]:
def power10(x):
  s = x
  for i in range(9):
    s *= x
    return s
print(f'power10({2}) = {power10(2)}')
Out [ ]:
2 to the power of 10 = 1024
	168	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
CLASS STATEMENT
The class statement is used to define new classes. The syntax of defining a new 
class that only inherits from the base class (object) is as follows:
Class class_name:
  < suite >
or
Class class_name(object):
  < suite >
To define a new class that inherits from classes other than object, the syntax 
is as follows:
Class Class_name(<list of base classes>):
  < suite >
TRY-­
EXCEPT STATEMENT
The try-­
except statement is used to handle errors and exceptions, especially 
when certain errors are expected. The following are some common types of 
errors that you may encounter in your programs:
ArithmeticError
FileExistsError
LookupError
FloatingPointError
FileNotFoundError
IndexError
OverflowError
InterruptedError
KeyError
ZeroDivisionError
IsADirectoryError
MemoryError
AssertionError
NotADirectoryError
NameError
AttributeError
PermissionError
UnboundLocalError
BufferError
ProcessLookupError
BrokenPipeError
EOFError
TimeoutError
ConnectionAbortedError
ImportError
ReferenceError
ConnectionRefusedError
ModuleNotFoundError
RuntimeError
ConnectionResetError
Refer to https://​
docs​
.python​
.org/​
3/​
library/​
exceptions​
.html for a detailed 
discussion about the exceptions and error types defined in Python.
	
Essential Building Blocks of Computer Programs	
169
 https://doi.org/10.15215/remix/9781998944088.01
The following is an example showing how to handle errors from user input 
that use 0 for the denominator.
Code sample: for statement with dictionary
1
 try:
2
    a = int(input("give me a number:"))
3
    b = int(input("give me another number:"))
4
    print(f"{a} / {b} = {a / b}")
5
 except ZeroDivisionError:
6
    print(f"incorrect second input {b}!")
7
The details of error and exception handling in programs will be discussed 
in Chapter 4.
WITH STATEMENT
The with statement is used to provide a context for the execution of a code 
block. The mechanism is a bit complex, but the following may provide some 
help. Remember that the with statement works only on objects that have special 
methods __enter__() and __exit__() implemented in accordance with Python 
context management protocol (PEP 343). For the mechanisms behind the with 
statement, read https://​
effbot​
.org/​
zone/​
python​
-with​
-statement​
.htm or search 
the internet for more details.
The general syntax of the with statement is as follows:
With <expression of object> as < variable referring to the object>:
<suite>
where the value of <expression of the object> will be an object on which the 
context management protocol has been implemented and the <variable refer­
ring to the resulted object> will often be used in the suite. A good and common 
example of using the with statement is dealing files, which, when opened, are 
objects with context management protocol implemented. The following is an 
example:
Code sample: with statement
1
 """
2
 This program will get an input of a big integer from 
user, and
3
 find all the prime numbers not greater than the integer 
input from the user, and
	170	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
4
 write all the prime numbers into a text file.
5
"""
6
 m = int(input("""
7
    Please tell me a big integer number and
8
    then I can find all the primes less than
9
    the prime number:"""))
10
 import math as mt
11
 with open("c:\\workbench\\myprimes.txt", 'w') as p:
12
    i = 2
13
    while i <= m:
14
      flag = True
15
      j = 2
16
      while j <= int(mt.pow(i,1/2)) + 1 and flag:
17
        if i % j == 0:
18
          flag = False
19
          j += 1
20
        if flag:
21
          p.write(str(i)+ "\n")
22
          i += 1
Chapter Summary
•	 Vocabulary is important for any language, and even more important 
for computer languages, because computers will not understand your 
programs at all if you have used the wrong vocabulary.
•	 For programming languages, including Python, vocabulary includes 
various types of data, operators, built-­
in functions, reserved words 
(including keywords), and variables identified by user-­
defined names 
(also called identifiers).
•	 Identifiers must begin with a letter or underscore in the ASCII table, 
then be followed by letters, digits, and/or an underscore.
•	 Identifiers in Python are case-­
sensitive, which means that A1 and a1 are 
two different identifiers.
•	 Within the Python community, there are conventions for how 
identifiers should be made and used for identifying different things in 
Python programs.
•	 Simple data types include integer numbers, float numbers, Boolean 
numbers, and complex numbers.
•	 Complex numbers are represented as a + bj or a − bj, where a and b are 
integers or float numbers.
•	 Compound data are made of other data that can be of two types: simple 
or compound.
	
Essential Building Blocks of Computer Programs	
171
 https://doi.org/10.15215/remix/9781998944088.01
•	 A string is a sequence of characters within a pair of single or double 
quotation marks.
•	 Some special characters in a string must be represented using 
an escape sequence, such as \n for newline, \t for tab, and \\ for a 
backslash, and so on.
•	 In a string, all characters are indexed starting from 0, so that each 
individual character can be accessed using its index.
•	 There are many functions available to manipulate strings.
•	 There are three ways of formatting strings: using placeholders, using 
the format method, and using the f prefix before a string. The last one 
is preferred.
•	 A list is a sequence of data within a pair of square brackets.
•	 Members of a list are also indexed, and each individual member can be 
accessed through its index.
•	 A tuple is a sequence of data within a pair of parentheses.
•	 Members of a tuple are also indexed, and each individual member can 
also be accessed through its index.
•	 While individual members of a list can be deleted or changed, 
individual members in a tuple cannot be deleted or changed.
•	 A set is a collection of data within a pair of curly braces.
•	 Members in a set are not indexed, so individual members in a set 
cannot be accessed through the index.
•	 A dictionary is a collection of key-­
value pairs within a pair of curly 
braces.
•	 Keys are used to access the values of a dictionary.
•	 In Python, everything can be treated as an object.
Exercises
	
1.	 Indicate which of the following are not legitimate Python identifiers to 
name variables, functions/methods, and classes, and explain why.
This
3da
My_name
for
i9
vote
$s
_sum_
cLearance
method
lists
t5#
	
2.	 Write a single statement to complete each of the following tasks:
	
a.	 Read an integer from user into variable k.
	
b.	 Print a multiple-­
line mailing label with your name and home 
address, including the postal code.
	
c.	 Print the area of a circle with a radius of 13.
	172	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
	
d.	 Assign the cube of 23 to variable x.
	
e.	 Print the square of 12, 25, and 56, respectively, on one line.
	
3.	 Evaluate the following expressions
	
a.	 23 + 16 / 2
	
b.	 round(78.3)
	
c.	 pow(2,3) + 5
	
d.	 sum([1,3,5,7,9])/13
	
e.	 bin(9)
	
f.	 divmod(13, 5)
	
g.	 int(38.6)//7
	
h.	 (3.5 + 6.7j) + (5.3 + 12.9j)
	
i.	 'Well' * 3 + '!'
	
4.	 Mentally run the following code blocks and state what each code block 
will display.
	
a.	 x = 5
	
	     y = 6
	
	     print(x + y)
	
b.	 m = 5
	
	     k = 3
	
	     print(f’{m}**{k} = {m**k}’)
	
c.	 m, k = 35, 12
	
	     m //= k
	
	     print(m)
	
d.	 m, k = 35, 12
	
	     m %= k
	
	     print(m)
Projects
	
1.	 Write a program to read a float number from the user into variable s, 
then calculate and print the area of a square with s as the length of 
its side.
	
2.	 Write a program to read two numbers and calculate the product of the 
two numbers.
	
3.	 A parking lot charges $2.50 per hour. Write a program to read the 
number of hours a vehicle has parked, then calculate and print the 
total to be paid for parking.
	
4.	 The arithmetic mean of several numbers is the sum of all these 
numbers divided by the number of these numbers. For this project, 
	
Essential Building Blocks of Computer Programs	
173
 https://doi.org/10.15215/remix/9781998944088.01
write a program that will generate three numbers from users and 
calculate and display the arithmetic mean of these three numbers.
	
5.	 A cube has 6 faces and 12 edges, all of the same length. Write a 
program that takes a number from the user as the length of an edge 
and calculate and display the total surface area of the cube.
This page intentionally left blank
 https://doi.org/10.15215/remix/9781998944088.01
Chapter 3
Flow Control of Statements
If you praise computers for their diligence when they iterate operations tirelessly 
trillions of trillions of times, you must also appreciate their intelligence when they 
do certain things only if certain conditions are met, because decision making is 
important for all intelligent beings, including modern computers. All computer 
programming languages provide constructs for decision making—­
to run a state­
ment or a block of statements only under certain conditions. Python does the same.
In Chapter 3, you will learn how to use the if, if-­
else, if-­
elif, and if-­
elif-­
else 

statements to instruct computers to do certain things only under certain 
conditions.
Learning Objectives
After completing this chapter, you should be able to
•	 use an if statement to run a code block only under a set condition.
•	 use if-­
else to run two code blocks under two different conditions.
•	 use if-­
elif to make multiple selections.
•	 use if-­
elif-­
else to make multiple selections.
•	 use for statements to make loops to run code blocks repeatedly.
•	 use while statements correctly and efficiently to put a code block in a loop.
•	 use break and continue statements correctly to change the flow of 
program within the code block.
3.1 Selective with the if Statement
In Python, all selections are done with the if statement, which can take mul­
tiple forms. The following is a code sample showing how if is used to make a 
single selection.
	176	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Code sample in Python interactive mode
1
"""
2
Code sample showing how to use an if statement to have a 
code block run under a certain condition
3
this piece of code is used to calculate the square root of 
number n only if it is a positive number.
4
"""
5
n = input('Tell me a number and I will tell you the square 
root:')
6
n = float(n) # convert n from string to float
7
if n >= 0:
8
  print(f"The square root of {n} is {n ** (1 / 2)}")
9
10
11
Note that a code block for if statements must begin on the next line after a 

colon : and be properly indented, as shown below:
n = int(input("n = ?"))
if n >= 0:
  Code block
Note: Each code block must be properly indented to indicate what the code 
block belongs to.
The conditions for an if statement can be any Boolean expression, as dis­
cussed in 2.1.
3.2 Single-branch selective with if Statement
In the above example, the program specifies only what to do when n >= 0 but 
does not say what to do otherwise. With Python, you can further specify what 
can be done if n >= 0 is not true. The following is a revised code sample—­

it simply tells the user to input a positive number.
Code sample in Python interactive mode
1
"""
2
Code sample showing how to use an if statement have a code 
block run under a certain condition
3
this piece of code is used to calculate the square root of 
number n only if it is a positive number
4
"""
	
Flow Control of Statements	
177
 https://doi.org/10.15215/remix/9781998944088.01
5
6
n = float(input('Tell me a number and I will calculate the 
square root for you:'))
7
if n >= 0:
8
  print(f"The square root of {n} is {n ** (1 / 2)}")
9
else:
10
  print ("Please give me a positive number!")
Note that no condition needs to be specified for an else clause because it implies 
that the condition is the negation of the condition for that if clause—­
that is, 
not n >= 0.
With the if and if-­
elif statements studied above, you can make single-­
 or 
two-­
branch selections, which are depicted in Figures 3-­
1 and 3-­
2.
3.3 Multiple-branch selective with if-­
elif-… and 
if-­
elif-…-­
else Statements
In decision making, there can be multiple options, each of which requires 
different actions to be taken. In Python, multiple selections can be made with 
if-­
elif and if-­
elif-­
else statements. The logic flow of these two statements is 
depicted in the following diagrams.
The flowchart in Figure 3-­
3 shows the logic flow of an if-­
elif-­
elif…elif state­
ment without else, which can be used to make multiple selections. The flowchart 
in Figure 3-­
4 illustrates the logic flow of an if-­
elif-­
elif…else statement for mul­
tiple selections.
?
Code block
Yes
No
Figure 3-­
1: Flowchart of an if statement
?
Code block A
Code block B
Yes
Figure 3-­
2: Flowchart of an if-­
else statement
	178	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Now, you are ready to tackle a real problem: to decide what letter grade 
should be assigned for a given numeric mark of a student in a course, accord­
ing to Table 3-­
1.
Table 3-­
1: Assignment of letter grade to numeric grade
Number of selections 
needed
Numeric grade (%)
Alpha/letter grade
1
90–­
100
A+
2
85–­
89
A
3
80–­
84
A−
4
76–­
79
B+
5
73–­
75
B
6
70–­
72
B−
7
67–­
69
C+
8
64–­
66
C
9
60–­
63
C−
10
55–­
59
D+
11
50–­
54
D
12
0–­
49
F
?
CB 2
No
Yes
?
CB n
No
No
Yes
?
CB 1
No
Yes
Figure 3-­
3: Flowchart of an if-­
elif-­
elif-­
elif… statement
?
CB 2
No
Yes
?
CB n
CB Else
No
No
Yes
?
CB 1
No
Yes
Figure 3-­
4: Flowchart of an if-­
elif-­
elif-­
else statement
	
Flow Control of Statements	
179
 https://doi.org/10.15215/remix/9781998944088.01
The table shows only integer numeric grades, but decimal inputs, auto­
matically rounded to the nearest integer, are also allowed. The case study is 
shown in Table 3-­
2.
Table 3-­
2: Case study: How to use if-­
elif-­
else
The problem
In this case study, design a program using an if-­
elif-­
else statement 
to convert numeric grades to alpha/letter grades.
The analysis 
and design
As the above grade-­
conversion table shows, the program needs to 
make 12 selections. For each selection, a letter grade will be printed 
out when the numeric grade falls within the corresponding interval.
The code
"""
You are required to design a program using an if-­
elif-­
else statement
to convert numeric grades to alpha letter/grades.
"""
number_grade = round(float(input("Please tell me a 
numeric grade between 0 and 100:")))
if number_grade >= 90:
  print(f"alpha/letter grade for {number_grade}% is A+")
elif number_grade >= 85:
  print(f"alpha/letter grade for {number_grade}% is A")
elif number_grade >= 80:
  print(f"alpha/letter grade for {number_grade}% is A-")
elif number_grade >= 76:
  print(f"alpha/letter grade for {number_grade}% is B+")
elif number_grade >= 73:
  print(f"alpha/letter grade for {number_grade}% is B")
elif number_grade >= 70:
  print(f"alpha/letter grade for {number_grade}% is B-")
elif number_grade >= 67:
  print(f"alpha/letter grade for {number_grade}% is C+")
elif number_grade >= 64:
  print(f"alpha/letter grade for {number_grade}% is C")
elif number_grade >= 60:
  print(f"alpha/letter grade for {number_grade}% is C-")
elif number_grade >= 55:
  print(f"alpha/letter grade for {number_grade}% is D+")
elif number_grade >= 50:
  print(f"alpha/letter grade for {number_grade}% is D")
elif number_grade >= 0:
  print(f"alpha/letter grade for {number_grade}% is F")
else:
  print("Numeric grade must be a positive integer!")
The result
Please tell me a numeric grade between 0 and 100: 88
alpha/letter grade for 88 is A
	180	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The code above didn’t explicitly specify the upper bounds of the intervals 
shown in the grade conversion table because it takes advantage of the if-­
elif-­

elif statement—­
that is, the upper bound of the current if condition has been implicitly 
satisfied when the previous if condition is not satisfied, and the program flow gets 
into the current elif selection. Taking the first elif statement as an example, since 
the previous if condition is number_grade >= 90, when the condition is not satis­
fied and the program flow goes to the elif, the number_grade must be less than 90, 
which is equal to number_grade <= 89, the upper bound of the first elif condition.
After you run the code on your computer, you may notice that for each 
conversion, you have to rerun the program to get another chance to input a 
numeric grade. How can you do as many conversions as you want until you tell 
the program to stop? You’ll be able to do that after learning how to put a code 
block in a loop in the next chapter.
CODING TRICK
How would you specify the conditions for the elif if you began from the 
lowest numeric grade to make number_grade <= 49 for the if?
3.4 Iterate with for Statement
Computers can do many amazing things. Many of these amazing things can 
only be done in thousands or even trillions of trillions of steps. Luckily, pro­
grammers don’t need to write trillions of trillions of statements in a computer 
program, because computers can be instructed to run a block of statements 
in a loop as many times as needed without complaint. As such, a programmer 
must be able to correctly put code blocks in loops when programming. In 

this and the next section of this chapter, you will learn how to use for statements 
and while statements correctly and effectively to put code blocks in loops.
In Python, the for statement is one of only two statements that can be used to 
make loops or iterations. In previous sections, you already saw some examples 
using the for statement. Formally, a for loop takes the following form:
for <iteration variable> in <sequence to be looped through>:
  <Code Block>
in which for and in are keywords, and the iteration variable is used to take items 
one by one from the sequence, which can be a list, a tuple, a string, or an iterable 
object or generator, as you will see. The code block is a block of Python code to 
	
Flow Control of Statements	
181
 https://doi.org/10.15215/remix/9781998944088.01
be executed in each iteration of the loop. The following example loops through 
a list of integers and calculates the cube of each.
In [ ]:
for i in range(1, 11):
  print(f'The cube of {i} is {i * i * i}')
Out [ ]:
The cube of 1 is 1
The cube of 2 is 8
The cube of 3 is 27
The cube of 4 is 64
The cube of 5 is 125
The cube of 6 is 216
The cube of 7 is 343
The cube of 8 is 512
The cube of 9 is 729
The cube of 10 is 1000
A flowchart describing the for loop is shown in Figure 3-­
5.
Now we are ready to solve a more complex problem, shown in Table 3-­
3.
Table 3-­
3: Case study: How to display a multiplication table
The task
Print a multiplication table from 1 * 1 to 9 * 9, and the result table 
should be a right triangle.
Analysis 
and 
design
The resulting multiplication table should be a right triangle like this:
1 x 1 = 1
1 x 2 = 2  2 x 2 = 4
1 x 4 = 3  2 x 3 = 6  3 x 3 = 9
…
so we will need two loops: the outer one is used to loop through the 
row, whereas the inner one loops through the column of each row. 
The algorithm is as follows:
Step 1: Start a row I, I = 1, 2,…, 9
Step 2: Start a column j of row I, j = 1,…i
Step 3: Print j × I = j * i on the same line until I * i
Step 4: Go back to step 1 and finish all rows
Still unused item in
the sequence?
Get next item
Code block
Yes
No item unused
Figure 3-­
5: Flowchart of the for loop
(continued on next page)
	182	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
1
"""
2
This program is used to print a multiplication table 
from 1 x 1 to 9 x 9.
3
The table will be displayed nicely as a right 
triangle. It uses two loops,
4
an outer loop for the rows and an inner loop for the 
columns.
5
"""
6
7
for i in range(1, 10):
8
  for j in range(1, i + 1):
9
    print(f"{i}x{j} = {i * j}", end = "  ")
10
    if j == i:
11
      print("\n")
12
Output in 
terminal
1 x 1 = 1
1 x 2 = 2 2 x 2 = 4
1 x 3 = 3 2 x 3 = 6 3 x 3 = 9
1 x 4 = 4 2 x 4 = 8 3 x 4 = 12 4 x 4 = 16
1 x 5 = 5 2 x 5 = 10 3 x 5 = 15 4 x 5 = 20 5 x 5 = 25
1 x 6 = 6 2 x 6 = 12 3 x 6 = 18 4 x 6 = 24 5 x 6 = 30 6 x 6 = 36
1 x 7 = 7 2 x 7 = 14 3 x 7 = 21 4 x 7 = 28 5 x 7 = 35 6 x 7 = 42 7 x 7 = 49
1 x 8 = 8 2 x 8 = 16 3 x 8 = 24 4 x 8 = 32 5 x 8 = 40 6 x 8 = 48 7 x 8 = 56 
8 x 8 = 64
1 x 9 = 9 2 x 9 = 18 3 x 9 = 27 4 x 9 = 36 5 x 9 = 45 6 x 9 = 54 7 x 9 = 63 
8 x 9 = 72 9 x 9 = 81
Our next problem, in Table 3-­
4, is to find all the Pythagorean triples of 
integers less than an integer given by the user.
Table 3-­
4: Case study: How to find Pythagorean triples
The task
Three integers—­
A, B, and C—­
are called a Pythagorean triple when C * C 
= A * A + B * B.
This program will take an integer input by the user and find all the 
Pythagorean triples of integers less than that integer.
Analysis 
and 
design
Step 1: Get input from user
Step 2: Find all the Pythagorean triples
Step 3: Print all the triples
Step 2.0: Make an empty list, say, plist =[]
Step 2.1: One loop for A = 1…user input
Step 2.2: One loop for B = 1…user input
Step 2.3: One loop for C = 1…user input
Step 2.4: If C * C = A * A + B * B, add the triple to the list plist
1
"""
2
Three integers -­
 A, B, and C -­
 are called a 
Pythagorean triple when C * C = A * A + B * B.
Table 3-­
3: Case study: How to display a multiplication table (continued)
	
Flow Control of Statements	
183
 https://doi.org/10.15215/remix/9781998944088.01
3
This program will take an integer input by the user 
and find all the Pythagorean triples of integers 
less than that integer.
4
"""
5
6
upper_bound = int(input("Give me a big integer:"))
7
plist = []
8
for i in range(1, upper_bound + 1):
9
  for j in range(i, upper_bound + 1):
10
    for k in range(j, upper_bound + 1):
11
      if k * k == j * j + i * i:
12
        plist.append((i, j, k))
13
for i in plist:
14
  print(i)
15
16
17
Output in 
terminal
Give me a big integer:39
(3, 4, 5)
(5, 12, 13)
(6, 8, 10)
(7, 24, 25)
(8, 15, 17)
(9, 12, 15)
(10, 24, 26)
(12, 16, 20)
(12, 35, 37)
(15, 20, 25)
(15, 36, 39)
A for statement can have multiple iteration variables if needed. In order to 
make it work, however, each item of the iteration sequence needs to have multiple 
values for the multiple iteration variables, as shown in the following example:
for i, j in [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]:
    print(f"{i} * {j} = {i * j}")
or
for i, j in zip(range(5), range(5)):  # zip is a special 
function
    print(f"{i + 1} * {j + 1} = {(i + 1) * (j + 1)}")
In the above, zip is a built-­
in function that takes an element from each 
iterable and forms a tuple, as shown below:
>>> list(zip(range(5), range(5), range(6)))
[(0, 0, 0), (1, 1, 1), (2, 2, 2), (3, 3, 3), (4, 4, 4)]
Table 3-­
4: Case study: How to find Pythagorean triples (continued)
	184	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The function zip will stop making tuples when the shortest iterable has 
reached the end.
Note that the following two statements are totally different:
for i in range(5):
  for j in range(5):
    print(f"{j + 1} * {i + 1} = {(i + 1)*(j + 1)}")z
versus
for i, j in zip(range(5), range(5)):
  print(f"{i + 1} * {j + 1} = {(i + 1)*(j + 1)}")
The first statement is two loops nested, whereas the second is a single loop.
You may copy and paste the code into Jupyter Notebook to find out why and how.
Using break and continue Statements and an else Clause Within 
Loops
Chapter 2 discussed what the break statement and continue statement do. 
Within a for loop, if you want to get out of the iteration immediately when some­
thing has occurred, you can use a break statement; if you want to go to the next 
item in the iteration sequence right away, you can use a continue statement.
A for statement can also have an else clause whose code block will be exe­
cuted when the iteration sequence is used up. The following code example 
taken from the Python documentation explains how the break statement and 
else clause can be used on a for loop.
In [ ]:
for n in range(2, 10):
  for x in range(2, n):
    if n % x == 0:
      print(n, 'equals', x, '*', n // x)
      break   # if break is ever executed, the else 
code block will never be reached
    else:   # the else code block is executed when 
      range(2, n) is used up without finding a factor
      print(n, 'is a prime number')
Out [ ]:
2 is a prime number
3 is a prime number
4 equals 2 * 2
5 is a prime number
6 equals 2 * 3
7 is a prime number
8 equals 2 * 4
9 equals 3 * 3
	
Flow Control of Statements	
185
 https://doi.org/10.15215/remix/9781998944088.01
In the example above, pay particular attention to the indentation of else. 
The else block is treated as a clause of the inner for statement because it 

has the same indentation as the inner for. If it were indented the same as the 
if statement, the else block would become part of the if statement.
Common Coding Mistakes with the for Loop
Because Python made the for loop to run an iteration variable or variables 
through a sequence with a finite number of items, it has essentially avoided 
some mistakes common in other languages such as C, C++, and Java. You should, 
however, remember to not change the value of any iteration variable within 
the code block of a for loop because it needs to be changed automatically by 
Python interpreter to the next item in the sequence. The iteration might be 
unexpected if the value of the iteration variable is changed in the code block.
3.5 Iterate with the while Statement
The while statement is another statement you can use to make loops. As dis­
cussed in Chapter 2, while is best used if you know when the loop should stop 
but do not know how many times the code will iterate. For the problem solved 
in the previous section, even though you also know when each loop should 
stop, it can still be coded with the while statement, as shown below:
The code
1
"""
2
This program is used to print a multiplication table from 
1 x 1 to 9 x 9.
3
The table will be displayed nicely as a right triangle. 
The two loops are coded with the while statement
4
instead of the for statement.
5
"""
6
7
  i = 1
8
  while i < 10:
9
    j = 1
10
    while j <= i:
11
      print(f"{j} x {i} = {i * j}", end ="")
12
      if j == i:   # if statement is used to decide when 
to start a new line
13
        print("\n")
14
      j += 1
15
    i += 1
16
17
	186	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
While a for loop can always be replaced with a while loop, a while loop cannot 
be replaced with a for loop in cases where the number of iterations is unknown.
Consider the problem of calculating the average of the student marks taken 
from user input. Either the total number of marks is unknown or you do not 
expect the user to count how many marks they input, so it is not possible to use 
a for loop to solve the problem. However, you do know there will be no negative 
marks, which can then be used to indicate the end of the input. Hence, you can 
use a while loop to take input from the user until you get a negative number 
from the user. The program is shown in Table 3-­
5.
Table 3-­
5: Case study: How to stop a while loop
Code sample in VS Code IDE
The task
Get student marks from user input and calculate the average mark, using 
a negative number input by the user to indicate the end of marks.
Analysis 
and 
design
You don’t know how many marks will be input from the user, but you do 
know there will be no negative marks. You can then use a negative 
number, input by the user, to end the application and use the while 
loop to iterate.
To calculate the average, you need to know the sum of all the marks 
as well as the total number of marks. For the former, you need to 
add each mark to the total, whereas for the latter, you need to use a 
counter to count every mark. Use the variable total to keep the sum 
and use the variable count to keep the number of marks. Both need to 
be initialized to 0. The algorithm is below:
Step 1: Initialize both count and total to 0
Step 2: Take an input from user and convert it to a float number
Step 3: If the number is a mark (>= 0), then do the following:
  Step 3.1: Increase count by 1
  Step 3.2: Add mark to total
  Step 3.3: Get another input from user and convert to float
  Step 3.4: Go back to Step 3
Step 4: Calculate the average using total/count and print out the result.
Step 5: End the program
Is condition to
loop met?
Code block
Met
Not met
Figure 3-­
6: Flowchart illustrating the while loop
	
Flow Control of Statements	
187
 https://doi.org/10.15215/remix/9781998944088.01
Code sample in VS Code IDE
1
"""
2
Program file name: averagemark.py
3
Application: this application takes marks from user 
input and calculates the average mark.
4
A negative number from user input is used to 
indicate the end of the program.
5
"""
6
7
count, total = 0, 0   # two variables are 
initialized in one assignment statement
8
mark = float(input("Please input a mark or a 
negative number to end:"))
9
while mark >= 0:
10
  total += mark
11
  count += 1
12
  mark = float(input("Please input next mark or a 
negative number to end:"))
13
print(f"The average of the {count} marks is {total/count}")
14
Output in 
terminal
Please input a mark or a negative number to end: 78
Please input next mark or a negative number to end: 89
Please input next mark or a negative number to end: 98
Please input next mark or a negative number to end: 88
Please input next mark or a negative number to end: 85
Please input next mark or a negative number to end: -­
1
The average of the 5 marks is 87.6
Similarly, we can also write a program that takes a list of student marks 
and identify the lowest marks, the highest marks, and the mean, as shown 

in Table 3-­
6.
Table 3-­
6: Case study: How to use a while loop statement
The problem
In this problem, you will get a list of student marks and find out the 
lowest, the highest, and the mean.
The analysis 
and design
The steps involved are
Step 1: Start with an empty list
Step 2: Get marks in a loop and build a list
Step 3: Sort the list
Step 4: Get the lowest mark, the mean, and the highest mark from 
the sorted list
Table 3-­
5: Case study: How to stop a while loop (continued)
(continued on next page)
	188	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The code
"""
Get a number of marks into a list, sort the list and
find the mean, max, and min.
"""
mark = int(input("Please input a mark or -­
1 to 
complete:"))
marks = []
while mark >= 0:
  marks.append(mark)
  mark = int(input("Please input next mark or -­
1 
to complete:"))
marks = sorted(marks)
ln = len(marks)
print(f"The lowest is {marks[0]}, mean is 
{marks[ln // 2]}, highest is {marks[ln -­
 1]}")
print(marks)
The result
The lowest is 25, mean is 65, highest is 85
[25, 32, 36, 54, 55, 58, 65, 66, 74, 77, 85, 85]
The next programming task for using a while loop is to write a program 
that can take an integer from a user and decide whether the integer is a prime 
number or not (see Table 3-­
7).
Table 3-­
7: Code sample: Prime number test
Code sample in VS Code IDE
The task
Take an integer from a user and decide whether the integer is a 
prime number or not.
Analysis and 
design
A prime number is an integer greater than 1 that cannot be divided by 
any of the integers between 1 and itself. The way to test this can be 
very simple: try to divide that number by all the numbers between 1 
and that number. If it can be divided, and the answer is a whole 
number, then that number is prime. However, since i*j = j*i, we only 
need to test integers <= square root of m to speed up the test. We 
can assume the integer is a prime at the start of the test with a flag 
initialized to True; if a number in the range discussed above is found 
to be able to divide into the integer, the flag is changed to False and 
the test is complete. If no such number is found until the end of 
the range, the flag will remain True, and the number is a prime. The 
algorithm is as follows:
Step 1: Get an integer from the user into variable n
Step 2: Initialize flag to True
Step 3: Initialize variable i to 2
Step 4: If i <= sqrt(n), do the following:
	
Flow Control of Statements	
189
 https://doi.org/10.15215/remix/9781998944088.01
Code sample in VS Code IDE
  Step 4.1: If n % m != 0, then m = m + 1; go to Step 4, else
  Step 4.2: If flag = False, break out and stop testing
Step 5: If flag = True, then number n is a prime; print it out
Step 6: End program
1
"""
2
Program file name: primetest.py
3
Application: this program takes an integer from 
user input and determines
4
whether it is a prime or not.
5
"""
6
7
m = int(input("Give me an integer that is greater 
than 1, and I will tell you if it is a prime: "))
8
flag = True
9
if m < 2:
10
  print("The number must be greater than 1")
11
  flag = False
12
else:
13
  i = 2
14
  while i< = m ** (1 / 2):   # because i * j = j * 
i, we only need to check integers < = sqrt(m)
15
    if m % i == 0:
16
      print(f"{m} is divisible by {i}, so that ", 
end=" ")
17
      flag = False
18
      break
19
    else:
20
      i += 1
21
if flag:
22
  print(f"{m} is a prime")
23
else:
24
  print(f"{m} is not a prime")
25
26
27
Output in 
terminal
Give me an integer that is greater than 1, and I will tell you if it is a 
prime: 911
911 is a prime
Please note the break statement in the example above. It is used to get out 
of the loop immediately by ignoring all the code before it without going back 
to test the looping condition. This is a way to get out of a loop in the middle of 
an iteration and is applicable to both the while loop and for loop.
Somewhat related to the break statement, the continue statement is used 
within a loop to go back directly to the beginning of the iteration—­
testing the 
Table 3-­
7: Code sample: Prime number test (continued)
	190	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
looping condition in a while loop or taking the next item of the sequence in a 
for loop.
Common Coding Mistakes with a while Loop
As mentioned, the while loop is good for iterations in which the number 
of iterations is unknown but the condition of looping is known. To ensure 

that the loop will end as expected, the looping condition must be changed 
within the code block of the while statement. Otherwise, the loop will go on 
forever. To ensure that, there must be at least one variable within the code block 

of the loop whose value needs to be changed during iterations. Such a variable 
is called an iteration variable.
There are two common mistakes when using the while statement. The first 
one is not correctly writing the looping condition, which could be coded so that 
it is always true (hence, the iteration will keep going forever) or incorrectly 
coded to become false at the wrong time. For example, if x < 0 is written in 
place of x > 0 as the looping condition, the iteration would not finish as desired 
or wouldn’t run at all.
The other common mistake people often make when using the while 
statement is not coding the code block correctly to ensure that the following 
conditions hold:
	
1.	 There will be at least one iteration variable within the code block of 
the while loop.
	
2.	 The value(s) of iteration variable(s) must change within the code 
block.
	
3.	 The logical expression of the looping condition is not correctly 
written. This mistake may occur when inequal operators are involved 
in the logical expression of the looping condition. For example, using 
> in place of >=, or using < in place <=, will cause the program to miss 
one iteration of the loop.
In the example we just mentioned above, if x is never changed within the code 
block of the while loop, the value of the looping condition will remain the same, 
and the iteration will keep going forever as well.
3.6 Iterate with for Versus while
The for loop is controlled by a variable going through a sequence with a finite 
number of items. So essentially, the for loop is good for cases when the number 
of iterations is known. Let’s take a second look at the example about finding 

	
Flow Control of Statements	
191
 https://doi.org/10.15215/remix/9781998944088.01
the average mark for a class. Assume now that we know the class has 30 students 
and we want the program to take the final marks of all students in the class and 
calculate the average mark. Because the number of students in the class is known, 
the for loop can be used to iterate, as shown below:
In [ ]:
total = 0
for i in range(30):
  mark = int(input("Please input a mark:"))
  total += mark
print(f'The average course mark is {total/30}.')
When the number of iterations is unknown, the while loop must be used, 
in which case the condition for exiting from the loop must be known. In this 
particular application, because no mark will be a negative number, we can use 
negative numbers to signify the end of input, to end the iteration, as shown in 
the following example:
In [ ]:
total, mark, count = 0, 0, 0
while mark >= 0:
  mark = int(input("Please input a mark:"))
  if (mark >= 0):
    total += mark
    count += 1
print(f'The average course mark of {count} students is 
{total/count}.')
Out [ ]:
Please input a mark: 89
Please input a mark: 96
Please input a mark: 78
Please input a mark: 97
Please input a mark: 88
Please input a mark: -­
7
The average course mark of 5 students is 89.6.
In the example above, we use mark as an iteration variable to control the 
loop. Initializing it with 0 = ensures that the looping condition (logical expres­
sion mark >= 0) is satisfied to start the iteration.
Since we know the logical expression (mark >= 0) is true when 0 is assigned 
to mark, we can also simply use constant True in place of mark >= 0 and then 
use an if statement with the break statement to get out of the loop when a 
certain condition (condition to exit the loop) is met. The revised version of the 
program is shown below:
	192	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
total, mark, count = 0, 0, 0
while True:
  mark = int(input("Please input a mark:"))
  if (mark >= 0):
    total += mark
    count += 1
  else:
    break
print(f'The average course mark of {count} students is 
{total/count}.')
Out [ ]:
Please input a mark: 88
Please input a mark: 98
Please input a mark: 97
Please input a mark: 96
Please input a mark: 78
Please input a mark: -­
3
The average course mark of 5 students is 91.4.
In the previous section we mentioned that the while loop is an entry-­
controlled iteration, which means that the code block of the loop statement 
may not be executed at all if the entry condition is not met at the beginning. In 
the example above, when we use True in place of the looping condition, it has 
guaranteed that the code block will always be run at least once, and the itera­
tion could go on forever if a break statement is not used and executed when a 
certain condition (condition to exit) is met. This has made while statement an 
exit-­
controlled iteration. The flowchart of such iteration is shown in Figure 3-­
7.
Compared to the for statement, the while statement is more powerful and 
its uses are more versatile. In fact, all code written with a for statement can 
be rewritten with a while statement, though when looping through sequences, 
coding with for statements is more elegant and more readable.
Condition to 
exit
Code block
Condition to exit
is not met
Condition to exit
is met
Figure 3-­
7: Flowchart for a while loop
	
Flow Control of Statements	
193
 https://doi.org/10.15215/remix/9781998944088.01
Since we know how to put a code block in a while loop, we can improve the 
grade conversion program written in the previous chapter so that we do not 
have to rerun the program for each conversion (see Tables 3-­
8 and 3-­
9).
Table 3-­
8: Conversion between numeric grade and letter grade in 
Alberta
Letter grade
Percentage
A+
90–­
100%
A
95–­
89%
A−
80–­
84%
B+
77–­
79%
B
73–­
76%
B−
70–­
72%
C+
67–­
69%
C
63–­
66%
C−
60–­
62%
D
55–­
59%
D
50–­
54%
F
0–­
49%
Table 3-­
9: Case study: How to make a grade converter
The problem
In this case study, you are required to design a program using an 
if-­
elif-­
else statement to convert as many numeric grades to alpha/
letter grades as needed until the user inputs -­
1 to stop.
The analysis 
and design
In Canada, different provinces may use different conversion tables 
for numeric grade to letter grade conversion. In this case study, 
we take the one used in Alberta, as shown above. Based on the 
conversion table, our program needs to make 12 selections; for 
each selection, a letter grade will be printed out when the numeric 
grade falls within the corresponding interval. Since we allow a 
user to convert as many numeric grades as needed until the user 
explicitly tells the program to stop by inputting -­
1, we will put the 
above if-­
elif-­
elif multiple selection statements inside a while loop. 
Note that for this problem, the for loop will not work because we 
do not know how many times the loop will need to run.
(continued on next page)
	194	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The code
"""
Design a program using an if-­
elif-­
else statement
to convert numeric grades to alpha/ letter grades.
"""
number_grade = 0
while number_grade >= 0:
  number_grade = input("Please input a numeric grade 
between 0 and 100 to convert; input -­
1 to exit:")
  number_grade = round(float(number_grade))
  if number_grade >= 90:
    print(f"alpha/letter grade for {number_grade} 
is A+")
  elif number_grade >= 85:
    print(f"alpha/letter grade for {number_grade} 
is A")
  elif number_grade >= 80:
    print(f"alpha/letter grade for {number_grade} 
is A-")
  elif number_grade >= 76:
    print(f"alpha/letter grade for {number_grade} 
is B+")
  elif number_grade >= 73:
    print(f"alpha/letter grade for {number_grade} 
is B")
  elif number_grade >= 70:
    print(f"alpha/letter grade for {number_grade} 
is B-")
  elif number_grade >= 67:
    print(f"alpha/letter grade for {number_grade} 
is C+")
  elif number_grade >= 64:
    print(f"alpha/letter grade for {number_grade} 
is C")
  elif number_grade >= 60:
    print(f"alpha/letter grade for {number_grade} 
is C-")
  elif number_grade >= 55:
    print(f"alpha/letter grade for {number_grade} 
is D+")
  elif number_grade >= 50:
    print(f"alpha/letter grade for {number_grade} 
is D")
  elif number_grade >= 0:
    print(f"alpha/letter grade for {number_grade} 
is F")
  else:
    print("Thank you for using this grade 
converter!")
The result
Please input a numeric grade between 0 and 100 to convert; input -­
1 
to exit:96
alpha/letter grade for 96% is A+
Please input a numeric grade between 0 and 100 to convert; input -­
1 
to exit:79
alpha/letter grade for 79% is B+
Please input a numeric grade between 0 and 100 to convert; input -­
1 
to exit:67
alpha/letter grade for 67% is C+
Please input a numeric grade between 0 and 100 to convert; input -­
1 
to exit:-­
1
Thank you for using this grade converter!
Table 3-­
9: Case study: How to make a grade converter (continued)
	
Flow Control of Statements	
195
 https://doi.org/10.15215/remix/9781998944088.01
Chapter Summary
•	 Knowing what to do at a given time and under certain conditions is 
important for any intelligent being.
•	 Conditional statements are necessary and important constructs in all 
programming languages.
•	 if, if-­
else, if-­
elif, if-­
elif-­
else are the constructs for conditional 
statements.
•	 Each if, if-­
else, if-­
elif, if-­
elif-­
else statement represents a flow of 
program execution.
•	 The if statement is for one selection. It will execute a code block if the 
condition is met.
•	 The if-­
else statement is good for two selections.
•	 The if-­
elif and if-­
elif-­
else statements are good for multiple selections.
•	 The conditions behind if and elif are logical or Boolean expressions.
•	 Python has two constructs for iteration, the for statement and the while 
statement.
•	 The for statement can be used to repeat a code block through each 
member of an iterable, such as a list, tuple, or string, or an iterable 
object such as range(…).
•	 When the iteration includes a for statement, the number of iterations 
can be determined most of the time, unless the break statement is used 
within the code block to break out from the loop.
•	 The while statement is used to iterate under certain conditions.
•	 The number of repetitions needed when using a while statement is 
often unknown. One can be used with or without a break statement 
within the code block.
•	 The continue statement can be used within the code block of a for or 
while statement to directly go to the next iteration.
•	 Any for statement can be rewritten as a while statement.
Exercises
	
1.	 Mentally run the following code blocks and write down the output of 
each code block.
a.
m, n = 10, 20
if m * n < 1000:
   print('This is not enough!')
	196	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
b.
m, n = 10, 3
if m // n == m / n:
   print(f'{m} // {n} = {m//n}')
else:
   print(f'{m} / {n} = {m/n}')
c.
m, n = 13, 5
if m * 2 > n**2:
   print(f'{m} * {2} = {m*2}')
else:
   print(f'{n} ** {2} = {n**2}')
	
2.	 Mentally run each of the code blocks below and write down the output 
of each code block:
a.
for i in range(1, 6):
 print(f'The cube of {i} is {i*i*i}')
b.
i, s = 1, 1
while i<=10:
 s *= i
 i += 1
print("the product of 1x2x3…10 is ", s)
c.
total = 0
for i in range(10):
 total += i*2 +1
print(f'1+3+5+ … +19 = {total}')
d.
number = 32
factors = []
for d in range(1, number):
 if number % d == 0:
 factors += [d]
print(f'factors of {number} are {factors}')
Projects
	
1.	 Write a program that gets three numbers from the user and displays the 
biggest number among the three.
	
2.	 Write a program that gets a number from the user then says whether 
the number is an even number or odd number.
	
3.	 Write a program that takes three numbers from the user as the lengths 
of three lines, then determines if the three lines can make a triangle.
	
4.	 Write a program that takes three numbers from the user as the 
lengths of three lines, then determines if the three lines can make a 
triangle. If the three lines can make a triangle, the program should 
further determine if the triangle is an equilateral triangle or an 
isosceles triangle.
	
Flow Control of Statements	
197
 https://doi.org/10.15215/remix/9781998944088.01
	
5.	 Write a program that takes three numbers from the user as the lengths 
of three lines, then determines if the three lines can make a triangle. 
If the three lines can make a triangle, the program should further 
determine if the triangle will be a right triangle.
	
6.	 Compound interest is a common practice in finance and banking, 
allowing you to earn interest on interest as well as on the principal. 
Assume that your bank offers a savings account with which you can 
earn compound interest. The amount you deposit into the account is 
p, and annual compound interest is r. By the end of n years after your 
initial deposit, the account balance will be a = p(1 + r)n. For this project, 
write a program that takes three numbers from the user as the initial 
deposit, the annual interest, and the number of years that the user 
wants the money to stay in the account. Calculate and display how 
much money the user will have by the end of the nth year.
	
7.	 In some countries like Canada, tax on taxable personal income for a 
year is calculated progressively according to a calculation table set for 
the year, such as the one shown below:
Income 
tax
15% on 
the first 
$48,534 
or less
20.5% on 
the next 
$48,534
26% on 
the next 
$53,404
29% on 
the next 
$63,895
33% on 
taxable 
income 
over 
$214,368
Income
$0–­
$48,535
$48,536–­
$97,069
$96,070–­
$150,473
$150,474–­
$214,368
over 
$214,368
Write a program that takes taxable income from a user and calculates 
the total income tax payable according to the table above.
	
8.	 A mortgage is the money borrowed from a lender for the purchase 
of a property. Mortgages and mortgage payments are a big thing for 
almost everyone. For a mortgage with principal of P at a fixed monthly 
interest rate of r that needs to be paid off in Y years or 12 * Y = N 
months, the monthly payment would be:
Write a program that takes the principal, fixed annual interest rate, 
and years of amortization then calculates and displays the monthly 
payment amount. Hint: You will need to work out the number of 
months from number of years, and the monthly interest rate from the 
annual interest rate.
	198	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
	
9.	 In the world of science and mathematics, the existence of some 
constants has attracted the attention of many scientists and 
mathematicians. Among those constants, pi π is the most well-­
known. 
Many great efforts have been made to get a more precise value for π. 
The following is a formula developed by Gottfried Leibniz for the 
calculation of π.
Write a program that takes an integer from the user to specify the 
number of terms used to calculate π. Calculate and display the 
approximate value.
	
10.	 Three integers—­
A, B and C—­
are called a Pythagorean when C * C = 
A * A + B * B. Write a program to take an input of integer from the 
user and find all the Pythagorean triples of integers, none of which 
are bigger than the integer taken from the user. For example, if the 
number from the user is 6, then 5, 4, and 3 are a Pythagorean triple 
because 52 = 42 + 32 = 25.
	
11.	 Compound interest is a common practice in finance and banking 
to earn interest on interest as well as on the principal. Assume that 
your bank offers you a deposit account through which you can earn 
compound interest, the amount you deposit into the account is p, and 
annual compound interest is r. By the end of n years after your initial 
deposit, the account balance will be a = p(1 + r)n. For this project, get 
p, r, and n from the user, then calculate and display a table showing 
the balance, the interest earned each year, and the total interest 
earned so far.
	
12.	 An integer is called a perfect number* if the sum of its factors, 
excluding itself, is equal to the integer itself. For example, 6 is a 
perfect number because 6 = 1 + 2 + 3, and 1, 2, and 3 are all its factors. 
Write a program to get a number from a user, then determine if the 
number is a perfect number. If yes, display all its factors.
	
13.	 For a given integer n, if another integer m can divide n, then m is 
called a factor of n. In mathematics, finding all factors of a given 
integer is an important operation, especially for cryptography. Write 
a program that takes an integer from the user and determine and 
display all the factors of the number given by the user.
* By definition, a perfect number is a positive integer that is equal to the sum of all its divisors, 
excluding itself but including 1. The smallest perfect number is 6, which is equal to the sum of 
1, 2, and 3.
	
Flow Control of Statements	
199
 https://doi.org/10.15215/remix/9781998944088.01
	
14.	 Read a series of float numbers from the user and calculate and display 
the average of all the numbers given by the user. Assume that the 
number of float numbers is unknown but that a negative number is 
used to indicate the end of the input.
	
15.	 For a mortgage with a principal of P at a fixed monthly interest rate of 
r that needs to be paid off in Y years or 12 * Y = N months, the monthly 
payment would be:
Continuing the project you did above for project 8, calculate a table 
showing the interest and principal paid each month and the principal 
balance at each month’s end.
This page intentionally left blank
 https://doi.org/10.15215/remix/9781998944088.01
Chapter 4
Handle Errors and 
Exceptions in Programs
Errors in programs are inevitable but must be handled elegantly when they 
occur. In this chapter, you will learn how to raise and handle exceptions when 
errors occur in programs.
Learning Objectives
After completing this chapter, you should be able to
•	 explain different types of errors and exceptions that may occur in a 
Python program.
•	 write down the specific codes for some common types of exceptions.
•	 use the try statement properly to handle possible exceptions raised by 
potential errors in a block of program code.
•	 understand the cause of the following messages:
◾	 TypeError
◾	 NameError
◾	 RuntimeError
◾	 OSError
◾	 ValueError
◾	 ZeroDivisionError
◾	 AssertionError
◾	 FileNotFoundError
•	 understand how to purposely throw an exception using a raise 
statement in a program.
•	 use an assert statement to prevent future exceptions in a program.
•	 list user-­
defined exceptions.
•	 define a class of exceptions.
	202	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
4.1 Errors in Your Programs
It is not unusual to have errors in your programs, especially for beginners. There 
are three types of errors in computer programs: syntax errors, runtime errors, and 
logic errors. If you program in a modern IDE such as VS Code, syntax errors can 
be easily avoided because whenever there is incorrect syntax, such as a misspelled 
keyword, you will be alerted by the IDE. Modern IDEs can even detect whether an 
identifier is used properly, such as when an undefined function is called or the 
value of a variable is used but no value has been previously assigned to the variable.
On the other hand, runtime errors only happen during the runtime of pro­
grams. Runtime errors are the most irritating to users and should be caught 
and handled gracefully in programs.
Logic errors are those caused by incorrect logic or operation in a program 
for a given problem or task. The following are some examples of logic errors:
	
1.	 An incorrect operator is used in an expression or statement, such as 
use + instead of −, > instead <, or vice versa.
	
2.	 The boundary of a sequence is miscounted.
Compared to syntax errors and runtime errors, the consequences of logic errors can 
be more costly because they often cause the program to produce incorrect results. 
It is even more concerning because logic errors often remain undetected until 
someone realizes that the result from the program is not what was expected. For 
example, syntax and runtime errors will produce no result, which will be immedi­
ately noticed by the user, whereas an incorrect result often goes unnoticed till it 
causes unexpected consequences, such as a missile being sent to the wrong target.
No programming techniques can help eliminate logic errors. It is up to the 
programmers to make the logic correct. That is why computer programmers 
should also take certain math courses.
Because Python programs are normally interpreted without compilation, 
syntax errors such as misspelled keywords are often found at runtime as well 
(unless the programs were developed in a smart IDE that can help identify the 
syntax errors while programming). However, the exception-­
handling mechan­
ism provided by Python or other programming is not intended to catch syntax 
errors. You, as a programmer, must ensure that the programs you write use 
correct syntax, with the help of an IDE whenever is available.
You may be wondering what errors can be handled by the exception-­
handling 
mechanism provided by Python. The following is a long list of exception classes, all 
of which can be caused by errors in programs. The try-­
except statement provided 
by Python to handle exceptions and errors uses the names of exception classes to 
	
Handle Errors and Exceptions in Programs	
203
 https://doi.org/10.15215/remix/9781998944088.01
identify particular exceptions caused by specific errors. Remember at least the 
names of these commonly occurring exceptions or know where to find them.
Exception
This is the superclass of all exception classes to be detailed below. In the code 
sample below, any error will be caught and treated the same because it has 
“Exception” in the list of exceptions behind the except clause.
In [ ]:
try:
  n = int(input('Give me an integer:'))
  m = int(input('Give me another integer:'))
  n /= m   # divide n by m
except Exception:
  print('Wrong: It is not an integer or m is 0')
Out [ ]:
Give me an integer: 12
Give me another integer: 0
Wrong: It is not an integer or m is 0
In this particular case, m was given 0 so that the exception was caused by 
dividing n by 0, but the except clause could not tell because “Exception” is not 
a specific exception class.
When programming, you should put a code block in a try-­
except statement if 
you know that an error or errors might occur and you may even know what kind 
of error it may be. You want to have the errors handled elegantly. In the sample 
code above, because we ask for input from users and there is no guarantee that 
the user will not input a 0 for m, which will be used as the denominator or divisor, 

we put the code in a try-­
except to handle the possible exception raised by the error. 
Otherwise, the program would stop with a report of the error, as shown below:
In [ ]:
n = int(input('Give me an integer:'))
m = int(input('Give me another integer:'))
n /= m # divide n by m
Out [ ]:
Give me an integer: 12
Give me another integer: 0
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
ZeroDivisionError  Traceback (most recent call last)
<ipython-­
input-­
2-­
d0d8abede315> in <module>
1 n = int(input('give me an integer:'))
2 m = int(input('give me another integer:'))
-­
> 3 n /= m   # divide n by m
ZeroDivisionError: division by zero
	204	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The use of the try-­
except statement will be explained in the next section. 
For now, just remember the code lines between try and except are part of the 
program to be executed for the application, while the code under the except 
header tells what to do when a given exception has occurred.
ArithmeticError
The base class of all arithmetic errors, including OverflowError, ZeroDivision­
Error, and FloatingPointError, which means except ArithmeticError would be 
the same as except (OverflowError, ZeroDivisionError, FloatingPointError). 
Note that when there are multiple error names behind the except keyword, a 
pair of parentheses is used to enclose them.
OverflowError
This subclass of ArithmeticError is raised when the result of an arithmetic 
operation is too large to be represented.
A coding example of catching arithmetic errors like this is shown below:
In [ ]:
try:
  x = pow(123567,999999)
  print(f'Big x has {len(str(x))} digits')
except OverflowError:
  print('It has overflowed because the number is too 
big')
Out [ ]:
Big x has 5091898 digits
The code in the try clause calculates the power of 123567 to 999999 or 
123567**999999. The code is put in a try-­
except statement because the result 
is expected to be very big and may overflow. Though the result has over five 
million digits, no exception is raised because the design and implementation 
of Python can handle very big numbers.
ZeroDivisionError
ZeroDivisionError is raised when the divisor of a division or module operation 
is 0. With this very specific exception/error name, the earlier example of this 
section can be rewritten as shown below:
In [ ]:
try:
  n = int(input('Give me an integer:'))
  m = int(input('Give me another integer:'))
  n /= m   # divide n by m
except ZeroDivisionError:
  print('Wrong: 0 cannot be used as a divisor!')
	
Handle Errors and Exceptions in Programs	
205
 https://doi.org/10.15215/remix/9781998944088.01
Out [ ]:
Give me an integer: 23
Give me another integer: 0
Wrong: 0 cannot be used as a divisor!
FloatingPointError
FloatingPointError is raised when a floating-­
point operation fails. However, 
Python does not raise such errors by default in its standard distribution. You 
will need a Python built with the -­
-­
 with-­
fpectl flag, and import a module called 
fpectl when you want to turn the floating-­
point error control on or off.
AssertionError
AssertionError is raised when the assert statement fails. The assert statement 

is used to make an assertion on an assumed fact, such as whether a variable is 

defined, whether a variable is holding a specific value, or whether a value 

is a member of a sequence or set. If the assumed fact is not True, an Asser­
tionError will be raised so that we know the assumed fact is untrue and we 
may need to deal with it, such as doing something else in the absence of the 
assumed fact.
In [ ]:
vs = list(range(19))   # create a list with 19 members 
indexed from 0 to 18
assert(20 in vs)   # 20 is not in the list
Out [ ]:
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
AssertionError  Traceback (most recent call last)
<ipython-­
input-­
14-­
5a912881af6c> in <module>
1 vs = list(range(19))   # create a list with 19 members indexed from 0 to 18
-­
-­
-­
-­
> 2 assert(20 in vs)   # 19 is out of the range > 18
AssertionError:
AttributeError
AttributeError is raised when an attribute assignment or reference fails. Such an 
error will occur if you use an attribute of an object but the attribute itself does 
not exist.
In [ ]:
class Student:
  pass
s0 = Student()
s0.firstname = 'John'
s0.lastname = 'Doe'
print(s0.fullname)
	206	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Out [ ]:
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
AttributeError  Traceback (most recent call last)
<ipython-­
input-­
15-­
5dc5b1212e9f> in <module>
6 s0.lastname = 'Doe'
7
-­
-­
-­
-­
> 8 print(s0.fullname)
AttributeError: 'Student' object has no attribute 'fullname'
BufferError
BufferError is raised when a buffer-­
related operation cannot be performed. 
This often happens when working directly with computer memory and making 
restricted changes to a given memory area (buffer). The following is an example:
In [ ]:
import io
data = b'Hello, Python!'   # this creates a bytearray
darray = io.BytesIO(data)   # this creates a read-­
write 
copy of the bytearray
dbuff = darray.getbuffer()   # the memory of the 
bytearray is exported
darray.write(b'Hello World!')   # raise error because 
the buffer is not changeable
Out [ ]:
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
BufferError  Traceback (most recent call last)
<ipython-­
input-­
23-­
dc2c4a5f6bbd> in <module>
3 darray = io.BytesIO(data)   # this creates a read-­
write copy of the 
bytearray.
4 dbuff = darray.getbuffer()   # the memory of the bytearray is exported
-­
-­
> 5 darray.write(b'Hello World!')   # raise error because the buffer is not 
changeable
BufferError: Existing exports of data: object cannot be re-­
sized
EOFError
EOFError is raised when the input() function hits the end-­
of-­
file condition.
GeneratorExit
GeneratorExit is raised when a generator’s close() method is called.
ImportError
ImportError is raised when the imported module is not found.
	
Handle Errors and Exceptions in Programs	
207
 https://doi.org/10.15215/remix/9781998944088.01
IndexError
IndexError is raised when the index of a sequence is out of range.
In [ ]:
vs = list(range(19))   # create a list with 19 members 
indexed from 0 to 18
vs[19] *= 3   # 19 is out of the range > 18
Out [ ]:
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
IndexError  Traceback (most recent call last)
<ipython-­
input-­
3-­
47e31ad8b75b> in <module>
1 vs = list(range(19))
-­
-­
-­
-­
> 2 vs[19] *= 3
IndexError: list index out of range
KeyError
KeyError is raised when a key is not found in a dictionary.
In [ ]:
vdict = {1:'One', 2:'Two', 3:'Three'}   # create a 
dictionary
vdict[5]   # the dictionary doesn't have key 5
Out [ ]:
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
KeyError  Traceback (most recent call last)
<ipython-­
input-­
4-­
3011ee6a346e> in <module>
1 vdict = {1:'One', 2:'Two', 3:'Three'}
-­
-­
-­
-­
> 2 vdict[5]
KeyError: 5
KeyboardInterrupt
KeyboardInterrupt is raised when the user hits the interrupt key (Ctrl+C or 
Delete).
MemoryError
MemoryError is raised when an operation runs out of memory.
ModuleNotFoundError
ModuleNotFoundError is raised by import when a module could not be located, 
or None is found in sys.modules.
In [ ]:
import fpectl   # import module fpectl for floating-­
points control
round(14.5/0, 3)
	208	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Out [ ]:
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
ModuleNotFoundError  Traceback (most recent call last)
<ipython-­
input-­
8-­
3808b892163e> in <module>
-­
-­
-­
-­
> 1 import fpectl
2 round(14.5/0, 3)
ModuleNotFoundError: No module named 'fpectl'
NameError
NameError is raised when a variable is not found in the local or global scope.
In [ ]:
print(what)   # print the value of variable named what, 
undefined
Out [ ]:
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
NameError  Traceback (most recent call last)
<ipython-­
input-­
1-­
8b57ddde6300> in <module>
-­
-­
-­
-­
> 1 print(what)
NameError: name 'what' is not defined
NotImplementedError
NotImplementedError is raised by abstract methods such as when an abstract 
method is called.
OSError
OSError is raised when a system operation causes a system-­
related error.
BlockingIOError
BlockingIOError is a subclass of OSError, raised when an operation would block 
on an object (e.g., a socket) set for a nonblocking operation.
ChildProcessError
ChildProcessError is a subclass of OSError, raised when an operation on a child 
process fails.
ConnectionError
ConnectionError is a subclass of OSError and a base class for connection-­
related issues.
	
Handle Errors and Exceptions in Programs	
209
 https://doi.org/10.15215/remix/9781998944088.01
BrokenPipeError
BrokenPipeError is a subclass of ConnectionError, raised when trying to write 
on a pipe while the other end has been closed or when trying to write on a 
socket that has been shut down for writing.
ConnectionAbortedError
ConnectionAbortedError is a subclass of ConnectionError, raised when a con­
nection attempt is aborted by the peer.
ConnectionRefusedError
ConnectionRefusedError is a subclass of ConnectionError, raised when a 

connection attempt is refused by the peer.
ConnectionResetError
ConnectionResetError is a subclass of ConnectionError, raised when a con­
nection is reset by the peer.
FileExistsError
FileExistsError is a subclass of OSError, raised when trying to create a file or 
directory that already exists.
FileNotFoundError
FileNotFoundError is a subclass of OSError, raised when a file or directory 

is requested but does not exist.
IsADirectoryError
IsADirectoryError is a subclass of OSError, raised when a file operation is 
requested on a directory.
NotADirectoryError
NotADirectoryError is a subclass of OSError, raised when a directory oper­
ation is requested on something that is not a directory.
PermissionError
PermissionError is a subclass of OSError, raised when trying to run an operation 
without adequate access rights such as filesystem permissions.
	210	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
ProcessLookupError
ProcessLookupError is a subclass of OSError, raised when a given process 
doesn’t exist.
TimeoutError
TimeoutError is a subclass of OSError, raised when a system function has timed 
out at the system level.
RecursionError
RecursionError is a subclass of Exception, raised when the maximum recursion 
depth set by the system is exceeded. The set recursion depth can be found by 
calling sys.getrecursionlimit().
ReferenceError
ReferenceError is a subclass of Exception, raised when a weak reference proxy 
is used to access a garbage collection referent.
RuntimeError
RuntimeError is raised when an error does not fall under any other category.
StopIteration
StopIteration is raised by the next() function to indicate that there is no further 
item to be returned by the iterator.
StopAsyncIteration
StopAsyncIteration is raised by the __anext__() method of an asynchronous 
iterator object to stop the iteration.
SyntaxError
SyntaxError is raised by the parser when a syntax error is encountered.
In [ ]:
s = 0
for i in range(10)   # a colon is missing which will 
cause a syntax error
  s += i
Out [ ]:
File '<ipython-­
input-­
16-­
6e54ba8cdb35>', line 2
for i in range(10)
                                 ^
SyntaxError: invalid syntax
	
Handle Errors and Exceptions in Programs	
211
 https://doi.org/10.15215/remix/9781998944088.01
IndentationError
IndentationError is raised when there is an incorrect indentation. Such errors 
may occur quite often at the beginning of your study of Python programming. 
You must pay great attention to it because indentation matters a lot in Python 
programs/scripts.
In [ ]:
s = 0
while i < 10:
  s += i
  i += 1# not indented the same
Out [ ]:
File '<tokenize>', line 4
    i += 1   # not indented the same
    ^
IndentationError: unindent does not match any outer indentation level
TabError
TabError is raised when the indentation consists of inconsistent tabs and spaces. 
Indentations can be made of spaces and tabs, but they need to be consistent 
to avoid such errors.
SystemError
SystemError is raised when the interpreter detects an internal error.
SystemExit
SystemExit is raised by the sys.exit() function.
TypeError
TypeError is raised when a function or operation is applied to an object of an 
incorrect type.
In [ ]:
sm = 10 + 'twenty'   # computer doesn't know twenty is 
20
Out [ ]:
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
TypeError  Traceback (most recent call last)
<ipython-­
input-­
19-­
a90f29de94a2> in <module>
-­
-­
-­
-­
> 1 sm = 10 + 'twenty'
TypeError: unsupported operand type(s) for +: 'int' and 'str'
	212	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
UnboundLocalError
UnboundLocalError is raised when a reference is made to a local variable in a 
function or method but no value has been bound to that variable.
UnicodeError
UnicodeError is raised when a Unicode-­
related encoding or decoding error occurs.
UnicodeEncodeError
UnicodeEncodeError is raised when a Unicode-­
related error occurs during 
encoding.
UnicodeDecodeError
UnicodeDecodeError is raised when a Unicode-­
related error occurs during decoding.
UnicodeTranslateError
UnicodeTranslateError is raised when a Unicode-­
related error occurs during 
translation.
ValueError
ValueError is raised when a function gets the correct type of argument but an 
improper value.
In [ ]:
i = int('ten')   # int doesn't convert ten into 10
Out [ ]:
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
ValueError  Traceback (most recent call last)
<ipython-­
input-­
20-­
6bbb9f319a0e> in <module>
-­
-­
-­
-­
> 1 i = int('ten')
ValueError: invalid literal for int() with base-­
10: 'ten'
The following is a sample program to show how errors should be handled 
in a Python program:
# a python program to show how errors and exceptions are 
handled
 
# ask the user to enter two numbers
num1 = input("Enter the first integer number: ")
num2 = input("Enter the second integer number: ")
	
Handle Errors and Exceptions in Programs	
213
 https://doi.org/10.15215/remix/9781998944088.01
# try to convert the inputs to floats and divide them
try:
  result = int(num1) / int(num2)
  print(f"The result of dividing {num1} by {num2} is 
{result}.")
# handle the possible errors and exceptions
except ValueError:
    print("Invalid input. Please enter numbers only.")
except ZeroDivisionError:
    print("Cannot divide by zero. Please enter a nonzero 
number.")
except Exception as e:
    print(f"An unexpected error occurred: {e}")
The following exception will be raised when you run the code but input a 
literal instead of an integer:
Invalid input. Please enter numbers only.
If you type a 0 for the second input, the following exception will be raised:
Cannot divide by zero. Please enter a nonzero number.
Note that in real applications, you may not want a user to restart the pro­
gram when an error has occurred. Instead, you may want to let the program 
continue until the user has given a valid input.
# a python program to show how errors and exceptions are 
handled
 
# initialize a flag to indicate if the division is 
successful
success = False
 
# use a while loop to keep asking for inputs until 
success is True
while not success:
    # ask the user to enter two numbers
    num1 = input("Enter the first number: ")
    num2 = input("Enter the second number: ")
	214	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
    # try to convert the inputs to floats and divide them
    try:
        result = int(num1) / int(num2)
        print(f"The result of dividing {num1} by {num2} 
is {result}.")
        # set success to True if no error occurs
        success = True
    # handle the possible errors and exceptions
    Zexcept ValueError:
        print("Invalid input. Please enter numbers 
only.")
    except ZeroDivisionError:
        print("Cannot divide by zero. Please enter a 
nonzero number.")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
This will ensure the program will continue until two integer numbers are 
received and the division is successful.
Now let us solve a real problem: write a Python program to find all perfect 
numbers in a given range set by a user. A perfect number is an integer number 
that is equal to the sum of all factors, including 1 but excluding itself. For example, 
6 is a perfect number because 6 = 1 + 2 + 3, and 1, 2, and 3 are all its factors.
So basically, the steps to take, or the algorithm, will be as follows:
	
1.	 Get two integers from user to set the range, assigned to a and b, 
respectively. If a is greater than b, then we swap their values.
	
2.	 Loop through all the numbers between a and b, including a and b, and 
test each number to see if it is a perfect number; if yes, we add it to 
a list holding perfect numbers found so far. The list should be set as 
empty at the beginning.
	
3.	 Print out all the perfect numbers in the list, and stop.
To test a number to see if it is perfect, according to the definition above, we 
need to first find out its factors and check whether the sum of all the factors is 
equal to the number itself. So there will be two additional steps:
	 2.1.	 Find out all the factors, and keep them all in a list.
	 2.2.	 Check whether the number is equal to the sum of all its factors in the 
list built up in step 2.1.
	
Handle Errors and Exceptions in Programs	
215
 https://doi.org/10.15215/remix/9781998944088.01
The following is one implementation of the algorithm in Python, taken 
from a Jupyter Notebook cell:
# a python program to find all the perfect numbers in a 
range
# set by the user
 
# first get two integers from user
# initialize a flag to indicate if the division is 
successful
success = False
 
# use a while loop to keep asking for inputs until 
success is True
while not success:
    # ask the user to enter two numbers
    num1 = input("Enter the first number: ")
    num2 = input("Enter the second number: ")
 
    # try to convert the inputs to floats and divide them
    try:
 
        a, b = int(num1), int(num2)
 
        # set success to True if no error occurs
        success = True
 
        if a>b: # then we need to swap a and b
            c = a
            a = b
            b = c
        perfect_list = [] # make an empty list ready to 
hold all perfect numbers
        for n in range(a, b+1): # we said b is included
            # start finding all factors of n
            factor_list = [1] # make a list with 1 as a 
single element
            for f in range(2,n): # start from 2, with n 
as excluded from factors
                if n%f == 0: # f is a factor of n
	216	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
                if n%f == 0: # f is a factor of n
                    if not f in factor_list:
                        factor_list.append(f)
            # now we have a list of factors for n
            if n == sum(factor_list): # n is a perfect 
number
                perfect_list.append([n, factor_list]) # 
keep factors too for checking
        # now we have found all the perfect numbers in 
the range
        print(f"Perfect numbers found between {a} and 
{b}:")
        for n in perfect_list:
            print(n, end=" ")
 
    # handle the possible errors and exceptions
    except ValueError:
        print("Invalid input. Please enter numbers 
only.")
    except ZeroDivisionError:
        print("Cannot divide by zero. Please enter a 
nonzero number.")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
When running the program with Jupyter Notebook in VS Code, by pressing 
Ctrl+Enter and inputting 3 and 1000 for the two numbers requested, the fol­
lowing output will be produced:
Perfect numbers found between 3 and 1000:
[6, [1, 2, 3]] [28, [1, 2, 4, 7, 14]] [496, [1, 2, 4, 8, 16, 31, 62, 124, 248]]
The output shows both the perfect numbers and a list of their factors.
4.2 Handling Runtime Errors and Exceptions
The runtime errors and exceptions discussed can be fatal or nonfatal. By a non­
fatal error, we mean that when the error occurs, the program can still continue 
if it is properly handled. In contrast, when a fatal error occurs, the program 
stops and has to be fixed before you can restart the program.
	
Handle Errors and Exceptions in Programs	
217
 https://doi.org/10.15215/remix/9781998944088.01
When programming, since runtime errors (or “exceptions,” to use a more 
techie term) are unavoidable, the best a programmer can do is to have all 
exceptions caught and handled properly when they occur. Otherwise, what 
renders to the users when an error has occurred could be overwhelming 
and irritating. Consider the following code example, which simply asks for 
a numeric grade.
In [ ]:
grade = int(input('Please input your grade: '))
When a letter grade is entered instead, a runtime error occurred, and Python 
interpreter or Python Virtual Machine (PVM) renders a bunch of information 
about the error, as shown below:
Out [ ]:
Please input your grade: A
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
ValueError  Traceback (most recent call last)
<ipython-­
input-­
13-­
d0126eb94acb> in <module>
-­
-­
-­
-­
> 1 grade = int(input('Please input your grade: '))
ValueError: invalid literal for int() with base-­
10: 'A'
Although the information above may be helpful for programmers to debug 
the code and correct the error, it is completely useless for ordinary users. For 
that reason, all modern programming languages provide some way to handle 
runtime errors and exceptions so that only sensible information can be seen 
by users and, in most cases, programs can continue and recover from errors 
peacefully, without crashing.
Similar to those in other modern programming languages, Python excep­
tions are handled with a try statement. The general coding structure of try 
statements is as follows:
# the try clause is for enclosing a code block of the 
program
# in which errors may occur
try:
  <code block in the normal code flow>   # things to do 
normally
 
except <exception/error 1>:   # the except clause is for 
handling errors
	218	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
  <code block for exception 1>   # things to do if 
exception 1 happens
 
except <exception/error 2>:   # except clause may have a 
list of errors
  <code block for exception 2>   # things to do if 
exception 2 happens
 
except <exception/error 3>:   # there can be more 
exceptions
  <code block for exception 3>   # things to do if 
exception 3 happens
 
else:   # do something when no error has occurred
  <code block for else>   # things to do when no 
exceptions are raised
 
finally:   # finally clause allows to do something 
regardless of the above
  <code block for finally>   # things to do regardless of 
the above
As shown, a try statement starts with a try clause, which encloses the 
code that you want to run for the application but may cause errors and raise 
exceptions.
Right after the try clause is one or more exception clauses, each of which 
starts with the keyword “except,” followed by a system-­
defined error/exception 
name. The code of each exception clause specifies what you want to do if this 
error happens.
In [ ]:
try:
  grade = int(input('Please input your grade: '))
except ValueError as e:
  print('Exception has been raised! ', e)
Out [ ]:
Please input your grade: A
Exception has been raised! invalid literal for int() with base-­
10: 'A's
Note that in the code above, ValueError is the name of a built-­
in exception 
class. We put this code in a try statement because you do not know whether 
the user will type an integer as expected. If a nonnumber is typed, an error 
will occur for function int.
	
Handle Errors and Exceptions in Programs	
219
 https://doi.org/10.15215/remix/9781998944088.01
The else clause encloses the code specifying what to do if no errors are 
caught by all the exception blocks.
The finally clause encloses the code that will run regardless of whether any 
exception has been raised within the try clause.
Now comes the question of when you need to put a code block in a try state­
ment. You cannot put every piece of code in a try statement. The rule is that 
if a statement or block of code may cause an error during runtime, especially 
when the possibility is out of your control, the statement or code should be 
enclosed in a try statement and each of the possible errors should be handled 
properly. Examples of such a possibility may include the following situations:
	
1.	 Statements involve user input, because you never know if a user will 
do what you expected.
	
2.	 Statements involve the use of files, because there is no guarantee as to 
the status of the file. It may have been deleted when you want to read 
it; it may already have existed when you want to create a new one with 
same name.
	
3.	 Statements involve the use of resources on the web or on the internet 
in general because the resources may no longer be available.
	
4.	 Statements involve the use of numbers from user input or involve 
calculation, where 0 may end up as a denominator.
	
5.	 Statements involve extensive use of computer memory, which may 
lead to the depletion of RAM.
Chapter Summary
•	 Programs can have syntax errors and logic errors.
•	 Errors that are found when running the program are runtime errors.
•	 A good IDE can often help you avoid many syntax errors, including 
undefined names, incorrect indentation, incorrect formation of 
statements, and more. If there are syntax errors in your program, look 
for marks that your IDE may have added to indicate them in your code.
•	 Logic errors are caused by incorrect problem solving or programming 
logic. Examples include values that are out of the intended range and 
the incorrect use of operators or functions.
•	 Some logic errors can raise exceptions at runtime. For example, if an 
index variable for a sequence (string, list, or tuple) is out of range, an 
exception will be raised.
•	 Some logic errors can only be discovered by programmers, system testers, 
or users who notice an unexpected result or behaviour in the system.
	220	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
•	 A Python interpreter or virtual machine will raise exceptions when a 
runtime error has occurred. If exceptions are not caught and properly 
handled, the application or system will crash and become very ugly.
•	 Python and many other modern programming languages use try-­
except 
statements to handle exceptions.
•	 In Python, a try statement may take one of five forms: try-­
except, 
try-­
except-­
else, try-­
except-­
finally, try-­
except-­
else-­
finally, and 
try-­
finally.
•	 Between try and except, there should be a code block that may have 
runtime errors (such as incorrect input from users, files, or network 
sockets). The try keyword and the code block together form a try 
clause; right behind the except keyword, there should be the name or 
names of errors, followed by a code block to be run when the named 
error or errors occurred, which together form an except clause.
•	 A try clause can be followed by multiple except clauses.
•	 An except clause can be followed by an else clause, which consists of 
the else keyword and a code block to be run when an error has occurred 
but didn’t match any of the named errors in the except clauses.
•	 The finally clause can be used as a final clause of a try statement. It 
consists of the finally keyword and a code block that is to be run in all 
circumstances, whether an error has occurred or not.
Exercises
	
1.	 Suppose that you want to get an integer from a user, but you are 
concerned that the user may type something else other than an 
integer. Write a piece of code, as concise as possible, that asks the user 
for input until an integer is entered by the user.
	
2.	 What error will occur when running the following code?
	
a.	 s = 8 + 'a'
	
b.	 students = ['John', 'May', 'Jim']
	
c.	 total = sum(12, 90, 32, 'one hundred')
	
3.	 What’s wrong with the following code?
idx = 1
product = 0
while idx>10:
 product *= idx
 idx++
print(product)
 https://doi.org/10.15215/remix/9781998944088.01
Chapter 5
Use Sequences, Sets, 
Dictionaries, and Text Files
Chapter 5 details how compound data types and files can be used in program­
ming to solve problems. Data need to be structured and organized to represent 
certain kinds of information and to make problem solving, information process­
ing, and computing possible and more efficient. In addition to integer, float, 
and complex numbers, Python provides compound data types to represent 
more complicated information. These compound data types include strings, 
lists, tuples, sets, and dictionaries, as well as files that can be used to store 

a large volume of data in the long term (after the computer is shut off).
Learning Objectives
After completing this chapter, you should be able to
•	 explain sequences.
•	 explain strings and the methods and functions that can be applied to 
them.
•	 construct and format strings with the f prefix and the format method.
•	 discuss lists and tuples and the differences between the two.
•	 properly use the methods and functions of lists and tuples.
•	 explain sets and dictionaries and discuss the methods and functions 
that can be used on them.
•	 explain files and discuss the differences between text files and binary 
files and the methods and functions available for manipulating files.
•	 use strings, lists, tuples, sets, dictionaries, and files in problem solving 
and system design and development with Python.
	222	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
5.1 Strings
The string is one of the most important data types for information representa­
tion and processing. Strings are the base of information and data, and they 
were used to structure the sequences of characters for the ASCII table in the 
early days of modern computers. They are still used the same way now in UTF-­
8 

(8-­
bit Unicode Transformation Format Unicode), which includes characters for 
all human languages in the world.
Because strings are sequences of characters, the characters are ordered 

and indexed. We can access and manipulate individual characters through these 
indexes, starting from 0, as shown in the following example:
>>> name = "John Doe"
>>> name[0]
"J"
>>> name[3]
"n"
To construct a string from another data type, you use built-­
in function str(), 
as shown in the following example:
>>> tax_rate = 0.16
>>> tax_string = str(tax_rate)
>>> tax_string
'0.16'
>>> type(tax_string)
<class 'str'>
Methods of Built-­
In Class str
As is the case with some other object-­
oriented programming languages, string 
is a built-­
in class but is named str in Python. The str class has many powerful 
methods built into it, as detailed below with coding samples.
S.CAPITALIZE()
This converts the first character of the first word of string s to upper case and 
returns the converted string. Please note that characters in string s remain 
unchanged. This is the same for all string methods: no string method will alter 
the content of the original string variable. Rather, the method will make a copy 
of the content, manipulate the copy, and return it.
	
Use Sequences, Sets, Dictionaries, and Text Files	
223
 https://doi.org/10.15215/remix/9781998944088.01
>>> s = "intro to programming with python"
>>> s_capitalized = s.capitalize()
>>> s_capitalized
'Intro to programming with python'
>>> s
'intro to programming with python'
S.CASEFOLD()
Converts all characters of string s into lower case and returns the converted 
characters.
>>> s_capitalized
'Intro to programming with python'
>>> s_capitalized.casefold()
'intro to programming with python'
S.CENTER(SPACE)
Returns a string centred within the given space. Note how the empty whitespace 
is divided when the number is not even.
>>> s="hello"
>>> s.center(10)
' hello '
S.COUNT(SUB)
Returns the number of times a specified value occurs in a string.
>>> s = "intro to programming with python"
>>> s.count('i')
3
>>> s.count('in')
2
S.ENCODE()
Returns an encoded version of characters if they are not in the standard ASCII 
table. In the example below, there are Chinese characters in the string assigned 
to variable es.
>>> es = "Python is not a big snake (蟒蛇)"
>>> print(cs.encode())
b'Python is not a big snake \xe8\x9f\x92\xe8\x9b\x87'
	224	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Please note that the b in b'Python is not a big snake \xe8\x9f\x92\xe8\x9b\
x87' indicates that all non-­
ASCII characters in the string are in byte.
S.ENDSWITH(SUB)
Returns true if the string ends with the specified value, such as a question mark.
>>> cs = "Is Python an animal?"
>>> print(cs.endswith('?'))
True
S.EXPANDTABS(TS)
Sets the size of tabs in the string to ts, which is an integer.
>>> cs = "Is\t Python\t an\t animal?"
>>> cs
'Is\t Python\t an\t animal?'
>>> print(cs)
Is Python an animal?
>>> print(cs.expandtabs(10))
Is  Python  an  animal?
S.FIND(SUB)
Searches the string for a substring and returns the position of where it was 
found.
>>> s= 'intro to programming with python'
>>> s.find("ro")
3
S.FORMAT(*ARGS, **KWARGS)
Formats specified values given in the list of position arguments *args, and/or 
the list of keyword arguments **kwargs into string s, according to the format­
ting specs given in s.
This is very useful in constructing complex strings.
>>> "Hello {0}, you are {1:5.2f} years 
old.".format("Python", 23.5)
'Hello Python, you are 23.50 years old.'
	
Use Sequences, Sets, Dictionaries, and Text Files	
225
 https://doi.org/10.15215/remix/9781998944088.01
Please note that when mapping a dictionary, s.format(**mapping) can 
be used to format a string by mapping values of the Python dictionary to 
its keys.
>>> point = {'x':9,'y':-­
10} # point is a dictionary
>>> print('{x} {y}'.format(**point))
9 -­
10
Please note that ** has converted the dictionary point into a list of key­
word arguments. This formatting can also be done by directly using keyword 
arguments:
>>> print('{x} {y}'.format(x=9,y=-­
10))
9 -­
10
S.FORMAT_MAP(MAPPING)
Similar to format(**mapping) above. The only difference is that this one takes 
a dictionary without operator **.
>>> point = {'x':9,'y':-­
10}
>>> print('{x} {y}'.format_map(point))
9 -­
10
S.INDEX(SUB)
Searches the string for a substring and returns the position of the substring. 
Generates a return error if there is no such substring.
Note that this may not be a good method to test if one string is a substring 
of another.
>>> s= 'intro to programming with python'
'intro to programming with python'
>>> s.index("ing")
17
>>> s.index('w')
21
>>> s.index('z')
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
ValueError: substring not found
	226	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
S.ISALNUM()
Returns True if all characters in the string are alphanumeric.
>>> "98765".isalnum()
True
>>> "98765abcde".isalnum()
True
>>> "98765<>abcde".isalnum()
False
S.ISALPHA()
Returns True if all characters in the string are in the alphabet, including Unicode 
characters.
>>> "abcde".isalpha()
True
>>> "abcTde".isalpha()
True
>>> "abc35Tde".isalpha()
False
>>> "abc他Tde".isalpha()
True
S.ISDECIMAL()
Returns True if all characters in the string are decimals.
>>> "1235".isdecimal()
True
>>> "1235.65".isdecimal()
False
>>> "1235.65e".isdecimal()
False
S.ISDIGIT()
Returns True if all characters in the string are digits.
>>> "123565".isdigit()
True
>>> "1235.65".isdigit()
False
	
Use Sequences, Sets, Dictionaries, and Text Files	
227
 https://doi.org/10.15215/remix/9781998944088.01
>>> "1235y65".isdigit()
False
S.ISIDENTIFIER()
Returns True if the string is an identifier by Python’s definition.
>>> "w1235y65".isidentifier()
True
>>> "9t1235y65".isidentifier()
False
>>> "w1235_y65".isidentifier()
True
S.ISLOWER()
Returns True if all characters in the string are lower case.
>>> "w1235y65".isidentifier()
True
>>> "9t1235y65".isidentifier()
False
>>> "w1235_y65".isidentifier()
True
S.ISNUMERIC()
Returns True if all characters in the string are numeric.
>>> "123565".isnumeric()
True
>>> "1235.65".isnumeric()
False
>>> "123565nine".isnumeric()
False
S.ISPRINTABLE()
Returns True if all characters in the string are printable.
>>> "123565nine".isprintable()
True
>>> "123565 all printable".isprintable()
True
	228	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> "123565 all printable<>!@#$%^&**".isprintable()
True
S.ISSPACE()
Returns True if all characters in the string are whitespace.
>>> "  ".isspace()
True
>>> " \t  ".isspace()
True
>>> " \t  \n".isspace()
True
>>> " \t  m\n".isspace())
False
S.ISTITLE()
Returns True if the string follows the rules of a title—­
that is, the first letter of 
each word is upper case, while the rest are not.
>>> "Python Is a Great Language".istitle()
False
>>> "Python Is A Great Language".istitle()
True
S.ISUPPER()
Returns True if all characters in the string are upper case.
>>> "THIS IS ALL UPPER".isupper()
True
>>> "THIS IS ALL UPPER with some lower".isupper()
False
SEP
.JOIN(ITERABLE)
Joins the elements of an iterable with the separator. The iterable can be a list, 
tuple, string, dictionary, or set. Note that each element of the iterable must be 
a string. An integer or other number will raise an error.
>>> "-­
".join([" for", " programming!"])
'for-­
 programming!'
>>> "&".join([" for", " programming!"])
	
Use Sequences, Sets, Dictionaries, and Text Files	
229
 https://doi.org/10.15215/remix/9781998944088.01
'for& programming!'
>>> "%".join([" for", " programming!"])
'for% programming!'
>>> "%".join(" for programming!")
'%f%o%r% %p%r%o%g%r%a%m%m%i%n%g%!'
>>> "%".join(('a', '2', '3'))
'a%2%3'
>>> "%".join({'a', '2', '3'})
'3%a%2'
>>> "%".join({'a':'mnmn', '2':'987', '3':'43322'})
'a%2%3'
S.LJUST(SL)
Returns a left-­
justified version of the string within the given size of space.
>>> "Python Is A Great Language".ljust(30)
'Python Is A Great Language  '
S.LOWER()
Converts a string into lower case.
>>> "Python Is A Great Language".lower()
'python is a great language'
S.LSTRIP()
Returns a left trim version of the string.
>>> "  Python Is A Great Language  ".lstrip()
'Python Is A Great Language  '
S.MAKETRANS(DICT)
S.MAKETRANS(S1, S2)
Return a translation table to be used in translations.
In s.maketrans(dict), key-­
value pairs of dict provide mapping for translation; in 
the case of s.maketrans(s1, s2), chars in s1 are mapped to chars in s2 one by one.
>>> "Python Is A Great Language".maketrans({'a':'b', 
'c':'d'})
{97: 'b', 99: 'd'}
>>> "Python Is A Great Language".maketrans('ab', 'cd')
{97: 99, 98: 100}
	230	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
S.PARTITION(SUB)
Returns a tuple where the string is divided into three parts with sub in the 
middle.
>>> "Python Is A Great Language".partition('A')
('Python Is ', 'A', ' Great Language')
S.REPLACE(S1, S2)
Returns a string where a specified value is replaced with a specified value.
>>> "Python Is A Great Language".replace('Great', 
'Powerful')
'Python Is A Powerful Language'
S.RFIND(SUB)
Searches the string from the right for a substring and returns the position 

of where it was first found.
>>> "Python Is A Great Language".rfind('g')
24
S.RINDEX(SUB)
Searches the string from the right for a substring and returns the index of 

the substring where it was first found.
>>> "Python Is A Great Language".rindex('g')
24
S.RJUST(SUB)
Returns a right-­
justified version of the string within the given size of space.
>>> "Python Is A Great Language".rjust(35)
'   Python Is A Great Language'
S.RPARTITION(SUB)
Returns a tuple where the string is divided into three parts at the substring 
found from the right.
>>> "Python Is A Great Language".rpartition('g')
('Python Is A Great Langua', 'g', 'e')
	
Use Sequences, Sets, Dictionaries, and Text Files	
231
 https://doi.org/10.15215/remix/9781998944088.01
S.RSPLIT(SEP)
Splits the string at the specified separator and returns a list.
>>> "Python Is A Great Language".rsplit('g')
['Python Is A Great Lan', 'ua', 'e']
S.RSTRIP()
Returns a right-­
trimmed version of the string.
>>> "Python Is A Great Language ".rstrip()
'Python Is A Great Language'
S.SPLIT(SEP)
Splits the string at the specified separator and returns a list.
>>> "Python Is A Great Language".split('g')
['Python Is A Great Lan', 'ua', 'e']
S.SPLITLINES()
Splits the string at line breaks and returns a list.
>>> "Python Is A Great Language.\n I love 
it.".splitlines()
['Python Is A Great Language.', ' I love it.']
S.STARTSWITH(SS)
Returns true if the string starts with the specified value.
>>> "Python Is A Great Language".startswith('g')
False
>>> "Python Is A Great Language".startswith('P')
True
S.STRIP()
Returns a trimmed version of the string.
>>> " Python Is A Great  Language ".strip()
'Python Is A Great  Language'
	232	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
S.SWAPCASE()
Swaps cases, so lower case becomes upper case, and vice versa.
>>> "Python Is A Great Language".swapcase()
'pYTHON iS a gREAT lANGUAGE'
S.TITLE()
Converts the first character of each word to upper case.
>>> 'pYTHON iS a gREAT lANGUAGE'.title()
'Python Is A Great Language'
S.TRANSLATE()
Returns a string translated from s using a translation table created with the 
maketrans() method.
>>> table = "".maketrans("ab", 'cd')
>>> print("Python Is A Great Language".translate(table))
Python Is A Grect Lcngucge
S.UPPER()
Converts a string into upper case.
>>> "Python Is A Great Language".upper()
'PYTHON IS A GREAT LANGUAGE'
S.ZFILL(SL)
Fills the string to a specific length with a specified number of 0s at the beginning.
>>> "Python Is A Great Language".zfill(39)
'0000000000000Python Is A Great Language'
Built-­
In Functions and Operators for Strings
In addition to the string methods that you can use to manipulate strings, there 
are built-­
in functions and operators. The following are some examples.
USE OPERATOR + TO JOIN STRINGS TOGETHER
>>> "Python is a good language " + "for first-­
time 
programming learners."
'Python is a good language for first-­
time programming 
learners.'
	
Use Sequences, Sets, Dictionaries, and Text Files	
233
 https://doi.org/10.15215/remix/9781998944088.01
USE OPERATOR * TO DUPLICATE A STRING
>>> "Python! "*3
'Python! Python! Python! '
USE BUILT-­
IN FUNCTION LEN(S) TO FIND OUT THE LENGTH IF A 
STRING
>>> p_string = "Python is a good language " + "for first-­
time programming learners."
>>> len(p_string)
62
USE OPERATOR [I:J] TO SLICE A STRING
>>> p_string[0:5]   # slice begins at index 0 till index 
5 but excluding 5
'Pytho'
>>> p_string[5:25]   # slice begins at index 5 till index 
25 but excluding 25
'n is a good language'
>>> p_string[:16]   # when the starting index point is 
missing, 0 is assumed
'Python is a good'
>>> p_string[6:]   # when the ending index point is 
missing, the string is copied from the start to the end
'is a good language for first-­
time programming 
learners.'
>>> p_string[:]   # when both indexes are missing, the 
entire string is copied
'Python is a good language for first-­
time programming 
learners.'
>>> p_string[:-­
1] #the result is the same as using [:]
'Python is a good language for first-­
time programming 
learners'
Table 5-­
1 summarizes the operators and built-­
in functions you can use to 
manipulate strings.
	234	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Table 5-­
1: String-­
related operators and built-­
in functions
Operators and 
built-­
in functions 
on string
Operation
Code samples in Python interactive 
mode
s[n]
Get the character at 
nth position (n is 
an integer)
>>> name = "John Doe"
>>> name[2]
'h'
s[start:end]
Get a slice of the 
string. Negative 
indexes can also 
be used to count 
from the end.
>>> name = "John Doe"
>>> name[2:6]
'hn D'
>>> name = "John Doe"
>>> name[:-­
3]
'John '
s1 + s2
Concatenate two 
strings together
>>> first_name = "John"
>>> last_name = "Doe"
>>> first_name +' '+ 
last_name
'John Doe'
s * n
Duplicate s n times
>>> (name +' ')*3
'John Doe John Doe John Doe '
s1 in s
Test if s1 is a 
substring of s
>>> first_name in name
True
len(s)
Get the length of 
string s
>>> len(name)
8
print(s)
Print string s
>>> name = "John Doe"
>>> print(name)
John Doe
In addition to the ways discussed above to construct and manipulate strings, 
Python also provides some methods for constructing and formatting strings 
nicely.
Constructing and Formatting Strings
Because text is made of strings, and text is very important in representing data, 
information, and knowledge, there is a need to convert various data objects into 
well-­
formatted strings. For this purpose, Python has provided programmers 
with a very powerful means of formatting strings that may consist of various 
types of data such as literals, integer numbers, float numbers with different 
precisions, compound data, and even user-­
defined objects.
	
Use Sequences, Sets, Dictionaries, and Text Files	
235
 https://doi.org/10.15215/remix/9781998944088.01
In 2.1, we saw how we could use f/F, r/R, u/U, and b/B to provide some dir­
ection on string formation and representation. We also saw that prefixing f or 
F to a string allows us to conveniently embed expressions into the string with 
{ } and have the expressions be automatically evaluated. In the following, you 
will see two more ways of formatting strings.
FORMATTING WITH %-­
LED PLACEHOLDERS
Let’s begin with an example to explain how %-­
led placeholders are used to 
format and construct strings:
In [ ]:
d, n = 5.689, 8   # assigning values to variable d and 
n
s0 = "n has a value of %3d, and d has a value of 
%9.5f"%(n, d)   # with %-­
led placeholders
print(s0)   # s is evaluated
Out [ ]:
n has a value of 8, and d has a value of 5.68900
In the example above, the string before the last percentage sign % is called 
a formatting string. %3d is a %-­
led placeholder for an integer that will take a 
3-­
digit spot, whereas %9.5 is a %-­
led placeholder for a float number, where 9 
specifies the total number of digits the float number will take and 5 specifies the 
total number of decimal digits. The values in the tuple behind the last percent­
age sign are to be converted and placed into their corresponding placeholders. 
In the example, the value of n will be converted to an integer and placed into the 
first placeholder, whereas the value of d will be converted into a float number 
and placed into the second placeholder.
You can also use named placeholders, as shown in the next example, where 
the course and language (in the parentheses) are the names of the placeholders.
In [ ]:
course_number = 'comp218'
language = 'Python'
s1 = '%(course)7s -­
 introduction to programming in 
%(language)s '%{'course':course_number,
'language':language}
print(s1)
Out [ ]:
comp218 -­
 introduction to programming in Python
Note that when named placeholders are used, you will need to use dictionary 
instead of a tuple behind the last percentage sign.
The general format of a %-­
led placeholder is as follows:
	236	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
%[flags][width] [.precision] type
or the following, if you like to use named placeholders:
%[(name)][flags][width] [.precision] type
The flags may use one or a combination of the characters in Table 5-­
2.
Table 5-­
2: Flags used in placeholders in formatting strings
Flag
Meaning
Code sample
#
Used with b, o, x, or X, 
this specifies that the 
formatted value is 
preceded with 0b, 0o, 0x, 
or 0X, respectively.
>>> data = ("COMP 218", 10)
>>> '%s has %#X units.' % data
'COMP 218 has 0XA units.'
0
The conversion result 
will be zero-­
padded for 
numeric values.
>>> data = {"course": "COMP 
218", "number": 10}
>>> '%(course)s has 
%(number)016d units.' % data
'COMP 218 has 0000000000000010 
units.'
-­
The converted value is 
left-­
adjusted.
>>> data = {"course": "COMP 
218", "number": 10}
>>> '%(course)s has 
%(number)-­
6d units.' % data
'COMP 218 has 10  units.'
If no sign (e.g., a minus 
sign) is going to be 
written, a blank space is 
inserted before the value.
>>> data = {"course": "COMP 
218", "number": -­
10}
>>> '%(course)s has 
%(number)16d units.' % data
'COMP 218 has  10 units.'
+
The converted value is 
right-­
adjusted, and a 
sign character (+ or -­
, 
depending on whether 
the converted value is 
positive or negative) will 
precede it.
>>> data = {"course": "COMP 
218", "number": -­
10}
>>> '%(course)s has 
%(number)+6d units.' % data
'COMP 218 has  -­
10 units.'
The width is the total width of space held for the corresponding value, and 
precision is the number of digits that the decimal portion will take if the value 
is a float number. The type can be one of the types shown in Table 5-­
3.
	
Use Sequences, Sets, Dictionaries, and Text Files	
237
 https://doi.org/10.15215/remix/9781998944088.01
Table 5-­
3: Types used in placeholders for formatting strings
Conversion
Meaning
Code sample
d, i, or u
Signed integer decimal.
Note that in the last three coding 
samples, the plus sign has 
been automatically removed in 
the printout.
>>> print("%+d"% (88))
+88
>>> print("%+i"% (88))
+88
>>> print("%+u"% (88))
+88
>>> print("%+u"% (-­
88))
-­
88
>>> print("%+i"% (-­
88))
-­
88
>>> print("%+d"% (-­
88 ))
-­
88
o
Unsigned octal.
>>> print("%10o"% (25))
31
>>> print("%10.3o"% 
(25))
031
>>> print("%10.5o"% 
(25))
00031
X or x
Unsigned hexadecimal.
>>> print("%6.5X"% (88))
00058
>>> print("%6.5x"% (88))
00058
>>> print("%#5X"% (88))
0X58
>>> print("%5X"% (88))
58
E or e
Floating-­
point exponential format 
(lower case or upper case).
>>> print("%10.3e"% 
(123456.789))
1.235e+05
>>> print("%10.3E"% 
(123456.789))
1.235E+05
F or f
Floating-­
point decimal format.
>>> print("%13.5f"% 
(123456.789))
123456.78900
>>> print("%13.5F"% 
(123456.789))
123456.78900
G or g
Same as E or e if exponent is 
greater than −4 or less than 
precision; F otherwise.
>>> print("%13.5g"% 
(123456.789))
1.2346e+05
>>> print("%13.5G"% 
(123456.789))
1.2346E+05
(continued on next page)
	238	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Conversion
Meaning
Code sample
c
Single character (accepts integer 
or single character string).
>>> s = 'Python is 
great!'
>>> 'The first character 
of string %s is %c'%(s, 
s[0])
'The first character of 
string Python is great! 
is P'
r
String (converts any python 
object using repr() or __repr__(), 
instead of str() or __str__()). In 
class definition, you need to 
implement the dunder method 
__repr__ in order for repr() or __
repr__() to work on the objects 
of the defined class.
>>> 'The complex number 
will be displayed as 
%r'%(cn)
'The complex number 
will be displayed as 
(12+35j)'
s
String (converts any python 
object using str()). We will see 
the difference between %r and 
%s when we defined __repr__ 
method for a user-­
defined 
class.
>>> 'The complex number 
will be displayed as 
%s'%(cn)
'The complex number 
will be displayed as 
(12+35j)'
%%
No argument is converted 
(results in a "%" character in 
the result). It works only if the 
formatting is complete.
>>> '%% will be displayed 
as a single percentage 
sign, and the complex 
number is %s'%(cn)
'% will be displayed as 
a single percentage 
sign, and the complex 
number is (12+35j)'
FORMATTING STRINGS WITH THE FORMAT METHOD
Compared to the two methods we have seen so far, a more formal way of string 
formatting in Python is using the format method, as shown in the following 
example:
>>> s = "{0} is the first integer; {1} is the second 
integer".format(88, 99)
>>> s
'88 is the first integer; 99 is the second integer'
Table 5-­
3: Types used in placeholders for formatting strings (continued)
	
Use Sequences, Sets, Dictionaries, and Text Files	
239
 https://doi.org/10.15215/remix/9781998944088.01
The {} in the above example is also called a placeholder or replacement 
field. You can index the placeholders with integer numbers starting from 0, 
corresponding to the positions of values. You can also name the placeholders, 
in which case dictionary or keywords arguments need to be used within the 
format method call. In the example above, if we switch the indices (0 and 1), 
99 will be placed as the first integer and 88 will be placed as the second integer, 
as shown below:
>>> s = "{1} is the first integer; {0} is the second 
integer".format(88, 99)
>>> print(s)
99 is the first integer; 88 is the second integer
The general form of the replacement field is as follows:
{[field_name] [! conversion] [: format_spec]}
As mentioned before, having the item inside [] is optional; a placeholder 
can be as simple as an empty {}, as shown in the following example:
>>> 'X: {}; Y: {}'.format(3, 5)
'X: 3; Y: 5'
In the general form of the replacement field above, field name is something 
that can be used to identify the object within the arguments of the format 
method. It can be an integer to identify the position of the object, a name if 
keyword arguments are used, or a dot notation referring to any attribute of the 
object, as shown in the following example:
>>> c = 23 -­
 35j
>>> ('The complex number {0} has a real part {0.real} and 
an imaginary part {0.imag}.').format(c)
'The complex number (23 -­
 35j) has a real part 23.0 and 
an imaginary part -­
35.0.'
In this string formatting example, the first placeholder is {0}, in which 
integer 0 indicates that the value of the first argument of the format method 
call will be placed here; the second placeholder is {0.real}, which indicates 
that the value of the attribute real of the first object pf the format method call 
will be converted and inserted in that location; and the third placeholder is 
	240	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
{0.imag}, which indicates that the value of the attribute imag of the first object 
of the format method call will be converted and inserted in that location. It 
is up to the programmer to use the right attribute names or to compose the 
right reference to a valid object or value within the arguments of the format 
method call.
Please note that conversion in the general form of the replacement field 
above is led by an exclamation mark !, which is followed by a letter: r, s, or a. 
The combination !r is used to convert the value into a raw string, !s is used to 
convert the value into a normal string, and !a is used to convert the value into 
standard ASCII, as shown in the following examples:
>>> print('{!r} is displayed as a raw string'.format('\t 
is not tab, \n is not newline'))
'\t is not tab, \n is not newline' is displayed as a raw 
string.
 
>>> print('{!s} is not displayed as a raw string'.
format('\t is a tab, \n is a new line'))
is a tab,
is a new line is not displayed as a raw string.
 
>>> print('{!s} is displayed in Chinese'.format('Python 
is not 大蟒蛇.'))
Python is not 大蟒蛇. is displayed in Chinese.
 
>>> print('{!a} is displayed as an ASCII string'.
format('Python is not 大蟒蛇.'))
'Python is not \u5927\u87d2\u86c7.' is displayed as an 
ASCII string.
Please note the difference between the two outputs using !s and !a in 
particular.
It may also have been noted that with !r, the quotation marks surrounding 
the argument remain in the output, whereas with !s, the quotation marks have 
disappeared from the output. This is true when the argument for the !r is a 
string.
When the argument for !r is not a string, especially when it is a compli­
cated object, o, the !r will cause the placeholder to be replaced with the result 
of o.repr(), which in turn calls the dunder method __repr__() defined for the 
	
Use Sequences, Sets, Dictionaries, and Text Files	
241
 https://doi.org/10.15215/remix/9781998944088.01
object’s class. You will learn how to define and use Python dunder methods 
later in Chapter 7.
In string formatting with format method, formatting specification is led by 
a colon :, which is followed by formatting instructions, including the following:
	
1.	 justification or alignment: > for right justification, < for left 
justification, ^ for centre justification
	
2.	 with/without sign for numbers: + for always showing the sign, − for 
only show the minus sign, and ' ' for showing a whitespace when the 
number is positive
	
3.	 the total number of letter spaces allocated to the data, such as in {:6d}, 
where 6 specifies that 6 letter spaces are taken by the integer number
	
4.	 the number of decimal digits for float numbers, such as in {:6.2f}, in 
which the 2 specifies the decimal, so the float number will be rounded 
to take 2 spaces
	
5.	 data type conversion indicates what data will be converted and 
inserted into the placeholder; the types of data include
	
a.	 s for string
	
b.	 d for integer
	
c.	 f for float number
	
d.	 x or X for hex number
	
e.	 o for octal number
	
f.	 b for binary number
	
g.	 #x, #X, #o, and #b to prefix the numbers 0x, 0X, 0o, and 0b, 
respectively
The following example shows how the data type conversions work:
>>> '{:+12.8f}, {:+f}, {:#b}, {:#X}'.format(2.71828182, 
-­
3.14, 78, 127)
' +2.71828182, -­
3.140000, 0b1001110, 0X7F'
If you wish the output of a placeholder to be left, right, or centre justified 
within the given space, <, >, or ^ can be used to lead the format spec, as shown 
in the following example:
>>> '{:<+22.8f}, {:+f}, {:#b}, {:#X}'.format(2.71828182, 
-­
3.14, 78, 127)
'+2.71828182  , -­
3.140000, 0b1001110, 0X7F'
	242	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
If you want the extra space to be filled with a special character, such as #, 
you can put the character between the colon and <, >, or ^, as shown below:
>>> '{:#^+22.8f}, {:+f}, {:#b}, {:#X}'.format(2.71828182, 
-­
3.14, 78, 127)
'#####+2.71828182######, -­
3.140000, 0b1001110, 0X7F'
By this point, we have learned three ways of constructing and formatting 
strings: the first one is to use the f/F prefix, the second is to use a %-­
led place­
holder, and the last is to use the format method.
Among the three, the first one is the most compact and good for simple 
string construction without any fancy formatting. The expression within each 
{} will be evaluated, and the value will be converted into a string with which 
the placeholder is replaced as is.
Both the second and the third way can be used to construct and format 
more complex strings from various objects. The difference between the two is 
that the second, using a %-­
led placeholder, is more casual, whereas the third 
is more formal and the code more readable.
Regular Expressions
Information processing and text manipulation are important uses for modern 
computers, and regular expressions, called “REs” or “regexes” for short, were 
developed as a powerful way to manipulate text. Many modern programming 
languages have special libraries for searching and manipulating text using 
regular expressions. In Python, a standard module called re was developed 
for that purpose.
To correctly use the re module, we first must understand what regular 
expressions are and how to construct a regular expression that genuinely 
defines the strings we want to find and/or manipulate within a text because 
almost all functions/methods of the re module are based on such defined 
regular expressions.
What is a regular expression? A regular expression is a pattern that describes 
certain text or literal strings. Examples of some useful patterns include tele­
phone numbers, email addresses, URLs, and many others.
To be able to correctly define a regular expression precisely describing the 
strings we want to find and manipulate, we must first understand and remem­
ber the rules of regular expressions, as well as special characters and sequences 
that have special meanings in a re module. Since regular expressions are strings 
themselves, they should be quoted with single or double quotation marks. For 
	
Use Sequences, Sets, Dictionaries, and Text Files	
243
 https://doi.org/10.15215/remix/9781998944088.01
simplicity, however, we may omit some quotation marks in our discussion when 
we know what we are talking about in the context.
Plain literals such as a, b, c,…z, A, B, C,…Z, and numeric digits such as 0, 1, 
2,…9 can be directly used in a regular expression to construct a pattern, such 
as Python, Foo, Canada. Some symbols in the ASCII table have been given 
special meanings in re. These symbols, called metacharacters, are shown 

in Table 5-­
4.
Table 5-­
4: Metacharacters and basic rules for constructing 
regular expressions
Symbols
Meaning
Example
.
Match any character except \n, a 
new line, in a string.
t..t will match test, text,…
^
Affixed to a pattern to match the 
preceding regex if it is at the 
beginning of the string being 
searched.
^Hello will only match Hello when 
it is at the start of an email
$
Affixed to a pattern to match the 
preceding regex if it is at the end 
of a string.
mpeg$ will only match mpeg 
when it is at the end of a text
|
Match either the regex on the left 
or the regex on the right.
Wang|Wong will match either 
Wang or Wong
\
Form an escape sequence such 
as \d, \s,… with special meaning. 
Table 5-­
5 lists all the escape 
sequences defined in the re 
module.
Also used to escape the 
metacharacters in this table 
back to their original meanings.
\d will match any single decimal 
digit
\D is the negation of \d, meaning 
it will not match any single 
decimal digit
[…]
Define a set/class of characters.
[xyz] will match either x, y, or z.
W[ao]ng is the same as 
Wang|Wong
[^…]
Define a set of characters 
excluded from the pattern. 
Inside and at the beginning of [], 
^ is used as negation
[^A-­
Z\s] will match everything else 
except upper case letters and 
whitespace
[…x-­
y…]
Within [], define a range of 
characters from x to y
[0-­
9], [a-­
zA-­
Z]
(continued on next page)
	244	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Symbols
Meaning
Example
(…)
Match enclosed regex and save 
as subgroup for later use.
(B|blah\s)+ will only match the 
second blah in “blah, blah and 
blah” and save it
?
This and the rest in this table 
are called quantifiers. When 
? is affixed to a preceding 
regex (character or group) it 
becomes a nongreedy qualifier, 
meaning it will match only 0 or 
1 occurrence of the preceding 
regex.
? can also be affixed to + as +?, or 
* as *?, to make + or * nongreedy.
mpe?g will match mpg or mpeg
*
Affixed to pattern meaning to 
match 0 or more (greedy) 
occurrences of preceding 
regular expression. Greedy 
means that it will match as 
many as possible.
=* will match 0 or more 
consecutive =s
+
Affixed to a pattern to match 1 
or more occurrences of the 
preceding regular expression.
=+ will match 1 or more 
consecutive =s
{n}
Affixed to a pattern to match 
exactly n occurrences of the 
preceding regex.
[0-­
9]{3} will match the first 3 
occurrences of digits, like an 
area code, for example
{m, n}
Affixed to a pattern to match 
from m to n occurrences of the 
preceding regex.
[0-­
9]{5, 11} will match all 
sequences of decimal digits that 
are 5 to 11 digits in length
Table 5-­
5: Escape sequences with special meanings in re
Escape sequence
Special meaning in re
Example
\d
Match any decimal digit 0-­
9.
Img\d+.jpg
\D
Opposite of \d, meaning do 
not match any decimal digit.
[\D] will match everything but 
decimal digits
\w
Match any alphanumeric 
character, A-Z, a-z, 0-­
9.
[_a-­
zA-­
Z]\w* will match all 
legitimate identifiers in 
Python
Table 5-­
4: Metacharacters and basic rules for constructing 
regular expressions (continued)
	
Use Sequences, Sets, Dictionaries, and Text Files	
245
 https://doi.org/10.15215/remix/9781998944088.01
Escape sequence
Special meaning in re
Example
\W
Opposite of \w, meaning 
do not match any 
alphanumeric character.
[\W] will match everything but 
alphanumeric characters
\n
Match a new line whitespace.
\.\n will match all periods that 
end a paragraph
\t
Match a tab whitespace.
re.findall(r'\t', py_scripts) 
will find all the tabs in the 
py_scripts
\r
Match a return/enter 
whitespace.
re.findall(r'\r', article) will 
find all the return/enter 
whitespaces in the article.
\v
Match a vertical feed 
whitespace.
re.findall(r'\v', article) will 
find all the vertical feed 
whitespaces in the article
\f
Match a feed whitespace.
re.findall(r'\f', article) will find 
all the feed whitespaces in 
the article
\s
Match any of the whitespaces 
above.
re.findall(r'\s', article) will find 
all the whitespaces in the 
article
\S
Opposite of \s, \S matches 
any character which is not a 
whitespace character.
re.findall(r'\S', article) will 
find everything except 
whitespaces in the article
\N
N is an integer > 0. \1 refers 
to the first subgroup saved 
with (…).
In r'\b\w*(\w)\w*\1', \1 
refers to the first found 
alphanumeric characters 
that appear more than once 
in a word
\b
Match any word boundary: the 
left boundary if \b is at the 
left of the pattern, the right 
boundary if \b is at the right 
side of the pattern
\bthe\b will match the if it is 
not part of other words
\B
Opposite of \b.
\bthe\B will match the if it is 
at the beginning of other 
words
\.
\\
\+
\*
Match a special symbol ., \, +, 
* respectively.
\d+\*\d+ will match 
multiplications of two 
integers in a text
\A
Match at the start of a string, 
same as ^.
\AHello will match Hello if 
Hello is at the beginning of 
the string
\Z
Match at the end of a string, 
same as $.
\.com\Z will match .com if it 
is at the end of the string
Table 5-­
5: Escape sequences with special meanings in re (continued)
	246	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The above are the basic rules for constructing regular expressions or regex 
patterns. Using these rules, we can write regular expressions to define most 
string patterns we are interested in.
The following are some examples of regex patterns:
780-­
\d{7}, pattern for telephone numbers in Edmonton, Alberta
\$\d+\.\d{2}, pattern for currency representations in accounting
[A-­
Z]{3}-­
\d{3}, pattern for licence plate numbers
The re module is also empowered with the following extension rules, which 
all begin with a question mark ? within a pair of parentheses. Although sur­
rounded by a pair of parentheses, an extension rule, except (?P<name>…), does 
not create a new group.
(?AILMSUX)
Here, ? is followed by one or more letters from set a, i, L, m, s, u, and x, 
setting the corresponding flags for the re engine. (?a) sets re.A, meaning 
ASCII-­
only matching; (?i) sets re.I, meaning ignore case when matching; 
(?L) sets re.L, meaning local dependent; (?m) sets re.M, meaning multiple 
lines; (?s) sets re.S, meaning dot matches all characters including newline; 
(?u) sets re.U, meaning Unicode matching; (?x) sets re.X, meaning verbose 
matching. These flags are defined in the re module. The details can be found 
by running help(re).
The flags can be used at the beginning of a regular expression in place of 
passing the optional flag arguments to re functions or methods of pattern object.
(?AILMSUX-­
IMSX:…)
Sets or removes the corresponding flags. (?a-­
u…) will remove Unicode matching.
(?:…)
Is a noncapturing version of regular parentheses, meaning the match cannot 
be retrieved or referenced later.
(?P<NAME>…)
Makes the substring matched by the group accessible by name.
(?P=NAME)
Matches the text matched earlier by given name.
	
Use Sequences, Sets, Dictionaries, and Text Files	
247
 https://doi.org/10.15215/remix/9781998944088.01
(?#…)
Is a comment; ignored.
(?=…)
Matches if… matches next but does not consume the string being searched, 
which means that the current position in string remains unchanged. This is 
called a lookahead assertion.
John (?=Doe) will match John only if it is followed by Doe.
(?!…)
Matches if… does not match next.
Jon (?!Doe) will match Jon only if it is not followed by Doe.
(?<=…)
Matches if preceded by… (must be fixed length).
(?<=John) Doe will find a match in John Doe because there is John before Doe.
(?<!…)
Matches if not preceded by… (must be fixed length).
(?<!John) Doe will find a match in Joe Doe because there is not Joe before Doe.
(?(ID)YES PATTERN | NO PATTERN)
(?(NAME)YES PATTERN | NO PATTERN)
Match yes pattern if the group with id or name is matched; match no pattern 
otherwise.
To do text manipulation and information processing using regular expressions 
in Python, we will need to use a module in the standard Python library called Re. 
Similarly, we will need to import the module before using it, as shown below:
>>> import re
Using the dir(re) statement, you can find out what names are defined in the 
module, as shown below, but you will need to use help(re) to find out the core 
functions and methods you can use from the re module.
The following are functions defined in the re module:
re.compile(pattern, flags=0)
Compile a pattern into a pattern object and return the compiled pattern 
object for more effective uses later.
	248	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> import re
>>> pobj=re.compile('780-­
?\d{3}-­
?\d{4}')
>>> pobj.findall('780-­
9381396, 7804311508, 
18663016227')   # findall method of pattern object
['780-­
9381396', '7804311508']
>>> b = re.compile(r'\d+\.\d*')
>>> b.match('32.23')   # match method of pattern object
<re.Match object; span=(0, 5), match='32.23'>
RE.MATCH(PATTERN, STRING, FLAGS=0)
Match a regular expression pattern to the beginning of a string. Return None 
if no match is found.
>>> r = re.match(r'\d+\.\d*', '123.89float')
>>> r
<re.Match object; span=(0, 6), match='123.89'>
RE.FULLMATCH(PATTERN, STRING, FLAGS=0)
Match a regular expression pattern to all of a string. Return None if no match 
is found.
>>> r = re.fullmatch(r'\d+\.\d*', '123.89')
# this will match
>>> r = re.fullmatch(r'\d+\.\d*', '123.89float')
# this will not match
RE.SEARCH(PATTERN, STRING, FLAGS=0)
Search a string for the presence of a pattern; return the first match object. 
Return None if no match is found.
>>> r = re.search(r'\d+\.\d+', 'real 123.89')
>>> r
<re.Match object; span=(5, 11), match='123.89'>
RE.SUB(PATTERN, REPLACING, STRING, COUNT=0, FLAGS=0)
Substitute occurrences of a pattern found in a string by replacing and return 
the resulted string.
>>> re.sub('t', 'T', 'Python is great.')
'PyThon is greaT.'
	
Use Sequences, Sets, Dictionaries, and Text Files	
249
 https://doi.org/10.15215/remix/9781998944088.01
RE.SUBN(PATTERN, REPLACING, STRING, COUNT=0, FLAGS=0)
Same as sub, but also return the number of substitutions made.
>>> re.subn('t', 'T', 'Python is great.')
('PyThon is greaT.', 2)
RE.SPLIT(PATTERN, STRING, MAXSPLIT=0, FLAGS=0)
Split a string by the occurrences of a pattern and return a list of substrings cut 
by the pattern.
>>> re.split(r'\W+', 'Python is great.')   # \W is 
nonalphanumeric so it will get a list of words
['Python', 'is', 'great', '']
RE.FINDALL(PATTERN, STRING, FLAGS=0)
Find all occurrences of a pattern in a string and return a list of matches.
>>> re.findall('t', 'Python is great.')
['t', 't']
RE.FINDITER(PATTERN, STRING, FLAGS=0)
Return an iterator yielding a match object for each match.
>>> re.finditer('t', 'Python is great.')
<callable_iterator object at 0x00000198FE0F5FC8>
RE.PURGE()
Clear the regular expression cache.
>>> re.purge()
>>>
RE.ESCAPE(PATTERN)
Backslash all nonalphanumerics in a string.
>>> print(re.escape('1800.941.7896'))
1800\.941\.7896
Suppose we want to write a program to check if a name given by a user is a 
legitimate Python identifier. We can define a regex pattern for a Python iden­
tifier as shown below:
	250	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
idPatt = '\b_{0,2}[A-­
Za-­
z](_?[A-­
Za-­
z0-­
9])*_{0,2}\b\'
Before using the re module, we need to import it, as shown below:
import re
The next step will be to get an input from the user and test it:
name = input('Give me a name and I will tell you if it is 
a Python identifier: ')
Trim the whitespace at the beginning and the end of the name just in case:
name = name.strip()  # this will strip the whitespaces
Then, we do the real test:
if re.match(idPatt, name) is not None:
print('Congratulations! It is!') else:
print('Sorry, it is not.')
The complete code of the program is shown in the code section of Table 5-­
6.
Table 5-­
6: Case study: How to check Python identifiers
The problem
In this case study, we will write a program to check if a name given 
by a user is legitimate Python identifier.
The analysis 
and design
Steps:
Step 1: Import re module before using it
Step 2: Define a regex pattern for Python identifiers
Step 3: Get an input from the user, and
Step 4: Test it with an if-­
else statement
The code
import re
idPatt = '(^[A-­
Za-­
z]\w+)$|(^_[A-­
Za-­
z]\
w+_$)|(^__[A-­
Za-­
z]\w+__$)'
name = input('Give me a name and I will tell you 
if it is a Python identifier:')
name = name.strip()
if re.match(idPatt, name) is not None:
  print('Congratulations! It is!')
else:
  print('Sorry, it is not.')
The result
Give me a name and I will tell you if it is a Python identifier:A2
Congratulations! It is!
	
Use Sequences, Sets, Dictionaries, and Text Files	
251
 https://doi.org/10.15215/remix/9781998944088.01
5.2 Lists
The list is an important compound data type in Python and in almost all pro­
gramming languages, though not many programming languages have list as 
a built-­
in data type.
In previous sections, you saw a few program examples with a list involved. 
In the following, we explain the operators and functions that can be used 
on lists.
LIST(ITERABLE)
To construct a list from an iterable such as a sequence or call to range().
>>> l1 = list("test")
>>> l1
['t', 'e', 's', 't']
>>> l2 = list((1,2,3,4))
>>> l2
[1, 2, 3, 4]
>>> l5 = list(range(13, 26))
>>> l5
[13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]
In addition, you can also create a list by directly putting items in a pair of 
square brackets, as shown below:
>>> l6 = ['Jon', 'John', 'Jonathan', 'Jim', 'James']
>>> l6
['Jon', 'John', 'Jonathan', 'Jim', 'James']
L[NTH]
To get the nth element of list l.
>>> students = ['John', 'Mary', 'Terry', 'Smith', 'Chris']
>>> students[3]
'Smith'
L[START:END]
To get a slice/sublist of l, including the members from a start position till right 
before the end position.
	252	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> students = ['John', 'Mary', 'Terry', 'Smith', 
'Chris']
>>> students[1:3]
['Mary', 'Terry']
L[START:END:STEP]
To get a slice/sublist of l, including members from a start position to right before 
an end position with set step.
>>> l6 = ['Jon', 'John', 'Jonathan', 'Jim', 'James']
>>> l6[:5:3]   # start from 0 till 5 with step set as 3.
['Jon', 'Jim']
L[N] = E
To replace element at n with e.
>>> print(students)
['John', 'Mary', 'Terry', 'Smith', 'Chris']
>>> students[2] = 'Cindy'
>>> print(students)
['John', 'Mary', 'Cindy', 'Smith', 'Chris']
L1 + L2
To concatenate list l2 to l1, but without changing l1. As such, if you want to keep 
the result of concatenation, you will need to assign the result to a new variable.
>>> teachers = ['Jeffery', 'Clover', 'David']
>>> students + teachers
['John', 'Mary', 'Terry', 'Smith', 'Chris', 'Jeffery', 
'Clover', 'David']
>>> teachers
['Jeffery', 'Clover', 'David']
>>> class_members = students + teachers
>>> class_members
['John', 'Mary', 'Terry', 'Smith', 'Chris', 'Jeffery', 
'Clover', 'David']
L * N
N * L
To duplicate list l n times but without changing l.
	
Use Sequences, Sets, Dictionaries, and Text Files	
253
 https://doi.org/10.15215/remix/9781998944088.01
>>> students[1:3]
['Mary', 'Terry']
>>> students[1:3] * 2
['Mary', 'Terry', 'Mary', 'Terry']
>>> 2*students[1:3]
['Mary', 'Terry', 'Mary', 'Terry']
E IN L
To test if e is in list l. If l has compound data such as lists, tuples, or instances 
of a class, e is only part of a compound data or object and is not considered 
in the list.
>>> teachers
['David', 'Jeffery', 'Clover']
>>> 'Clover' in teachers
True
>>> l0 = [1, 2, 3, [4, 5], 6]   # 4 and 5 are members of 
a sublist of l0
>>> 5 in l0   # so that 5 is not considered as part of 
list l0
False
LEN(L)
To get the number of elements in the list l.
>>> students
['John', 'Mary', 'Terry', 'Smith', 'Chris']
>>> len(students)
5
PRINT(L)
To print list l. Note that the list will be recursively printed, but complex objects 
such as instances of a user-­
defined class may not be printed the way you 
expected unless you have defined the __str__() method for the class.
>>> print(teachers)
['Jeffery', 'Clover', 'David']
In addition, there are also built-­
in methods for list objects, as detailed below.
	254	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
L.APPEND(E)
To append element e to list l.
>>> l = ['T', 'h']
>>> l.append('e')
>>> l
['T', 'h', 'e']
L.CLEAR()
To remove all items from list l.
>>> l1 = list("test")
>>> l1
['t', 'e', 's', 't']
>>> l1.clear()
>>> l1   # l1 became an empty list
[]
L.COPY()
To return a shallow copy of list l—­
that is, it only copies simple objects of the list 
such as numbers and strings; for compound data, it does not copy the actual 
objects but only makes references to the objects.
>>> l7 = l6.copy()   # from above we know that items in 
l6 are all simple strings
>>> l7
['Jon', 'John', 'Jonathan', 'Jim', 'James']
>>> l7[3] = 'Joe'   # change the value of l7[3]
>>> l7   # it shows l7 has been changed
['Jon', 'John', 'Jonathan', 'Joe', 'James']
>>> l6   # it shows l6 remains the same
['Jon', 'John', 'Jonathan', 'Jim', 'James']
Now suppose we have
>>> l8 = [[13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 
24, 25], ['Jon', 'John', 'Jonathan', 'Joe', 'James'], 
100]
>>> l9 = l8.copy()
>>> l9   # l9 has the same items as l8
	
Use Sequences, Sets, Dictionaries, and Text Files	
255
 https://doi.org/10.15215/remix/9781998944088.01
[[13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25], 
['Jon', 'John', 'Jonathan', 'Joe', 'James'], 100]
>>> l9[0][0] = 1000   # make change to the internal value 
of list l9[0], that is, l9[0][0] to 1000
>>> l9   # l9 has been changed
[[1000, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25], 
['Jon', 'John', 'Jonathan', 'Joe', 'James'], 100]
>>> l8   # l8 has been changed as well
[[1000, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25], 
['Jon', 'John', 'Jonathan', 'Joe', 'James'], 100]
As can be seen, if you make changes to a piece of compound data (a list as 
the first item of l9 copied from l8), the change also occurs in the original list, 
and vice versa.
L.INDEX(E, START = 0, STOP = 9223372036854775807)
To return the first index of element e, from a start position till a stop position. 
The default range is from 0 to 9223372036854775807.
>>> l6.index('Jim')
3
L.POP()
To remove and return an item from the end of list l.
>>> l.pop()
'e'
L.POP(2)
To remove and return an item from the middle of list l. When there are an even 
number of elements in the list, there will be two elements in the middle, but 
only the first one pops out.
>>> l = [1, 3, 2, 6, 5, 7]
>>> l.pop(2)
2
>>> l
[1, 3, 6, 5, 7]
>>> l.pop(2)
6
	256	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
L.REVERSE()
To reverse the list.
>>> l.reverse()
>>> l
[7, 5, 3, 1]
L.SORT()
To sort the list in ascending order by default. To sort in descending order, use 
l.sort(reverse = True).
>>> l.sort()
>>> l
[1, 3, 5, 7]
L.EXTEND(L0)
To extend list l by appending list l0 to the end of list l. It is different from l + l0 
but it is same as l += l0.
>>> l = list(range(5))
>>> l
[0, 1, 2, 3, 4]
>>> l0 = list(range(6, 11))
>>> l0
[5, 6, 7, 8, 9, 10]
>>> l.extend(l0)
>>> l
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
L.INSERT(I, E)
To insert e before index i of existing list l.
>>> l = list(range(10))
>>> l
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> l.insert(5, 13)
>>> l
[0, 1, 2, 3, 4, 13, 5, 6, 7, 8, 9]
	
Use Sequences, Sets, Dictionaries, and Text Files	
257
 https://doi.org/10.15215/remix/9781998944088.01
L.REMOVE(E)
To remove first occurrence of e in the list.
>>> l
[0, 1, 2, 3, 4, 13, 5, 6, 7, 8, 9]
>>> l.remove(5)
>>> l   # 5 has been removed from l
[0, 1, 2, 3, 4, 13, 6, 7, 8, 9]
L.COUNT(E)
To search the list and return the number of occurrences of e.
>>> l
[0, 1, 2, 3, 4, 13, 6, 7, 8, 9]
>>> l.count(6)
1
As you can see, elements in lists can be changed or mutated. You can insert, 
delete, replace, expand, and reorder all the elements in a list.
Lists are a very important data model in programming and problem solving. 
First, lists can be used as collections of data. Each member of the collection 
can be as simple as a number or a string and as complex as another list or any 
other compound data type, or even an object. Many functions and methods, 
as discussed above, have been made available for accessing and manipulating 
lists and their members.
Suppose we want to develop a management system for a company, for example. 
Within the system, we need to represent information on its employees. We can 
use a list containing the name, birthdate, department, start date at the company, 
and level of employment to represent information on each employee, then use 
another list to represent a collection of employees. This is illustrated as follows:
# this defines an embedded list or two-­
dimensional array
employees = [['Kevin Smith', 19560323, 'Sale', 20100621, 3],
['Paul Davina', 19860323, 'HR', 20120621, 5],
['Jim Carri', 1969323, 'Design', 20120625, 2],
['John Wong', 19580323, 'Customer Service', 20110323, 3],
['Keri Lam', 19760323, 'Sale', 20130522, 5]]
Moreover, lists can be used to represent trees, which is an important data 
structure in programming and problem solving.
	258	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
5.3 Tuples
Unlike a list, a tuple is an immutable object, which means that once created, 
the internal structure of a tuple cannot be changed. Hence, most methods you 
have seen for lists are not available for tuples, except for the following two.
T.COUNT(E)
To count and return the number of occurrences of a specified value in a tuple.
>>> t = (3, 6, 5, 7, 5, 9)
>>> t.count(5)
2
T.INDEX(E, START = 0, STOP = 9223372036854775807)
To search the tuple for a specified value e and return the index of the first 
occurrence of the value. Remember that just like a list, a tuple can have dupli­
cate values as well.
>>> t.index(6)
1
>>> t.index(7)
3
>>> t0 = tuple("same as list, tuple")
>>> t0
('s', 'a', 'm', 'e', ' ', 'a', 's', ' ', 'l', 'i', 's', 
't', ',', ' ', 't', 'u', 'p', 'l', 'e')
>>> t0.index('l')   # it only returns the index of the 
first l
8
>>> t.index('l', 9)   # to get the index of the next 
occurrence
17
As well, compared to list, fewer number of operators and built-­
in functions 
can be used on tuples, as shown below.
TUPLE(ITERABLE)
To construct a tuple from an iterable such as another sequence or a call to 
range(), a built-­
in function.
	
Use Sequences, Sets, Dictionaries, and Text Files	
259
 https://doi.org/10.15215/remix/9781998944088.01
>>> l1 = [1, 2, 3]
>>> t0 = tuple(l1)
>>> t0
(1, 2, 3)
This would be the same as the following:
>>> t0 = (1, 2, 3)
 
>>> t1 = tuple('tuple')
>>> t1
('t', 'u', 'p', 'l', 'e')
 
>>> tuple(range(7))
(0, 1, 2, 3, 4, 5, 6)
T[N]
To get nth element of a tuple.
>>> teachers = ('Jeffery', 'Clover', 'David')
>>> teachers[2]
'David'
Please note that because a tuple is an immutable sequence, making changes 
to its members will generate an error, as shown below:
>>> teachers[1] = 'Chris'
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item 
assignment
T[I:J]
To get a slice of tuple t including elements from point i to the one right before 
point j.
>>> teachers[0:2]
('Jeffery', 'Clover')
>>> print(teachers)
('Jeffery', 'Clover', 'David')
	260	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
T1 + T2
To concatenate tuple t2 to t1.
>>> students = tuple(students)
>>> print(students)
('John', 'Mary', 'Terry', 'Smith', 'Chris')
>>> students + teachers
('John', 'Mary', 'Terry', 'Smith', 'Chris', 'Jeffery', 
'Clover', 'David')
T * N
To duplicate tuple t n times.
>>> teachers * 2
('Jeffery', 'Clover', 'David', 'Jeffery', 'Clover', 
'David')
E IN T
To test if e is an element of tuple t.
>>> teachers
('David', 'Jeffery', 'Clover')
>>> 'David' in teachers
True
LEN(T)
To get the number of elements in the tuple t.
>>> len(teachers * 2)
6
PRINT(T)
To print tuple t. Again, print may print the tuple recursively, but the expected result 
can only be achieved if __str__() has been defined for every object at all levels.
>>> print(students)
('John', 'Mary', 'Terry', 'Smith', 'Chris')
Again, although we can extend the tuple by concatenating and duplicating, 
we cannot make any change to the existing element of a tuple as we did to 
	
Use Sequences, Sets, Dictionaries, and Text Files	
261
 https://doi.org/10.15215/remix/9781998944088.01
lists, because tuples are immutable. As a result, the tuple is not a suitable data 
structure for representing the group of employees in the example presented at 
the end of the previous section because employees may come and go.
5.4 Sets
As in mathematics, a set is a collection of unindexed and unordered elements. 
For sets, Python has very few operators and built-­
in functions that we can use.
SET(S)
To construct a set from s, which can be a list, tuple, or string.
>>> students = ['Cindy', 'Smith', 'John', 'Chris', 
'Mary']
>>> students = set(students)
>>> students
{'Cindy', 'Smith', 'John', 'Chris', 'Mary'}
>>> numbers = set(range(10))
>>> numbers
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
E IN S
To test if e is a member of set s.
>>> students
{'Cindy', 'Smith', 'John', 'Chris', 'Mary'}
>>> 'Chris' in students
True
LEN(S)
To get the total number of elements in the set.
>>> numbers
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
>>> len(numbers)
10
However, there are good number of methods defined for sets.
	262	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
S.ADD(M)
To add an element to the set s.
>>> s = set([3])
>>> s
{3}
>>> s.add(5)
>>> s
{3, 5}
S.CLEAR()
To remove all the elements from the set s.
>>> s.clear()
>>> s
set()
S.COPY()
To make and return a copy of the set s.
>>> s
{3, 5}
>>> s1 = s.copy()
>>> s1
{3, 5}
S.DIFFERENCE(S1,…)
To make and return a set containing only members of s that other sets in the 
arguments don’t have—­
that is, the difference between two or more sets.
>>> s1
{3, 5}
>>> s2 = {5, 7}
>>> s1.difference(s2)
{3}
>>> s3={3,7}
>>> s1.difference(s2,s3)   # returns an empty set
set()
	
Use Sequences, Sets, Dictionaries, and Text Files	
263
 https://doi.org/10.15215/remix/9781998944088.01
S.DIFFERENCE_UPDATE(*SX)
To remove the items in set s that are also included in another, specified set.
>>> s1 = {2 * i for i in range(15)}
>>> s2 = {3 * i for i in range(15)}
>>> s1
{0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28}
>>> s2
{0, 33, 3, 36, 6, 39, 9, 42, 12, 15, 18, 21, 24, 27, 30}
>>> s1.difference_update(s2)
>>> s1
{2, 4, 8, 10, 14, 16, 20, 22, 26, 28}
>>> s2
{0, 33, 3, 36, 6, 39, 9, 42, 12, 15, 18, 21, 24, 27, 30}
S.DISCARD(M)
To remove the specified item.
>>> s2
{0, 33, 3, 36, 6, 39, 9, 42, 12, 15, 18, 21, 24, 27, 30}
>>> s2.discard(18)
>>> s2
{0, 33, 3, 36, 6, 39, 9, 42, 12, 15, 21, 24, 27, 30}
S.INTERSECTION(*SX)
To return a set that is the intersection of two other sets.
>>> s1 = {2 * i for i in range(15)}
>>> s2 = {3 * i for i in range(15)}
>>> s1
{0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28}
>>> s2
{0, 33, 3, 36, 6, 39, 9, 42, 12, 15, 18, 21, 24, 27, 30}
>>> s1.intersection(s2)
{0, 6, 12, 18, 24}
S.INTERSECTION_UPDATE(*SX)
To remove the items in this set that are not present in another, specified set 
or sets.
	264	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> s1
{0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28}
>>> s2
{0, 33, 3, 36, 6, 39, 9, 42, 12, 15, 18, 21, 24, 27, 30}
>>> s1.intersection_update(s2)
>>> s1
{0, 6, 12, 18, 24}
S.ISDISJOINT(SX)
To check and return whether two sets have an intersection (common member) 
or not.
>>> s1
{0, 6, 12, 18, 24}
>>> s2
{0, 33, 3, 36, 6, 39, 9, 42, 12, 15, 18, 21, 24, 27, 30}
>>> s1.isdisjoint(s2)
False
S.ISSUBSET(SX)
To check and return whether another set contains this set or not.
>>> s1 = {2 * i for i in range(15)}
>>> s2 = {3 * i for i in range(15)}
>>> s1
{0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28}
>>> s2
{0, 33, 3, 36, 6, 39, 9, 42, 12, 15, 18, 21, 24, 27, 30}
>>> s1.issubset(s2)
False
S.ISSUPERSET(SX)
To check and return whether this set contains another set or not.
>>> s1.issuperset(s2)
False
S.POP()
To remove an element from the set.
	
Use Sequences, Sets, Dictionaries, and Text Files	
265
 https://doi.org/10.15215/remix/9781998944088.01
>>> s2
{0, 33, 3, 36, 6, 39, 9, 42, 12, 15, 18, 21, 24, 27, 30}
>>> s2.pop()
0
>>> s2
{33, 3, 36, 6, 39, 9, 42, 12, 15, 18, 21, 24, 27, 30}
S.REMOVE(M)
To remove the specified element.
>>> s2
{33, 3, 36, 6, 39, 9, 42, 12, 15, 18, 21, 24, 27, 30}
>>> s2.remove(18)
>>> s2
{33, 3, 36, 6, 39, 9, 42, 12, 15, 21, 24, 27, 30}
S.SYMMETRIC_DIFFERENCE(SX)
To construct and return a set with elements in either set s or another set but 
not both. These are called set symmetric differences (“I have you do not; you 
have I do not”).
>>> s1 = {2 * i for i in range(15)}
>>> s2 = {3 * i for i in range(15)}
>>> s1
{0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28}
>>> s2
{0, 33, 3, 36, 6, 39, 9, 42, 12, 15, 18, 21, 24, 27, 30}
>>> s1.symmetric_difference(s2)
{2, 3, 4, 8, 9, 10, 14, 15, 16, 20, 21, 22, 26, 27, 28, 
30, 33, 36, 39, 42}
S.SYMMETRIC_DIFFERENCE_UPDATE(SX)
To insert the symmetric differences from this set and another.
>>> s1.symmetric_difference_update(s2)
>>> s1
{2, 3, 4, 8, 9, 10, 14, 15, 16, 20, 21, 22, 26, 27, 28, 
30, 33, 36, 39, 42}
	266	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
S.UNION(SX)
To return a set containing the union of sets.
>>> s2 = {3 * i for i in range(5)}
>>> s1 = {2 * i for i in range(5)}
>>> s1
{0, 2, 4, 6, 8}
>>> s2
{0, 3, 6, 9, 12}
>>> s1.union(s2)
{0, 2, 3, 4, 6, 8, 9, 12}
S.UPDATE(SX)
To update the set by adding members from other sets.
>>> s1
{0, 2, 4, 6, 8}
>>> s2
{0, 3, 6, 9, 12}
>>> s1.update(s2)
>>> s1
{0, 2, 3, 4, 6, 8, 9, 12}
5.5 Dictionaries
A dictionary is a collection of key and value pairs enclosed in curly brackets. As 
with a set, the dictionary is also immutable. There are very few operators and 
built-­
in functions that can be used on dictionaries, as shown below.
DICT(**KWARG)
To construct a dictionary from a series of keyword arguments.
>>> dt = dict(one = 1, two = 2, three = 3)
>>> dt
{'one': 1, 'two': 2, 'three': 3}
DICT(MAPPING, **KWARG)
To construct a dictionary from mapping. If keyword arguments are present, 
they will be added to the dictionary constructed from the mapping.
	
Use Sequences, Sets, Dictionaries, and Text Files	
267
 https://doi.org/10.15215/remix/9781998944088.01
>>> d1 = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
>>> d2 = dict(zip([1, 2, 3], ['one', 'two', 'three']))
>>> d1
{'one': 1, 'two': 2, 'three': 3}
>>> d2
{1:'one', 2:'two', 3:'three'}
DICT(ITERABLE, **KWARG)
To construct a dictionary from an iterable. If keyword arguments are present, 
they will be added to the dictionary constructed from the mapping.
>>> d3 = dict([('two', 2), ('one', 1), ('three', 3)])
>>> d3
{'two': 2, 'one': 1, 'three': 3}
LIST(DT)
To return a list of all the keys used in the dictionary dt.
>>> d3
{'two': 2, 'one': 1, 'three': 3}
>>> list(d3)
['two', 'one', 'three']
DT[K]
To get the value of key k from dictionary dt.
>>> dt = {1:'One', 2:'Two', 3:'Three'}
>>> dt[1]
'One'
DT[K] = V
To set d[key] to value V.
>>> d3
{'two': 2, 'one': 1, 'three': 3}
>>> d3['two']
2
>>> d3['two'] = bin(2)
>>> d3['two']
'0b10'
	268	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
DEL DT[K]
To remove dt[key] from dt.
>>> d3
{'two':'0b10', 'one': 1, 'three': 3}
>>> del d3['two']
>>> d3
{'one': 1, 'three': 3}
K IN DT
To test if dt has a key k.
>>> d3
{'one': 1, 'three': 3}
>>> 'two' in d3
False
K NOT IN DT
Same as not k in dt, or k not in dt.
>>> 'two' not in d3
True
>>> not 'two' in d3
True
ITER(DT)
To return an iterator over the keys of dt. Same as iter(dt.keys()).
>>> iter(d3)
<dict_keyiterator object at 0x00000198FE0EFEF8>
>>> list(iter(d3))
['one', 'three']
LEN(DT)
To get the total number of elements in the dictionary.
>>> dt
{1:'One', 2:'Two', 3:'Three'}
>>> len(dt)
3
	
Use Sequences, Sets, Dictionaries, and Text Files	
269
 https://doi.org/10.15215/remix/9781998944088.01
REVERSED(DT)
To return a reverse iterator over the keys of the dictionary. Same effect as 
reversed(dt.keys()). This is new in Python 3.8.
>>> dt = {1:'One', 2:'Two', 3:'Three'}   # keys: 1, 2, 3
>>> rk = reversed(dt)   # reversed iterator over the keys 
in rk
>>> for k in rk:
print(k)
…
3
2
1
Note that in the output above, the keys in rk are 3, 2, 1.
The following built-­
in methods of the dictionary class can be used to manipu­
late dictionaries.
D.CLEAR()
To remove all the elements from the dictionary.
>>> dt = {1:'One', 2:'Two', 3:'Three'}
>>> dt
{1:'One', 2:'Two', 3:'Three'}
>>> dt.clear()
>>> dt
D.COPY()
To make and return a copy of the dictionary.
>>> dt = {1:'One', 2:'Two', 3:'Three'}
>>> dx = dt.copy()
>>> dx
{1:'One', 2:'Two', 3:'Three'}
DICT.FROMKEYS()
To make a dictionary from a list of keys.
	270	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> keys = ['Edmonton','Calgary','Toronto']
>>> weather = dict.fromkeys(keys, 'Sunny')
>>> print(weather)
{'Edmonton': 'Sunny', 'Calgary': 'Sunny', 'Toronto': 'Sunny'}
D.GET(K)
To return the value of the specified key.
>>> d3 =dict([('two', 2), ('one', 1), ('three', 3)])
>>> d3.get('two')
2
D.ITEMS()
To return a list containing a tuple for each key-­
value pair.
>>> d3.items()
dict_items([('two', 2), ('one', 1), ('three', 3)])
D.KEYS()
To return a list containing the dictionary’s keys.
>>> d3.keys()
dict_keys(['two', 'one', 'three'])
D.VALUES()
To return a list of all the values in the dictionary.
>>> d3.values()
dict_values([2, 1, 3])
D.POP(K)
To remove the element with the specified key. Note that the removed item will 
no longer exist in the dictionary.
>>> d3
{'two': 2, 'one': 1, 'three': 3}
>>> d3.pop('two')
2
>>> d3
{'one': 1, 'three': 3}
	
Use Sequences, Sets, Dictionaries, and Text Files	
271
 https://doi.org/10.15215/remix/9781998944088.01
D.POPITEM()
To remove an item from the end of the dictionary, as a key and value pair.
>>> d3
{'two': 2, 'one': 1, 'three': 3}
>>> d3.popitem()
('three', 3)
D.SETDEFAULT(KEY, VALUE)
To insert a key-­
value pair into the dictionary if the key is not in the dictionary; 
return the value of the key if the key exists in the dictionary.
>>> d3
{'two': 2, 'one': 1}
>>> d3.setdefault('three', 3)
3
>>> d3.setdefault('two', 'II')
2
>>> d3
{'two': 2, 'one': 1, 'three': 3}
D.UPDATE(DX)
To update the dictionary with the specified key-­
value pairs in dx.
>>> d3
{'two': 2, 'one': 1, 'three': 3}
>>> d2
{1:'one', 2:'two', 3:'three'}
>>> d3.update(d2)
>>> d3
{'two': 2, 'one': 1, 'three': 3, 1:'one', 2:'two', 
3:'three'}
5.6 List, Set, and Dictionary Comprehension
Lists, sets, and dictionaries are important data models for programmers to 
structure and organize data with. Before using lists, tuples, sets, and dictio­
naries, it is important to create them in a nice way. List, set, and dictionary 
comprehension is provided by Python to construct lists, sets, and dictionaries 
	272	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
in a concise but efficient language. The essential idea for list, set, and dictionary 
comprehension is the use of a for loop with or without conditions.
List Comprehension
The following is an example that constructs a list of odd numbers from 1 to 100:
In [ ]:
l0 = [i * 2 + 1 for i in range(50)]
print(l0)
Out [ ]:
[1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 
45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 
85, 87, 89, 91, 93, 95, 97, 99]
In the example, the expression before for represents the items of the list; 
the for loop will run through the item expression in each iteration. This list 
can also be generated using the for loop with an if clause, as shown below:
In [ ]:
l1 = [i for i in range(100) if i % 2 != 0]
print(l1)
Out [ ]:
[1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 
45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 
85, 87, 89, 91, 93, 95, 97, 99]
In the example above, the list item expression will be evaluated in every 
iteration of the for loop only if the condition of the if clause is met. In fact, we 
can put any condition on the iteration variable i. For example, assume we have 
a Boolean function isPrime(N) that can test if number N is prime or not; then 
the following statement will produce a list of prime numbers in the given range:
primes = [i for i in range(1000) if isPrime(i)]
Please note that the list item expression before for can be anything whose 
value is a legitimate list item, as shown in the example below:
In [ ]:
detailed = [f"{i} is odd" if i % 2 !=0 else f"{i} is 
even" for i in range(10)]
print(detailed)
Out [ ]:
['0 is even', '1 is odd', '2 is even', '3 is odd', '4 is even', '5 is odd', '6 is even', '7 
is odd', '8 is even', '9 is odd']
For item expressions involving two variables or more, nested for statements 
can be used. For example, the following statement will generate a list of com­
binations of some years and months:
	
Use Sequences, Sets, Dictionaries, and Text Files	
273
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
years = ['2015', '2016', '2017', ' 2018', '2019']
combo = [year + str(month).rjust(2, '0') for year in 
years for month in range(1, 13)]
print(combo)
Out [ ]:
['201501', '201502', '201503', '201504', '201505', '201506', '201507', '201508', 
'201509', '201510', '201511', '201512', '201601', '201602', '201603', '201604', 
'201605', '201606', '201607', '201608', '201609', '201610', '201611', '201612', 
'201701', '201702', '201703', '201704', '201705', '201706', '201707', '201708', 
'201709', '201710', '201711', '201712', ' 201801', ' 201802', ' 201803', ' 
201804', ' 201805', ' 201806', ' 201807', ' 201808', ' 201809', ' 201810', ' 
201811', ' 201812', '201901', '201902', '201903', '201904', '201905', '201906', 
'201907', '201908', '201909', '201910', '201911', '201912']
Set Comprehension
A set is a collection of unique unordered items. With that in mind, set compre­
hension is similar to list comprehension, except that the items are enclosed in 
curly brackets, as shown in the example below:
In [ ]:
asc = {chr(c) for c in range(ord('A'), ord('Z') + 1)}
print(asc)
Out [ ]:
{'K', 'M', 'G', 'T', 'C', 'O', 'L
', 'D', 'S', 'I', 'B', 'N', 'A', 'F', 'W', 'H', 'P', 'X', 'J', 'Z', 'E', 'R', 'U', 
'Y', 'Q', 'V'}
What would happen if items generated from the iteration were duplicated? 

No worries! The implementation of set comprehension can take care of that. 
If we want to find out all the unique words contained in a web document, we 
can simply use set comprehension to get them, as shown below:
In [ ]:
import requests   # import requests module to handle 
requests for web resources
content = requests.get("https://scis.athabascau.ca/").
text
separators = [',', '.', '"', "'", '>', '<', '-­
-­
', '!', 
'|', ']', '[', '?', ';', '/']   # separators used to 
separate words
separators += [')', '(', '$', '&', ':', '}', '{']
operators = ['=', '+']
for sp in separators:
  content = content.replace(sp, ' ')   # replace each 
of the separators with a space
for op in operators:
  content = content.replace(op, f' {op} ')   # add a 
space before and after each operator
unique_words = {w for w in content.split()}
print(len(unique_words), unique_words)
Out [ ]:
969
	274	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The example above took a web document at https://​
scis​
.athabascau​
.ca, 
pulled all the unique words used in the document into a set, and printed the 
number of unique words used, which is 969.
As you can see, we could get the unique words in a document very easily 
by using set comprehension. How would we find out the ratio between the 
number of unique words and the total number of words used?
Dictionary Comprehension
Dictionary comprehension is very similar to set comprehension, except that 
we need to add a key and colon before each item to make a dictionary item, as 
shown in the following:
In [ ]:
months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
m_dict = {i + 1: months[i] for i in range(12)}
print(m_dict)
Out [ ]:
{1: 'Jan', 2: 'Feb', 3: 'Mar', 4: 'Apr', 5: 'May', 6: 'Jun', 7: 'Jul', 8: 'Aug', 9: 'Sep', 10: 
'Oct', 11: 'Nov', 12: 'Dec'}
This can also be written in nested for clauses, as shown below:
In [ ]:
months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
m_dict = {i + 1: m for i in range(12) for m in 
months}
print(m_dict)
Out [ ]:
{1: 'Dec', 2: 'Dec', 3: 'Dec', 4: 'Dec', 5: 'Dec', 6: 'Dec', 7: 'Dec', 8: 'Dec', 9: 'Dec', 
10: 'Dec', 11: 'Dec', 12: 'Dec'}
5.7 Text Files
For people and smart beings in general, part of intelligence is being able to 
remember things. Memory is an important part of that.
Computers have two types of memory. The first is RAM, which is volatile, 
expensive, and of relatively lower capacity but provides high-­
speed access. 
The variables we have been talking about so far are using RAM to hold data 
and running programs that are also inside RAM. If the computer is turned off, 
both data and programs will disappear from RAM. RAM is also called internal 
memory.
	
Use Sequences, Sets, Dictionaries, and Text Files	
275
 https://doi.org/10.15215/remix/9781998944088.01
The second type of memory that modern computers have is persistent 
memory, such as a hard drive, flash memory card, or solid-­
state hard disk. This 
type of memory is also called external memory. For this type of memory to be 
useful, it must be part of a file system managed by an OS such as Windows, iOS, 
or Linux. Within a file system, files are used for saving data and programs to 
external memory, and the files are organized into hierarchical directories or 
folders. In a file system, a file can be located through a path from the root to 
the file within a tree-­
like structure.
Opening and Closing a File
To use a file, the first step is to open the file using the built-­
in function open. 
The following will open a file for writing:
f = open("./mypoem.txt", 'w')   # open file mypoem.txt in 
the current working directory for writing
The statement above opened the file mypoem.txt in the current working 
directory and returned a stream, which was then assigned to variable f, often 
called a file handle.
The general syntax of the open statement is as follows:
open(file, mode = 'r', buffering = -­
1, encoding = None, 
errors = None, newline = None, closefd = True, opener = 
None)
The statement opens a file and returns a stream or file object; it will raise 
OSError upon failure. In the statement, file is a text or byte string referring to 
the file to be opened. It may include the path to the actual file if the file is not 
in the current working directory.
Apart from the first argument for the name of the file to be opened, all 
other arguments have default values, which means that these arguments are 
optional. If no value is supplied, the default value will be used.
The second argument is called mode. It is optional with a default value r, 

which means “open a text file for reading.” This argument is used to tell 
the program what to do with the file after opening. Because reading from 
a text file is not always what you want it to do with a file, the argument 
is not optional. All available values for the mode argument are shown in 

Table 5-­
7.
	276	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Table 5-­
7: List of mode arguments for the open function
Mode argument
Access or accesses
r
Open for reading only; file must already exist.
r+
Open for both reading and writing; file must already exist.
w
Open for writing only; file may or may not exist. If not, a new 
file will be created and ready for writing; if file already exists, 
content will be overwritten.
w+
Open for writing and reading; file may or may not exist.
a
Open for appending, same as w, but will not overwrite the 
existing content.
a+
Open for both appending and reading.
x
Create a new file for writing. File Exists Error will occur if the 
file already exists. This would help prevent accidentally 
overwriting an existing file.
The file to be opened or created can be either a text file, referred to as t, or 
a binary file containing raw bytes, referred as b. To explicitly specify whether 
the file is a text or binary file, t or b can be used in combination with each 

of the values in Table 5-­
7. The default file type is text, so you do not have to 

use t if the file is a text file. So in the example above, the statement is equivalent 
to the following, in which t is used to explicitly indicate that it is a text file:
f = open("./mypoem.txt", 'wt')   # open text file mypoem.
txt in the current working directory
In both examples, we assigned the file stream returned from the open state­
ment to a variable f, which is called the file handle. After the file is opened, 
all operations on the file—­
such as read, write, append, or even close—­
must 
be appended to the file handle. Every file must be closed using the f.close() 
method after open and use unless the file is opened within a with statement, 
in which case a context manager will take over access to the file and close it 
when the job is done, as in the sample code below:
In [ ]:
with open("./mypoem.txt", 'r') as f:   # f is still a 
file handle
  for ln in f:   # a file stream referred by f is an 
iterator
    print(ln)
Out [ ]:
Yet it was plain she struggled, and that salt
	
Use Sequences, Sets, Dictionaries, and Text Files	
277
 https://doi.org/10.15215/remix/9781998944088.01
When not using the with statement, you will need to use the following 
instead:
In [ ]:
f = open("./mypoem.txt", 'r')   # f is still a file 
handle
for ln in f:   # a file stream referred by f is an 
iterator
  print(ln)
f.close()
Out [ ]:
Yet it was plain she struggled, and that salt
The third argument is called buffering. It takes an optional integer used to 
specify the buffering policy of the file operation. Passing 0 turns off buffering, 
but it is only allowed for binary files. Passing 1 selects line buffering, which is 
only allowed for text files. Passing an integer greater than 1 specifies the actual 
size of a fixed-­
size chunk buffer. When no buffering argument is provided, the 
default value −1 is used, which means that if the file is a binary file, the file will 
be buffered in a fixed-­
size chunk; if the file is a text file, line buffering policy 
is used, which means that the data will be flush to the actual file (on a disk 
such as a hard drive) from the buffer (a portion of internal memory to buffer 

the data) after each line was written.
The fourth argument is encoding, which specifies how the data in the file 
are encoded. This argument only makes sense for text files. The default value 
is platform dependent. If you believe that the encoding of data on a file is not 
the default, you can specify whatever encoding in which the data are encoded. 
However, the encoding must be supported by Python. In most cases, UTF-­
8 is 
the default encoding.
The next optional argument is errors, which takes a string if provided. The 
string specifies how encoding errors should be handled. Again, this argument 
only makes sense if the file is a text file. The same is true for the optional new­
line argument, which controls how universal newlines work in a text file. The 
optional newline argument can take the following:
•	 None
•	 ,
•	 \n
•	 \r
•	 \rn
Once a file is opened, a list of methods can be used to operate on the file object, 
as detailed below.
	278	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Write or Append to a File
New data can be added to a file in two different manners. The first one is to 
overwrite everything already in the file and place the new data at the beginning 
of the file, and the second one is to keep the data already in the file and append 
the new data to the end of the existing data. The write methods are the same 
for both, but the file must be opened with a different mode depending on the 
operation. That is, mode w or x must be used to open a file for writing the data 
from the beginning of the file, and mode a must be used to append new data, 
as you will see shortly in the examples.
There are two methods for writing to a file. The first one is f.write(string), 
which writes string to the file referred by f. The second method is f.writelines(se­
quence), in which the sequence is any iterable object, such as a list or tuple, 
but often a list of strings. The following is an example of opening or creating 
a file (if the file does not exist yet) for writing data from the beginning of the 
file using the write(string) method:
>>> f = open("./mypoem.txt", "w")   # open file in the 
current working directory for writing
>>> f.write("\nYou may write me down in history")   # add 
\n to write on a new line
>>> f.flush()   # to flush the data out to the actual file
The resulting file will read,
You may write me down in history
If you could write only this one line of your poem and had to close the 
file and shut down the computer, you would be more likely to continue from 
where you had stopped the next time you came back to the poem. So you need 
to append the new lines to the file. This is done by opening the file in a mode, 
as shown below:
>>> f = open("./mypoem.txt", "a")   # open file in the 
current working directory for writing
>>> f.write("\nWith your bitter, twisted lies")   # add 
\n to write on a new line
>>> f.flush()   # to flush the data out to the actual 
file
The file is extended with one more line of poem:
	
Use Sequences, Sets, Dictionaries, and Text Files	
279
 https://doi.org/10.15215/remix/9781998944088.01
You may write me down in history
With your bitter, twisted lies
Note that the write method will only write a string to the file. As such, any­
thing that is not a string must be converted into a string before being written 
to the file, as shown in the following example:
>>> f.write(f'\n{3.1415926}')
Also, because of buffering, the data you write to a file will not immediately 
show up in the actual file until you close the file or use the flush() method 

to flush the data in the buffer out to the file, as shown below:
>>> f.flush()
The write(string) method can only write one string to a file each time. To 
write multiple strings to a file, the writelines(sequence) method is used. How­
ever, keep in mind that writelines() does not automatically write one string on 
each line. You will still need to add \n at the beginning of the string if you want 
it to be on the next line or at the end of the string if you don’t want anything 
behind the string on the same line.
Recall the example of printing a 9 × 9 multiplication table. Now we can write 
the table to a text file so that you can print it out whenever you want. This is 
shown in the two examples below:
"""This first code sample is using the write method."""
 
f = open('./my9x9table.txt', 'w')
for i in range(1, 10):
  for j in range(1, i + 1):
    f.write('{:1d} x {:1d} = {:2d} '.format(j, i, i * j))
  f.write('\n')
f.close()
The output of the program is in the file my9x9table.txt:
1 x 1 = 1
1 x 2 = 2     2 x 2 = 4
1 x 3 = 3     2 x 3 = 6      3 x 3 = 9
1 x 4 = 4     2 x 4 = 8      3 x 4 = 12     4 x 4 = 16
1 x 5 = 5     2 x 5 = 10     3 x 5 = 15     4 x 5 = 20     5 x 5 = 25
	280	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
To use the writelines(sequence) method, we need to store the results in a 
list first; each item of the list will be printed on one line. The code is shown 
as follows:
"""This code sample is using the writelines method."""
 
table = []
for i in range(1, 10):
  newline = ''
  for j in range(1, i + 1):
    newline += '{:1d} x {:1d} = {:2d} '.format(j, i, i * j)
  newline += '\n'
  table.append(newline)
 
f = open('./my9x9table0.txt', 'w')
f.writelines(table)
f.close()
The result is the same as in the my9x9table.txt text shown above.
Reading from a File
To read from a file, three methods can be used. These methods are read([size]), 
readline([size]), and readlines([sizehint]).
Use the read([size]) method to read the entire file and return the entire 
contents as a single string or, if the optional size argument is given, to read 
the specified number of bytes and return the contents as a single string. The 
following example shows how the 9 × 9 multiplication table is read using 

the read([size]) method:
In [ ]:
f = open('./my9x9table0.txt', 'r')
ln = f.read()
print(ln)
f.close()
Out [ ]:
1 x 1 = 1
1 x 2 = 2 2 x 2 = 4
1 x 3 = 3 2 x 3 = 6 3 x 3 = 9
1 x 4 = 4 2 x 4 = 8 3 x 4 = 12 4 x 4 = 16
1 x 5 = 5 2 x 5 = 10 3 x 5 = 15 4 x 5 = 20 5 x 5 = 25
1 x 6 = 6 2 x 6 = 12 3 x 6 = 18 4 x 6 = 24 5 x 6 = 30 6 x 6 = 36
1 x 7 = 7 2 x 7 = 14 3 x 7 = 21 4 x 7 = 28 5 x 7 = 35 6 x 7 = 42 7 x 7 = 49
1 x 8 = 8 2 x 8 = 16 3 x 8 = 24 4 x 8 = 32 5 x 8 = 40 6 x 8 = 48 7 x 8 = 56 8 x 
8 = 64
1 x 9 = 9 2 x 9 = 18 3 x 9 = 27 4 x 9 = 36 5 x 9 = 45 6 x 9 = 54 7 x 9 = 63 8 x 
9 = 72 9 x 9 = 81
	
Use Sequences, Sets, Dictionaries, and Text Files	
281
 https://doi.org/10.15215/remix/9781998944088.01
If size is given, only that number of bytes will be read, as shown in the next 
example:
In [ ]:
f = open('./my9x9table0.txt', 'r')
ln = f.read(135)   # only read 135 bytes
print(ln)
f.close()
Out [ ]:
1 x 1 = 1
1 x 2 = 2 2 x 2 = 4
1 x 3 = 3 2 x 3 = 6 3 x 3 = 9
1 x 4 = 4 2 x 4 = 8 3 x 4 = 12 4 x 4 = 16
1
Because the given size is so small, only a small portion of the multiplication 
table has been read from the file.
Our next method for reading data from a file is readline([size]). This method 
will read and return one entire line from the file if the optional size argument 
is not provided or if the integer value is equal to or greater than the size of the 
line. If the provided size is smaller than the actual size of the line being read, 
then only part of that line, equal to the size in bytes, will be read and returned, 
as shown in the following example:
In [ ]:
f = open('./my9x9table0.txt', 'r')
ln = f.readline(3)
print(ln, end='')
f.close()
Out [ ]:
1 x
Using this method to read all the lines of the 9 × 9 multiplication table in the 
file shown in the previous examples, we will need to put it in a loop and read 
line by line until the end of the file. In Python, however, there is no effective 
way to test if it has reached the end of the file. For this particular file, since 
we know there is no blank line before the end of the file, we will use an empty 
string to signify the end of the file. The revised code is shown below:
In [ ]:
f = open('./my9x9table0.txt', 'r')
while True:
  ln = f.readline()
  print(ln, end='')
  if ln == '':   # test if it has reached the end of 
the table
    break
f.close()
	282	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Out [ ]:
1 x 1 = 1
1 x 2 = 2 2 x 2 = 4
1 x 3 = 3 2 x 3 = 6 3 x 3 = 9
1 x 4 = 4 2 x 4 = 8 3 x 4 = 12 4 x 4 = 16
1 x 5 = 5 2 x 5 = 10 3 x 5 = 15 4 x 5 = 20 5 x 5 = 25
1 x 6 = 6 2 x 6 = 12 3 x 6 = 18 4 x 6 = 24 5 x 6 = 30 6 x 6 = 36
1 x 7 = 7 2 x 7 = 14 3 x 7 = 21 4 x 7 = 28 5 x 7 = 35 6 x 7 = 42 7 x 7 = 49
1 x 8 = 8 2 x 8 = 16 3 x 8 = 24 4 x 8 = 32 5 x 8 = 40 6 x 8 = 48 7 x 8 = 56 8 x 
8 = 64
1 x 9 = 9 2 x 9 = 18 3 x 9 = 27 4 x 9 = 36 5 x 9 = 45 6 x 9 = 54 7 x 9 = 63 8 x 
9 = 72 9 x 9 = 81
The code above does not look so neat. In fact, since the text file is treated 
as an iterator in Python, with one item for each line, the above code can be 
simply written as follows:
f = open('./my9x9table0.txt', 'r')
for ln in f:
  print(ln, end = '')
f.close()
The output is the same as above.
Using a context manager with the code can be further simplified as follows:
with open('./my9x9table0.txt', 'r') as f:
for ln in f:
  print(ln, end='')   # keyword argument end is set empty 
because ln already has newline in it
Considering the fact that a text file is an iterator, the built-­
in function 
next(iterator) can be used to iterate the file line by line. However, it would raise 
a StopIteration error if it reached the end of the file. The following example 
shows how to use next(iterator) to read and print the entire multiplication table:
In [ ]:
f = open('./my9x9table0.txt', 'r')
try:
  while True:
    line = next(f)   # treat f as an iterator
    print(line, end='')
except (StopIteration):
  f.close()   # if it reached the end of the file, 
close the file
	
Use Sequences, Sets, Dictionaries, and Text Files	
283
 https://doi.org/10.15215/remix/9781998944088.01
Out [ ]:
1 x 1 = 1
1 x 2 = 2 2 x 2 = 4
1 x 3 = 3 2 x 3 = 6 3 x 3 = 9
1 x 4 = 4 2 x 4 = 8 3 x 4 = 12 4 x 4 = 16
1 x 5 = 5 2 x 5 = 10 3 x 5 = 15 4 x 5 = 20 5 x 5 = 25
1 x 6 = 6 2 x 6 = 12 3 x 6 = 18 4 x 6 = 24 5 x 6 = 30 6 x 6 = 36
1 x 7 = 7 2 x 7 = 14 3 x 7 = 21 4 x 7 = 28 5 x 7 = 35 6 x 7 = 42 7 x 7 = 49
1 x 8 = 8 2 x 8 = 16 3 x 8 = 24 4 x 8 = 32 5 x 8 = 40 6 x 8 = 48 7 x 8 = 56 8 x 
8 = 64
1 x 9 = 9 2 x 9 = 18 3 x 9 = 27 4 x 9 = 36 5 x 9 = 45 6 x 9 = 54 7 x 9 = 63 8 x 
9 = 72 9 x 9 = 81
The third method for reading data from a file is readlines([sizehint]), where 
optional sizehint, if provided, should be an integer hinting at the amount of 
data to be read. Again, it is only available for text files. As the name implies, 
it reads multiple lines into a Python list until the end of the file, or as much 
as defined by sizehint, if the argument is provided. For example, if the total 
amount of data of the first n lines is less than sizehint, but the first n + 1 lines 
is greater than sizehint, then the method will read (n + 1) lines. So it will read 
whole lines rather than partial, in contrast to the readline([size]) method.
Sometimes, we might like to read from a particular portion of a file, just like we 
want to start reading a book from a specific page. How can we do that in Python?
Imagine there is a pointer indicating where the reading will start in a file. 
In Python, several methods can be used to adjust the pointer.
The first method is f.tell(), which determines where the pointer is in terms 
of how many bytes ahead it is, as shown in the following example:
In [ ]:
f = open('./my9x9table0.txt', 'r')
while True:
  pt = f.tell()
  line = f.readline()
  print('{:3d}: {:s}'.format(pt, line), end = '')
  if line == '':   # test if it has reached the end of 
the table
    break
f.close()
Out [ ]:
0:   1 x 1 = 1
15:  1 x 2 = 2 2 x 2 = 4
43:  1 x 3 = 3 2 x 3 = 6 3 x 3 = 9
84:  1 x 4 = 4 2 x 4 = 8 3 x 4 = 12 4 x 4 = 16
138: 1 x 5 = 5 2 x 5 = 10 3 x 5 = 15 4 x 5 = 20 5 x 5 = 25
205: 1 x 6 = 6 2 x 6 = 12 3 x 6 = 18 4 x 6 = 24 5 x 6 = 30 6 x 6 = 36
285: 1 x 7 = 7 2 x 7 = 14 3 x 7 = 21 4 x 7 = 28 5 x 7 = 35 6 x 7 = 42 7 x 7 = 49
378: 1 x 8 = 8 2 x 8 = 16 3 x 8 = 24 4 x 8 = 32 5 x 8 = 40 6 x 8 = 48 7 x 8 = 56 
8 x 8 = 64
484: 1 x 9 = 9 2 x 9 = 18 3 x 9 = 27 4 x 9 = 36 5 x 9 = 45 6 x 9 = 54 7 x 9 = 63 
8 x 9 = 72 9 x 9 = 81
603:
	284	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The output above shows where each line starts. For example, the end of 
the file is at 603. So with this information, the code using the readline([size]) 
method to read the multiplication table previously given can be easily revised 
to the following:
f = open('./my9x9table0.txt', 'r')
while f.tell() != 603:   # we use the read location to 
identify if it has reached the end of the file
  line = f.readline()
  print(line, end = '')
f.close()
What if we want to read from a specific point in the file? To do that, we 
need to move the pointer to that point. That brings us to the second method 
of adjusting the pointer, which is f.seek(offset, start), in which the offset is 
how much to move it from the start. The default value for start is the cur­
rent position of the pointer in the file. It would have been 0 when the file 

opened.
So suppose we want to read the line of the multiplication table 138 bytes from 
the beginning of the file. We would have to move the pointer to 138 first. From 0 
at the beginning, the offset would be 138 as well. The code is shown below:
In [ ]:
f = open('./my9x9table0.txt', 'r')
f.seek(138)
pt = f.tell()
line = f.readline()
print('{:3d}: {:s}'.format(pt, line), end = '')
f.close()
Out [ ]:
138: 1 x 5 = 5 2 x 5 = 10 3 x 5 = 15 4 x 5 = 20 5 x 5 = 25
Update Existing Content of a Text File
In a text file, how do we replace an existing line with something else? To achieve 
this, we need to take the following steps:
	
1.	 Open the file in r+ mode
	
2.	 Find out the position of the line
	
3.	 Move the file pointer to that position using f.seek(offset, start)
	
4.	 Write whatever you want to the file, which will replace the original 
content on that line
	
Use Sequences, Sets, Dictionaries, and Text Files	
285
 https://doi.org/10.15215/remix/9781998944088.01
An example of such an update is shown below:
In [ ]:
f = open('./my9x9table0.txt', 'r+')
f.seek(138)
pt = f.tell()
line = f.readline()
f.seek(138, 0)
f.write("update this line\n")
print('{:3d}: {:s}'.format(pt, line), end = '')
f.close()
Out [ ]:
138: 1 x 5 = 5 2 x 5 = 10 3 x 5 = 15 4 x 5 = 20 5 x 5 = 25
The updated content of the file is shown below:
1 x 1 = 1
1 x 2 = 2     2 x 2 = 4
1 x 3 = 3     2 x 3 = 6      3 x 3 = 9
1 x 4 = 4     2 x 4 = 8      3 x 4 = 12     4 x 4 = 16
1 x 5 = 5 2 x 5 = 1update this line
= 20     5 x 5 = 25
Note that if there is less new content than the original, only part of the 
original is replaced.
We can also replace a single original line with multiple lines, as shown 
below:
In [ ]:
f = open('./my9x9table0.txt', 'r+')
f.seek(138)
pt = f.tell()
line = f.readline()
f.seek(138, 0)
f.write("we write a line at the current position\n")
f.write("we write another line below\n")
f.write("we add third line below the two lines already 
written\n")
print('{:3d}: {:s}'.format(pt, line), end = '')
f.close()
Out [ ]:
138: 1 x 5 = 5 2 x 5 = 10 3 x 5 = 15 4 x 5 = 20 5 x 5 = 25
The updated file is shown below:
	286	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
1 x 1 = 1
1 x 2 = 2     2 x 2 = 4
1 x 3 = 3     2 x 3 = 6      3 x 3 = 9
1 x 4 = 4     2 x 4 = 8      3 x 4 = 12     4 x 4 = 16
1 x 5 = 5 2 x 5 = 1we write a line at the current position
we write another line below
we add third line below the two lines already written
4 3 x 7 = 21 4 x 7 = 28 5 x 7 = 35 6 x 7 = 42 7 x 7 = 49
1 x 8 = 8 2 x 8 = 16 3 x 8 = 24 4 x 8 = 32 5 x 8 = 40 6 x 8 = 48 7 x 8 = 
56 8 x 8 = 64
1 x 9 = 9 2 x 9 = 18 3 x 9 = 27 4 x 9 = 36 5 x 9 = 45 6 x 9 = 54 7 x 9 = 
63 8 x 9 = 72 9 x 9 = 81
However, if the total size of the new written data is longer than the line 
being replaced, part of the line or lines under will be overwritten. Therefore, 
if you want to replace a specific line of the text file exactly, you will need to 
write just enough to cover the existing data—­
no more, no less.
Deleting Portion of a Text File
To delete a portion of existing data from a file, you will need to use the f.trun­
cate([size]). If the optional size argument is given, the file will be truncated to 
that size or the size of the file. Otherwise, the file will be truncated to the current 
file position. So if a file is freshly opened in w, w+, a, or a+ mode, f.truncate() 
will remove all data from the beginning to the end of the file. Please note that if 
the optional size argument is given and greater than 0, the file must be opened 
in a or a+ mode in order to truncate the file to the expected size.
f = open('./my9x9table0.txt', 'a')
f.truncate(399)
 
f.close()
The resulting content of the file is shown below:
1 x 1 = 1
1 x 2 = 2 2 x 2 = 4
1 x 3 = 3 2 x 3 = 6 3 x 3 = 9
1 x 4 = 4 2 x 4 = 8 3 x 4 = 12 4 x 4 = 16
1 x 5 = 5 2 x 5 = 1we write a line at the current position
we write another line below
we add third line below the two lines already written
4 3 x 7 = 21 4 x 7 = 28 5 x 7 = 35 6 x 7 = 42 7 x 7 = 49
1 x 8 = 8 2 x 8 = 16 3 x 8 = 24 4 x 8 = 32 5 x 8 = 40 6 x 8 = 48 7 x 8 
= 56
	
Use Sequences, Sets, Dictionaries, and Text Files	
287
 https://doi.org/10.15215/remix/9781998944088.01
Please note that only part of the content in the file is left.
If the file is opened in w or w+ mode, the file will be truncated to a size of 
0 regardless.
With all we have learned so far, we are ready to design and code a program 
to analyze an article stored in a text file. The program is shown in Table 5-­
8.
Table 5-­
8: Case study: How to create a word list
The problem
Different people have different styles when writing articles. These 
styles may include the words, phrases, and even sentences used 
most often in their writing. In this case study, we will develop a 
program that analyzes an article stored as a text file to create a list 
of the words used most often in the article.
The analysis 
and design
To analyze the article, we need to read the file into memory, build a 
list of words used in the article, then count how many times each 
word appears in the article. Because the file needs to be read line 
by line, we will read, analyze, and count the words in each line. 
How can we store the result containing the unique words and the 
number of times each word appeared in the article? Recall what 
we learned about dictionaries: each unique word can be used as a 
key, and the number of times the word appears can be the value. 
We then just need to determine the words used most often in the 
article. The best way to do that would be to sort the items of the 
dictionary based on the values (instead of keys), then take the 
first 10 items as the result. The algorithm is as follows:
 
1. Prepare by creating a list of punctuation marks and a list of 
nonessential words that can be ignored.
 
2. Initialize by setting the counter to 0, w_dict = {}.
 
3. Read the first line from the article into the memory.
 
4. Build a list of all words within the line:
   a.  replace all the punctuation marks with whitespace
   b.  split the entire article at whitespace to build a list of words
   c.  remove all nonessential words from the list
 
5. Add the length of the list to the word counter:
   a.  get a word from the list
   b.  
if the word is already in w_dict, increase the value by 1; 
otherwise, add dictionary item (word:1) to w_dict
   c.  repeat step 5
 
6. Repeat steps 3–­
5 on the next line until there are no remaining lines 
in the file.
 
7. Sort w_dict based on the values.
 
8. Print out the first 10 items to show the words used most often by 
the article’s author.
Please note that this is just an example of programming with text 
files and Python dictionaries. The underlying theory about writing 
style may not be sound. The words that appear most often in an 
article may also be relevant to the topics covered by the article.
(continued on next page)
	288	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The code
"""
This program finds out the frequencies of all words 
used in a news article stored in a text file.
"""
def news_analysis(article="WritingProposal.txt"):
  f = open(article, 'r')
  w_dict = {}   # we use dictionary to store the 
result, the key is the word, the value is times 
used
  punctuations = ['//', '-­
', ',', '.', ':', '"', 
'[', ']', '(', ')', ';', '!', '?', '\n']
  less_meaningful = ['the', 'a', 'an', 'to', 'of', 
'and', 'was', 'is', 'are', 'in', 'on']
  space, words_total, unique_count = ' ', 0, 0
  for m in f:   # this will lead the PVM to read the 
file line by line
    for c in punctuations:
      m = m.replace(c, ' ')
    words = m.split(f"{space}")
    for w in words:
      if w == '':
        continue
      else:
        words_total += 1   # count total number of 
all words
    for w in less_meaningful:
      m = m.replace(f' {w} ', ' ')
      m = m.replace(f' {w.capitalize()} ', ' ')
    words = m.split(f"{space}")
    for w in words:
      if w == '':
        continue
      else:
        if w not in w_dict.keys():
          unique_count += 1
          w_dict.update({w: 1})
        else:
          w_dict[w] += 1
  f.close()
  return words_total, [(k, v) for k, v in sorted(w_
dict.items(), reverse=True, key=lambda item: 
item[1])]
result = news_analysis()
print(f"The article has {result[0]} words in total")
print(f"The number of unique words used is 
{len(result[1])}")
for i in range(20):
  print(f'word "{result[1][i][0]}" used 
{result[1][i][1]} times.')
Table 5-­
8: Case study: How to create a word list (continued)
	
Use Sequences, Sets, Dictionaries, and Text Files	
289
 https://doi.org/10.15215/remix/9781998944088.01
The result
The article has 926 words in total
The number of unique words used is 467
word "will" used 20 times.
word "be" used 13 times.
word "NATO" used 13 times.
word "https" used 13 times.
word "research" used 10 times.
word "interoperability" used 9 times.
word "as" used 9 times.
word "Information" used 8 times.
word "standards" used 7 times.
word "military" used 7 times.
word "Interoperability" used 7 times.
word "for" used 7 times.
word "www" used 7 times.
word "such" used 6 times.
word "This" used 5 times.
word "this" used 4 times.
word "Canada" used 4 times.
word "essay" used 4 times.
word "exchange" used 4 times.
word "MIP" used 4 times.
Chapter Summary
•	 Computer intelligence is achieved by computing and information 
processing.
•	 Both computing and information processing involve the manipulation 
of data.
•	 Simple types of data such as integers, floats, characters, and bools are 
the fundamental elements for complex data types.
•	 Unlike other languages, such as C, Python doesn’t have a separate data 
type for single characters. In Python, a single character is a string 
whose length is 1.
•	 Python has two constants, True and False, defined as values of type 
bool. However, Python also treats 0, None, and empty string, empty 
list, empty tuple, empty set, and empty dictionary as False and treats all 
other values/objects as True.
•	 Python has some special data values/constants that don’t belong to 
any ordinary data type. These special values/constants include None, 
NotImplemented, Ellipsis, and __debug__.
•	 Strings, lists, tuples, sets, and dictionaries are the compound data types 
in Python.
Table 5-­
8: Case study: How to create a word list (continued)
	290	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
•	 A string is a sequence of characters (ASCII, Unicode, or another 
encoding standard).
•	 A list is a sequence of data in a pair of square brackets [], such as [1, 2, 
3, 4, 5].
•	 A tuple is a sequence of data in a pair of parentheses (), such as (1, 2, 3, 
4, 5).
•	 The difference between a list and a tuple is that a list is mutable 
whereas a tuple is immutable, which means that once created, the data 
member of a tuple cannot be changed.
•	 Characters in a string and members of a list or a tuple are indexed from 
0 to n − 1, where n is the length of the string, list, or tuple.
•	 The character at place j of string s can be accessed using s[j].
•	 Similarly, a data member at place j of a list or tuple x can be accessed 
using x[j].
•	 Strings, lists, and tuples are collectively called sequences.
•	 A slice of sequence (string/list/tuple) x can be taken using x[i:j], in 
which i specifies where the slice starts and j specifies that the slice 
should end right before location j.
•	 A number of operators and functions are available for constructing and 
manipulating strings, lists, or tuples.
•	 String, list, and tuple objects also have a number of methods available 
for constructing and manipulating strings, lists, or tuples.
•	 Some operators, functions, and methods are common for strings, lists, 
and tuples.
•	 A set is a collection of unique data enclosed by a pair of curly brackets 
{}, such as {1, 2, 3, 5}.
•	 Members of a set s are unordered, which means that they cannot be 
accessed using notion S[j], for example.
•	 A set has some very special functions and methods from other 
compound data types in Python.
•	 A dictionary is a collection of keys: value pairs enclosed by a pair of 
curly brackets {}, such as {'one':1, 'two':2, 'three':3, 'five':5}.
•	 Members of a set s are unordered, which means that in a dictionary, 
there is no such thing as a member at location j, for example.
•	 However, the value of a dictionary d can be accessed using the key 
associated with the value with the notion of d[k], which refers to the 
value whose associated key is k.
•	 Some special methods are defined for the operations of dictionaries.
•	 Files are important for storing data and information permanently.
•	 Files include text files and binary files.
	
Use Sequences, Sets, Dictionaries, and Text Files	
291
 https://doi.org/10.15215/remix/9781998944088.01
•	 The basic operations of files include create, read, write, append, and 
expand.
•	 A new file can be created when open with the w or x flag, when the file 
doesn’t already exist. Opening a file with the w flag will overwrite the 
existing content of the file.
•	 To prevent data already in a file from being overwritten, open a file 
with the a flag or x flag. The a flag will open the file for appending new 
data to the end of the existing content of the file, while the x flag will 
not open the file if it already exists.
•	 Open a file with the t flag to indicate that the file is a text file.
•	 Open a file with the b flag to indicate that the file is a binary file.
•	 After reading or writing a file, use the close() file object method to close 
the file.
Exercises
	
1.	 Mentally run the following code blocks and write down the output of 
each code block.
	
a.	 course = 'comp218 -­
 introduction to programming in 
Python'
print(f'The length of \'{course}\' is 
{len(course)}')
	
b.	 course = 'comp218 -­
 introduction to programming in 
Python'
print(f'The length of \'{course[10:22]}\' is 
{len(course[10:22])}')
	
c.	 ls = list(range(9))
print(ls[2:5])
	
d.	 asc = {chr(c) for c in range(ord('A'), 
ord('Z')+1)}
print(asc)
	
e.	 l0 = [i*2+1 for i in range(10)]
print(l0[2])
	
f.	 combo = [year + str(month+1) for year in ['2015', 
'2016'] for month in range(6)]
print(combo)
	
g.	 s0 = 'Python '
s1 = 'is my language!'
print(s0+s1)
	292	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Projects
	
1.	 Write a program that reads a text from a user, then counts and displays 
how many words and how many alphanumeric letters are in the text.
	
2.	 Write a program that
	
a.	 reads a series of numbers that are separated by whitespace and 
uses a new line to end the input, then converts the numbers in the 
input string and puts them into a list.
	
b.	 sorts the numbers in the list in descending order, using the sort() 
list object method.
	
c.	 sorts the numbers in the list in descending order, using the Python 
built-­
in function sorted().
Write your own code to sort the numbers in the list in ascending order 
without using the sort() method or sorted() function.
	
3.	 Sorting is a very important operation in computing and information 
processing because it is much easier to find a particular item (a 
number or a word) from a large collection of items if the items 
have been sorted in some manner. In computer science, many 
algorithms have been developed, among which selection sort, bubble 
sort, insertion sort, merge sort, quick sort, and heap sort are the 
fundamental ones. For this project, search the internet for articles 
about these sorting algorithms. Choose one to sort a list of integers.
	
4.	 Every course offered at universities has a course number and a title. 
For this project, write an application that uses a dictionary to save 
course information, allows users to add a course into the dictionary, 
and allows a user to get the title of a course for a given course 
number. The application should perform the following functions:
	
a.	 Get a course number and name from a user and add an item, with 
the course number as key and the name as value, to the dictionary 
if the course doesn’t already exist in the dictionary.
	
b.	 Get a course number from a user, then find out the name of the 
course.
	
c.	 Display a list of all the courses in the dictionary showing the course 
numbers as well as names.
	
d.	 Quit the application.
Hint: You will need a top-­
level while loop, which displays a menu 
showing the four options then acts accordingly.
	
5.	 This project is about text analysis. Find a news article on the internet, 
analyze the content, and generate and display some statistical data 
from the article. The detailed requirements are as follows:
	
Use Sequences, Sets, Dictionaries, and Text Files	
293
 https://doi.org/10.15215/remix/9781998944088.01
	
a.	 Find a news article on the internet and save it as a text file on your 
computer.
	
b.	 Have your program build a list of words in the article while reading 
the news content from the file.
	
c.	 Generate and display the following statistics of the article:
	
i.	 the total number of words in the article
	
ii.	 a list of unique words
	
iii.	 the frequency of each unique word in the article
	
iv.	 a short list of words that represent the essence of the article
	
v.	 a table with the above data nicely presented
	
6.	 Cryptography is the study of theory and technology for the protection 
of confidential documents in transmission or storage. It involves both 
encryption and decryption. In any cryptographic scheme, encryption 
is the process of converting plaintext to ciphertext according to a 
given algorithm using an encryption key, whereas decryption is the 
process of converting encrypted text (ciphertext) back to plaintext 
according to a given algorithm using a decryption key. If the 
encryption key and decryption key are the same in a cryptographic 
scheme, the scheme is a symmetric cryptographic scheme; if the 
two keys are different, the scheme is an asymmetrical cryptographic 
scheme.
Among the many cryptographic schemes, substitution is a classic 
one, though the scheme is prone to frequency analysis attack. Write a 
program that can
	
a.	 automatically generate a substitution key and add it to a key list 
stored in a file.
	
b.	 display the substitution keys in the file.
	
c.	 allow the user to choose a key in the list and encrypt some text 
taken from the user.
	
d.	 allow the user to choose a key to decrypt an encrypted text taken 
from the user.
	
e.	 allow the user to choose a key, encrypt the content of a text file, 
and save the encrypted content into a different file.
	
f.	 allow a user to choose a key, decrypt the encrypted content in a 
file, and display the plaintext decrypted content.
This page intentionally left blank
 https://doi.org/10.15215/remix/9781998944088.01
Chapter 6
Define and Use Functions
In programming or software development, program codes must be well 
structured to be manageable. Some program codes can be reused to make pro­
gramming and software development more efficient. Functions and modules 
serve these two goals. Chapter 6 shows you how to define and use functions in 
Python and how to make and use modules in programming.
Learning Objectives
After completing this chapter, you should be able to
•	 explain what functions are in Python.
•	 define new functions correctly.
•	 use functions, including both built-­
in and programmer-­
defined 
functions.
•	 use return statements properly to return various values from a 
function.
•	 use positional arguments in defining and using functions.
•	 use variable-­
length lists of arguments in defining and using functions.
•	 use keyed arguments in defining and using functions.
•	 use positional arguments, keyed arguments, and variable-­
length lists of 
arguments.
•	 explain what recursive functions are and how they work.
•	 define and use recursive functions.
•	 explain what anonymous/lambda functions are.
•	 define and use anonymous/lambda functions.
•	 use special functions such as mapping, filtering, and reducing.
•	 explain what generators are and what advantages they have.
•	 define a function as a generator.
	296	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
•	 explain what closures and decorators are and how they are used.
•	 define and use closures and decorators.
•	 describe the properties of functions and use them properly.
6.1 Defining and Using Functions in Python
You have already seen and used some built-­
in functions in the previous chap­
ters. These built-­
in functions are built into Python Virtual Machine (PVM) 
in its standard distribution so that you can use them without importing any 
Python modules. For example, the built-­
in function sum can be used directly 
to calculate the sum of a sequence of numbers, as shown in the following 
code sample:
>>> sum([12, 23, 25, 65, 52])
177
As you will see, many Python modules, available via either Python distribu­
tion or a third party, have also defined functions ready for you to use in your 
programs.
For functions defined in a standard or third-­
party module, you must 
import the module before you can call the function by using the dot notation 
or operator, such as m.f(…), where m is a name referring to the module, 
and f is the name of the function to be used. Within the pair of parentheses 
are data as arguments of the function call, to be passed to the function for 
processing. The following is an example calling the pow() function from 
the math module:
>>> import math
>>> math.pow(35,12)
3.3792205080566405e+18
Note that when calling a function, a pair of parentheses must be attached to 
the name of the function, even if there is no argument to pass. Otherwise, the 
name of the function will be evaluated as a first-­
class object, and the type of 
the object and the name will be returned, as shown in the following example:
>>> print(sum)
<built-­
in function sum>
>>> print(id)
<built-­
in function id>
	
Define and Use Functions	
297
 https://doi.org/10.15215/remix/9781998944088.01
Although many modules have been developed by others and many func­
tions have been made available, programmers do need to define their own 
functions for their specific purposes.
To define a function in Python, the def compound statement is used. The 
general syntax is as follows:
def <function name>(parameters):
  <code block>
Where function name is a legitimate identifier in the local scope, parameters 
are legitimate variable names that can be used to pass values (arguments) to 
the function, and a code block (function body, in this compound statement) 
is the real program code that does the computing or information processing. 
What makes a code block in a function definition different from code blocks 
in other compound statements such as for, while, and if is that it will always 
return a value with the return statement. Even if you do not have anything 

to return from a function definition and do not have a return statement, special 
value None will still be automatically returned from the function.
The following is a real example showing how a function is defined in Python:
In [ ]:
def factorial(n):
"""This function calculates and returns n!, the 
factorial of an integer n > 0."""
  if (not isinstance (n, int)) or (n < 1):
    return None
  r = 1
  for i in range(n):
    r *= (i + 1)
    return r
As documented in the docstring, the function is to calculate and return the 
factorial of an integer if the number is greater than 0; otherwise, it returns 
None.
The function you defined can be used in the same way as built-­
in functions. 
The following example shows how to call the factorial function defined above:
In [ ]:
N = 16
fn = factorial(N)
print(f'factorial of {N} is {fn}.')
Out [ ]:
factorial of 16 is 20922789888000.
	298	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Sometimes you need to return more than one value from a function. To 
do that, you can either put the values in a compound data type such as a 
list, tuple, set, or dictionary, or just put the value all behind return. In the 
latter case, the values will be automatically packed in a tuple by the return 
statement.
The following example calculates and returns both the quotient and remain­
der of two integers at the same time.
In [ ]:
def idivmod(n, m):
  if (not isinstance(n, int)) or (not isinstance(n, 
int)) or (m == 0):
    return None
  return n // m, n % m
n, m = 23, 5
print(f'The value returned from idivmod({n}, {m}) is 
{idivmod(n, m)}.')
Out [ ]:
The value returned from idivmod(23, 5) is (4, 3).
In the remainder of this section, we show how to program to solve slightly 
more complicated problems with Python.
A perfect number is an integer that equals the sum of all its factors excluding 
the number itself. For example, 6 is a perfect number because 6 = 1 + 2 + 3. So 
is 28. It sounds simple, but the next perfect number is very far from 28: 496. A 
program for finding perfect numbers is shown in Table 6-­
1.
Table 6-­
1: Case study: How to find perfect numbers
The problem
In this case study, we are going to write a program to ask for a big 
integer from the user, then find all the perfect numbers smaller 
than the big integer.
The analysis 
and design
Step 1.	 Take an input from user, and convert it into an integer
Step 2.	 Loop from 2 to the big integer
   a. Test each integer to see if it is a perfect number
   b. If yes, print the number and all its factors
Step 3.	 Finish
Steps to check if a number is a perfect number:
Step 4.	 Find all its factors, including 1 but excluding the number 
itself, and put them into a list
Step 5.	 Sum up the factors with sum(factors)
Step 6. If the number == sum(factors), then return True.
	
Define and Use Functions	
299
 https://doi.org/10.15215/remix/9781998944088.01
The code
"""
This program is used to find all the perfect 
numbers that are less than N given by a user.
"""
def perfect(n):
  factor = [1]   # create a list with 1 as the 
first factor
  for j in range(2, (n // 2) + 1):   # only need 
loop to n // 2 + 1
    if n % j == 0:   # if j is a factor
      factor.append(j)   # add j to the list
    if n == sum(factor):   # if the sum of the 
factors = n
      return [True, factor] # return True as well 
as factors
    else:
      return [False, []]
upper_bound = int(input("Tell me the upper 
bound:"))
for i in range(2, upper_bound):
  test = perfect(i)
  if test[0]:
    print(f"{i} = {test[1]}")
The result
Tell me the upper bound:32198765
6 = [1, 2, 3]
28 = [1, 2, 4, 7, 14]
496 = [1, 2, 4, 8, 16, 31, 62, 124, 248]
8128 = [1, 2, 4, 8, 16, 32, 64, 127, 254, 508, 1016, 2032, 4064]
6.2 Parameters and Arguments in Functions
When you define a function, you can use variables within the parentheses 
right next to the function name to specify what values can be taken when 
the function is called. These variables within the parentheses are called par­
ameters, and the values to be passed to the parameters in a function call are 
called arguments.
In Python, a function call may take positional arguments, keyword argu­
ments, variable-­
length lists of nonkeyword arguments, variable-­
length lists 
of keyword arguments, and default arguments. These are determined in the 
definition of the function.
In a function definition, a simple variable name can be used for a parameter 
expecting a positional argument or keyword argument, to give a parameter, such 
as x, a default V using assignment x = V. When a parameter is given a default 
Table 6-­
1: Case study: How to find perfect numbers (continued)
	300	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
value, the default value will be used when no value is given to the parameter 
in a function call.
To indicate that parameter y will hold a variable-­
length list of nonkeyword 
arguments, use *y; to indicate that parameter z will take variable-­
length 
of keyword arguments, use **z. Keyword arguments will be explained 

shortly.
When calling a function, positional arguments are the arguments passed to 
their respective parameters in accordance with their positions. That is, the first 
parameter in a function call is passed to the first argument in the definition of 
the function, the second parameter is passed to the second argument, and so 
on. This is illustrated in the example below:
In [ ]:
def func_demo1(a, b, c):
  print(f'a = {a}, b = {b}, c = {c}')
func_demo1(1, 2, 3)
Out [ ]:
a = 1, b = 2, c = 3
This shows that the first argument was passed to the first parameter a, the 
second argument was passed to the second parameter b, and the third argument 
was passed to the third parameter c.
When calling a function, its parameter name, such as x, can be used as a 
keyword to explicitly indicate that a specific value, such as v, will be passed to 
x. This is done using x = v syntax, called a keyword argument in a function call. 
The following example shows how keyword arguments are used.
In [ ]:
def func_demo1(a, b, c):
  print(f'a = {a}, b = {b}, c = {c}')
func_demo1(b =1, a = 2, c = 3)
Out [ ]:
a = 2, b = 1, c = 3
In this case, the order of the arguments does not matter because the code 
explicitly indicates which argument is given to which parameter. Please note 
that in a function call when keyword argument is used, no more positional 
arguments, except variable-­
length nonkeyword arguments, may follow. An 
error will occur otherwise, as shown below:
	
Define and Use Functions	
301
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
def func_demo1(a, b, c):
  print(f'a = {a}, b = {b}, c = {c}')
func_demo1(b=1, 2, 3)
Out [ ]:
File "<ipython-­
input-­
51-­
6539f4d878e5>", line4
func_demo1(b = 1, 2, 3)
    ^
SyntaxError: positional argument follows keyword argument
Also, in a function definition, parameters expected to be used as keywords 
must be placed behind those expecting positional arguments. An error will 
occur otherwise, as shown in the following example:
In [ ]:
def func_demo1(a, b, c):
  print(f'a = {a}, b = {b}, c = {c}')
func_demo1(3, 1, a = 2)
Out [ ]:
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
TypeError   Traceback (most recent call last)
<ipython-­
input-­
185-­
f540d2127799> in <module>
  2 print(f'a = {a}, b = {b}, c = {c}')
  3 -­
-­
-­
-­
>
  4 func_demo1(3, 1, a = 2)
TypeError : func_demo1() got multiple values for argument 'a'
When a parameter in a function definition has a default value, the argu­
ment for the parameter can be omitted if the default value is to be used. The 
function defined in the following example will calculate the square of num­
ber x by default, but it can also calculate x power of y by passing a particular 
value to y:
In [ ]:
def powerof(x, y = 2):
  return f'{x} ** {y} = {x ** y}'
print(powerof(12))
print(powerof(23, 5))
print(powerof(13, y = 6))
print(powerof(y = 21, x = 3))   # with keyword 
arguments, the order doesn't matter
Out [ ]:
12 ** 2 = 144 23 ** 5 = 6436343 13 ** 6 = 4826809 3 ** 21 = 10460353203
	302	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The following example demonstrates how to define a function that can 
take variable-­
length nonkeyword arguments. The function is to calculate the 
product of a series of numbers:
In [ ]:
def product(*n):
  s = 1
  for i in n:
    s *= i
  return f'Product of all numbers in {n} is {s}'
print(product(1,2,5,32,67))
print(product(11,32,25,3,7))
print(product(19,12,15,322,6))
Out [ ]:
Product of all numbers in (1, 2, 5, 32, 67) is 21440
Product of all numbers in (11, 32, 25, 3, 7) is 184800
Product of all numbers in (19, 12, 15, 322, 6) is 6607440
As can be seen, using variable-­
length nonkeyword positional arguments 
has made the function more powerful.
Sometimes in a function call, you may also want to use variable-­
length 
keyword arguments. The following example shows how this can be done:
In [ ]:
def reporting(**kwargs):
  for k, v in kwargs.items():
    print(f'{k}:{v}')
reporting(First_name ='John', Last_name ='Doe', Sex 
='Male')
reporting()
Out [ ]:
First_name:John
Last_name:Doe
Sex:Male
When calling a function with variable-­
length keyword arguments, the key­
words look like parameter names to which the values are passed. However, 
in the case of variable-­
length keyword arguments, these keywords cannot be 
used as variables inside the function definition because they are not in the 
parameter list when the function is defined.
While variable-­
length nonkeyword arguments are passed to a function as 
a tuple, variable-­
length keyword arguments are passed to the function as a 
dictionary. As such, what can be achieved by using variable-­
length keyword 
	
Define and Use Functions	
303
 https://doi.org/10.15215/remix/9781998944088.01
arguments can also be achieved by passing a dictionary instead. For example, 
the above example can be easily rewritten as follows:
In [ ]:
def dict_reporting(ps):   # kw is a dictionary
  for k, v in ps.items():
    print(f'{k}:{v}')
pdict = {'First_name':'John', 'Last_name':'Doe', 
'Sex':'Male'}
dict_reporting(pdict)
Out [ ]:
First_name:John
Last_name:Doe
Sex:Male
Similarly, functions taking variable-­
length nonkeyword arguments can be 

easily rewritten to take a tuple. So the example of list_product function can 

be rewritten as follows:
In [ ]:
def product_tuple(nt):
  s = 1
  for i in nt:
    s *= i
  return f'Product of all numbers in {nt} is {s}'
print(product_tuple((1,2,5,32,67)))
print(product_tuple((11,32,25,3,7)))
print(product_tuple((19,12,15,322,6)))
Out [ ]:
Product of all numbers in (1, 2, 5, 32, 67) is 21440
Product of all numbers in (11, 32, 25, 3, 7) is 184800
Product of all numbers in (19, 12, 15, 322, 6) is 6607440
The difference between using variable-­
length arguments and passing a 
tuple or dictionary is that, because the length of variable-­
length arguments can 
be 0, you do not have to pass any argument at all if you don’t have one. With 
a tuple or dictionary, on the other hand, you would have to have a legitimate 
argument for the corresponding parameter in the function definition unless 
you have set a default value to it. Also, as can be seen from the two examples 
above, in some applications, using variable-­
length arguments is more natural 
and elegant.
	304	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
CODING PRACTICE
We know that given a, b, and c for equation ax2 + bx + c = 0, x is (−b + 
sqrt(b2 − 4ac)) / 2a, or (−b − sqrt(b2 − 4ac)) / 2a.
Design a program that will take three numbers with the input 
statement, and then solve quadratic equation ax2 + bx + c = 0 by calling 
a function solve quadratic(a, b, c) which you need to design. The two 
solutions x1, x2 should be returned in a tuple as (x1, x2).
6.3 Recursive Functions
A function is recursive if it calls itself either directly or indirectly. Recursion 

is a powerful concept in computing and computational theory. In computational 
theory, it has been proven that any problem computable by modern computers 
can be represented as a recursive function.
In programming, recursive functions do not make your programs run fast. 
However, they do provide a powerful means of algorithm design to solve a 
problem and make neater program code.
Take the factorial function n! as an example. You know that n! is defined as 
1 * 2 * 3 * … * n. If you use fac(n) to refer to the factorial function, you cannot 
simply define the function in Python as
def fac(n):
  return 1 * 2 * 3 * … * n   # this does not work in 
Python
because the dots (…) do not make sense to computers in this context. With what 
you have learned so far, the function can be defined as
def fac(n):
  if n == 0:
    return 1
  product = 1
  for i in range(n):   # using loop
    product *= (i + 1)
  return product
The function above has seven lines of code.
	
Define and Use Functions	
305
 https://doi.org/10.15215/remix/9781998944088.01
Since you know that 0! = 1, and n! can be computed as n * (n − 1)! if n > 0, 
you can program a recursive function in Python to solve the factorial problem, 
as shown in the case study in Table 6-­
2.
Table 6-­
2: Case study: How to use a recursive function for 
calculating factorial n
The problem
Define a recursive function to calculate factorial n as n!
The analysis 
and design
We know that 0! = 1, and n! can be computed as n * (n − 1)! when 
n > 0. So if we use fac(n) to denote n!, this will be translated as 
fac(n) = 1 if n = 0 and as fac(n)= n * fac(n − 1) if n > 0. Accordingly, 
we can define a recursive factorial function in Python as follows:
The code
def fac(n):
  if n == 0:
    return 1
  else:
    return n * fac(n -­
 1)
n = 9
print(f"{n}! = {fac(n)}")
The result
9! = 362880
As you can see, the function has become shorter and neater, although it 
often takes more memory and more time to run.
The next case study, in Table 6-­
3, shows how a recursive function can be 
used to find the greatest common divisor of two integers.
CODING ALERT
What will happen if fac(n) is called with n < 0? For example, as fac(−9)?
Table 6-­
3: Case study: How to use a recursive function
The problem
This simple problem aims to find the greatest common divisor 
(GCD) for two given integers. A common divisor of two integers 
is an integer that can divide both integers, and the GCD is the 
biggest one among the common divisors. For example, 1 and 2 are 
common divisors of 4 and 6, and 2 is the GCD of 4 and 6.
The analysis 
and design
At first glance, a straightforward approach is to find all the divisors 
for each integer,
(continued on next page)
	306	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
The code
"""
Ask for two integers and find the GCD of the two 
using the improved Euclidean algorithm.
"""
def my_gcd(a, b):
  global depth
  if b == 0:   # condition to finish
    return b
  else:
    b, a = sorted((abs(a -­
 b), b))   # sort and 
reassign
    depth += 1   # recursion depth increased by 1
    print(f"recursion #{depth} for{(a, b)}")
    return my_gcd(a, b)
i = int(input("Tell me the first integer:"))
j = int(input("Tell me the second integer:"))
if i < j:
  i, j = j, i
depth = 0
print(f"The greatest common divisor of {i} and {j} 
is {my_gcd(i, j)} after {depth} recursions.")
The result
Tell me the first integer:3238
Tell me the second integer:326
recursion #1 for (2912, 326)
recursion #2 for (2586, 326)
recursion #3 for (2260, 326)
recursion #4 for (1934, 326)
recursion #5 for (1608, 326)
recursion #6 for (1282, 326)
recursion #7 for (956, 326)
recursion #8 for (630, 326)
recursion #9 for (326, 304)
recursion #10 for (304, 22)
recursion #11 for (282, 22)
recursion #12 for (260, 22)
recursion #13 for (238, 22)
recursion #14 for (216, 22)
recursion #15 for (194, 22)
recursion #16 for (172, 22)
recursion #17 for (150, 22)
recursion #18 for (128, 22)
recursion #19 for (106, 22)
recursion #20 for (84, 22)
recursion #21 for (62, 22)
recursion #22 for (40, 22)
recursion #23 for (22, 18)
recursion #24 for (18, 4)
recursion #25 for (14, 4)
recursion #26 for (10, 4)
recursion #27 for (6, 4)
recursion #28 for (4, 2)
recursion #29 for (2, 2)
recursion #30 for (2, 0)
The greatest common divisor of 3238 and 326 is 2 after 30 
recursions.
Table 6-­
3: Case study: How to use a recursive function (continued)
	
Define and Use Functions	
307
 https://doi.org/10.15215/remix/9781998944088.01
As noted, the program took 30 recursions to find the GCD of 3238 and 326. 
Can we make it more efficient? The answer is yes, and it is fun to design and 
code a better and faster program to solve a problem, as shown in the case study 
of this same problem in Table 6-­
4.
Table 6-­
4: Case study: How to use a recursive function—­
revised
The problem
This simple problem aims to find the greatest common divisor 
(GCD) for two given integers. A common divisor of two integers 
is an integer that can divide both integers, and the GCD is the 
biggest one among the common divisors. For example, 1 and 2 are 
common divisors of 4 and 6, and 2 is the GCD of 4 and 6.
The analysis 
and design
The original Euclidean algorithm is great because it only needs 
subtraction to find out the greatest common divisor, but sometimes 
it will involve too many steps, especially if we do the calculation 
manually. For example, to find the greatest common divisor of 4 
and 40000, one needs to complete 10000 subtractions to find out 
that 4 is the GCD. An obvious and straightforward improvement to 
the algorithm is to use modular operation in place of subtraction.
The code
"""
Ask for two integers and find the GCD of the two 
using the improved Euclidean algorithm.
"""
def my_gcd(a, b):
  global depth
  if b == 0:   # condition to exit from recursion
    return a
  else:
    b, a = sorted(((a % b), b))   # sort and 
reassign
    depth += 1   # recursion depth increased by 1
    print(f"recursion # {depth} for {(a, b)}")
    return my_gcd(a, b)
i = int(input("Tell me the first integer:"))
j = int(input("Tell me the second integer:"))
if i < j:
  i, j = j, i
depth = 0
print(f"The greatest common divisor of {i} and {j} 
is {my_gcd(i, j)} after {depth} recursions.")
The result
Tell me the first integer:3238
Tell me the second integer:326
recursion #1 for (326, 304)
recursion #2 for (304, 22)
recursion #3 for (22, 18)
recursion #4 for (18, 4)
recursion #5 for (4, 2)
recursion #6 for (2, 0)
The greatest common divisor of 3238 and 326 is 2 after 6 
recursions.
	308	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
As you can see, for the same numbers, the improved algorithm took only six 
recursions, whereas the original took 30. Another benefit of using the improved 
algorithm is that because Python Virtual Machine (PVM) has a limit on the 
maximum depth of recursions due to the limitations of computer memory, 
the improved algorithm will be able to handle much bigger numbers than the 
original algorithm. You may run the two programs on 24230336504090 and 
356879542 to see the difference between the two algorithms.
6.4 Anonymous Functions: lambda Expressions
In previous sections, you saw functions with names, which make it possible to 
call a function by its name. Sometimes, especially when the operations of the 
function are simple and used only once, it is more convenient to simply use a 
small code block as a function without defining a function with a name. This 
is where anonymous functions or lambda expressions come to play.
The word lambda originates from lambda calculus, which has played an 
important role in the development of modern computational theory and func­
tional programming. You are encouraged to search for lambda calculus on the 
internet for more details.
In Python, an anonymous function can be defined using the following 
syntax:
lambda <formal argument list> : <expression whose value is to be 
returned>
In the above syntax, a formal argument list is a list of variables separated 
by commas but without surrounding parentheses, and everything behind the 
colon takes the role of the code block in the regular function definition. But 
it must be a single expression whose value is to be returned by the lambda 
function without a keyword return.
The following is an example of a lambda function in Python that is used to 
construct an odd number from a given integer:
>>> lambda n: 2 * n + 1
<function <lambda> at 0x012CBD20>
>>>
Because an anonymous function is meant to have no name, the common use 
of such a function is to have it called directly when it is defined, as shown below:
	
Define and Use Functions	
309
 https://doi.org/10.15215/remix/9781998944088.01
>>> (lambda n: 2 * n + 1)(4)
9
Note that a pair of parentheses encloses the entire lambda expression to 
signify the end of the lambda expression.
A lambda expression can also have two or more formal arguments, as shown 
below:
>>> (lambda x, y: x + y)(3, 5)
8
In the example above, we first defined a lambda function within a pair of paren­
theses, then applied it to a list of two actual arguments within a pair of parentheses.
An anonymous function can even be defined to take a variable-­
length list 
of arguments, as shown in the following example:
>>> (lambda& * x: sum(x) * 3)(1, 2, 3, 4, 5)
15
Although an anonymous function is meant to have no name, that does not 
stop you from giving it a name, as shown in the next example:
>>> double = lambda x: 2 * x
We can then call the function with the name, as shown below:
>>> double(23)
46
Our next anonymous function takes two arguments and checks if one is a 
multiple of the other:
>>> is_multiple = lambda m, n: m % n == 0
>>> is_multiple(32, 4)
True
>>> is_multiple(32, 5)
False
The next section will show how lambda expressions can be used to program 
more effectively.
	310	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
6.5 Special Functions: Mapping, Filtering, and 
Reducing
As mentioned, Python treats everything as objects, including functions, which 
can be accessed in the same way as ordinary objects. The following is an example:
>>> f_objects = [abs, len, open]   # the list has three 
functions as its members
>>> f_objects[0](-­
2)   # f_objects[0] refers to the first 
item in the list, which is built-­
in function abs
12
>>> f_objects[1](f_objects)   # f_objects[1] refers to the 
second item in the list, which is built-­
in function len
3
This has provided programmers with great possibilities. For example, 
Python has three special built-­
in functions that can take other functions as 
arguments and apply them to a list. These special functions include mapping, 
filtering, and reducing.
Mapping
It is easier to explain what mapping does with a code example:
>>> integers = [-­
12, 32, -­
67, -­
78, -­
90, 88]   # this list 
has negative numbers
>>> list(map(abs, integers))   # this maps the function 
abs to each integer in the list
[12, 32, 67, 78, 90, 88]
Note that abs() has been applied to every member of the list.
Basically, the map function can apply any function to as many lists as 
required for its arguments. The following is an example:
>>> def sum(a, b):   # this function requires two 
arguments
… return a + b
…
>>> list(map(sum, [1, 2, 3], [5,8,9]))   # this maps the 
sum function to two lists for the two arguments
[6, 10, 12]
	
Define and Use Functions	
311
 https://doi.org/10.15215/remix/9781998944088.01
Given what you have already learned about anonymous functions, you can 
generate a list of odd numbers neatly, as follows:
>>> list(map(lambda n: 2 * n + 1, range(10)))
[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
Similarly, we can generate all multiples of a number k, such as 3 in the 
example below:
>>> list(map(lambda n: 3 * n, range(10)))
[0, 3, 6, 9, 12, 15, 18, 21, 24, 27]
Filtering
The filtering function takes the same form as the mapping function but is used 
to extract items from the iterable that satisfy the Boolean filtering condition at 
hand. The following sample code keeps only even numbers in the generated list:
>>> def even(n):
… return n % 2 == 0   # if it can be divided by 2, then 
return true; return false otherwise
…
>>> list(filter(even, range(10)))   # filter applies to 
each even number and keeps only some
[0, 2, 4, 6, 8]
The code above can be neatly rewritten by using a lambda expression, as 
follows:
>>> list(filter(lambda n: n % 2 == 0, range(10)))
[0, 2, 4, 6, 8]
The filter function may play an important role in selecting items from a 
given list based on certain criteria, as shown in the following example:
>>> st = "The filter function may play an important role 
in selecting words from a given text. In the following 
example, only words that contain the letter o are selected"
>>> list(filter(lambda s: 'o' in s, st.split()))
['function', 'important', 'role', 'words', 'from', 
'following', 'only', 'words', 'contains', 'o']
Note that only the words that include the letter o are selected.
	312	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Reducing
The reduce function is not a built-­
in function but defined in the functools mod­
ule. It takes the same form as the mapping and filtering functions but applies 
the function to items in the iterable progressively until the list is exhausted 
and reduced to a single value or object, as shown in the following example in 
JupyterLab:
In [ ]:
def pow(m, n):
  return m ** n
from functools import reduce
reduce(pow, range(2, 6))   # equal to pow(pow(pow(2, 
3), 4), 5)
Out [ ]:
1152921504606846976
We can recode the above operation with the lambda expression (anonymous 
function) we learned in the previous section, as shown below:
In [ ]:
reduce(lambda n, m: n ** m, range(2, 6))
Out [ ]:
1152921504606846976
As seen from the examples above, a lambda expression becomes handy 
when you use a function only once and the function is simple enough to be 
written with an expression.
6.6 Generators: Turning a Function into a Generator 
of Iterables
As you have seen, sequences (including lists, tuples, and strings) are an import­
ant way of organizing data. In addition to having a relatively static list accessible 
through a variable, Python also provides a means to make a generator that can 
generate members of a sequence dynamically.
Assume we want to find out a sequence of perfect numbers within a 
given range. Instead of finding all perfect numbers within the range and 
returning them in a list, we can define a generator of perfect numbers 
using the yield statement in place of the return statement, as shown in the 
following example:
	
Define and Use Functions	
313
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
def isPerfect(n):
  factor = [1]
  for j in range(2, (n // 2) + 1):
    if n % j == 0:
      factor.append(j)
    if n == sum(factor):
      return [True, factor]
    else:
      return [False, []]
def perfectGenerator(m = 100):
  for i in range(m):
    testResult = isPerfect(i)
    if testResult[0]:
      yield [i, testResult[1]]
myPerfects = perfectGenerator(10000)
print(myPerfects)
Out [ ]:
<generator object perfectGenerator at 0x00000191402373C8>
As we can see, instead of returning a list of all the perfect numbers and 
factors within the given range, the function actually returned a generator.
To get the next perfect number in the generator, we use the built-­
in function 
next, as shown below:
In [ ]:
print(next(myPerfects))
print(next(myPerfects))
print(next(myPerfects))
print(next(myPerfects))
print(next(myPerfects))
Out [ ]:
[1, [1]]
[6, [1, 2, 3]]
[28, [1, 2, 4, 7, 14]]
[496, [1, 2, 4, 8, 16, 31, 62, 124, 248]]
[8128, [1, 2, 4, 8, 16, 32, 64, 127, 254, 508, 1016, 2032, 4064]]
Note that in the output above, we found five perfect numbers between 1 and 
10000. Output on each line is a list, and the first member is a perfect number, 
whereas the second member contains a list of its factors (whose sum is equal 
to the first number).
Recall that we have used the built-­
in function range() with for loops. We can 
use user-­
defined generators with for loops as well, as shown below:
	314	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
myPerfects = perfectGenerator(10000)
for p in myPerfects:
  print(p)
Out [ ]:
[1, [1]]
[6, [1, 2, 3]]
[28, [1, 2, 4, 7, 14]]
[496, [1, 2, 4, 8, 16, 31, 62, 124, 248]]
[8128, [1, 2, 4, 8, 16, 32, 64, 127, 254, 508, 1016, 2032, 4064]]
You may wonder why we need generators instead of returning a list of 
objects. The reason is for performance in terms of both speed and memory 
usage. The next two examples show the difference in speed between a generator 
and a normal function returning a list of perfect numbers.
In [ ]:
import time   # time module for time and timing 
related functions
from memory_profiler import profile   # a module 
for profiling memory usage
def isPerfect(n):
  factor = [1]
  for j in range(2, (n // 2) + 1):
    if n % j == 0:
      factor.append(j)
    if n == sum(factor):
      return [True, factor]
    else:
      return [False, []]
def getAllPerfects(n = 10):
  perfects=[]
  for i in range(1, n + 1):
    testResult = isPerfect(i)
    if testResult[0]:
      perfects.append((i, testResult[1]))
  return perfects
t0 = time.process_time()
perfectNumbers = getAllPerfects(10000)
t1 = time.process_time()
print(f"{t1 -­
 t0} seconds are used to get a list 
of perfect numbers")
Out [ ]:
1.1875 seconds are used to get a list of perfect numbers
	
Define and Use Functions	
315
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
import time   # time module for time and timing related 
functions
from memory_profiler import profile   # a module for 
profiling memory usage
def isPerfect(n):
  factor = [1]
  for j in range(2, (n // 2) + 1):
    if n % j == 0:
      factor.append(j)
    if n == sum(factor):
      return [True, factor]
    else:
      return [False, []]
def perfectGenerator(m = 100):
  for i in range(m):
    testResult = isPerfect(i)
    if testResult[0]:
      yield [i, testResult[1]]
t0 = time.process_time()
myPerfects = perfectGenerator(10000)
t1 = time.process_time()
print(f"{t1 -­
 t0} seconds are used to get a generator 
of perfect numbers")
Out [ ]:
0.0 seconds are used to get a generator of perfect numbers
The first code sample is to find a list of perfect numbers within a given 
range using a normal function to return a list of perfect numbers, whereas the 
second code sample uses a generator instead. As you can see, to get a generator 
of perfect numbers took no time (0.0 seconds), whereas using a function to 
return a list of perfect numbers took 1.1875 seconds.
The gain from returning a generator instead of a complete list from a func­
tion is even more obvious in terms of memory usage, because a list would 
usually take a bigger chunk of computer memory, which increases drastically 
along with the growth of the list, whereas for a list generator, the memory 
usage is determined by the coding of the function and will not change. In our 
examples above, the generator that generates perfect numbers from 1 to 100000 
has almost the same number of lines of code as the function that produces a list 
of perfect numbers in the same range, but the function consumes much more 
memory than the generator because of the use of list. To get a sense of how 
much memory would be consumed by a bigger list, see the following example:
	316	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
import sys
print(f"The size of a list containing numbers from 0 to 
100 is {sys.getsizeof(list(range(100)))}Bytes")
print(f"The size of list containing numbers from 0 to 
1000 is {sys.getsizeof(list(range(1000)))}Bytes")
print(f"The size of list containing numbers from 0 to 
10000 is {sys.getsizeof(list(range(10000)))}Bytes")
Out [ ]:
The size of a list containing numbers from 0 to 100 is 1008Bytes
The size of a list containing numbers from 0 to 1000 is 9112Bytes
The size of a list containing numbers from 0 to 10000 is 90112Bytes
As you can see, a simple list containing integer numbers from 0 to 10000 
takes up almost 90KB of memory.
6.7 Closures: Turning a Function into a Closure
In Python and some other programming languages such as JavaScript, closures 
are the result of a nested function—­
that is, one function that is defined inside 
another—­
as shown in the following example:
In [ ]:
def outer(greeting):
    print('Good morning!')
    def inner(msg):
        print(msg)
    inner(greeting)
outer('Good day!')
Out [ ]:
Good morning!
Good day!
In the example above, the outer function can also return the inner function 
with the parameter list as a first-­
order object, as shown below:
In [ ]:
def outer():
    greeting = 'Good morning,'
    def greet(who):
        print(greeting, who)
    return greet
cl = outer() # cl will hold function greet
name = input('What is your name?')
cl(name) # local greeting in outer still attached
Out [ ]:
Good morning, Joe
The output was produced when you input Joe for the name.
	
Define and Use Functions	
317
 https://doi.org/10.15215/remix/9781998944088.01
What has been returned from call of outer() is a function object. However, 
because of the way the function is defined and returned, the value of the vari­
able greeting, defined locally within the outer function, has been attached to 

the inner function object. This is called closure—­
the binding of certain data 

to a function without actually executing the function.
6.8 Decorators: Using Function as a Decorator 
in Python
Python has many powerful means and program constructs that you can use to 
solve problems and get the jobs done. Decorators are one of them.
In Python, a decorator can be a function, but it is used to modify the func­
tionality of other functions. Suppose we want to keep a log of the time a function 
is called, the parameters passed, and the time the call took to run. A decorator 
function can be defined as follows:
In [ ]:
import time # import the time module
# define a function as a decorator
def calllog(function_logged):   # calllog function will 
be used as a high order function and decorator
    def wrapper_function(*args, **kwargs):
        t0 = time.asctime()
        t1 = time.time()   # time started in seconds as 
a float number
    func_handle = function_logged(*args, **kwargs)
        t2 = time.time()   # time ended in seconds as a 
float number
        call_args = ''
        if args:
            call_args += str(args)
    if kwargs:
            call_args += str(kwargs)
        with open("calllog.txt", "w") as logs:
            log_str = f"Call to {function_logged.__
name__}{call_args}\n"
            log_str += f"was made at {t0}, taking {t2 
-­
 t1} \n"
            logs.write(log_str)
            print(f"Logging string written to file 
is:\n {log_str}")
    return func_handle
  return wrapper_function
@calllog   # calllog is used as decorator
def real_function(message = "Operation",m=2, n=3):
  print(message,'\n', f'{m}**{n}=\n', m**n)
real_function(message="Operation m to the power of n", 
m=123456789, n=199)
	318	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Out [ ]:
Operation m to the power of n
123456789**199=
16273480830928460132417950594596569558877352891957597527186
5178655668529042309237619989258306106107470796567847777669
4979578642000466712019740418952547246055989565285203342320
1635987631993944618743752213013724549514037908343831333069
3339877194631448240511529289603414404095019761182651422306
3215694559633025394947655131573832171589906384161873332226
4922481325525627831284047397626329561279283208434591744868
1553425787599413514884427065211671134509510806599010879043
4049581161589934723326683225949480983457824265493831766741
8414495414087226417784891667194654738380143539652423296727
8397336246191565592631874430342301391129941032341482155018
4853648462203555248458520671193824561733068153104155547783
9087024586408999843855597754908302821728495386842518994478
2520828778542782626615331157474809673798175226065273267575
2489133426820060935499575223584065751090015735421676999145
0814755577140900813045111393260168223478200641944154844292
6373709258668550718362777098506123158504564363626666999333
4013946685549557175420965888062340558027537152951783153293
2230219978406047270164537039827469092224210875077720641113
1334391598657540208216549131267004257438048558678889138741
5395857275045805521942026082836745137076008067859592825225
6417990024617027365928579573806527191486578290433390603117
7020338769884454165407411399431838155103129975186500016431
8853234471269192633863320874318241295949565851371992467870
9745114665575426890554943460193024792121207815114065877782
2152688458823924816621267882515972976339888586466699424919
8618153756380986737526890055365847162354423404796566823762
41467062062297627346560365999071034663278109
Logging string written to file is:
Call to real_function{'message': 'Operation m to the power of n', 'm': 
123456789, 'n': 199}
was made at Mon Mar 13 12:07:27 2023, taking 0.0
As shown above, the log written to the calllog.txt file is as follows:
Call to real_function{'message': 'Operation m to the power of n', 'm': 
123456789, 'n': 199}
was made at Mon Mar 13 12:07:27 2023, taking 0.0
Our next example is to use the calllog function as a decorator, as defined 
above, to record the time it takes to find all perfect numbers in a given range, 
the example we have worked on in Chapter 4.
This time, since we have learned how to define and use functions, we will 
define functions for factorization and perfect number testing, respectively, so 
that we can log the time on calls to the function. The code is as follows:
	
Define and Use Functions	
319
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
def factors(n): # function for finding factors of a given 
number
    # the function will return a list of factors for n
    factor_list = [1] # make a list with 1 as a single element
    for f in range(2,n): # start from 2, with n as excluded 
from factors
        if n%f == 0: # f is a factor of n
            if not f in factor_list:
                factor_list.append(f)
    # now we have a list of factors for n
    return factor_list
# function to find all perfect numbers in a given range
def perfect_numbers(a, b):
    if a>b: # then we need to swap a and b
        c = a; a = b; b = c
    perfect_list = [] # make an empty list ready to hold all 
perfect numbers
    for n in range(a, b+1): # b is included
        factor_list = factors(n)
        if n == sum(factor_list):
            perfect_list.append([n, factor_list]) # keep 
factors too for checking
    return perfect_list
# now the main
@calllog   # calllog is used as a decorator
def do_perfect():
    success = False
    # use a while loop to keep asking for inputs until success 
is True
    while not success:
        num1 = input("Enter the first number: ")
        num2 = input("Enter the second number: ")
        # try to convert the inputs to floats and divide them
            try:
            a, b = int(num1), int(num2)
            # set success to True if no error has occurred by 
now
            success = True
            perfect_list = perfect_numbers(a, b)
        # now we have found all the perfect numbers in the 
range
            print(f"Perfect numbers found between {a} and 
{b}:")
            for n in perfect_list:
                print(n, end=" ")
        # handle the possible errors and exceptions
        except ValueError:
            print("Invalid input. Please enter numbers only.")
        except ZeroDivisionError:
            print("Cannot divide by zero. Please enter a 
nonzero number.")
        except Exception as e:
            print(f"An unexpected error occurred: {e}")
    # end of do_perfect
do_perfect()
	320	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Out [ ]:
Perfect numbers found between 3 and 10000:
[6, [1, 2, 3]]
[28, [1, 2, 4, 7, 14]]
[496, [1, 2, 4, 8, 16, 31, 62, 124, 248]]
[8128, [1, 2, 4, 8, 16, 32, 64, 127, 254, 508, 1016, 
2032, 4064]] Logging string written to file is:
Call to do_perfect
was made at Mon Mar 13 13:18:15 2023, taking 
5.2627036571502686
As shown above, the log written to the calllog.txt is
Call to do_perfect
was made at Mon Mar 13 13:18:15 2023, taking 5.2627036571502686
As you can see, although a decorated function is called in the same way as other 
functions, a lot of other things can be done through a decorator during the call.
It is also worth noting that perfect numbers are very rare. Between 3 and 
10000, there are only four perfect numbers, and it took a little over 5 seconds to 
find them. Tested on the same machine, it took more than 100 second to look 
for all the perfect numbers between 3 and 100000, and there are no perfect 
numbers between 10000 and 100000.
6.9 Properties of Functions
Functions are important building blocks of programs in all programming lan­
guages. In Python, a function will have the following properties, and most of 
them can be written by the programmer of the function.
__DOC__
This holds the function’s docstring, written by the programmer, or None if no 
docstring is written by the coder. The docstring will show up when the help() 
function is called on a function, though help() will also show some standard 
information even if no docstring is available.
__NAME__
This contains the name of the function.
__QUALNAME__
This contains the qualified name of the function and is new to Python 3.3 and 
later versions. By qualified name, we mean the name that includes the path 
	
Define and Use Functions	
321
 https://doi.org/10.15215/remix/9781998944088.01
leading to the location where the function is defined. For example, a function F 

can be a method defined in a class C, which is defined in a module M, in which 
case the qualified name will be M.C.F.
__MODULE__
This stores the name of the module in which the function was defined. It con­
tains None if module info is unavailable.
__DEFAULTS__
This stores a tuple containing default argument values for those arguments that 
have defaults or stores None if no arguments have a default value.
__CODE__
This contains the actual code object representing the compiled function body.
__GLOBALS__
This contains a reference to the dictionary that holds the function’s global 
variables, the global namespace of the module in which the function was 
defined. It is a read-­
only function automatically generated by Python Virtual 
Machine (PVM).
__DICT__
This stores a dictionary describing names of attributes and their values in the 
namespace of the function. In Python, a namespace is a mapping from names 
to objects and is implemented as a Python dictionary.
__CLOSURE__
This stores a tuple of cells that contain bindings for the function’s free variables. 
Each cell has an attribute called cell_contents from which a cell’s value can be 
retrieved. It is automatically generated by PVM.
__ANNOTATIONS__
This stores a dictionary containing annotations of parameters. The keys of the 
dictionary are the parameter names, and return as key for the return annota­
tion, if provided, and the values of the dictionary are the expected data type of 
the parameters as well as the expected data type of the object to be returned 
by the function.
__KWDEFAULTS__
This stores a dictionary containing default values for keyword-­
only parameters.
	322	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Chapter Summary
•	 Functions are important building blocks of programs in almost all 
programming languages.
•	 Different languages use different keywords to signify the definition of 
a function. Python uses def to start the definition of a function (and 
method within a class definition).
•	 In Python, the definition of one function can contain the definition of 
other function or functions.
•	 A function can have positional arguments, variable-­
length lists of 
arguments, and keyword arguments.
•	 When calling a function, the parameters for positional arguments must 
come first, followed by variable-­
length lists of arguments. Keyword 
arguments come last.
•	 A recursive function is a function that calls itself within its definition.
•	 Anonymous functions are functions without a name. They begin 
with the keyword lambda. Anonymous functions are useful when the 
function is only used once.
•	 Mapping, filtering, and reducing are special functions that can used 
to apply a function, including an anonymous function, to a list of 
parameters.
•	 Mapping applies a function to each item of a list.
•	 Filtering applies some criteria specified in a Boolean function to a list 
to filter out the items that do not meet the criteria.
•	 Reducing sequentially applies a function to the members of a list and 
reduces the list to a single member.
•	 Functions are often used to process and return the results of 
information processing using the return statement.
•	 In a function definition, the return statement can be replaced with the 
yield statement to turn the function into a generator of a sequence.
Note that a function cannot be turned into a generator by simply 
replacing the return statement with a yield statement.
Exercises
	
1.	 Python has a built-­
in input function for taking input from users. 
However, it treats everything from the user as a string. For this 
exercise, define a function named getInteger, which takes one 
optional argument as a prompt and gets and returns an integer from 
the user.
	
Define and Use Functions	
323
 https://doi.org/10.15215/remix/9781998944088.01
	
2.	 Define a function that has one argument, n, that will take a natural 
number and return the product of all the odd numbers between 1 and n.
	
3.	 Define a function that has one argument, n, that will take an integer 
and return the product of all the odd numbers between 1 and n, or 
between n and −1 if n is a negative integer, or that will return None if n 
is not an integer.
	
4.	 The Fibonacci sequence (Fn) is well-­
known in mathematics, and is 
defined as follows:
F0 = 1, F1 = 1, Fn = Fn−1 + Fn−2
Define a recursive function that takes one argument, n, and 
calculates and returns the nth item (Fn) of the Fibonacci sequence.
	
5.	 Define a recursive function that takes one argument, n, and calculates 
and returns the entire list of all items from F0 to Fn, of the Fibonacci 
sequence.
	
6.	 Define a function that takes a variable-­
length list of numbers and 
returns the product of all these numbers.
Projects
	
1.	 Study the federal personal income tax rates for the current tax 
year and define a function that takes one argument as net taxable 
income and calculates and returns the total federal income tax due.
	
2.	 Study both the federal personal income tax rates and the provincial 
tax rates for your province for the current tax year. Define a function 
that takes one argument as net taxable income and calculate and 
return both total federal income tax due and total provincial tax due.
	
3.	 Modify the function defined for 6.6 by adding a keyword argument 
with the default value f or F to tell the function to calculate and return 
the federal tax due. If the argument passed to the keyword parameter 
is p or P, then provincial tax due should be calculated and returned. 
Test the modified function with different values passed to the keyword 
argument to make sure it works as expected.
	
4.	 The Tower of Hanoi is a mental game. It consists of three rods and N 
disks of different sizes that can move onto any rod one by one, but 
at no time is a bigger disk allowed to be on top of a smaller disk. The 
three rods are labelled A, B, and C. The game begins with all disks 
stack on rod A, and the goal is to move all the disks onto rod C. Write 
a recursive function that takes one argument as the number of disks 
initially on rod A and print out the moves to be taken in order to move 
	324	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
all the disks from A to C. Each move can be represented as i: Rs Rd, 
where i is 0, 1, 2…, Rs and Rd is A, B or C, but Rs and Rd cannot be the 
same. It means that at step i, take one disk from source rod Rs and 
slide it onto destination rod Rd. For example, if there are three disks 
on rod A, the moves will be as follows:
1: A  C, 2 : A  B, 3 : C  B, 4 : A  C, 5 : B  A, 6 : B  C, 7 : A  C
 https://doi.org/10.15215/remix/9781998944088.01
Chapter 7
Object-­
Oriented 
Programming with Python
This chapter introduces you to object-­
oriented programming, including how to 
define classes and how to use classes as a new data type to create new objects, 
and will show you how to use objects in programming. Programming for com­
puters essentially means modelling the world, or parts of it, for computers. 
In modern computing and programming, object-­
oriented programming is a 
very powerful means of thinking and modelling. In Python, everything can be 
treated as an object.
Learning Objectives
After completing this chapter, you should be able to
•	 explain object-­
oriented programming and list its advantages.
•	 define a new class to model objects in programming and software 
development.
•	 create and use objects and instances of classes in programming and 
system development.
•	 use subclasses and superclasses properly when defining and using 
classes.
•	 properly define and use public, private, and protected members of 
a class.
•	 correctly define and use class attributes.
•	 effectively define and use class methods and static methods when doing 
object-­
oriented programming.
•	 properly define and use dunder methods.
•	 use class as a decorator.
	326	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
•	 explain the built-­
in property function and use it to add an attribute 
or property to a class with or without explicit setter, getter, or deleter 
functions.
•	 use the property function as a decorator to turn a method into an attribute 
of a class, and declare explicitly the setter, getter, or deleter of the attribute.
7.1 Introduction to Object-­
Oriented Programming 
(OOP)
Object-­
oriented programming, including analysis and design, is a powerful 
methodology of thinking of how things are composed and work. The world 
is made of objects, each of which has certain attributes and contains smaller 
objects. What is specially offered by object-­
oriented analysis, design, and 
programming in a systematic and even scientific manner are abstraction, 
information hiding, and inheritance.
Abstraction
Abstraction is a very fundamental concept of object-­
oriented programming. The 
concept is rather simple. Because an object in the real word can be very com­
plicated, containing many parts and with many attributes, it would be practical 

to consider only those parts and attributes that are relevant to the programming 
tasks at hand. This simplified model of a real-­
world object is an abstraction of it.
Information Hiding or Data Encapsulation
The concept of information hiding is very simple and straightforward. There are 
two reasons for hiding certain kinds of information: one is to protect the infor­
mation, and the other is to make things easier and safer by hiding the details. 
An example of information hiding that you have already seen is defining and 
using functions. The code block of a function can be very lengthy and hard to 
understand. After a function is defined, however, a programmer only needs to 
know what the function does and how to use it, without considering the lengthy 
code block of how the function works.
In OOP, information hiding is further down within classes. Some OOP lan­
guages strictly limit direct access to class members (variables declared within 
a class), and all access must be done through the setter and getter methods. 
Python, however, has no such restriction, but you still need to remember the 
benefit of information hiding: avoiding direct access to the internal members 
of objects. Python also provides a way to hide, if you want to, by using double 
underscored names, such as __init__, __str__, and __repr__.
	
Object-­
Oriented Programming with Python	
327
 https://doi.org/10.15215/remix/9781998944088.01
Inheritance
Inheritance is a very important concept of object-­
oriented programming, 
and inheriting is an important mechanism in problem solving and system 
development with the object-­
oriented approach. The underlying philosophy 
of inheritance is how programmers describe and understand the world. Most 
often, things are categorized and put in a tree-­
like hierarchy with the root on 
the top, as shown in Figure 7-­
1 below. In such a tree-­
like hierarchy, the root 
of the tree is the most generic class or concept, and the leaves are the most 
specific and often refer to specific objects. From the root down to the leaves, 
nodes on a lower level will inherit the properties of all the connected nodes 
at higher levels.
Within such a hierarchy, it is more convenient to have a model that captures 
general attributes shared by desktop, laptop, and tablet computers than to 
have models capturing the specifics of desktop, laptop, and tablet computers, 
respectively, with these specific models inheriting the common attributes cap­
tured by the generic model for computers. In such a hierarchy, the computer is 
the superclass of the desktop, laptop, and tablet, whereas the desktop, laptop, 
and tablet are a subclass of the computer.
7.2 Defining and Using Classes in Python
Normally in OOP, a class would include some attributes and methods, as well 
as a constructor or initiator for creating instances of the class. However, com­
pared to other object-­
oriented programming languages, especially the earlier 
generations such as C++ and Java, Python provides some less-­
restricted ways 
of defining classes and instantiating objects.
In Python, a class can be easily created with only two lines of code, as 
shown below:
>>> class Computer:
…   pass
Computer
Figure 7-­
1: Illustration of class inheritance
	328	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
This defines a class named Computer containing no attribute and no 
method, though it automatically inherits all the attributes and methods of the 
generic object class in the built-­
in module of Python. As mentioned before, 
the pass statement is simply a placeholder for everything needed to com­
plete the class definition. We can use the help statement to see that the class 

has been created, as shown below:
>>> help(Computer)
Help on class Computer in module __main__:
 
class Computer(builtins.object)
| Data descriptors defined here:
|
| __dict__
|   dictionary for instance variables (if defined)
|
| __weakref__
|   list of weak references to the object (if defined)
The builtins.object is a built-­
in class of Python from which all classes auto­
matically inherit by default. In OOP term, the class that inherits from another 
class is called a subclass of the other class, while the class being inherited 

from is called a superclass.
Formally in Python, if you are defining a class that needs to inherit from 
another class, you can put the superclass(es) in a pair of parentheses, as shown 
in the following example:
>>> class PC(Computer):
…   pass   # the pass statement does nothing, but it 
completes the class definition
We can check the result using the help statement, as shown below:
>>> help(PC)
Help on class PC in module __main__:
 
class PC(Computer)
| Method resolution order:
|   PC
|   Computer
	
Object-­
Oriented Programming with Python	
329
 https://doi.org/10.15215/remix/9781998944088.01
|   builtins.object
|
| Data descriptors inherited from Computer:
|
| __dict__
|   dictionary for instance variables (if defined)
|
| __weakref__
|   list of weak references to the object (if defined)
This shows that the class PC has been created, which is a subclass of Computer.
Although the Computer class contains nothing in its original definition, we 
can create an instance of the class, add attributes to the instance, and manipu­
late the attributes using some built-­
in functions. For example, we can use the 
setattr function to add an attribute called CPU to an instance of the Computer 
class, as shown below:
>>> c = Computer()   # to create an instance of the 
Computer class
>>> setattr(c, 'CPU', 'Intel i6800')
>>> c.CPU
'Intel i6800'
In the above example, Computer() is the constructor of class Computer. In 
Python, X() will be automatically the constructor of class X, but it calls a special 
method named __init__, which can be defined within the class to instantiate 
instances of the class. In our simplest definition of class Computer, we did not 
define the __init__ method, but it has been automatically inherited from class 
builtins.object.
Now we can use special attribute __dict__ of instance c of class Computer 
to check the attribute and value of object c, as shown below:
>>> print(c.__dict__)
{'CPU': 'intel i6800'}
As you can see, the c object has an attribute called CPU and its value intel 
i6800.
In addition to setattr, Python has a number of built-­
in functions available 
for class and object manipulation. These built-­
in functions are summarized 
in Table 7-­
1.
	330	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Table 7-­
1: Built-­
in functions for class and object manipulation
Built-­
in function
Operation
Coding example
getattr(o, attr)
Return the value of 
object o's attribute 
attr, same as o.attr
>>> getattr(math, 'sqrt')
<built-­
in function sqrt>
>>> getattr(math, 'e')
2.718281828459045
hasattr(o, attr)
Test if object o has 
attribute attr; return 
True if it does
>>> hasattr(math, 'e')
True
>>> hasattr(math, 'sqrt')
True
setattr(o, a, v)
Set/add an attribute 
a to object o, and 
assign value v to the 
attribute
>>> class student:
…   pass
…
>>> s1 = student()
>>> setattr(s1, 'name', 
'John')
>>> s1.name
'John'
delattr(o, a)
Delete attribute a 
from object o
>>> delattr(s1, 'name')
>>> hasattr(s1, 'name')
False
isinstance(o, c)
Return true if o is an 
instance of class c 
or a subclass of c
>>> class student:
…   pass
…
>>> s1 = student()
>>> isinstance(s1, student)
True
issubclass()
Return true if class c 
is a subclass of C
>>> class 
graduate(student):
…   pass
…
>>> issubclass(graduate, 
student)
True
repr(o)
Return string 
representation of 
object o
>>> repr(graduate)
"<class '__main__.
graduate'>"
The rest of this section describes in detail how to define classes in Python—­
in 
particular, how to define attributes and methods in a class definition. Your jour­
ney to learn OOP begins with modelling a small world, shapes, which include 
the circle, rectangle, and triangle.
	
Object-­
Oriented Programming with Python	
331
 https://doi.org/10.15215/remix/9781998944088.01
First, define an abstract class called shape, as shown in Table 7-­
2.
Table 7-­
2: Example of class definition with overriding
Code sample in Python interactive mode
1
"""
2
Modelling the world of shapes. First Python app with 
OOP.
3
"""
4
5
class Shape:
6
  """We design an abstract class for shape."""
7
  def circumference(self):
8
    """Method to be overridden."""
9
    pass
10
11
def area(self):
12
"""Method to be overridden."""
13
pass
14
15
class Circle(Shape):
16
  def __init__(self, radius):   # two underscores on 
each side
17
    self.radius = radius
18
19
  def circumference(self):   # this overrides the 
method defined in Shape
20
    return self.radius * 2 * 3.14
21
22
  def area(self):   # this overrides that defined in 
Shape
23
    return self.radius ** 2 * 3.14
24
25
c1 = Circle(35)
26
print(f"A circle with a radius of {c1.radius} has an 
area of {c1.area()},")
27
print(f"and the circumference of the circle is {c1.
circumference()}")
Output
A circle with a radius of 35 has an area of 3846.5,
and the circumference of the circle is 219.8
In the example above, __init__ is a reserved name for a special method in 
a class definition. It is called when creating new objects of the class. Please 
remember, however, that you need to use the name of the class when creating 
new instances of the class, as shown on line 25 of the example above.
It may have been noted that “self” appears in the list of arguments when 
defining the __init__ method and other methods of the class, but it is ignored in 

	332	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
the calls of all these methods. There is no explanation as to why it is ignored. 
In the definitions of all these methods, “self” is used to refer to the instance of 
the class. It is the same as “this” in other OOP languages such as C++ and Java, 
though “this” doesn’t appear in the list of formal arguments of any method 
definition.
Another detail worth noting when defining classes in Python is that there 
can be no explicit definition of any of the attributes, as is the case in C++ or 
Java. Instead, attributes are introduced within the definition of the __init__ 
method by assignment statements or by using the built-­
in function setattr(o, 
a, v), which are all the attributes of the particular instance created by the 
constructor of the class. Function setattr(o, a, v) sets the value of attribute a 
of object o to n, if o has attribute a; if not, it will add attribute a to o, then set 
its value to v.
Next, we define a class for a rectangle, as shown in Table 7-­
3.
Table 7-­
3: Example of subclass definition
Code sample in Python interactive mode
1
"""
2
Modelling the world of shapes. First Python app 
with OOP.
3
"""
4
5
class Shape:
6
  """We design an abstract class for shape."""
7
  def circumference(self):
8
    """Method to be overridden"""
9
    pass
10
11
  def area(self):
12
    """Method to be overridden"""
13
    pass
14
15
class Rectangular(Shape):
16
  def __init__(self, length, width):
17
    self._length = length
18
    self._width = width
19
20
  def circumference(self):
21
    return (self._length + self._width) * 2
22
23
  def area(self):
24
    return self._length * self._width
25
26
  def is_square(self):
	
Object-­
Oriented Programming with Python	
333
 https://doi.org/10.15215/remix/9781998944088.01
27
    return self._width == self._length
28
29
rt1 = Rectangular(35, 56)
30
31
print(f"The circumference of the rectangle is 
{rt1.circumference()}, and")
32
print(f"the area is {rt1.area()}")
33
print(f"Is the rectangle a square? {rt1.
is_square()}")
Output of the 
program
The circumference of the rectangle is 182, and
the area is 1960
Is the rectangle a square? False
Note that class Rectangular not only has overridden two methods of 
Shape but has also defined a new method named is_square() to test if the 
rectangular is a square.
Inheritance: Subclass and Superclass
If you want to inherit from other base classes when defining a new class in 
Python, you need to add all the base classes to the list of inheritances enclosed 
in a pair of parentheses, as shown below:
class myClass(base_1, base_2, base_3):
  pass
The new class will inherit all the attributes and methods from base_1, 
base_2, and base_3 and override the methods defined in the base classes.
In Python, all classes are a subclass of the built-­
in base object class and 
inherit all the properties and methods of object, even if object is not explicitly 
included in the inheritance list. So the following two statements will have the 
same effects:
In [ ]:
class myClassA:
  pass
dir(myClassA)
Out [ ]:
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', 
'__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', 
'__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_
ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 
'__weakref__']
Table 7-­
3: Example of subclass definition (continued)
	334	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
class myClassB(object):
  pass
dir(myClassB)
Out [ ]:
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', 
'__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', 
'__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_
ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 
'__weakref__']
As you can see, myClassA and myClassB both inherit from the base class 
object. However, in the list, some of the dunder names such as __le__ and __ge__ 
inherited from base class object are merely wrapper descriptors. If you want to 
make real use of these wrapper descriptors in your class, you will need to over­
ride them. Some inherited dunder methods can be used, but the values returned 
are not so useful. In particular, you will need to override the dunder methods 
__init__ __str__, and __repr__. The method __init__ is a dunder method used 

as constructor called internally by PVM whenever a new instance of a class needs 
to be created. The method __str__ is a dunder method called internally when­
ever an object of a class needs to be converted to a string, such as for printout. 
Finally, __repr__ is a dunder method called internally when an object needs to be 
converted to a representation for serialization—­
a process that converts a Python 
object into a byte stream that can be stored or transmitted.
Public, Private, and Protected Members of a Class
People familiar with other OO programming languages such as C++ and Java 
may be wondering how to declare and use public, private, and protected attrib­
utes in Python, as they are used to doing in other OO programming languages. 
Python, however, doesn’t differentiate attributes between public, private, and 
protected members. Instead, Python treats all attributes of a class as public. 
It is up to the programmers to decide whether a member should be public, 
private, or protected. To ensure that everyone reading the code understands 
the intention of the original coder/programmer, Python has a convention for 
naming protected members, private members, and public members: a name 
with a leading underscore _ is a protected member of the class in which it is 
defined, a name with a double underscore __ is a private member of the class 
in which it is defined, and all other names will be public.
According to the common principles of object-­
oriented programming, 
public members of a class can be seen and accessed from outside of the class 
or the instance of the class; protected members of a class can only be seen 
	
Object-­
Oriented Programming with Python	
335
 https://doi.org/10.15215/remix/9781998944088.01
and accessible within the class or a subclass of the class; private members can 
only be accessed within the class. In Python, however, the rule for protected 
members is not strictly enforced. As such, the following code will not raise 
any error or exception.
In [ ]:
class Student:
  def __init__(self, firstname, lastname):
    self._firstname = firstname
    self._lastname = lastname
s0 = Student('Jim', 'Carte')
print(s0._firstname, s0._lastname)
Out [ ]:
Jim Carte
In our example about shapes, _width and _length are protected attributes 
of the class, which should only be accessible within the class or its subclasses 
and should be hidden from the outside.
In contrast, the rule on private members, those with names prefixed with 
a double underscore __, is strictly enforced in Python. So if we change first­
name and lastname to private members, it will raise exceptions, as shown in 
the following example:
In [ ]:
class Student:
  def __init__(self, firstname, lastname):
    self.__firstname = firstname
    self.__lastname = lastname
s0 = Student('Jim', 'Carte')
setattr(Student, '_firstname', 'Richard')
print(s0.__firstname, s0.__lastname)
Out [ ]:
AttributeError Traceback (most recent call last)
<ipython-­
input-­
5-­
87cd9bc7801e> in <module>
  6 s0 = Student('Jim', 'Carte')
  7 setattr(Student, '_firstname', 'Richard')
-­
-­
-­
-­
> 8 print(s0.__firstname, s0.__lastname)
AttributeError: 'Student' object has no attribute '__firstname'
If you want to access the private members of a class from outside, the built-­
in 
functions setattr and getattr can be used to access both private and protected 
members of a class or its instance, as shown below:
	336	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
class Student:
  def __init__(self, firstname, lastname):
    self.__firstname = firstname
    self.__lastname = lastname
s0 = Student('Jim', 'Carte')
setattr(s0, '__firstname', 'Richard')
setattr(s0, '__lastname', 'Selot')
print(getattr(s0, '__firstname'), getattr(s0, '__lastname'))
Out [ ]:
Richard Selot
Class Methods
As we have seen, in Python, special method __init__ is used as a constructor 
of the class. People familiar with C++ or Java might be wondering if __init__ 
can be overloaded or defined multiple times in Python to make multiple con­
structors, because a class in C++ and Java can have two or more constructors 
with different signature. In Python, however, a class cannot have more than 
one __init__ effectively defined. If you define two or more __init__ within a 
class definition, only the last one will take effect.
So how can you create an instance of a class differently in Python if there 
can be only one constructor, the special __init__ method, in a class definition? 
The solution is to use the class method, as shown in the next example:
In [ ]:
class Graduate:
  def __init__(self, fullname):
    firstname, lastname = fullname.split(' ')
    self.firstname = firstname
    self.lastname = lastname
@classmethod # this decorator declaires a class method
def newGraduate(cls, firstname, lastname): # cls as 1st
    return cls(f'{firstname} {lastname}') # return an 
object
def __str__(self): # normal method
    return f'{self.firstname} {self.lastname}'
g0 = Graduate('James Gord') # __init__ is called to 
construct a new object
g1 = Graduate.newGraduate('John', 'Doe')
# newGraduate() is called to create a new object
print(g0) # __str__ is called to convert the object to 
a string
print(g1) # __str__ is called to convert the object to 
a string
Out [ ]:
James Gord
John Doe
	
Object-­
Oriented Programming with Python	
337
 https://doi.org/10.15215/remix/9781998944088.01
In the example above, decorator @classmethod is used to declare that 
method newGraduate() is a class method, which means that the first param­
eter refers to the class instead of an instance of the class, and the method is 
bound to the class and can be called through the class. A class method can be 

used to directly modify the structure of the class. For example, we can have a 

class method for Graduate class that sets the value of the class attribute 
at the beginning of a new year, say, 20210101. In this particular example 
above, however, class method newGraduate() is used as an alternate con­
structor of class Graduate, which takes first name and last name separately to 

instantiate an instance of Graduate.
When defining a class method, it is a convention to use cls as the name 
of the first parameter to refer to the class. Technically, however, it can be 
anything unique in the scope of a class definition, as long as you know it 
refers to the class. This is similar to “self” in definitions of regular methods, 
which is only the conventional name referring to the instance itself being 
instantiated.
Static Methods
Similar to the class method of a class, a static method can be called directly 
through the class. The difference is that in the definition of a static method, no 
parameter refers to the class nor to the instance itself. Its usefulness may be 
demonstrated by the example below, where we define a class called Convertor, 
and within the class definition, we define a number of static methods, each of 
which convert values from one unit to another:
In [ ]:
class Convertor:
  @staticmethod
  def kg2lb(w):
    return w * 2.20462
  @staticmethod
  def lb2kb(w):
    return w/2.20462
  @staticmethod
  def metre2feet(l):
    return l * 3.28084
  @staticmethod
  def feet2metre(l):
    return l / 3.28084
	338	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
  @staticmethod
  def C2F(d):
    return (d * 9 / 5) + 32
  @staticmethod
  def F2C(d):
    return (d -­
 32) * 5 / 9
  @staticmethod
  def acr2hec(a):
    return a * 0.404686
  @staticmethod
  def hec2arc(a):
    return a / 0.404686
print(Convertor.kg2lb(123))
print(Convertor.C2F(21))
Out [ ]:
271.16826
69.8
As you can see from the above example, the static methods can be called dir­
ectly through the class Convertor, without an instance. Defining a static method 
within a class is a way to add utility functions to the class so that it can be used 
without instantiating an object.
Class Attributes
As previously mentioned, in Python, you can define a class without explicitly 
declaring attributes of the class. However, Python does allow the explicit dec­
laration of attributes within a class definition. These attributes are called class 
attributes. Explicit declaration of an attribute within a class definition means 
that the attribute is declared outside of the __init__ method. In the following 
example, student_id is declared as a class attribute.
In [ ]:
class Graduate:
  student_id = 20201195 # student_id is a class 
attribute
  def __init__(self, fullname):
# self refers to the instance in normal method
    firstname, lastname = fullname.split(' ')
    self.f_name = firstname
    self.l_name = lastname
    self.__class__.student_id += 1
# self.__class__.student_id must be used to
# refer class attribute
	
Object-­
Oriented Programming with Python	
339
 https://doi.org/10.15215/remix/9781998944088.01
  @classmethod   # decorator
  def newGraduate(cls, firstname, lastname):
# cls refers to the class
    return cls(f'{firstname} {lastname}')
  def __str__(self):
    return f'{self.f_name} {self.l_name}, {self.
student_id}'
g0 = Graduate('James Gord')
print(g0)
# newGraduate() is called from class Graduate
g1 = Graduate.newGraduate('John', 'Doodle')
print(g1)
Out [ ]:
James Gord, 20201196
John Doodle, 20201197
From this example, you can see how a class attribute is used and shared 
among all the instances of the class. You can create student_id as a class attrib­
ute to dynamically track the student IDs allocated to new students—­
a new 
instance of the class Graduate. It starts from 20201195 and increases by one 
every time a new student is enrolled.
Note the dunder name __class__ used in the example. In Python, __class__ 
refers to the class of an object. So in the example above, self.__class__ refers to 
the class of object self—­
that is, Graduate. If you do not have __class__ between 
self and student_id but simply use self.student_id, student_id would become 
an attribute of each instance of the class, different from the class attribute, as 
demonstrated in the following example:
In [ ]:
class Graduate:
  student_id = 20201195
  def __init__(self, fullname):
    firstname, lastname = fullname.split(' ')
    self.f_name = firstname
    self.l_name = lastname
    self.student_id += 1
# self.student_id is an attribute of an individual object
  def __str__(self):   # self refers to the instance/
object
    return f'{self.f_name} {self.l_name}, {self.
student_id}'
g0 = Graduate('James Gord')
print(g0)
print(f'class attr student_id = {g0.__class__.student_id}')
g1 = Graduate('John Doodle')
print(g1)
Out [ ]:
James Gord, 20201196
class attribute student_id = 20201195
John Doodle, 20201196
	340	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
As you can see from the example above, although value 20201195 of 
class attribute student_id is used to calculate the student_id (20201195 
+ 1) when instantiating each instance of the class, the result 20201196 has 
no effect on the class attribute whose value remains to be 20201195. How 
did that work? Remember that assignment self.student_id += 1 is short for 

self.student_id = self.student_id. In this example, self.student_id on the right 
side of the assignment statement is resolved to be the class attribute according 
to the rule, whereas self.student_id on the left side of the assignment statement 
is an attribute of the object being instantiated. That is, the two self.student_id 
are two different variables.
Class attributes have different behaviours from static attributes in C++ or 
Java, although they do have certain things in common. In Python, class attrib­
utes are shared among all the objects of the class and can also be accessed 
directly from the class, without an instance of the class, as shown above.
7.3 Advanced Topics in OOP with Python
The previous section showed how classes can be defined and used in prob­
lem solving and system development. With what you learned in the previous 
section, you can certainly solve some problems in an object-­
oriented fashion. 
To be a good OOP programmer and system developer, it is necessary to learn 
at least some of the advanced features offered in Python for object-­
oriented 
programming.
Dunder Methods in Class Definition
Python has a list of names reserved for some special methods called dunder 
methods or magic methods. These special names have two prefix and suffix 
underscores in the name. The word dunder is short for “double under (under­
scores).” Most of these dunder methods are used for operator overloading. 
Examples of the dunder/magic methods that can be used for overloading 
operators are __add__ for addition, __sub__ for subtraction, __mul__ for multi­
plication, and __div__ for division.
Some dunder methods have specific meanings and effects when overloaded 
(defined in a user-­
defined class). These dunder methods include __init__, 
__new__, __call__, __len__, __repr__, __str__, and __getitem__.
In the previous section you saw how __init__ method is used as a constructor 
of class. The following sheds some light on the others.
	
Object-­
Oriented Programming with Python	
341
 https://doi.org/10.15215/remix/9781998944088.01
__CALL__
Dunder method __call__ can be used to make an object, an instance of class, 
callable, like a function. In the following example, a class is defined as Home, 
which has two attributes: size and value. In addition to __init__ as a con­
structor, a dunder function __call__ is defined, which turns object h1, an 
instance of class Home, into a callable function.
In [ ]:
class Home():
  def __init__(self, size, value):
    self.size = size
    self.value = value
  def __call__(self, check='average'):   # return the 
size, or value, or average
    if check == 'size':
      return self.size
    elif check == 'value':
      return self.value
    else:
      return self.value/self.size
h1 = Home(3270, 986500)
print(h1())   # using default value for the keyword 
argument
print(h1(check='size'))   # check the size of the home
print(h1(check='value'))   # check the value of the 
home
Out [ ]:
301.68195718654437
3270
986500
What can be done through dunder method __call__ can also be done through a 
normal method, say checking. The obvious benefit of using the dunder method 
__call__ is cleaner and neater code.
__NEW__
Dunder method __new__ is a method already defined in the object base class. It 
can be overridden to do something extra before the creation of a new instance 
of a class. Dunder method __ new__ itself doesn’t create or initialize an object 
for a class. Instead, it can check, for example, if a new object can be created. 
If the answer is yes, then it will call __init__ to do the actual work of creation 
and initialization, as shown in the following example:
	342	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
class TravelPlan():
  _places = dict()
  _step = 0
  def __new__(cls, newPlace):
    if newPlace in TravelPlan._places.values():
      print(f"{newPlace} is already in the plan!")
      return newPlace
    else:
      return super(TravelPlan, cls).__new__(cls)
  def __init__(self, newPlace):
    TravelPlan._places[TravelPlan._step] = newPlace
    print(f'{TravelPlan._places[TravelPlan._step]} is 
added.')
    TravelPlan._step += 1
  @staticmethod
  def printPlan():
    for pl in TravelPlan._places:
      print(f'Stop {pl + 1}: {TravelPlan._places[pl]}')
TravelPlan('Calgary')
TravelPlan('Toronto')
TravelPlan('Calgary')
TravelPlan.printPlan()
Out [ ]:
Calgary is added.
Toronto is added.
Calgary is already in the plan!
Stop 1: Calgary
Stop 2: Toronto
The example above makes a travel planning system by making a list of 
places to be visited. The __new__ method is defined to control the addition 

of a new city to the list. It checks whether the city has already been added to 
the plan and will not add the city if it is already on the list.
Note that we also defined and used two protected class attributes in the def­
inition of class TravelPlan. One is a dictionary storing the places in the plan and 
their order. We also used a static method so we can print out the entire plan when 
it is needed. Because the class attributes are shared among the instances of the 
class, changes to the class attributes will be retained, and at any time before 

the application is stopped, one can use the static method to print out the plan.
__STR__
Dunder method __str__can be used to implement the string representation of 
objects for a class so that it can be printed out by using the print statement. 
The method will be invoked when str() function is called to convert an object 

	
Object-­
Oriented Programming with Python	
343
 https://doi.org/10.15215/remix/9781998944088.01
of the class to a string. In our definition of class Graduate in our earlier example, 
the __str__ has been implemented to just return the full name of a student. 
You may, of course, choose to return whatever string you think would better 
represent the object for a given purpose.
__LEN__
Dunder method __len__ can be used to return the length of an object for a class. 
It is invoked when function len(o) is called on object o of the class. It is up to the 
programmer to decide how to measure the length, though. In our definition of 
class Graduate, we simply use the sum of the first name, last name, and id length.
__REPR__
Dunder method __repr__ can be used to return the object representation of a 
class instance so that, for example, the object can be saved to and retrieved from 
a file or database. An object representation can be in the form of a list, tuple, or 
dictionary, but it has to be returned as a string in order to be written to and read 
from a file or database. The __repr__ method will be invoked when function 
repr() is called on an object of the class. The following example extended from 
the definition of class Graduate shows how dunder methods __str__, __len__, 
and __repr__ can be defined and used.
In [ ]:
class Graduate:
  student_id = 20201195
  def __init__(self, fullname):
    firstname, lastname = fullname.split(' ')
    self.firstname = firstname
    self.lastname = lastname
    self.__class__.student_id += 1
  @classmethod
  def newGraduate(cl, firstname, lastname):
    return cl(f'{firstname} {lastname}')
  def __str__(self):
    return f'{self.firstname} {self.lastname}'
  def __len__(self):
    return len(self.firstname) + len(self.lastname) + 
len(str(self.student_id))
  def __repr__(self):
    return "{'firstname':" + self.firstname +", 
'lastname':" + self.lastname + ", 'student_id':" + 
str(self.student_id) + "}"
g0 = Graduate('James Gord'); print(g0, g0.student_id)
g1 = Graduate.newGraduate('John', 'Doodle')   # 
newGraduate() is called from class Graduate
print(g1, g1.student_id); print(len(g0)); 
print(str(repr(g1)))
	344	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Out [ ]:
James Gord 20201196
John Doodle 20201197
17
{'firstname':John, 'lastname':Doodle, 'student_id':20201197}
__GETITEM__ AND __SETITEM__
These two methods are used to turn a class into an indexable container object. 
__getitem__ is called to implement the evaluation of self[key] whereas __
setitem__ is called to implement the assignment to self[key].
__DELITEM__
This is called to implement the deletion of self[key].
__MISSING__
This is called by dict.__getitem__() to implement self[key] for dict subclasses 
when the key is not in the dictionary.
__ITER__
This is called when an iterator is required for a container.
__REVERSED__
This can be implemented and called by the reversed() built-­
in function to 
implement a reverse iteration.
__CONTAIN__
This is called to implement membership test operators. It should return True 
if the item is in self and False if it is not.
__DELETE__
This is called to delete the attribute on an instance of the owner class.
Tables 7-­
4, 7-­
5, 7-­
6, and 7-­
7 show a comprehensive list of dunder methods 
and their respective operators that can be overridden by programmers when 
defining new classes.
Table 7-­
4: Binary operators
Overridden operator
Dunder method
+
object.__add__(self, other)
-­
object.__sub__(self, other)
*
object.__mul__(self, other)
	
Object-­
Oriented Programming with Python	
345
 https://doi.org/10.15215/remix/9781998944088.01
Overridden operator
Dunder method
//
object.__floordiv__(self, other)
/
object.__truediv__(self, other)
%
object.__mod__(self, other)
**
object.__pow__(self, other[, modulo])
<<
object.__lshift__(self, other)
>>
object.__rshift__(self, other)
&
object.__and__(self, other)
^
object.__xor__(self, other)
|
object.__or__(self, other)
Table 7-­
5: Augmented assignment operators
Overridden operator
Dunder method
+=
object.__iadd__(self, other)
-­
=
object.__isub__(self, other)
*=
object.__imul__(self, other)
/=
object.__idiv__(self, other)
//=
object.__ifloordiv__(self, other)
%=
object.__imod__(self, other)
**=
object.__ipow__(self, other[, modulo])
<<=
object.__ilshift__(self, other)
>>=
object.__irshift__(self, other)
&=
object.__iand__(self, other)
^=
object.__ixor__(self, other)
|=
object.__ior__(self, other)
Table 7-­
4: Binary operators (continued)
	346	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Table 7-­
6: Unary operators
Overridden operator
Dunder method
-­
object.__neg__(self)
+
object.__pos__(self)
abs()
object.__abs__(self)
~
object.__invert__(self)
complex()
object.__complex__(self)
int()
object.__int__(self)
long()
object.__long__(self)
float()
object.__float__(self)
oct()
object.__oct__(self)
hex()
object.__hex__(self)
Table 7-­
7: Comparison operators
Operator
Dunder method
<
object.__lt__(self, other)
<=
object.__le__(self, other)
==
object.__eq__(self, other)
!=
object.__ne__(self, other)
>=
object.__ge__(self, other)
>
object.__gt__(self, other)
Using Class as Decorator
In Chapter 6, we saw how decorators can be used as powerful and useful tools 
that wrap one function with another to change the behaviour of the wrapped 
function without modifying the wrapped function. In this section, we show how 
to use classes as decorators to modify the behaviour of an existing function.
As we know, a class has two types of members. One is attributes and the 
other is methods. Our first example uses the methods of a class as a decorator, 
as shown below:
	
Object-­
Oriented Programming with Python	
347
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
class MyClass:
  def __init__(self, decorated):
    self.func = decorated
  def __call__(self, *args, **kwargs):   # variable-­
length arguments
    print("More code can be added before calling the 
decorated function")
    self.func(*args, **kwargs)   # call the decorated 
function
    print("More code can be added after calling the 
decorated function")
# use MyClass as a decorator
@MyClass
def myFunc(name, message ='Welcome to COMP218'):
  print(f"Hello {name}, {message}")
myFunc("Joe", "Welcome to the world of Python")
Out [ ]:
More code can be added before calling the decorated function
Hello Joe, Welcome to the world of Python
More code can be added after calling the decorated function
As shown in the example above, the __init__ method is used to pass a func­
tion to be decorated or wrapped to the class, and the __call__ method is used 
to actually wrap the real function passed to the class.
We learned in Chapter 6 how to calculate the actual execution time of a 
program using a function as a decorator. The same can be done with a class 
as a decorator when we time finding all the primes within a given range using 
an algorithm called “sieve of Eratosthenes.”
In [ ]:
from time import time
class ProgramTimer:
     def __init__(self, func):
          self.function = func
     def __call__(self, *args, **kwargs):
          program_start_time = time()
          result = self.function(*args, **kwargs)
          program_end_time = time()
          print(f"Execution of {self.function} took
            {program_end_time- program_start_time} seconds"
          return result
	348	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
# add a decorator to the class
def sieving(n, l):
  """Remove all n's multiples from list l."""
  return list(filter(lambda m: m == n or m%n != 0, l))
def i_list(max_l_int):
  """Create initial list."""
  l0 = [2] + list(range(3, max_l_int, 2))
  return l0
@ProgramTimer
def primesBySieving(upper_bound):
  nl = i_list(upper_bound)
  sl = nl[1: len(nl) // 2 + 1]   # initial sieve
  flag = True
  while flag:
    d = sl[0]
    nl = sieving(d, nl)
    sl = sl[1:]
    if d**2 > nl[-­
1]:
      flag = False
      return nl
ub = 2**19
pl = primesBySieving(ub)
print(f"{len(pl)} prime numbers have been found between 
2 and {ub}")
Out [ ]:
Execution of <function primesBySieving at 0x0000014363F8AEE8> took 
3.1760756969451904 seconds
43390 prime numbers have been found between 2 and 524288
In the above examples, we used class to decorate a function. Within the class, 
a special dunder function __call__ is used to execute the decorated function 
and calculate the time spent on the execution of the function that finds all the 
prime numbers between 2 and 32768 (2 ** 15).
Built-­
In Property() Function and Property Decorator
Python has a special built-­
in function named property, as mentioned in Chap­
ter 2. It can be called directly to create an attribute of a class with potentially 

added setter, getter, and deleter methods and documentation. In this case, the 
function can either be called within a class definition or outside a class defin­
ition while adding the created property to a class or object of a class.
A call of the property function may take none or any combination of the 
four optional keyword arguments, as shown below:
	
Object-­
Oriented Programming with Python	
349
 https://doi.org/10.15215/remix/9781998944088.01
Property_name = property(fget=None, fset=None, fdel=None, 
doc=None)
# fget, fset, and fdel take functions only
firstname = property()   # call of the property function 
with default
lastname = property(set_lastname, get_lastname, 
delete_lastname)
# call with three function names
firstname.setter(set_firstname)   # add a set function to 
property firstname. set_firstname must be a function
firstname.getter(get_firstname)
# add a get function to property firstname. get_firstname 
must be a function
If property() function is called with no argument, you can add a setter 
function, getter function, and/or deleter function later by calling the setter, 
getter. and deleter methods.
The following example demonstrates how the built-­
in property function is 
used to add a property/attribute to a class:
In [ ]:
class Employee:
  def __init__(self, firstname, lastname):
    self.firstname = firstname
    self.lastname = lastname
  def setFullname(self, fullname):
    names = fullname.split()
    self.firstname = names[0]
    self.lastname = names[1]
  def getFullname(self):
    return f'{self.firstname} {self.lastname}'
  fullname = property(getFullname, setFullname)
e1 = Employee('Jack', 'Smith')
print(e1.fullname)
e1.fullname = 'John Doe'
print(e1.fullname)
print(f'{e1.lastname}, {e1.firstname}')
Out [ ]:
Jack Smith
John Doe
Doe, John
	350	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
A built-­
in property function can also be used as a decorator within a class def­
inition to make a method name to be used as an attribute/property of the class.
Similar to the example above, suppose we want to define a class named Stu­
dent for a management system at a university. The attributes should include the 
first name, last name, full name, email address, and some other information. 
We know that a full name is made of a first name and a last name and that the 
university often has a rule of assigning an email address based on the first name 
and last name. If we define full name and email address as ordinary attributes, 
the dependencies would not be reflected because a change to the first name 
or last name of a student will not automatically result in the change to the full 
name and email address. Using property() function as a decorator can nicely 
solve the problem, as shown in the following example:
In [ ]:
class Student:
  def __init__(self, firstname, lastname):
    self.firstname = firstname
    self.lastname = lastname
  @property
  def fullname(self):
    return f"{self.firstname} {self.lastname}"
  @property
  def emailaddress(self):
    return f"{self.firstname}.{self.lastname}@
globalemail.com"
s0 = Student('John', 'Doe')
print(f'First name: {s0.firstname}')
print(f'Last name: {s0.lastname}')
print(f'Full name: {s0.fullname}')
print(f'Email address: {s0.emailaddress}')
s0.lastname = 'Smith'
print(f'First name: {s0.firstname}')
print(f'Last name: {s0.lastname}')
print(f'Full name: {s0.fullname}')
print(f'Email address: {s0.emailaddress}')
Out [ ]:
First name: John
Last name: Doe
Full name: John Doe
Email address:​
John​
.Doe​
@globalemail​
.com
First name: John
Last name: Smith
Full name: John Smith
Email address:​
John​
.Smith​
@globalemail​
.com
	
Object-­
Oriented Programming with Python	
351
 https://doi.org/10.15215/remix/9781998944088.01
In the example above, we use built-­
in property() function as a decorator to 
decorate method fullname() and emailaddress(). By doing that, the function 
name can be used as a property or attribute of the object, but access to the 
attribute invokes a call to the function so that an updated full name or email 
address is retrieved. In the example, when the last name is changed to Smith, 
the full name is automatically changed to John Smith, and the email address 
is automatically changed to John​
.Smith​
@globalemail​
.com.
Using decorator, we can also further add setter, getter, and deleter methods 
to the property fullname, as shown below:
In [ ]:
class Student:
  def __init__(self, firstname, lastname):
    self.firstname = firstname
    self.lastname = lastname
  @property
  def fullname(self):
    return f"{self.firstname} {self.lastname}"
  @fullname.setter
  def fullname(self, fullname):
    """
    Set the value of fullname. However,
    you cannot do self.fullname = fullname
    because fullname is not true attribute.
    """
    names = fullname.split()
    self.firstname = names[0]
    self.lastname = names[1]
s0 = Student('John', 'Doe')
print(s0.fullname)
s0.fullname = 'Kevin Smith'
print(s0.fullname)
Out [ ]:
John Doe
Kevin Smith
Note that using a property decorator can make a method to be used like an 
attribute/property without the need to allocate memory space to keep the value 
of the attribute. As such, you cannot assign a value directly to such an attribute.
	352	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Creating a New Class Dynamically and Modify a Defined Class or 
Instance
In Python, you have the freedom to make changes to an already defined class 
or an instance of the class, and you can even create a new class dynamically.
To create a new class dynamically in your Python program, a built-­
in func­
tion type is used, as shown below:
In [ ]:
Shape = type('Shape', (object,), dict(points=[(1,1)]))
s0=Shape()
s1=Shape()
print(f's0.points = {s0.points}')
print(f's1.points = {s1.points}')
s0.points += [(12, 23)]   # add a new point to s0
print(f's0.points = {s0.points}')
print(f's1.points = {s1.points}')
s1.points = [(35, 67)]   # this adds an attribute point 
to s1
print(f's0.points = {s0.points}')
print(f's1.points = {s1.points}')
Out [ ]:
s0.points = [(1, 1)]
s1.points = [(1, 1)]
s0.points = [(1, 1), (12, 23)]
s1.points = [(1, 1), (12, 23)]
s0.points = [(1, 1), (12, 23)]
s1.points = [(35, 67)]
In the example above, we dynamically create a new class called Shape and set 
one attribute called points, which is a list of points initially assigned one point 
(1, 1). We then create two instances of the Shape class, s0 and s1, in the same 
way that we do with other classes defined with the class statement. We then even 
added one more point to s0. Because attributes added to the class with built-­
in 
function type() are automatically treated as class attributes and shared by all 
instances of the class, changes to points of s0 are also reflected in the value of 
points of s1. However, the third-­
to-­
last statement above adds an attribute with 
the same name as the class attribute to object s1, which only belongs to s1. As 
a result, a change to this attribute of s1 has no effect on s0.
As we have already seen above, with a defined class or an instance of a 
defined class, you can modify the class or instance by adding or deleting attrib­
utes to/from the class or instance. Moreover, you can even add or delete a new 
method dynamically to or from a class or instance of a class.
One way to add an attribute to an object, either a class or an instance of a class, 
is to directly name a new attribute and assign a value in the same way that we 
	
Object-­
Oriented Programming with Python	
353
 https://doi.org/10.15215/remix/9781998944088.01
introduce a new variable to a program. For example, we can add a new attribute 
called shape_type to s0 instantiated above with the first statement of code below:
In [ ]:
s0.shape_type = 'line'
print(f'The shape is a {s0.shape_type}, with points 
{s0.points}')
Out [ ]:
The shape is a line, with points [(1, 1), (12, 23)]
The second statement has proved that a new attribute shape_type has been 
added to object s0, and now this particular instance of Shape is called line.
A new attribute can also be added by using the built-­
in function setattr(). 

To add the shape_type attribute to s0 with setattr(), run the following statement:
In [ ]:
setattr(s0, 'shape_type', 'rectangle')
# this will only add attribute shape_type to object s0
s0.shape_type
Out [ ]:
'rectangle'
An attribute can also be deleted from an object using the built-­
in function 
delattr(). When you want to add or delete an attribute, but you are not sure if the 
attribute exits, you can use built-­
in function hasattr() to check, as shown below:
In [ ]:
print(hasattr(s0, 'shape_type'))
delattr(s0, 'shape_type')
print(hasattr(s0, 'shape_type'))
Out [ ]:
True
False
Remember, attributes added to an instance of a class will not be seen by 
other instances of the same class. If we want to make the shape_type attribute 
visible to all instances of the Shape class because every shape should have a 

shape type, we need to add the shape_type attribute to the class to make it 

a class attribute. This is done with the following statement:
Shape.shape_type = 'point'
From now on, all instances of the Shape class will have an attribute called 
shape_type, as shown in the examples below:
	354	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
Shape.shape_type = 'point'
print(f's0.shape_type = {s0.shape_type}')
print(f's1.shape_type = {s1.shape_type}')
Out [ ]:
s0.shape_type = point
s1.shape_type = point
As you may have noted, the attribute shape_type and its value, added to the 
Shape class, have been propagated to both s0 and s1 because the shape_type 
attribute was added as a class attribute. By comparison, the attribute later added 
to an individual instance of the class is the attribute of that instance only. This 
is shown in the following code sample:
In [ ]:
print(s0.points, s1.points)
s0.weight = 1
print(s0.weight)
hasattr(s1, 'weight')
Out [ ]:
[(1, 1), (12, 23), (2, 3), (2, 3)] [(1, 1), (12, 23), (2, 3), (2, 3)]
1
False
The example shows that the new attribute weight was only added to object 
s0, and s1 does not have the attribute. Again, if you want the weight attribute 
and its value to be shared by all instances of the class, you have to add the 
attribute to the class directly, as shown below:
In [ ]:
Shape.weight = 1
print('s0 weight = ', s0.weight)
print('s1 weight = ', s1.weight)
Out [ ]:
s0 weight = 1
s1 weight = 1
How can you add a new method to an already defined class? You can do this 
in almost the same way as you would add new attributes to a class or instance 
of a class, as shown in the following example:
In [ ]:
def print_points(self):   # we define a function with a 
parameter
  for i, p in enumerate(self.points):
    print(f'point {i} at {p}')
Shape.print_points = print_points   # we now attach the 
function
s0.print_points()   # the method is called on s0
	
Object-­
Oriented Programming with Python	
355
 https://doi.org/10.15215/remix/9781998944088.01
Out [ ]:
Point 1 at (1, 1)
Point 2 at (12, 23)
This provides programmers with so much power, as they can create new 
classes and modify all aspects of classes dynamically. For example, we know 
we can only define one __init__() in a class definition, so we only have one 
constructor to use when creating new instances of the class. By attaching a 
different properly defined method to the __init__ attribute, we are now able 
to construct a new instance of a class in whatever way we want, as shown in 
the following example:
In [ ]:
def print_shape(self):
  print(f'A {self.shape_type} has {len(self.points)} 
point(s):')
  for i, p in enumerate(self.points, 1):
    print(f'Point {i} at {p}')
Shape.print_shape = print_shape
def c1(self, *points):   # a point
  self.points = list(points)
  self.shape_type = 'point'
def c2(self, *points):   # a line, a shape made of two 
points
  self.points = list(points)
  self.shape_type = 'line'
def c3(self, *points):   # a triangle, a shape made of 
three points
  self.points = list(points)
  self.shape_type = 'triangle'
Shape.__init__= c1   # constructor for one point
p1 = Shape((3,5))
Shape.__init__= c2 # constructor for a line
l1 = Shape((3,5), (12, 35))
Shape.__init__= c3   # constructor for a triangle
t1 = Shape((3,5), (12, 35), (26, 87))
print(p1.print_shape())
print(l1.print_shape())
print(t1.print_shape())
	356	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Out [ ]:
A point has 1 point(s):
Point 1 at (3, 5)
None
A line has 2 point(s):
Point 1 at (3, 5)
Point 2 at (12, 35)
None
A triangle has 3 point(s):
Point 1 at (3, 5)
Point 2 at (12, 35)
Point 3 at (26, 87)
None
In this example, we defined three methods to use as constructors or 
initiators for the shape class we previously defined. Constructor c1 is for 
creating point objects, c2 is for creating line objects, and c3 is for creating 
triangle objects. We then attach each method to the __init__ attribute of the 
shape class to create the shape object we want. We also defined a method 
called print_shape() for the class, just to show the results of the three different 
constructors.
As you may imagine, however, the consequence of modifying instances of 
a class is that different instances of the same class may have totally different 
attributes. In an extreme case, two instances of the same class can have totally 
different attributes. This is something you need to keep in mind when enjoying 
the freedom offered by Python.
Keeping Objects in Permanent Storage
As mentioned previously, classes and objects are a very powerful way to model 
the world. Hence, in a program, classes and objects can be used to represent 
information and knowledge for real-­
world application. You do not want to 
lose that information and knowledge whenever you shut down the computer. 
Instead, you want to keep this information and knowledge in permanent stor­
age and reuse it when you need it. For example, you may have developed a 
management system using the Student class, defined earlier in this section, 
and created a number of objects of the Student class containing information 
about these students. You need to reuse the information about these students 
contained in those student objects next time you turn on the computer and run 
the system. How can you do that?
Previously, we discussed defining the __repr__ dunder method, which 
returns a string representation of an object that can be in the form of list, tuple, 
or dictionary, as shown in the following example:
	
Object-­
Oriented Programming with Python	
357
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
class Employee:
  age : int = 20
  salary : float = 30000
  def __init__(self, firstname, lastname):
    self.firstname = firstname
    self.lastname = lastname
  def __str__(self):
    return f'{self.firstname} {self.lastname}, {self.
age}, {self.salary}'
  def __repr__(self):
    rdict = {'firstname':self.
firstname,'lastname':self.lastname, 'age':self.age, 
'salary':self.salary}
    return f"{rdict}"
e1 = Employee('Jack', 'Smith')
e1.age =37
e1.salary = 56900
e2 = Employee('Jone', 'Doe')
print(e1)   # this will call the __str__ method
e2 # this will call the __repr__ method
Out [ ]:
Jack Smith, 37, 56900
{'firstname': 'Jone', 'lastname': 'Doe', 'age': 20, 'salary': 30000}
With the __repr__() method for a class, you can save the representation of 
these objects into a file. To use the object representations stored in a file, you 
will need to write another function/method to pick up the information from 
each object representation and add it to its respective object. The two processes 
must work together to ensure that objects can be correctly restored from files. 
Neither process is easy. Fortunately, there is a Python module called pickle 
already developed just for this purpose.
In formal terms, saving data, especially complex data such as objects in OOP, 
in permanent storage is called serialization, whereas restoring data from perma­
nent storage back to its original form in programs is called deserialization. 
The pickle module is a library implemented for serializing and deserializing 
objects in Python. The pickling/serializing process converts objects with hier­
archical structure into a byte stream ready to save on a binary file, send across 
a network such as the internet, or store in a database, whereas the unpickling/
deserializing process does the reverse: it converts a byte stream from a binary 
file or database, or received from a network, back into the object hierarchy.
	358	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
There are some good sections and documents on the internet that explain 
how to use the pickle module for your Python programming needs. When you 
do need to use it, be aware of the following:
	
1.	 Unpickling with the pickle module is not secure. Unpickling objects from 
unknown and untrusted sources can be dangerous because harmful 
executable code may be deserialized into your computer memory.
	
2.	 Not all objects can be pickled. You need to know what data types 
and objects can be pickled before you pickle them. Pickling 
unpicklable objects will raise exception.
Chapter Summary
•	 Object-­
oriented programming is an important approach to object 
modelling and programming.
•	 Abstraction, information hiding, and inheritance are important 
concepts and principles in OOP.
•	 New classes can be defined with the class statement.
•	 A class contains attributes/properties and methods.
•	 In Python, there are attributes called class attributes, which can have 
default values.
•	 The __init__ method is called upon when instantiating new instances of 
classes.
•	 Except for class attributes, attributes of individual objects of a class 
don’t need to be explicitly declared in a class definition.
•	 Instead, attributes of a class are introduced in the definition of 
the __init__ method.
•	 In Python, each class can only have one constructor for the initializing 
instance of the class. That means that you can define only one __init__ 
method within a class.
•	 Methods of a class are defined the same way as functions, except that the 
first parameter of a method definition needs to be self, which refers to 
the object, an instance of the class on which the method is being called.
•	 There are methods called class methods in Python.
•	 There are also methods called static methods in Python class definition.
•	 A number of dunder methods can be defined in a class to achieve neat 
and powerful programming effects.
•	 Some dunder methods can be redefined in a class to mimic arithmetic 
operators.
	
Object-­
Oriented Programming with Python	
359
 https://doi.org/10.15215/remix/9781998944088.01
•	 Some important and interesting dunder methods include __repr__, 
__init__, __call__, __new__, and __len__.
•	 Class can also be used as a decorator of a function/method.
•	 The built-­
in function property() has two interesting uses: one is to 
attach specific getter, setter, and deleter functions to a property/
attribute of an object, and the other is to use it as a decorator—­
to create 
the name of a method to be used as a property/attribute name.
Exercises
	
1.	 Run the following code in a cell of one of the Jupyter Notebooks 
created for the chapter and answer the questions below:
class myClassB(object):
    pass
 
print(myClassB.__dict__)
dir(myClassB)
	
a.	 What does each statement do?
	
b.	 What is the output from print(myClassB.__dict__) statement?
	
c.	 What does dir(myClassB) return?
	
d.	 Python dir() function returns a list of the attributes and methods of 
any object. In the code above, no attribute or method is defined in 
the definition of class myClassB. Why does the list returned from 
dir(myClassB) have so many items in it? Find out and explain what 
each item is.
	
2.	 Mentally run the code below and write down the output of the program:
class Employee:
    def __init__(self, firstname, lastname):
         self.firstname = firstname
         self.lastname = lastname
 
    def setFullname(self, fullname):
         names = fullname.split()
         self.firstname = names[0]
         self.lastname = names[1]
 
    def getFullname(self):
	360	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
         return f'{self.firstname} {self.lastname}'
 
 fullname = property(getFullname, setFullname)
 
e1 = Employee('Jack', 'Smith')
print(e1.fullname)
e2 = e1
e2.fullname = 'John Doe'
print(e2.fullname)
	
3.	 For the Employee class defined in Exercise 2, define method __str__() 
so that the statement print(e1) will display the full name of the 
employee.
	
4.	 For the Employee class defined below, define setter and getter 
methods for attribute age and salary, respectively.
class Employee:
    age : int = 20
    salary : float = 30000
    def __init__(self, firstname, lastname):
         self.firstname = firstname
         self.lastname = lastname
	
5.	 For the Employee class defined in Exercise 4, define method 
__repr__() to return a dictionary whose item is a pair of that includes 
the attribute name and its value, such as 'firstname': 'John'.
	
6.	 Define a class named Quiz_question that models multiple-­
choice 
questions, including the correct answers. In addition to a constructor—­

the __init__ method to construct the objects of the class—­
there should 
be other methods allowing the user to change the description of 
the question, the individual choices, and the correct answers.
	
7.	 If we allow the number of choices to vary for the multiple-­
choice 
questions modelled by the Quiz_question class defined for Exercise 6, 
what changes need to be made to the Quiz_question class?
	
8.	 Define a class named Quiz that uses the Quiz_question class defined 
above to model a quiz that contains a number of quiz questions. It 
should have methods for a user to create a quiz, to add quiz questions 
to the quiz, to display a list of all quiz questions in a quiz for review, 
and to execute a quiz on a user and calculate the score.
	
Object-­
Oriented Programming with Python	
361
 https://doi.org/10.15215/remix/9781998944088.01
Project
	
1.	 Using the Quiz_question and Quiz classes you developed in Exercises 7 
and 8 above, develop a terminal-­
based quiz system that will allow the 
user to do the following:
•	 Create a quiz.
•	 Select a quiz and add new quiz questions.
•	 Select a quiz and preview all the quiz questions.
•	 Select a quiz and execute the quiz by presenting the quiz 
questions one by one.
•	 At the end of the quiz, calculate the user’s score as a percentage 
and show the correct answers to incorrectly answered questions. 
The quiz questions should be displayed to the user one by one 
during the quiz.
This page intentionally left blank
 https://doi.org/10.15215/remix/9781998944088.01
Chapter 8
Modules and Packages
Divide-­
and-­
conquer is a fundamental but effective strategy in problem solv­
ing as well as system design and development. This is because big problems 
can often be divided into smaller problems that can be easily solved or have 
already been solved, and large systems can often be made of smaller ones that 
can be easily created or are already readily available. Not only that, but the 
divide-­
and-­
conquer method also results in easier system maintenance, better 
quality insurance, quicker error detection and correction, and better reusability.
In Chapter 6, we learned how functions can be used in problem solving, 
and in Chapter 7, we studied object-­
oriented programming and learned how 
classes and objects can be used in system development and to solve problems. 
In computing, both functions and objects are common programming technol­
ogies that implement divide-­
and-­
conquer strategies.
In this chapter, we will study modules and packages that can also be used 
to implement the divide-­
and-­
conquer strategy in programming. In this way, 
we will learn how to create and use modules in programming and software 
development. We will also study some Python modules and packages that are 
readily available and often needed to solve problems and develop computer 
applications.
Learning Objectives
After completing this chapter, you should be able to
•	 describe modules.
•	 explain what packages are, what files are required, and how they are 
structured in a file system.
•	 import and use modules already in the Python programming/
development environment.
	364	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
•	 import and use specific parts from a module or specific modules from 
a package.
•	 explain the functionalities of some standard and widely used modules, 
and use them comfortably in programming.
•	 write and use your own modules and packages.
8.1 Creating Modules and Packages
As mentioned in previous sections, a module can be just a Python script file 
defining functions, classes, and other program constructs such as variables 
and constants. The following is an example of a Python module:
Code sample in VS Code IDE
1
"""
2
The module in this file defines some functions often used 
in calculations related to circles
3
4
Author: John Doe
5
Date: March 30, 2019
6
Version: 1.0
7
"""
8
9
10
PAI = 3.1415926
11
12
13
def area(r):
14
  """Calculate the area of a circle with radius r."""
15
  return PAI * r ** 2   # calculate the area
16
17
18
def circumference(r):
19
  """Calculate the circumference of a circle with radius 
r."""
20
  return 2 * PAI * r
21
22
The file can then be imported into a Python program and used as a module, 
as shown below:
In [ ]:
import circle
print(f'The area of a circle with a radius of 12 is 
{circle.area(12)}')
Out [ ]:
The area of a circle with a radius of 12 is 452.3893344
	
Modules and Packages	
365
 https://doi.org/10.15215/remix/9781998944088.01
How do you create a module or package and publish it at https://​
pypi​
.org/ 
for the Python community at large so that it can be found and installed with 
the pip command?
Suppose you want to create a package for developing e-learning applications. 
You would need to take the following steps to develop the package to make it 
available for the others in the Python community:
	
1.	 First, create a directory called mypackages, which will contain all the 
packages and modules that you will develop for yourself or the Python 
community at large.
	
2.	 Suppose you would like the package to be called elearn. You first need 
to check to see if the name has been used by others to name any top-­
level module or package published at http://​
pypi​
.python​
.org.
	
3.	 Under the mypackages directory, create a directory named elearn, 
which will contain everything for your elearn package or module.
	
4.	 Under this elearn directory, you can create Python script files (.py) 
and other subdirectories under which you may have other packages or 
modules.
	
5.	 To distinguish this elearn directory from other ordinary directories of 
the file system so that it can be searchable through a Python interpreter, 
create a special file called ​
_​
_init​
_​
_​
.py right under the elearn directory. 
The ​
_​
_init​
_​
_​
.py file should contain all the names and objects defined 
in the package or module, either directly or indirectly (by importing 
individual names and objects from each of the other files). The must-­
have ​
_​
_init​
_​
_​
.py file is the entry point of each package or module.
	
6.	 Under the mypackages directory, write a special Python script file 
called setup​
.py, which imports a special module called setuptools 
and calls the setup function to prepare the package to be sent to the 
repository. The following is an example of the setup​
.py file.
import setuptools
 
setup(name = 'elearn',
version = '1.0beta',
description = 'A package for developing elearn 
applications',
url = 'http://​
github​
.com/​
AU​
.CA/​
elearn',
author = 'SCIS Athabasca',
author_email = 'scis​
@athabascau​
.ca',
license = 'FSF free software foundation',
	366	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
packages = ['elearn'],
zip_safe = False)
	
7.	 If you are not really ready to submit the package to the repository but 
would rather test it or just want to use it by yourself, you can install the 
package locally so that it can be found with the import statement. The 
following is the command to be used to install the package when your 
current working directory is mypackages:
$ pip install .
	
8.	 To publish your elearn package, you need to
	
a.	 Register the package with PyPi so that the online repository will 
know about your package and create an entry-­
point link to the 
elearn package at GitHub, as specified in the setup​
.py file.
	
b.	 Create a single zip file that contains all Python script files.
	
c.	 Upload the zip file to PYPI repository.
By running the following command also under mypackages directory:
$ python setup​
.py register sdist upload
Upon completing the above steps, anyone on the internet will be able to install 
and use your elearn library to develop elearn applications using the following 
command:
$ pip install elearn
Please note that for your package to be available in a GitHub repository so 
that the link used in your entry at PYPI is valid, you will need to create or sign 
into an account with GitHub and do the following:
	
1.	 Create the project within your account at GitHub
	
2.	 Install Git on your computer and use the commands to manually 
synchronize your work on your computer with GitHub
VS Code IDE can work with Git and GitHub through respective GitHub exten­
sions that can be downloaded and installed in VS Code so that your project in 
VS can be easily synchronized with GitHub.
	
Modules and Packages	
367
 https://doi.org/10.15215/remix/9781998944088.01
8.2 Using Modules and Packages
To use a module, we first import it, as shown in the following example:
Code sample in Python interactive mode
1
2
import circle
3
4
radius = float(input("Tell me the radius:"))
5
6
print(f"The area of a circle with the radius 
{radius} is {circle.area(radius)}")
7
print(f"The circumference of a circle with the 
radius {radius} is {circle.circumference(radius)}")
The result
Tell me the radius: 12.3
The area of a circle with the radius 12.3 is 475.2915444540001
The circumference of a circle with the radius 12.3 is 77.28317796
When importing a module, you can also give the module an alias to use, 
especially if the original name is too long or hard to remember. In the above 
code sample, the import statement import circle can be changed to ci, as in 
the following:
>>> import circle as ci
Then in the program file, you can use ci in place of circle, as shown below:
>>> print(f"The area of a circle with the radius {radius} 
is {ci.area(radius)}")
When designing and coding a system, you may create and use as many 
modules as needed, but do so wisely and do not make a simple system too 
complicated. Managing too many unnecessary modules and files will consume 
time and resources as well, especially since many Python modules have already 
been developed by the great Python community for almost every application 
domain you can think of. In most cases, all you need is to know is what modules 
are available out there and what each module does, even if you do not want to 
learn about the details now.
In general, the import statement may take one of the following forms.
	368	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
IMPORT <THE NAME OF THE MODULE>
This is the simplest form, although you do need to know what the module has 
defined and know exactly what the name is, which is just the file name without 
the extension py.
IMPORT <THE NAME OF THE MODULE> AS <SIMPLER ALIAS FOR 
THE MODULE NAME>
Sometimes, the name of a module can be long and hard to remember, and giving 
the module an alias would make programming more efficient. For example, 
there is a module for mathematical plotting called matplotlib if you give an 
alias to the module when importing it as follows:
import matplotlib as mpl
A name such as o defined in the module can then be referred to using mpl.o, 
which is much simpler than matplotlib.o.
FROM <MODULE/PACKAGE NAME> IMPORT <NAME OF OBJECT 
OR MODULE>
When importing from a module, you can import a specific name you want to use 
instead of the entire module. For example, a mathematical module may have 
defined a number of mathematical constants such as PI and E. You may import 
only the one you want to use in your program.
As previously mentioned, a package usually contains other packages 

and modules, which can often be depicted as a tree. You can import just the 
package, module or even the name you want to use by using the import state­
ment above. Again, the important thing is that you need to know where the 
thing you want to import is located within the tree. Assume from the root r 

the module m is located at r.n.m; then the import statement can be written 
as follows:
from r.n import m
This dot notation can also be used to import a module from a package 
without using from, as shown in the following example:
import matplotlib.pyplot as ppl
which imports the pyplot module from the matplotlib package and assigns an 
alias to the module.
	
Modules and Packages	
369
 https://doi.org/10.15215/remix/9781998944088.01
FROM <MODULE/PACKAGE NAME> IMPORT <NAME OF OBJECT 
OR MODULE> AS <ALIAS>
This is the last form an import statement can take. It gives an alias to the module/
name imported from a package or module.
8.3 Install and Learn About Modules Developed by 
Others
To learn about modules already developed by others, your starting point can 
be a website called Python Package Index (PyPi) at https://​
pypi​
.org, where you 
can find, install, and publish Python packages and modules. By browsing this 
site, you will quickly get an idea what packages and modules have been already 
developed and published and are ready for use.
To see what modules and packages have already been installed on your 
computer, you can simply run pip list on a shell terminal such as PowerShell, 
as shown below:
PS C:\> pip list
Package             Version
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
  -­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
appdirs             1.4.4
argon2-­
cffi         20.1.0
asgiref             3.3.1
async-­
generator     1.10
attrs               20.3.0
backcall            0.2.0
bleach              3.2.1
certifi             2020.11.8
cffi                1.14.3
chardet             3.0.4
colorama            0.4.4
decorator           4.4.2
defusedxml          0.6.0
distlib             0.3.1
Django              3.1.5
entrypoints         0.3
filelock            3.0.12
idna                2.10
ipykernel           5.3.4
ipython             7.19.0
	370	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
ipython-­
genutils    0.2.0
ipywidgets          7.5.1
jedi                0.17.2
Jinja2              2.11.2
json5               0.9.5
jsonschema          3.2.0
jupyter             1.0.0
jupyter-­
client      6.1.7
jupyter-­
console     6.2.0
jupyter-­
core        4.6.3
jupyterlab          2.2.9
jupyterlab-­
pygments 0.1.2
jupyterlab-­
server   1.2.0
MarkupSafe          1.1.1
mistune             0.8.4
nbclient            0.5.1
nbconvert           6.0.7
nbformat            5.0.8
nest-­
asyncio        1.4.2
notebook            6.1.5
packaging           20.4
pandocfilters       1.4.3
parso               0.7.1
pickleshare         0.7.5
Pip                 21.1.3
pipenv              2020.11.15
prometheus-­
client   0.8.0
To find out what a particular installed module or package does, you can 
import the package or module into a Python interactive shell or a Jupyter Note­
book cell, then run the dir command/statement to find out the names defined 
in the module or package and use the help command/statement to see more 
detailed information for a particular name.
PS C:\> python
Python 3.9.0 (tags/v3.9.0:9cf6752, Oct 5 2020, 15:34:40) 
[MSC v.1927 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more 
information.
>>> import math
	
Modules and Packages	
371
 https://doi.org/10.15215/remix/9781998944088.01
>>> dir(math)
['__doc__', '__loader__', '__name__', '__package__', 
'__spec__', 'acos', 'acosh', 'asin , asinh , atan', 
'atan2', 'ata
nh', 'ceil', 'comb', 'copysign', 'cos', 'cosh', 'degrees', 
'dist', 'e', 'erf', 'erfc', 'exp', 'expmr, 'fabs', 'factoria
l', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 
'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'isqrt',
'1cm', 'Idexp', 'lgamma', 'log', 'log10', 'Ioglp', 
'log2', 'modf', 'nan', 'nextafter', 'perm', 'pi', 'pow', 
'prod', 'rad
ians', 'remainder', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 
'tau', 'trunc', 'ulp']
>>> help(math)
Help on built-­
in module math:
 
NAME
    math
 
DESCRIPTION
    This module provides access to the mathematical functions
    defined by the C standard.
 
FUNCTIONS
    acos(x, /)
        Return the arc cosine (measured in radians) of x.
 
        The result is between 0 and pi.
 
    acosh(x, /)
        Return the inverse hyperbolic cosine of x.
 
    asin(x, /)
        Return the arc sine (measured in radians) of x.
 
        The result is between -­
pi/2 and pi/2.
 
    asinh(x, /)
        Return the inverse hyperbolic sine of x.
 
	372	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
    atan(x, /)
        Return the arc tangent (measured in radians) of x.
 
        The result is between -­
pi/2 and pi/2.
 
    atan2(y, x, /)
        Return the arc tangent (measured in radians) of y/x.
 
        Unlike atan(y/x), the signs of both x and y are 
considered.
 
    atanh(x, /)
        Return the inverse hyperbolic tangent of x.
Another way to learn about and navigate through the available modules and 
packages is to use a module called pydoc. However, this module is usually run 
from a command shell or PowerShell terminal as shown below:
(base) PS C:\Users\james> python pydoc
pydoc -­
 the Python documentation tool
 
pydoc <name> …
    Show text documentation on something. <name> may be 
the name of a
    Python keyword, topic, function, module, or package, 
or a dotted
    reference to a class or function within a module or 
module in a
    package. If <name> contains a '\', it is used as the 
path to a
    Python source file to document. If name is 
'keywords', 'topics',
    or 'modules', a listing of these things is displayed.
 
pydoc -­
k <keyword>
    Search for a keyword in the synopsis lines of all 
available modules.
 
pydoc -­
n <hostname>
	
Modules and Packages	
373
 https://doi.org/10.15215/remix/9781998944088.01
    Start an HTTP server with the given hostname 
(default: localhost).
 
pydoc -­
p <port>
    Start an HTTP server on the given port on the local 
machine. Port
    number 0 can be used to get an arbitrary unused port.
 
pydoc -­
b
    Start an HTTP server on an arbitrary unused port and 
open a Web browser
    to interactively browse documentation. This option 
can be used in
    combination with -­
n and/or -­
p.
 
pydoc -­
w <name> …
    Write out the HTML documentation for a module to a 
file in the current
    directory. If <name> contains a '\', it is treated as 
a filename; if
    it names a directory, documentation is written for 
all the contents.
 
(base) PS C:\Users\james>
Note that when you want to run a Python module as a normal script, run 
Python with the -­
m switch before the module name.
As shown above, if you want to get documentation on something, just add 
the something behind pydoc. For example, if you want to see the documenta­
tion on the math module, run the following command in the command shell:
python -­
m pydoc math
The resulting documentation is shown below:
Help on built-­
in module math:
 
NAME
  math
 
	374	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
DESCRIPTION
  This module provides access to the mathematical 
functions
  defined by the C standard.
 
FUNCTIONS
  acos(x, /)
   Return the arc cosine (measured in radians) of x.
 
  acosh(x, /)
   Return the inverse hyperbolic cosine of x.
 
  asin(x, /)
   Return the arc sine (measured in radians) of x.
 
  asinh(x, /)
   Return the inverse hyperbolic sine of x.
 
  atan(x, /)
   Return the arc tangent (measured in radians) of x.
 
  atan2(y, x, /)
   Return the arc tangent (measured in radians) of y/x.
 
   Unlike atan(y/x), the signs of both x and y are 
considered.
 
  atanh(x, /)
   Return the inverse hyperbolic tangent of x.
With some installations of Python, such as those installed with Anaconda, 
pydoc has been made available as executable directly from command shell, 
as shown here:
(base) PS C:\Users\james> pydoc math
Help on built-­
in module math:
 
NAME
  math
 
	
Modules and Packages	
375
 https://doi.org/10.15215/remix/9781998944088.01
DESCRIPTION
  This module provides access to the mathematical functions
  defined by the C standard.
 
FUNCTIONS
  acos(x, /)
   Return the arc cosine (measured in radians) of x.
 
  acosh(x, /)
   Return the inverse hyperbolic cosine of x.
 
  asin(x, /)
   Return the arc sine (measured in radians) of x.
 
  asinh(x, /)
   Return the inverse hyperbolic sine of x.
 
  atan(x, /)
   Return the arc tangent (measured in radians) of x.
 
  atan2(y, x, /)
   Return the arc tangent (measured in radians) of y/x.
 
   Unlike atan(y/x), the signs of both x and y are considered.
 
  atanh(x, /)
   Return the inverse hyperbolic tangent of x.
pydoc has some switches that can be used when running it as a Python 
module or an executable directly from the command shell. These switches 
include the following.
-­
K <KEYWORD>
Used to search for a keyword in the synopsis lines of all available modules 
installed. The following example searches for all modules that has the word 
“hash” in the synopsis.
PS C:\Users\james> python -­
m pydoc -­
k hash
-­
N <HOSTNAME>
Used to start an HTTP server with the given <hostname>. When no hostname 
is given, localhost is default.
	376	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
-­
P <PORT>
Used to start an HTTP server on the given <port> on the local machine. Port 
number 0 can be used to get an arbitrary unused port.
-­
B
Used to start an HTTP server on an arbitrary unused port and open a web 
browser to interactively browse documentation. This option can be used in 
combination with -­
n and/or -­
p.
The following example starts a server on the local machine at an available 
port and launches a web browser to browse all available modules and packages.
(base) PS S:\Dev\learn-­
python> pydoc -­
b
Server ready at http://localhost:30128/
Server commands: [b]rowser, [q]uit
server>
Please note that if you type q to quit from the program, the server will be 
down and no longer available.
The browser opened by the example above will look like this:
Index of Modules
Built-­
In Modules
_abc	
_imp	
_stat
_ast	
_io	
_statistics	
builtins
_bisect	
_json	
_string	
cmath
_blake2	
_locale	
_struct	
errno
_codecs	
_lsprof	
_symtable	
faulthandler
_codecs_cn	
_md5	
_thread	
gc
_codecs_hk	
_multibvtecodec	 _tokenize	
itertools
_codecs_iso2022	 _opcode	
_tracemalloc	
marshal
_codecs_jp	
_operator	
_typing	
math
_codecs_kr	
_pickle	
_warnings	
mmap
_codecs_tw	
_random	
_weakref	
msvcrt
_collections	
_shal	
_winapi	
nt
_contextvars	
_sha256	
_xxsubinterpreters	 sys
_csv	
_sha3	
array	
time
_datetime	
_sha512	
atexit	
winreg
_functools	
_signal	
audioop	
xxsubtype
_heapq	
_sre	
binascii	
zlib
	
Modules and Packages	
377
 https://doi.org/10.15215/remix/9781998944088.01
Please note that the above only shows the built-­
in modules. There is more 
about nonbuilt-­
in modules if you scroll down to read further.
-­
W <NAME>…
Used to write out the HTML documentation for a module to a file in the current 
directory. If the name contains a backslash \, it is treated as a filename; if it 
names a directory, documentation is written for all the contents. The following 
example generates documentation in HTML for a module called timeit:
(base) PS S:\Dev\learn-­
python > pydoc -­
w timeit
wrote timeit.html
As can be seen, using the pydoc -­
b in command shell can easily access a 
server and start to browse documentation for all the available modules and 
packages installed on your computer. For example, if we want to learn more 
about the timeit module, we can browse or search for timeit within the first 
page of the browser window launched by the pydoc -­
b command, then click 
the link to see the details of the documentation.
The remainder of this chapter introduces some Python modules that you 
may need to use in the development of different computer applications.
8.4 Module for Generating Random Numbers
In certain computer applications, you often need to generate random numbers. 
For example, you need random numbers to automatically generate quizzes. In 
computer security, big random numbers play very important roles.
The random module comes with the standard Python distribution library. 
It provides functions and class definitions related to generating pseudor­
andom numbers, though they are not good enough to be used for security 
purposes. To see what names are defined at the top level of the module, run 
the dir(random) statement after importing the module to get a list of the 
names, as shown below:
>>> import random
>>> dir(random)
['BPF', 'LOG4', 'NV_MAGICCONST', 'RECIP_BPF', 
'Random', 'SG_MAGICCONST', 'SystemRandom', 'TWOPI', '_
BuiltinMethodType', '_MethodType', '_Sequence', '_Set', 
'__all__', '__builtins__', '__cached__', '__doc__', 
'__file__', '__loader__', '__name__', '__package__', 
	378	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
'__spec__', '_acos', '_bisect', '_ceil', '_cos', '_e', 
'_exp', '_inst', '_itertools', '_log', '_os', '_pi', 
'_random', '_sha512', '_sin', '_sqrt', '_test', '_
test_generator', '_urandom', '_warn', 'betavariate', 
'choice', 'choices', 'expovariate', 'gammavariate', 
'gauss', 'getrandbits', 'getstate', 'lognormvariate', 
'normalvariate', 'paretovariate', 'randint', 
'random', 'randrange', 'sample', 'seed', 'setstate', 
'shuffle', 'triangular', 'uniform', 'vonmisesvariate', 
'weibullvariate']
In the list, names with leading underscores are often intended to be hid­
den. It’s important to know only what those without leading underscores are 
and what they do. You can use the help statement to find out what randint is, 
for example:
>>> help(random.randint)
Running help on method randint in the random module outputs the 
following:
randint(a, b) method of random.Random instance
This returns a random integer within the range [a, b], including both end 
points.
As you can see with the help statement, all these names defined in the ran­
dom module are functions and methods. These functions and methods can be 
categorized as bookkeeping methods, random integer generating methods, ran­
dom real/float number generating methods, random item generating methods, 
or items from a sequence. The module also provides alternate random number 
generators such as the one provided by the operating system.
In the following, you will run through the functions provided in the ran­
dom module. These functions are categorized into four groups: bookkeeping 
functions, functions randomly generating integers, functions randomly gen­
erating float/real numbers, and functions randomly selecting items from a 
sequence.
	
Modules and Packages	
379
 https://doi.org/10.15215/remix/9781998944088.01
Functions for Bookkeeping
SEED(A = NONE, VERSION = 2)
This initializes the random number generator by seeding the generator. If there 

is no argument for a, the current time is used to seed the generator. Version 2 is 

the default version of the algorithm.
>>> import random
>>> random.seed(a = 3)
GETSTATE()
This gets and returns the current internal state of the random number generator.
>>> s1 = random.getstate()
SETSTATE(STATE)
This sets the internal state of the random number generator to state.
>>> random.setstate(s1)
GETRANDBITS(K)
This generates and returns an integer with k random bits.
>>> bin(random.getrandbits(9))
'0b100101111'
>>> bin(random.getrandbits(9))   # will get a different 
number
'0b10111101'
Functions for Generating Random Integers
RANDRANGE(START, STOP=NONE, STEP = 1)
This generates and returns a random number within the given range.
>>> random.randrange(99)
69
>>> random.randrange(99)
	380	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
RANDINT(A, B)
This generates and returns a random integer within the given range.
>>> random.randint(1, 100)
42
>>> random.randint(1, 100)
85
Functions for Randomly Generating Float Numbers
RANDOM()
This randomly generates and returns a random float number between 0 and 
1, including 0 but excluding 1.
>>> random.random()
0.4084252811341471
UNIFORM(A, B)
This randomly generates and returns a float number between a and b.
>>> random.uniform(2, 99)
73.1658416986511
>>> random.uniform(2, 99)
92.92610150048253
TRIANGULAR(LOW = 0.0, HIGH = 1.0, MODE = NONE)
This randomly generates and returns a random float number between low 
and high. The third argument for mode parameter can be used to indicate the 
preference for the outcome. If it is closer to low, it is more likely to get a ran­
dom float number on the low end, for example. Internally, the default value 
for mode is the midpoint between low and high.
>>> random.triangular(2, 99)
84.02716580051677
>>> random.triangular(2,99,35)
50.303535641546
BETAVARIATE(ALPHA, BETA)
This randomly generates and returns a random float number between 0 
and 1 based on the beta distribution of statistics. Parameters alpha and beta 

	
Modules and Packages	
381
 https://doi.org/10.15215/remix/9781998944088.01
(both > 0) are used to set the conditions of the distribution, as used in the beta 
distribution function.
>>> random.betavariate(2, 99)
0.011368344795580798
>>> random.betavariate(2, 99)
0.019428131869773747
EXPOVARIATE(LAMBDA)
This randomly generates and returns a random float number between 0 and 
1, or between 0 and −1 if lambda is negative, based on the exponential distri­
bution of statistics.
>>> random.expovariate(2)
0.379317249922913
GAMMAVARIATE(ALPHA, BETA)
This randomly generates and returns a random float number between 0 and 1 
based on the gamma distribution of statistics. Parameters alpha and beta (both 
> 0) are used to set the conditions of the distribution, as used in the gamma 
distribution function.
>>> random.gammavariate(2,99)
43.06391063895096
GAUSS(MU, SIGMA)
This randomly generates and returns a random float number between 0 and 1 
based on the Gaussian distribution of probability theories. Parameter mu is the 
mean, and sigma is the standard deviation, as used in the distribution function.
>>> random.gauss(2, 99)
38.05513497609059
LOGNORMVARIATE(MU, SIGMA)
This generates and returns a random float number between 0 and 1 based on a 
log-­
normal distribution of probability theories. Parameter mu is the mean, and 
sigma is the standard deviation, as used in the log normal distribution function.
>>> random.lognormvariate(2, 99)
9.252497191266324e-­
41
	382	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
NORMALVARIATE(MU, SIGMA)
This generates and returns a random float number between 0 and 1 based on 
the normal distribution of probability theories. Parameter mu is the mean, and 
sigma is the standard deviation, as used in the normal distribution function.
>>> random.normalvariate(2, 99)
155.45854862650918
VONMISESVARIATE(MU, KAPPA)
This generates and returns a random float number between 0 and 1 based 
on the von Mises distribution of directional statistics. Parameter mu is the 
mean angle, expressed in radians between 0 and 2 * pi, whereas kappa is 
the concentration.
>>> random.vonmisesvariate(2, 99)
1.9289474404869416
PARETOVARIATE(ALPHA)
This generates and returns a random float number between 0 and 1 based 
on the Pareto distribution of probability theories. Parameter alpha is used to 
indicate the shape.
>>> random.paretovariate(2)
1.7794461337233882
WEIBULLVARIATE(ALPHA,BETA)
This generates and returns a random float number between 0 and 1 based on 
the Weibull distribution of statistics. Parameter alpha is the scale, and beta 

is the shape, as in its mathematical function.
>>> random.weibullvariate(2, 99)
2.0164248554211417
Functions for Randomly Selected Item(s) from Sequences
Functions in this group are often used in statistics.
CHOICE(POPULATION)
This generates and returns a random element from the given population (in 
the form of a Python sequence).
	
Modules and Packages	
383
 https://doi.org/10.15215/remix/9781998944088.01
>>> random.choice(range(1, 1000))
536
>>> random.choice(list("The message will look like this 
but"))
'l'
>>> random.choice(list("The message will look like this 
but"))
't'
CHOICES(POPULATION, WEIGHTS = NONE, *, CUM_WEIGHTS = 
NONE, K = 1)
This generates and returns a list with k randomly selected items from the given 
sequence, with weights or cumulative weights considered if they are given. An 
optional argument for weights should be a list of integers specifying how likely 
the corresponding items are to be selected. The number of integers in weights 
must match the number of items in the population; optional argument for 
cum_weights is also a list. A value in the list is shown as cumulation of weights so 
far. Argument weights and cum_weights are just different ways of representing 
the same preferences.
>>> random.choices(range(1, 1000), k = 5)
[456, 79, 57, 51, 110]
>>> random.choices(range(1, 10), weights = [2, 3, 5, 8, 
2, 3, 3, 2, 10], k = 5)
[9, 4, 6, 3, 8]
This function can be very useful when you want to generate a quiz by ran­
domly selecting questions from a question bank. Assume the question bank is 
called q_bank, and each quiz will have 10 questions. The random choices can 
be easily made by calling the function as follows:
>>> random.choices(q_bank, k = 10)
SHUFFLE(POPULATION, RANDOM = NONE)
This takes a sequence, shuffles the members, then returns the sequence with 
the members randomly shuffled.
>>> l = list(range(10))
>>> l
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
	384	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> random.shuffle(l)
>>> l
[2, 9, 0, 4, 1, 6, 5, 3, 7, 8]
SAMPLE(POPULATION, K)
This generates and returns a sample for a given population. It seems similar 
to choices(), but internally the algorithm should check whether the choices 
would make a sample of the population according to some sampling criteria 
in statistics.
>>> random.sample(range(1, 1000), k = 5)
[251, 337, 822, 499, 853]
In the following programming problem in Table 8-­
1, you will study how well 
the random generator works. You will randomly generate 1000 integer numbers 
within the range of 0 to 999 and visualize the randomness of these numbers.
Table 8-­
1: Case study: Random number generator quality
The problem
This case study will find out how good the random number 
generator is.
The analysis 
and design
Random numbers generated by computers are not completely 
random. Rather, they are pseudorandom sequences. To study 
how good a generator is, you need to see if the numbers 
generated by the generator look random. We will show that in a 
two-­
dimensional chart to visualize it.
The code
import random
import matplotlib.pyplot as pyp
data = [random.randint(0,100) for i in 
range(1000)]
pyp.plot(list(range(1000)), data)
pyp.xlabel('Run #')
pyp.ylabel('Random Integer')
pyp.title('Visualization of Randomness')
pyp.show()
The result
Figure 8-­
1 below is plotted by the program. It seems the random 
generator works very well.
	
Modules and Packages	
385
 https://doi.org/10.15215/remix/9781998944088.01
8.5 Module for Mathematical Operations
The math module also comes with the standard Python distribution library 
and provides many useful mathematical functions that you may need. To learn 
what the module has for you, type the following statement in a Jupyter Note­
book cell and click run or press Shift+Enter at the same time. You will see 
the documentation for all these functions as well as the constants defined 

in the math module.
To learn what is defined in the module, run the dir statement on math after 
import, as we did before with the random module:
>>> import math
>>> dir(math)
['__doc__', '__loader__', '__name__', '__package__', 
'__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 
'atan2', 'atanh', 'ceil', 'copysign', 'cos', 'cosh', 
'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 
'factorial', 'floor', 'fmod', 'frexp', 'fsum', 
'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 
'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 
0
200
400
600
800
1000
Run #
0
20
40
60
80
100
Random Integer
Visualization of Randomness
Figure 8-­
1: Visualization of randomness
	386	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
'log1p', 'log2', 'modf', 'nan', 'pi', 'pow', 'radians', 
'remainder', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 
'trunc']
Then run help on a particular name to find out what that name, such as 
ceil, does:
>>> help(math.ceil)
Running help on the built-­
in function ceil in the math module outputs the 
following:
ceil(x, /)
    Return the ceiling of x as an Integral.
This returns the smallest integer >= x.
In the following, we run through the functions available in the math module.
ACOS(X)
This calculates and returns the arc cosine (measured in radians) of x, where 
0 <= x < = 1.
>>> import math
>>> math.acos(0.5)
1.0471975511965979
ACOSH(X)
This calculates and returns the inverse hyperbolic cosine of x. (Google “hyper­
bolic functions” to learn more.)
>>> math.acosh(1000)
7.600902209541989
ASIN(X)
This calculates and returns the arc sine (measured in radians) of x.
>>> math.asin(0.5)
0.5235987755982989
	
Modules and Packages	
387
 https://doi.org/10.15215/remix/9781998944088.01
MATH.ASINH(X)
This calculates and returns the inverse hyperbolic sine of x.
>>> math.asinh(5)
2.3124383412727525
MATH.ATAN(X)
This calculates and returns the arc tangent (measured in radians) of x.
>>> math.atan(0.5)
0.4636476090008061
MATH.ATAN2(Y, X)
This calculates and returns the arc tangent (measured in radians) of y/x. Unlike 
atan(y/x), the signs of both x and y are considered.
>>> math.atan2(3, -­
5)
2.601173153319209
MATH.ATANH(X)
This calculates and returns the inverse hyperbolic tangent of x.
>>> math.atanh(0.5)
0.5493061443340549
MATH.CEIL(X)
This calculates and returns the ceiling of x as an Integral—­
the smallest integer 
>= x.
>>> math.ceil(0.5)
1
MATH.COPYSIGN(X, Y)
This calculates and returns a float with the magnitude (absolute value) of x 
but the sign of y. On platforms that support signed zeros, copysign(1.0, −0.0) 
returns −1.0.
>>> math.copysign(0.5, -­
1.2)
-­
0.5
	388	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
MATH.COS(X)
This calculates and returns the cosine of x (measured in radians).
>>> math.cos(0.5)
0.8775825618903728
MATH.COSH(X)
This calculates and returns the hyperbolic cosine of x.
>>> math.cosh(50)
2.592352764293536e+21
MATH.DEGREES(X)
This converts angle x from radians to degrees and returns the result.
>>> math.degrees(0.5)
28.64788975654116
MATH.ERF(X)
This is the error function at x, as defined in statistics.
>>> math.erf(0.5)
0.5204998778130465
MATH.ERFC(X)
This is the complementary error function at x, so that erf(x) + erfc(x) = 1.
>>> math.erfc(0.5)
0.4795001221869534
MATH.EXP(X)
This calculates and returns e raised to the power of x. This is the same as 
math.e**x, or math.pow(math.e, x).
>>> math.exp(5)
148.4131591025766
MATH.EXPM1(X)
This calculates and returns exp(x)−1. This function avoids the loss of precision 
involved in the direct evaluation of exp(x)−1 for small x.
	
Modules and Packages	
389
 https://doi.org/10.15215/remix/9781998944088.01
>>> math.expm1(5)
147.4131591025766
MATH.FABS(X)
This calculates and returns the absolute value of the float x.
>>> math.fabs(-­
23.6)
23.6
MATH.FACTORIAL(X)
This calculates and returns x!. It will raise a ValueError if x is negative or 
nonintegral.
>>> math.factorial(23)
25852016738884976640000
MATH.FLOOR(X)
This calculates and returns the floor of x as an integer—­
that is, the return value 
is the largest integer < = x.
>>> math.floor(2.3)
2
MATH.FMOD(X, Y)
This calculates and returns fmod(x, y), according to platform C. x % y may differ.
>>> math.fmod(2.3, 1.5)
0.7999999999999998
MATH.FREXP(X)
This calculates the mantissa and exponent of x and returns a pair (m, e). m is 
a float, and e is an integer, such that x = m * 2** e. If x is 0, m and e are both 0. 
Otherwise, 0.5 <= abs(m) < 1.0.
>>> math.frexp(2.3)
(0.575, 2)
MATH.FSUM(SEQ)
This calculates and returns an accurate floating-­
point sum of values in the 
iterable seq. It assumes IEEE-­
754 floating-­
point arithmetic. It is a lossless sum.
	390	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> math.fsum([2.3, 2, 53454, 6.71232])
53465.01232
MATH.GAMMA(X)
This returns the value of the gamma function at x.
>>> math.gamma(2.3)
1.16671190519816
MATH.GCD(X, Y)
This calculates and returns the greatest common divisor of x and y.
>>> math.gcd(222, 780)
6
MATH.HYPOT(X, Y)
This calculates and returns the Euclidean distance—­
that is, the value of sqrt(x 
* x + y * y).
>>> math.hypot(3, 4)
5.0
MATH.ISCLOSE(A, B, *, REL_TOL = 1E-­
09, ABS_TOL = 0.0)
Determine whether two floating-­
point numbers are close in value. The rel_tol 
argument sets the maximum difference for being considered “close” relative 
to the magnitude of the input values, whereas abs_tol argument sets the max­
imum difference for being considered “close” regardless of the magnitude of 
the input values. Return True if a is close in value to b, and False otherwise. 
For the values to be considered close, the difference between them must be 
smaller than at least one of the tolerances set by rel_tol and abs_tol. -­
inf, inf, 
and NaN behave similarly to the IEEE 754 Standard. That is, NaN is not close to 
anything, even itself, and inf and -­
inf are only close to themselves.
>>> math.isclose(3.5, 3.51)
False
>>> math.isclose(3.5, 3.500000001)
True
>>> math.isclose(3.5, 3.50000001)
False
	
Modules and Packages	
391
 https://doi.org/10.15215/remix/9781998944088.01
MATH.ISFINITE(X)
This returns True if x is neither an infinity nor a NaN, and False otherwise.
>>> math.isfinite(3.5)
True
MATH.ISINF(X)
This returns True if x is a positive or negative infinity, and False otherwise.
>>> math.isinf(3.5)
False
MATH.ISNAN(X)
This returns True if x is a NaN (not a number), and False otherwise.
>>> math.isnan(3.5)
False
MATH.ISQRT(N)
This returns the integer square root of the nonnegative integer n, which is the 
floor of the exact square root of n, or equivalently the greatest integer is such 
that a2 ≤ n. This function is only available in Python 3.8.0 or later.
>>> math.isqrt(43)
6
MATH.LDEXP(X, I)
This calculates and returns x* (2 ** i). The function is essentially the inverse 
of frexp().
>>> math.ldexp(3, 12)
12288.0
MATH.LGAMMA(X)
This calculates and returns the natural logarithm of the absolute value of the 
gamma function at x.
>>> math.lgamma(3)
0.693147180559945
	392	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
MATH.LOG(X, BASE = MATH.E)
This calculates and returns the logarithm of x to the given base. If the base is 
not specified, it returns the natural logarithm (base-­
e) of x.
>>> math.log(3)
1.0986122886681098
>>> math.log(3,3)
1.0
>>> math.log(3,5)
0.6826061944859854
MATH.LOG10(X)
This calculates and returns the base-­
10 logarithm of x.
>>> math.log10(3)
0.47712125471966244
MATH.LOG1P(X)
This calculates and returns the natural logarithm of 1 + x (base-­
e). The result 
is computed in a way that is accurate for x near 0.
>>> math.log1p(3)
1.3862943611198906
MATH.LOG2(X)
This calculates and returns the base-­
2 logarithm of x.
>>> math.log2(3)
1.584962500721156
MATH.MODF(X)
This calculates and returns the fractional and integer parts of x. Both results 
carry the sign of x and are floats.
>>> math.modf(32.6)
(0.6000000000000014, 32.0)
MATH.POW(X, Y)
This calculates and returns x ** y (x to the power of y).
	
Modules and Packages	
393
 https://doi.org/10.15215/remix/9781998944088.01
>>> math.pow(32,6)
1073741824.0
MATH.RADIANS(X)
This converts angle x from degrees to radians and returns the result.
>>> math.radians(32)
0.5585053606381855
MATH.REMAINDER(X, Y)
This calculates and returns the difference between x and the closest integer 
multiple of y, which is x − n * y, where n * y is the closest integer multiple of y. 
In the case where x is exactly halfway between two multiples of y, the nearest 
even value of n is used. The result is always exact.
>>> math.remainder(32,7)
-­
3.0
>>> math.remainder(30,7)
2.0
>>> math.remainder(31,7)
3.0
MATH.SIN(X)
This calculates and returns the sine of x (measured in radians).
>>> math.sin(0.31)
0.3050586364434435
MATH.SINH(X)
This calculates and returns the hyperbolic sine of x.
>>> math.sinh(31)
14524424832623.713
MATH.SQRT(X)
This calculates and returns the square root of x.
>>> math.sqrt(31)
5.5677643628300215
	394	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
MATH.TAN(X)
This calculates and returns the tangent of x (measured in radians).
>>> math.tan(31)
-­
0.441695568020698
MATH.TANH(X)
This calculates and returns the hyperbolic tangent of x.
>>> math.tanh(31)
1.0
MATH.TRUNC(X)
This truncates the float number x to the nearest Integral toward 0. It uses the 
__trunc__ magic method.
>>> math.trunc(3.561)
3
In addition, the module also defines the following constants used in math:
math.e = 2.718281828459045
math.inf = inf
math.nan = nan
math.pi = 3.141592653589793
math.tau = 6.283185307179586
Note that to use these functions and constants, you will have to use the dot nota­
tion shown in the sample code above to indicate that it is from the math module.
If you only need to use one or some functions from the math module, you 
may import the particular functions from it to save computer memory and 
use the functions without using the dot notation. The following is an example, 
generating a table of square roots for numbers from 1 to 100, in which only the 
sqrt function has been imported from the math module:
In [ ]:
from math import sqrt
for i in range(100):
  print('{:<5.3}'.format(sqrt(i + 1)), end = ' ')
  if (i + 1) % 10 == 0:
    print('\n')
	
Modules and Packages	
395
 https://doi.org/10.15215/remix/9781998944088.01
Out [ ]:
1.0 1.41 1.73 2.0 2.24 2.45 2.65 2.83 3.0 3.16
3.32 3.46 3.61 3.74 3.87 4.0 4.12 4.24 4.36 4.47
4.58 4.69 4.8 4.9 5.0 5.1 5.2 5.29 5.39 5.48
5.57 5.66 5.74 5.83 5.92 6.0 6.08 6.16 6.24 6.32
6.4 6.48 6.56 6.63 6.71 6.78 6.86 6.93 7.0 7.07
7.14 7.21 7.28 7.35 7.42 7.48 7.55 7.62 7.68 7.75
7.81 7.87 7.94 8.0 8.06 8.12 8.19 8.25 8.31 8.37
8.43 8.49 8.54 8.6 8.66 8.72 8.77 8.83 8.89 8.94
9.0 9.06 9.11 9.17 9.22 9.27 9.33 9.38 9.43 9.49
9.54 9.59 9.64 9.7 9.75 9.8 9.85 9.9 9.95 10.0
8.6 Modules for Time, Date, and Calendar
Date and time are often used and referred to in many applications. You may 
also want to include a calendar in an application. Python has modules in its 
standard distribution that allow you to import these modules right away.
The Datetime Module
The first of these modules is the datetime module that comes in the standard 
Python library. To use the module, simply import it as shown below:
>>> import datetime
To find out what is defined and available in the module, run the following 
dir statement:
>>> dir(datetime)
 
['MAXYEAR', 'MINYEAR', '__builtins__', '__cached__', 
'__doc__', '__file__', '__loader__', '__name__', 
'__package__', '__spec__', 'date', 'datetime', 'datetime_
CAPI', 'sys', 'time', 'timedelta', 'timezone', 'tzinfo']
To further find out what each name is defined for, use the help statement 
on each. As usual, we will go through some of the important names defined in 
the module, with examples.
DATETIME.DATE(<YEAR, MONTH, DAY>)
This is the constructor of the date class defined in the datetime module and 
used to construct and return a date object for the day of the month of the year.
	396	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> d1 = datetime.date(2020, 7, 1)   # create a date 
object
>>> d1.year   # get the year attribute of the date object
2020
>>> d1.month   # get the month attribute of the date 
object
7
>>> d1.day   # get the day attribute of the date object
1
A date object has the following methods defined.
DATETIME.DATE.CTIME()
This returns a ctime()-­
style string.
>>> d1.ctime()
'Wed Jul 1 00:00:00 2020'
DATETIME.DATE.ISOCALENDAR()
This returns a three-­
tuple containing an ISO year, week number of the year, 
and day number of the week. In the datetime module, Monday is 1, Tuesday 
is 2,…, Sunday is 7.
>>> d1.isocalendar()
(2020, 27, 3)
DATETIME.DATE.ISOFORMAT()
This returns a date string in ISO 8601 format, YYYY-­
MM-­
DD.
>>> d1.isoformat()
'2020-­
07-­
01'
DATETIME.DATE.ISOWEEKDAY()
This returns an integer from 1 to 7 as the day of the week represented by the 
date.
>>> d1.isoweekday()
3
	
Modules and Packages	
397
 https://doi.org/10.15215/remix/9781998944088.01
DATETIME.DATE.REPLACE(…)
This returns the date with new specified fields.
DATETIME.DATE.STRFTIME(…)
This changes the date format and returns a strftime()-­
style string.
DATETIME.DATE.TIMETUPLE(…)
This returns a time-­
tuple that is compatible with time.localtime().
DATETIME.DATE.TOORDINAL(…)
This returns a proleptic Gregorian ordinal. January 1 of year 1 is day 1.
DATETIME.DATE.WEEKDAY(…)
This returns the day of the week represented by the date: Monday is 0…Sunday 
is 6.
The following are all class methods of the date class defined in the datetime 
module, which means they can be called from the class name date.
DATETIME.DATE.FROMISOFORMAT(<ISO_DATE_FORMAT 
STRING>)
This will construct a date object from an ISO date format string, which is 
YYYY-­
MM-­
DD.
>>> d2 = datetime.date.fromisoformat('2020-­
07-­
01')
>>> d2.ctime()
'Wed Jul 1 00:00:00 2020'
DATETIME.DATE.FROMORDINAL(<DAYS IN RELATION TO A 
PROLEPTIC GREGORIAN ORDINAL>)
This constructs a date object from an integer >= 1 representing the days after 
the proleptic Gregorian ordinal, which is January 1 of year 1, with ordinal 1.
>>> from datetime import date   # after this, you don't 
need to have datetime in the reference to date class
>>> d3 = date.fromordinal(1235)
>>> d3.ctime()
'Wed May 19 00:00:00 0004'
	398	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
DATETIME.DATE.FROMTIMESTAMP(<TIMESTAMP>)
This constructs a local date object from a POSIX timestamp (a big positive float 
number), such as returned time.time(), which will be explained shortly.
>>> import time
>>> time.time()   # it returns a timestamp for now
1593745988.6121984
>>> date.fromtimestamp(1593745988.6121984)
datetime.date(2020, 7, 2)
DATETIME.DATE.TODAY()
This returns a date object of for the current date.
>>> from datetime import date
>>> print(date.today())
2020-­
07-­
05
The datetime module also has a class called time. The following is the con­
structor of the time class.
DATETIME.TIME(HOUR = 0, MINUTE = 0, SECOND = 0, 
MICROSECOND = 0, TZINFO = NONE)
This returns a time object. All arguments with 0 as their default value must be in 
their reasonable range or the program will raise a value error. If no argument is 
provided, they are all 0, except tzinfo (for time zone information, which needs 
to be an instance of tzinfo class if given). The default value of tzinfo is None.
>>> from datetime import time
>>> print(time(hour = 23))
23:00:00
>>> t1 = time(11, 25, 5)
time is 11:25:05
>>> print(f'time is {t1}')
>>> print(f'hour is {t1.hour}')   # this is to get the 
hour of a time
hour is 11
>>> print(f'minute is {t1.minute}')   # this is to get 
the minute
minute is 25
	
Modules and Packages	
399
 https://doi.org/10.15215/remix/9781998944088.01
>>> print(f'second is {t1.second}')   # this is to get 
second
second is 5
The following is the only class method of the date class in the datetime module.
TIME.FROMISOFORMAT(…)
This class method will construct a date object from a string passed in the 
parameter.
>> import datetime
>> canada_day_str = "2022-­
07-­
01"
>> canada_day_object = datetime.date.
fromisoformat(canada_day_str)
>> print(f"{canada_day_object} as 
{type(canada_day_object)}")
2022-­
07-­
01 as <class 'datetime.date'>
The datetime module also has a class called datetime, which is a combination 
of date and time. The following is the constructor of the datetime objects.
DATETIME.DATETIME(YEAR, MONTH, DAY, HOUR = 0, MINUTE = 0, 
SECOND = 0, MICROSECOND = 0, TZINFO = NONE, *, FOLD = 0)
This returns a datetime object for the date and time given in the arguments. 
If no time is given, the default is the beginning of the day of the month 

of the year.
The following are the methods defined in the datetime class.
DATETIME.CTIME(…)
This returns a ctime()-­
style time string.
>>> from datetime import datetime
>>> dt1 = datetime.now()
>>> print(f'now it is {dt1.ctime()}')
now it is Mon Jul 6 14:07:01 2020
	400	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
DATETIME.ASTIMEZONE(TZ)
This converts to the local time with the time zone set to <tz> or local.
>>> from datetime import datetime
>>> dt1 = datetime.now()
>>> print(dt1)
2020-­
07-­
06 14:07:01.046202
>>> print(dt1.astimezone())
2020-­
07-­
06 14:07:01.046202-­
06:00
>>> import pytz
>>> asiachina=pytz.timezone('Asia/Chongqing')
>>> print(dt1)
2020-­
07-­
06 14:07:01.046202
>>> print(dt1.astimezone(asiachina)) # print time in 
China
2020-­
07-­
07 04:07:01.046202+08:00
A complete list of time zone names can be found at https://​
en​
.wikipedia​
.org/​
wiki/​
List​
_of​
_tz​
_database​
_time​
_zones.
DATETIME.DATE()
This returns a date object of the date portion of the datetime object with the 
same year, month, and day.
>>> from datetime import datetime
>>> tm1 = datetime.now()
>>> print(f'now is {dtm1.ctime()}')
now is Tue Jul 7 08:50:25 2020
>>> dt1 = dtm1.date()
>>> print(f'the date is {dt1}')
the date is 2020-­
07-­
07
DATETIME.DST()
This returns the DST (daylight saving time) status of a given tzinfo.
>>> print(f'the date is {dt1}')
the date is 2020-­
07-­
07
>>> print(f'the dst status is {dtm1.dst()}')
None
	
Modules and Packages	
401
 https://doi.org/10.15215/remix/9781998944088.01
DATETIME.ISOFORMAT(SEP = 'T')
This returns a date and time string in ISO 8601 format, YYYY-­
MM-­
DDT[HH[:MM[:SS[.mmm[uuu]]]]][+HH:MM]. sep is a single character used 
to separate the year from the time, and defaults to T. timespec specifies what 
components of the time to include. The allowed values include the following: 
auto, hours, minutes, seconds, milliseconds, and microseconds.
>>> from datetime import datetime
>>> dt1 = datetime.now()
>>> print(dt1.isoformat(sep='@'))
2023-­
03-­
13@18:51:29.324588
DATETIME.REPLACE(<FIELD>=<VALUE>)
This returns a datetime object with the named field(s) replaced.
>>> dt2 = dt1.replace(year=2025)
>>> print(f'new datetime becomes {dt}')
new datetime becomes 2021-­
07-­
07 09:00:37.138388
DATETIME.TIME()
This returns a time object for the time portion of the datetime object but with 
tzinfo = None.
>>> dt1 = dtm1.date()
>>> tm1=dtm1.time()
>>> print(f'the date is {dt1}')
the date is 2020-­
07-­
07
>>> print(f'the time is {tm1}')
the time is 09:17:06.055195
DATETIME.TIMESTAMP()
This returns POSIX timestamp as a float number.
>>> tmstamp = dtm1.timestamp()
>>> print(f'The timestamp of {dtm1} is {tmstamp}')
DATETIME.TIMETUPLE()
This returns a time-­
tuple compatible with time.localtime().
>>> tmtuple = dtm1.timetuple()
>>> print(f'The time-­
tuple of {dtm1} is {tmtuple}')
	402	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
DATETIME.TIMETZ()
This returns a time object with the same time and tzinfo. Note the difference 
between timetz() and time().
>>> tminfo = dtm1.timetz()
>>> print(f'The time of {dtm1} is {tminfo}')
The timezone info of 2020-­
07-­
07 09:24:39.517213 is 
09:24:39.517213
DATETIME.TZNAME(…)
This returns the tzname of tzinfo.
>>> import pytz
>>> tz = pytz.timezone('Canada/Mountain')
>>> dtm = datetime.fromisoformat('2020-­
07-­
05T21:05:33')
>>> ndtm = dtm.replace(tzinfo = tz)
>>> tmzname = ndtm.tzname()
>>> print(f'The timezone for {ndtm} is {tmzname}')
The timezone for 2020-­
07-­
05 21:05:33-­
07:34 is LMT
DATETIME.UTCOFFSET(…)
This returns utcoffset of tzinfo.
>>> tmzutcoffset = ndtm.utcoffset()
>>> print(f'The timezone utc offset of {ndtm} is 
{tmzutcoffset}')
The timezone utc offset of 2020-­
07-­
05 21:05:33-­
07:34 is 
-­
1 day, 16:26:00
The following are some class methods defined in the datetime class.
DATETIME.COMBINE(DT, TM)
This combines the date dt and time tm into a datetime object and returns the 
datetime object.
>>> dt = datetime.date.today()
>>> tm = datetime.time(20,59,12)
>>> dtm = datetime.datetime.combine(dt, tm)
>>> print(f'date is {dt}, time is {tm}, datetime is {dtm}')
	
Modules and Packages	
403
 https://doi.org/10.15215/remix/9781998944088.01
date is 2020-­
07-­
05, time is 20:59:12, datetime is 
2020-­
07-­
05 20:59:12
DATETIME.FROMISOFORMAT(DTMSTR)
This constructs the datetime object from a date and time string in ISO format 
and returns the converted datetimeobject. Remember that the ISO time string 
format is YYYY-­
MM-­
DDTHH:MM:SS:mmm:uuu.
>>> dtm = datetime.datetime.fromisoformat('2020-­
07
-­
05T21:05:33')
>>> print(dtm)
2020-­
07-­
05 21:05:33
DATETIME.FROMTIMESTAMP(…)
This constructs a datetime object from a POSIX timestamp.
>>> tmstamp1 = ndtm.timestamp()
>>> print(f'The time stamp of {ndtm} is {tmstamp1}')
The time stamp of 2020-­
07-­
05 21:05:33-­
07:34 is 
1594010373.0
>>> redtmobj = datetime.fromtimestamp(tmstamp1)
>>> print(f'It is a different object and the time value 
has changed to {redtmobj}')
It is a different object, and the time value has changed 
to 2020-­
07-­
05 22:39:33.
DATETIME.NOW(TZ = NONE)
This returns a datetime object representing the current time local to tz, which 
should be a Timezone object if given. If no tz is specified, the local timezone 
is used.
>>> from datetime import datetime   # import the datetime 
class from the datetime module
>>> dt1 = datetime.now()
>>> print(f'it is {dt1}')
it is 2020-­
07-­
05 11:22:48.876825
DATETIME.STRPTIME(<DATE_STRING, FORMAT>)
This returns a datetime object by parsing a date_string, based on a given format.
	404	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> dtstring = "7 July, 2020"
>>> dtobj = datetime.strptime(dtstring, "%d %B, %Y")   # 
note the date formatting string
>>> print("date object = ", dtobj)
 
date object = 2020-­
07-­
07 00:00:00
DATETIME.TODAY()
This returns a datetime object for today.
>>> dt2 = datetime.today()
>>> print(f'Today is {dt2}')
Today is 11:34:09.228618
DATETIME.UTCFROMTIMESTAMP()
This constructs a naive UTC datetime from a POSIX timestamp.
>>> redtmobj = datetime.utcfromtimestamp(tmstamp1)
>>> print(f'{redtmobj} is a UTC datetime from a POSIX 
timestamp {redtmobj}')
2020-­
07-­
06 04:39:33 is a UTC datetime from a POSIX 
timestamp 1594010373.0
DATETIME.UTCNOW()
This returns a new datetime representing the UTC day and time.
>>> dt2 = datetime.today()
>>> dt3 = datetime.utcnow()
>>> print(f'Today is {dt2}, and the UTC time is {dt3}')
Today is 2020-­
07-­
07 11:37:02.862356, and the UTC time is 
2020-­
07-­
07 17:37:02.862356
Sometimes, you need to deal with time intervals such as how long has passed 
since the last time you saw your best friend. That is what the timedelta class is 
defined for in the datetime module. The following is the constructor of the class.
DATETIME.TIMEDELTA(DAYS = 0, SECONDS = 0, MICROSECONDS 
= 0, MILLISECONDS = 0, MINUTES = 0, HOURS = 0, WEEKS = 0)
This constructs and returns a timedelta object. Note that all arguments are 
optional, and all default to 0 if not provided.
	
Modules and Packages	
405
 https://doi.org/10.15215/remix/9781998944088.01
>>> from datetime import timedelta
>>> ndlt = timedelta(days = 31)
TIMEDELTA.TOTAL_SECONDS(…)
This returns the total number of seconds in the duration.
>>> print(f'the total number of seconds in 31 days is 
{ndlt.total_seconds()}')
the total number of seconds in 31 days is 2678400.0
>>> ndlt = timedelta(31, 25, hours = -­
3)
>>> print(f'the total number of seconds in 31 days is 
{ndlt.total_seconds()}')
the total number of seconds in 31 days and 25 seconds 
minus 3 hours is 2667625.0
The Time Module
The second of these modules is the time module. It comes with the standard 
Python distribution, so there is no need for you to install anything in par­
ticular. This module can be imported and used directly within your program 
when needed. The following statements get us a list of the names defined in 
the module:
>>> import time
>>> dir(time)
['_STRUCT_TM_ITEMS', '__doc__', '__loader__', '__
name__', '__package__', '__spec__', 'altzone', 
'asctime', 'clock', 'ctime', 'daylight', 'get_clock_
info', 'gmtime', 'localtime', 'mktime', 'monotonic', 
'monotonic_ns', 'perf_counter', 'perf_counter_ns', 
'process_time', 'process_time_ns', 'sleep', 
'strftime', 'strptime', 'struct_time', 'thread_time', 
'thread_time_ns', 'time', 'time_ns', 'timezone', 
'tzname']
In the following, we explain the names, including attributes and functions, 
available in the time module on a Windows platform. The code samples are all 
shown as they would appear in a Python interactive shell. If you wish to see 

all functions defined in the time module, please read the documentation at 
https://​
docs​
.python​
.org/​
3/​
library/​
time​
.html.
	406	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
TIME.ALTZONE
This is an attribute that contains the offset of the local DST timezone in seconds 
west of UTC, if one is defined. The value is negative if the local DST timezone is 
east of UTC (as in Western Europe, including the UK). Only use this if daylight 
is nonzero.
>>> import time
>>> print("local time zone is %d " % (time.altzone/3600))
local time zone is 6
TIME.ASCTIME(TUPLETIME)
This accepts a time-­
tuple and returns a readable 24-­
character string such as Tue 
Dec 11 18:07:14 2008. A time-­
tuple has nine elements, as returned by gmtime() 
or localtime().
>>> import time   # you only need to import a module 
once, so this is just in case
>>> print("local time is %s " % (time.asctime()))
local time is Tue Nov 12 15:10:50 2019
>>> time.asctime(tuple(time.localtime()))
'Tue Nov 12 15:24:05 2019'
TIME.CLOCK()
This returns a floating-­
point number for the CPU time or real time since the 
start of the process or since the first call to clock(). It is very useful, especially 
when measuring the computational cost of a code block.
>>> time.clock()
428446.1717301
TIME.CTIME([SECS])
This returns a time in seconds since the epoch to a string in the local time. 
Remember that the argument in [] is optional.
This has the same result as asctime(localtime(secs)), and simply a call of 
asctime(), which will use the current local time in seconds.
>>> time.asctime()
'Tue Nov 12 15:24:49 2019'
>>> time.ctime()
'Tue Nov 12 15:24:55 2019'
	
Modules and Packages	
407
 https://doi.org/10.15215/remix/9781998944088.01
TIME.GET_CLOCK_INFO(NAME)
This returns information on the specified clock as a namespace object. Sup­
ported clock names and the corresponding functions to read their value are 
the following: monotonic, perf_counter, process_time, thread_time, and time.
>>> time.get_clock_info('monotonic')
namespace(adjustable = False, 
implementation='GetTickCount64()', monotonic=True, 
resolution = 0.015625)
>>> time.get_clock_info('time')
namespace(adjustable = True, implementation = 
'GetSystemTimeAsFileTime()', monotonic=False, 
resolution=0.015625)
TIME.GMTIME([SECS])
This accepts an instant expressed in seconds since the epoch and returns 

a time-­
tuple t with the UTC time. Note: t.tm_isdst is always 0.
>>> time.gmtime()
time.struct_time(tm_year = 2019, tm_mon = 11, tm_mday = 
12, tm_hour = 22, tm_min = 21, tm_sec = 31, tm_wday = 1, 
tm_yday = 316, tm_isdst = 0)
>>> tuple(time.gmtime())
(2019, 11, 12, 22, 22, 2, 1, 316, 0)
TIME.LOCALTIME([SECS])
This accepts an instant expressed in seconds since the epoch and returns 

a time-­
tuple t with the local time (t.tm_isdst is 0 or 1, depending on whether 
DST applies to instant secs by local rules).
>>> time.localtime()
time.struct_time(tm_year = 2019, tm_mon = 11, tm_mday = 
12, tm_hour = 15, tm_min = 19, tm_sec = 0, tm_wday = 1, 
tm_yday = 316, tm_isdst = 0)
>>> tuple(time.localtime())
(2019, 11, 12, 15, 22, 32, 1, 316, 0)
TIME.MKTIME(TUPLETIME)
This accepts a time instant expressed as a time-­
tuple in the local time and returns 
a floating-­
point value, with the instant expressed in seconds since the epoch.
	408	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> time.mktime((2019, 11, 12, 22, 22, 2, 1, 316, 0))
1573622522.0
TIME.MONOTONIC()
This returns the value of a monotonic clock as a float number, the number 
of seconds since the previous call. The clock is not affected by system clock 
updates. The reference point of the returned value is undefined, so that only 
the difference between the results of consecutive calls is valid.
>>> time.monotonic()
1557979.093
TIME.MONOTONIC_NS()
This is similar to monotonic() but returns time as nanoseconds.
>>> time.monotonic_ns()
1557954406000000
TIME.PERF_COUNTER()
This returns the value of a performance counter as a float number since the 
previous call. A performance counter is a clock with the highest available 
resolution to measure a short duration. It includes time elapsed during 
sleep and is system-­
wide. The reference point of the returned value is 
undefined, so that only the difference between the results of consecutive calls 

is valid.
>>> time.perf_counter()
429437.6389873
TIME.PERF_COUNTER_NS()
This is similar to perf_counter() but returns time as nanoseconds.
>>> time.perf_counter_ns()
429556266018100
TIME.PROCESS_TIME()
This returns the value (in fractional seconds) of the sum of the system and the 
user CPU time of the current process. It does not include time elapsed during 
sleep. It is process-­
wide by definition. The reference point of the returned value 
	
Modules and Packages	
409
 https://doi.org/10.15215/remix/9781998944088.01
is undefined so that only the difference between the results of consecutive 
calls is valid.
>>> time.process_time()
6.71875
TIME.PROCESS_TIME_NS()
This is similar to process_time() but returns time as nanoseconds.
>>> time.process_time_ns()
6687500000
TIME.SLEEP(SECS)
This suspends the calling thread for secs (seconds). It can be used to delay 
programs.
>>> time.sleep(6)   # sleep 6 seconds
TIME.STRFTIME(FMT[,TUPLETIME])
This accepts an instant expressed as a time-­
tuple in the local time and returns 
a string representing the instant as specified by string fmt.
>>> t = (2019, 11, 17, 17, 3, 38, 1, 48, 0)
>>> t = time.mktime(t)
>>> print(time.strftime("%b %d %Y %H:%M:%S", time.
gmtime(t)))
Nov 18 2019 00:03:38
TIME.STRPTIME(STRINGTIME[, FMT])
This parses str according to format string fmt and returns the instant in 
time-­
tuple format.
>>> time.strptime('Tue Nov 12 15:24:05 2019','%a %b %d 
%H:%M:%S %Y')
time.struct_time(tm_year = 2019, tm_mon = 11, tm_mday = 
12, tm_hour = 15, tm_min = 24, tm_sec = 5, tm_wday = 1, 
tm_yday = 316, tm_isdst = -­
1)
>>> tuple(time.strptime('Tue Nov 12 15:24:05 2019','%a %b 
%d %H:%M:%S %Y'))
(2019, 11, 12, 15, 24, 5, 1, 316, -­
1)
	410	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
TIME.TIME()
This returns the current time instant, a floating-­
point number of seconds 

since the epoch.
>>> time.time()
1573607220.4043384
>>> time.asctime(time.localtime(time.time()))   # it is 
the same as time.asctime()
'Mon Jun 8 13:59:35 2020'
>>> time.asctime()
'Mon Jun 8 13:59:45 2020'
The Calendar Module
If you prefer a simple and more direct module to handle time and date, you 
can use the calendar module, as detailed below.
CALENDAR.CALENDAR(YEAR, W = 2, L = 1, C = 6)
This returns a formatted calendar for year—­
a multiline string formatted into 
three columns separated by c spaces. w is the width in characters of each date; 
each line has length 21 * w + 18 + 2 * c. l is the number of lines for each week.
>>> import calendar as cl
>>> print(cl.calendar(2021))
                                2021
       January                 February                 March
Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su
             1  2  3     1  2  3  4  5  6  7     1  2  3  4  5  6  7
 4  5  6  7  8  9 10     8  9 10 11 12 13 14     8  9 10 11 12 13 14
11 12 13 14 15 16 17    15 16 17 18 19 20 21    15 16 17 18 19 20 21
18 19 20 21 22 23 24    22 23 24 25 26 27 28    22 23 24 25 26 27 28
25 26 27 28 29 30 31                            29 30 31
       April                    May                     June
Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su
          1  2  3  4                    1  2        1  2  3  4  5  6
 5  6  7  8  9 10 11     3  4  5  6  7  8  9     7  8  9 10 11 12 13
12 13 14 15 16 17 18    10 11 12 13 14 15 16    14 15 16 17 18 19 20
19 20 21 22 23 24 25    17 18 19 20 21 22 23    21 22 23 24 25 26 27
26 27 28 29 30          24 25 26 27 28 29 30    28 29 30
                        31
	
Modules and Packages	
411
 https://doi.org/10.15215/remix/9781998944088.01
       July                    August                September
Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su
          1  2  3  4                       1           1  2  3  4  5
 5  6  7  8  9 10 11     2  3  4  5  6  7  8     6  7  8  9 10 11 12
12 13 14 15 16 17 18     9 10 11 12 13 14 15    13 14 15 16 17 18 19
19 20 21 22 23 24 25    16 17 18 19 20 21 22    20 21 22 23 24 25 26
26 27 28 29 30 31       23 24 25 26 27 28 29    27 28 29 30
                        30 31
       October                November                December
Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su
             1  2  3     1  2  3  4  5  6  7           1  2  3  4  5
 4  5  6  7  8  9 10     8  9 10 11 12 13 14     6  7  8  9 10 11 12
11 12 13 14 15 16 17    15 16 17 18 19 20 21    13 14 15 16 17 18 19
18 19 20 21 22 23 24    22 23 24 25 26 27 28    20 21 22 23 24 25 26
25 26 27 28 29 30 31    29 30                   27 28 29 30 31
CALENDAR.FIRSTWEEKDAY()
This returns an integer that is the current setting for the weekday that starts each 
week. By default, when the calendar module is first imported, it is 0 for Monday.
>>> import calendar as cl
>>> cl.firstweekday()
0
CALENDAR.ISLEAP(YEAR)
This tests if a year is a leap year. It returns True if it is; it returns False otherwise.
>>> cl.isleap(2022)
False
CALENDAR.LEAPDAYS(Y1, Y2)
This returns the total number of leap days in the years within range(y1, y2).
>>> cl.leapdays(2020, 2030)
3
CALENDAR.MONTH(YEAR, MONTH, W = 2, L = 1)
This returns a multiline string with a calendar for month of year, one line per 
week plus two header lines. w is the width in characters of each date; each line 
has length 7 * w + 6. l is the number of lines for each week.
	412	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> print(cl.month(2021, 3))
     March 2021
Mo Tu We Th Fr Sa Su
 1  2  3  4  5  6  7
 8  9 10 11 12 13 14
15 16 17 18 19 20 21
22 23 24 25 26 27 28
29 30 31
CALENDAR.MONTHCALENDAR(YEAR, MONTH)
This returns a list of sublists of integers. Each sublist denotes a week starting 
from Monday. Days outside month of year are set to 0; days within the month 
are set to their day-­
of-­
month, 1 and up. The result as a list of sublists can be 
conveniently used in applications. For example, you can easily tell what date 
it is for Monday of the third week of a month.
>>> print(cl.monthcalendar(2020, 6))
[[1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12, 13, 14], [15, 16, 17, 18, 
19, 20, 21], [22, 23, 24, 25, 26, 27, 28], [29, 30, 0, 0, 0, 0, 0]]
CALENDAR.MONTHRANGE(YEAR, MONTH)
This returns two integers. The first one is the code of the weekday for the first 
day of the month in year; the second one is the number of days in the month. 
Weekday codes are 0 (Monday) to 6 (Sunday); month numbers are 1 (January) 
to 12 (December). This is useful if you want to print a calendar that begins on 
a specific day of the week.
>>> print(cl.monthrange(2020, 6))
(0, 30)
CALENDAR.PRCAL(YEAR, W = 2, L = 1, C = 6)
This prints a well-­
formatted calendar of a given year. It is the same as calendar.
calendar(year, w, l, c). Remember that w is the width of each date in number 
of characters and l is the number of lines for each week.
>>> cl.prcal(2020, w = 2, l = 1, c = 6)
                                 2020
       
January                 
February                  
March
Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su
       1  2  3  4  5                   1  2                       1
 6  7  8  9 10 11 12     3  4  5  6  7  8  9     2  3  4  5  6  7  8
13 14 15 16 17 18 19    10 11 12 13 14 15 16     9 10 11 12 13 14 15
20 21 22 23 24 25 26    17 18 19 20 21 22 23    16 17 18 19 20 21 22
27 28 29 30 31          24 25 26 27 28 29       23 24 25 26 27 28 29
                                                30 31
	
Modules and Packages	
413
 https://doi.org/10.15215/remix/9781998944088.01
 
        
April                    May                     June
Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su
       1  2  3  4  5                 1  2  3     1  2  3  4  5  6  7
 6  7  8  9 10 11 12     4  5  6  7  8  9 10     8  9 10 11 12 13 14
13 14 15 16 17 18 19    11 12 13 14 15 16 17    15 16 17 18 19 20 21
20 21 22 23 24 25 26    18 19 20 21 22 23 24    22 23 24 25 26 27 28
27 28 29 30             25 26 27 28 29 30 31    29 30
 
        July                   August                 
September
Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su
       1  2  3  4  5                    1  2        1  2  3  4  5  6
 6  7  8  9 10 11 12     3  4  5  6  7  8  9     7  8  9 10 11 12 13
13 14 15 16 17 18 19    10 11 12 13 14 15 16    14 15 16 17 18 19 20
20 21 22 23 24 25 26    17 18 19 20 21 22 23    21 22 23 24 25 26 27
27 28 29 30 31          24 25 26 27 28 29 30    28 29 30
                        31
 
       
October                 November                December
Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su    Mo Tu We Th Fr Sa Su
          1  2  3  4                       1        1  2  3  4  5  6
 5  6  7  8  9 10 11     2  3  4  5  6  7  8     7  8  9 10 11 12 13
12 13 14 15 16 17 18     9 10 11 12 13 14 15    14 15 16 17 18 19 20
19 20 21 22 23 24 25    16 17 18 19 20 21 22    21 22 23 24 25 26 27
26 27 28 29 30 31       23 24 25 26 27 28 29    28 29 30 31
                        30
CALENDAR.PRMONTH(YEAR, MONTH, W = 2, L = 1)
This prints a well-­
formatted calendar month, the same as the one created by 
calendar.month(year, month, w, l).
>>> cl.prmonth(2020, 6, w = 2, l = 1)
      June 2020
  Mo Tu We Th Fr Sa Su
   1  2  3  4  5  6  7
   8  9 10 11 12 13 14
  15 16 17 18 19 20 21
  22 23 24 25 26 27 28
  29 30
	414	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
CALENDAR.SETFIRSTWEEKDAY(WEEKDAY)
This sets the first day of each week. Weekday codes are 0 (Monday by default) 
to 6 (Sunday by default), so if you change this, you will see the days in the 
calendar shift.
>>> cl.setfirstweekday(6)   # set to start from Sunday
>>> cl.prmonth(2020, 6, w = 2, l = 1)
       June 2020
  Su Mo Tu We Th Fr Sa
      1  2  3  4  5  6
   7  8  9 10 11 12 13
  14 15 16 17 18 19 20
  21 22 23 24 25 26 27
  28 29 30
CALENDAR.TIMEGM(TUPLETIME)
This is the inverse of time.gmtime. It accepts a time instant in time-­
tuple form and 
returns the same instant as a floating-­
point number of seconds since the epoch.
>>> cl.timegm((2020, 6, 19, 11, 35, 56))
1592566556
CALENDAR.WEEKDAY(YEAR, MONTH, DAY)
This returns the weekday code for the given date. Weekday codes are 0 (Monday) 
to 6 (Sunday); month numbers are 1 (January) to 12 (December).
>>> import calendar as cl
>>> cl.weekday(2020, 6, 19)   # it is a Friday
4
Our last example in Jupyter Lab is to display a calendar for March of 1961.
import calendar
cld = calendar.month(1961, 3)
print(cld)
       March 1961
  Mo Tu We Th Fr Sa Su
         1  2  3  4  5
   6  7  8  9 10 11 12
  13 14 15 16 17 18 19
  20 21 22 23 24 25 26
  27 28 29 30 31
	
Modules and Packages	
415
 https://doi.org/10.15215/remix/9781998944088.01
With the calendar module, you will be able to produce a calendar of any 
year you want.
8.7 Modules for Data Representation and Exchange
JavaScript Object Notation (JSON) is a lightweight data interchange format widely 
used today. JSON can be used to represent different types of data, though the 
most used are objects or associate arrays made of key-­
value pairs. When used for 
data interchanges between applications, JSON data are represented in a string 
so that they can be stored, transmitted, and parsed by different applications.
Python has a built-­
in module called json to handle JSON data. The following 
two statements will get us a list of the few names defined in the json module:
>>> import json
>>> dir(json)
['JSONDecodeError', 'JSONDecoder', 'JSONEncoder', '__all__', 
'__author__', '__builtins__', '__cached__', '__doc__', 
'__file__', '__loader__', '__name__', '__package__', 
'__path__', '__spec__', '__version__', '_default_decoder', 
'_default_encoder', 'codecs', 'decoder', 'detect_encoding', 
'dump', 'dumps', 'encoder', 'load', 'loads', 'scanner']
In the following, we explain two pairs of important functions provided in 
the json module. The first pair of functions is used to convert JSON data to 
Python data, which is called deserialization or decoding. The other is used 

to convert Python data to JSON data, which is called serialization.
JSON.LOADS(S, *, ENCODING=NONE, CLS=NONE, OBJECT_
HOOK=NONE, PARSE_FLOAT=NONE, PARSE_INT=NONE, 
PARSE_CONSTANT=NONE, OBJECT_PAIRS_HOOK=NONE, **KW)
This deserializes json data in s, which can be a str, byte, or bytearray instance 
containing a JSON document and returns a Python object of s. Or, in plainer 
terms, it converts a string of JSON data into a Python object and returns the 
converted Python object.
>>> import json
>>> sj = '{"firstname": "Jone", "lastname": "Doe"}'
>>> pdict = json.loads(sj)
>>> print(pdict)
 
{'firstname': 'Jone', 'lastname': 'Doe'}
	416	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
JSON.LOAD(FP
, *, CLS = NONE, OBJECT_HOOK = NONE, PARSE_
FLOAT=NONE, PARSE_INT = NONE, PARSE_CONSTANT = NONE, 
OBJECT_PAIRS_HOOK = NONE, **KW)
This deserializes data in a file object or file-­
like object, such as a socket, referred 
to as fp that contains a JSON document, making it a Python object. Note the 
difference between loads and load function: loads convert JSON data in a string, 
whereas load converts JSON data in a file.
>>> import json
>>> from io import StringIO
>>> sio = StringIO('{"firstname": "Jone", "lastname": 
"Doe"}')
>>> json.load(sio)
{'firstname': 'Jone', 'lastname': 'Doe'}
The next pair of functions are used to convert Python objects into JSON data. 
This process is called serialization or encoding.
JSON.DUMPS(OBJ, *, SKIPKEYS=FALSE, ENSURE_ASCII=TRUE, 
CHECK_CIRCULAR=TRUE, ALLOW_NAN = TRUE, CLS = NONE, 
INDENT = NONE, SEPARATORS = NONE, DEFAULT = NONE, SORT_
KEYS=FALSE, **KW)
This serializes a Python object obj and returns a JSON-­
formatted string of the 
object.
>>> print(pdict)
{'firstname': 'Jone', 'lastname': 'Doe'}
>>> js = json.dumps(pdict)
>>> print(js)   # please note the double quotation marks 
used in JSON-­
formatted data
{"firstname": "Jone", "lastname": "Doe"}
JSON.DUMP(OBJ, FP
, *, SKIPKEYS = FALSE, ENSURE_ASCII = 
TRUE, CHECK_CIRCULAR = TRUE, ALLOW_NAN = TRUE, CLS = 
NONE, INDENT = NONE, SEPARATORS = NONE, DEFAULT = NONE, 
SORT_KEYS = FALSE, **KW)
This serializes the Python object obj and writes it as a JSON-­
formatted stream 
to a writable file or file-­
like object, such as a socket, referred to as fp.
	
Modules and Packages	
417
 https://doi.org/10.15215/remix/9781998944088.01
>>> from io import StringIO
>>> io = StringIO()
>>> json.dump({'firstname': 'Jone', 'lastname': 'Doe'}, io)
>>> io.getvalue()
'{"firstname": "Jone", "lastname": "Doe"}'
Conversions can be made between JSON and Python on different types of 

data. Table 8-­
2 shows those conversions.
Table 8-­
2: Conversion between JSON and Python data
Python
Sample Python 
data
JSON
Sample JSON 
data
dict
{'firstname': 
'Jone', 
'lastname': 
'Doe'}
Object
{"firstname": 
"Jone", 
"lastname": 
"Doe"}
list
['James', 
'Jone', 
'Smith', 
'Doe']
Array
["James", 
"Jone", 
"Smith", 
"Doe"]
tuple
('James', 
'Jone', 
'Smith', 
'Doe')
Array
["James", 
"Jone", 
"Smith", 
"Doe"]
str
"James, Jone, 
Smith, Doe"
String
"James, Jone, 
Smith, Doe"
int
98765321
Number
98765321
float
98765.321
Number
98765.321
True
True
true
true
False
False
false
false
None
None
null
null
As you can see, all basic Python data can be converted/serialized into JSON 
data, and vice versa. However, trying to serialize multiple Python objects by 
repeatedly calling dump() using the same file handle will result in an invalid 
JSON file because when doing deserialization with load() from the file, load has 
no way to find out the boundary between different JSON data. As such, there 
will be only one serialized Python object per file.
	418	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
8.8 Modules for Interfacing Operating Systems and 
Python Interpreter
On a computer, all applications run on top of an operating system (OS) such as 
Windows, MacOS, or Linux. Therefore, quite often when developing applica­
tions, you will need to interact with an OS, file paths, and the Python interpreter. 
In Python, the built-­
in os module, path submodule of os, and sys module provide 
powerful and convenient ways to interact with the OS, the file path, the Python 
interpreter, and the runtime environment.
OS Module for Interacting with the Operating System
Since it is a built-­
in module, all you need to do to use the os module is import it, 
as shown below:
import os
If you use the dir(os) statement, you can get a rather big list of names defined in 
the module. Note that because the os module is operating-­
system dependent, 
you may get a different list of names available depending on your platform (e.g., 
Windows or Linux).
The following are some functions provided in the os module. You are encour­
aged to test these functions with your own examples on your own machine.
OS.ACCESS(PATH, MODE)
This tests if access to path is in mode, which is an integer such as 777 (111111111) 
representing the global, group, and user’s executable, write, and read rights.
>>> import os
>>> p = os.path.abspath(".")
>>> p
'd:\\workshop'
>>> os.access(p,763)
True
OS.CHDIR(PATH)
This changes the current working directory to path.
>>> os.chdir('c:\\workbench')
>>> os.getcwd()
' c:\\workbench'
>>> os.listdir()
['myprimes.txt', ' news_01.txt', ' personal']
	
Modules and Packages	
419
 https://doi.org/10.15215/remix/9781998944088.01
OS.CHMOD(PATH, MODE)
This changes the mode of path to the numeric mode.
>>> os.chmod('c:\\workbench', 477)
OS.CHOWN(PATH, UID, GID)
This changes the owner and group id of path to the numeric uid and gid. Please 
note that these operations are more similar to what you would do on a Unix/
Linux system, all subject to permission by the operating system.
OS.CLOSE(FD)
This closes the file descriptor fd. A file descriptor is returned by the os.open() 
function.
>>> fd = os.open('/home/james/testing.txt')
>>> os.close(fd)
OS.CPU_COUNT()
This returns the number of CPUs in the system; it will return None if the num­
ber is indeterminable.
>>> os.cpu_count()
8
OS.GET_EXEC_PATH(ENV=NONE)
This returns the sequence of directories that will be searched for by the named 
executable.
>>> import os
>>> print(os.get_exec_path())
['/opt/tljh/user/bin', '/usr/local/sbin', '/usr/local/
bin', '/usr/sbin', '/usr/bin', '/sbin', '/bin', '/snap/
bin']
OS.GETCWD()
This returns a Unicode string representing the current working directory.
>>> import os
>>> print(os.getcwd())
/home/jupyter-­
kevin
	420	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
OS.GETCWDB()
This returns a byte string representing the current working directory.
>>> import os
>>> print(os.getcwdb())
b'/home/jupyter-­
kevin'
OS.GETENV(KEY, DEFAULT=NONE)
This returns an environment variable and returns None if it does not exist. The 
optional second argument can specify an alternate default.
OS.GETLOGIN()
This returns the actual login name.
>>> os.getlogin()
kevin
OS.LINK(SRC, DST)
This creates a hard link pointing to src named dst.
OS.LISTDIR(PATH)
This returns a list containing the names of the entries in the directory given 
by path.
>>> os.listdir('.')
['backups', 'Pipfile', 'snap']
OS.MKDIR(PATH, MODE=511, DIR_FD=NONE)
This function is used to create a directory, the mode argument only used on 
Unix-­
like systems, and will be ignored on Windows. The path argument is 
required; the mode argument is optional and takes an integer representing 
permission for the path to be created. Argument _dir_fd is a file descriptor 
referring to a directory that the new directory will be under; the path is not an 
absolute path. The default value is None.
>>> import os
>>> os.mkdir('/home/james/learn_python')
>>> os.listdir('.')
['backups', 'learn_python', 'Pipfile', 'snap']
	
Modules and Packages	
421
 https://doi.org/10.15215/remix/9781998944088.01
OS.MAKEDIRS(PATH, MODE = 511, EXIST_OK = FALSE)
This recursively makes directories. For example, if the path is ./comp218/
assignment1, it will first make a directory named comp218 under the current 
working directory, if it doesn’t exist, then make assignment1 under comp218. 
The optional mode argument is the same as the one in os.mkdir(). The optional 
exist_ok argument tells if the operation will continue if the leaf directory already 
exists. The default is False, meaning that a FileExistsError will be raised if the 
leaf directory already exists.
OS.OPEN(PATH, FLAGS, MODE = 511, *, DIR_FD = NONE)
This opens the file path and sets various flags for low-­
level IO and returns a 
file descriptor to be used by other functions in the os module. Argument dir_fd 
should be a file descriptor open to a directory (if not default None) and can be 
used to provide a directory that the file path is relative to. The flags argument 
tells what the path is opened for. It can take one or some of the following values 
joined with or |: os.O_RDONLY, os.O_WRONLY, os.O_RDWR, os.O_APPEND, 
os.O_CREAT, os.O_EXCL¶, os.O_TRUNC. These values are available on both 
Windows and Unix platforms.
OS.PUTENV(NAME, VALUE)
This changes or adds an environment variable if name doesn’t exist yet.
>>> os.times()
nt.times_result(user = 4.125, system = 1.890625, children_
user = 0.0, children_system = 0.0, elapsed = 0.0)
OS.READ(FD, N)
This reads at most n bytes from file descriptor fd and returns a string containing 
the bytes read. If the end of the file referred to by fd has been reached, an 
empty string is returned.
OS.UMASK(MASK)
This sets the current numeric umask to mask and returns the previous umask. 
umask is used by operating systems to determine the default permission for 
newly created files.
>>> import os
>>> os.umask(666)   # from now on all new files created 
will have umask 666 till next change
256
	422	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
OS.URANDOM(SIZE)
This returns a bytes object containing random bytes suitable for cryptographic use.
>>> os.urandom(5)
b'-­
\x8e\xeb\xf1\x7f'
OS.UTIME(PATH, TIMES = NONE)
This sets the access and modified times of path, such as on a file.
OS.WALK(TOP)
This is a directory-­
tree generator and returns a walk object. For each directory 
in the directory tree rooted at top, it will yield a three-­
tuple (dirpath, dirnames, 
filenames), in which dirpath is a string, the path to the directory; dirnames is 
a list of the names of the subdirectories in dirpath; and filenames is a list of 
the names of the nondirectory files in dirpath.
Note that the names in the lists are just names, with no path components. 
To get a full path (which begins with top) to a file or directory in dirpath, use 
os.path.join(dirpath, name).
In [ ]:
import os
# loop through all the directories and files
for dirName, subdirList, fileList in os.walk('.'):
    print('Found directory: %s' % dirName)
    for fname in fileList:
        print('\t%s' % fname)
Out [ ]:
Found directory: ./samples
        average marks​
.py
        brutal attack on cipher​
.py
        circle​
-­
­
v2​
.py
Found directory: ./samples/chapter3
    randomness​
.py
    regex1​
.py
    scratch​
-­
­
v3​
.py
    sieve prime​
.py
OS.WALK(TOP
, TOPDOWN = TRUE, ONERROR = NONE, 
FOLLOWLINKS = FALSE)
This generates the file names in a directory tree by walking the tree either from 
the top down or from the bottom up. The os.walk function will be very useful 
in completing one of the projects in the textbook.
	
Modules and Packages	
423
 https://doi.org/10.15215/remix/9781998944088.01
OS.WRITE(FD, STR)
This writes the string str to the file descriptor fd and returns the number of 
bytes actually written.
The path Submodule from os for Manipulating File Paths
When dealing with files and file systems, we quite often need to manipulate 
file paths. For that reason, the os module has a submodule called path. To use 
the path module, run the following statement:
>>> from os import path
The path module provides functions for joining and splitting paths, getting 
information about a path or file such as its size and timestamp, and testing 
whether a path is a file, a directory, a real path, or just a link.
PATH.ABSPATH(P)
This returns the absolute version of p.
>>> path.abspath('.')
'd:\\workshop\\comp218'
PATH.BASENAME(P)
This returns the final component of a pathname.
>>> os.path.basename(p)
'comp218'
PATH.COMMONPATH(PATHS)
This returns the longest common subpath for a given sequence of pathnames.
>>> os.path.commonpath(['d:/workshop/comp218','d:/
workshop/comp369'])
'd:\\workshop'
PATH.COMMONPREFIX(PATHS)
This returns the longest common leading component of a given list of pathnames.
>>> os.path.commonprefix(['d:/workshop/comp218','d:/
workshop/comp369'])
'd:/workshop/comp'
	424	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
PATH.DIRNAME(P)
This returns the directory component of a pathname.
>>> os​
.path​
.dirname​
(​
'd:​
/​
workshop/​
comp218/​
test​
.py')
'd:/workshop/comp218'
PATH.EXISTS(P)
This tests whether a path exists. It returns False for broken symbolic links.
>>> os​
.path​
.exists​
(​
'd:​
/​
workshop/​
comp218/​
test​
.py')
False
PATH.EXPANDUSER(P)
This expands ~ and ~user constructs, mostly for Unix/Linux systems. If user 
or $HOME is unknown, it does nothing.
>>> os​
.path​
.expanduser​
('​
~/​
workshop/​
comp218/​
test​
.py')
'C:\\Users\\kevin/​
workshop/​
comp218/​
test​
.py'
PATH.EXPANDVARS(P)
This expands shell variables of the forms $var, ${var}, and %var%. Unknown 
variables will be left unchanged.
PATH.GETATIME(FILENAME)
This returns the time a file was last accessed, as reported by os.stat().
PATH.GETCTIME(FILENAME)
This returns the time a file’s metadata was last changed, as reported by 
os.stat().
PATH.GETMTIME(FILENAME)
This returns the time a file was last modified, as reported by os.stat().
PATH.GETSIZE(FILENAME)
This returns the size of a file, as reported by os.stat().
PATH.ISABS(S)
This tests whether a path is absolute.
	
Modules and Packages	
425
 https://doi.org/10.15215/remix/9781998944088.01
PATH.ISDIR(P)
PATH._ISDIR(P)
These return True if the pathname refers to an existing directory.
>>> from os import path
>>> path.isdir('.')
True
PATH.ISFILE(P)
This tests whether a path is a regular file.
>>> from os import path
>>> path.isfile('.')
False
PATH.ISLINK(P)
This tests whether a path is a symbolic link. It will always return False for 
Windows prior to 6.0.
PATH.ISMOUNT(P)
This tests whether a path is a mount point (a drive root, the root of a share, or 
a mounted volume).
PATH.JOIN(P1, P2)
This is used to join two paths or a path with a file.
>>> from os import path
>>> fullpath = path.join('/comp218/', 'testfile')
>>> print(fullpath)
/comp218/testfile
PATH.LEXISTS(P)
This tests whether a path exists. It will return True for broken symbolic links.
PATH.NORMCASE(S)
This normalizes the case of a pathname. That is, it makes all characters lower 
case and all slashes backslashes.
PATH.NORMPATH(P)
This normalizes the path, eliminating double slashes, etc.
	426	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
PATH.ABSPATH(P)
This returns the absolute version of a path.
PATH.RELPATH(P
, START=NONE)
This returns a relative version of a path.
PATH.SAMEFILE(F1, F2)
This tests whether two pathnames reference the same actual file or directory.
PATH.SAMEOPENFILE(FP1, FP2)
This tests whether two open file objects reference the same file.
PATH.SAMESTAT(S1, S2)
This tests whether two stat buffers reference the same file.
PATH.SPLIT(P)
This splits a pathname and returns tuple (head, tail), where tail is everything 
after the final slash.
PATH.SPLITDRIVE(P)
This splits a pathname into a drive/UNC sharepoint and relative path specifiers 
and returns a two-­
tuple (drive_or_unc, path); either part may be empty.
PATH.SPLITEXT(P)
This splits the extension from a pathname. An extension is everything from 
the last dot to the end, ignoring leading dots. For some paths without a dot, the 
extension part will be empty.
The sys Module for Interaction Between the Python and Python 
Interpreter or Python Virtual Machine (PVM)
The os and path modules we studied above provide programmers with ways 
to interact with the operating system and to access the underlying interface 
of the operating system. The sys module we are going to study below allows 
programs to interact with Python interpreter.
The following are the objects defined in the sys module and maintained 
by Python interpreter. These objects are put into two groups: dynamic objects 
and static objects.
The following are the dynamic objects defined in the sys module. Dynamic 
means the values can be changed.
	
Modules and Packages	
427
 https://doi.org/10.15215/remix/9781998944088.01
SYS.ARGV
This holds command-­
line arguments; argv[0] is the script pathname if known. 
The following example shows what happens when we test it in Jupyter Lab:
# factorial.py
def fac(n):
    if n == 0:
        return 1
    else:
        return n * fac(n-­
1)
 
n = 9
 
print(f"{n}! = {fac(n)}")
 
import sys
print(f'argv = {sys.argv}')
 
python -­
u "d:\workshop\research\books\COMP218\samples\
factorial​
.py"
9! = 362880
argv = ['d:\\workshop\\research\\books\\COMP218\\
samples\\factorial​
.py']
SYS.PATH
This holds the module search path; path[0] is the script directory. The sys.path 
for the above Python program/script will be
sys.path = ['d:\\workshop\\research\\books\\COMP218\\
samples', 's:\\python\\python311\\python311.zip', 's:\\
python\\python311\\Lib', 's:\\python\\python311\\
DLLs', 'C:\\Users\\james\\AppData\\Roaming\\Python\\
Python311\\site-­
packages', 'C:\\Users\\james\\AppData\\
Roaming\\Python\\Python311\\site-­
packages\\win32', 'C:\\
Users\\james\\AppData\\Roaming\\Python\\Python311\\
site-­
packages\\win32\\lib', 'C:\\Users\\james\\AppData\\
Roaming\\Python\\Python311\\site-­
packages\\Pythonwin', 
's:\\python\\python311', 's:\\python\\python311\\Lib\\
site-­
packages']
	428	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
SYS.MODULES
This is a dictionary of all loaded modules. It will provide a long list of modules 
it is using.
SYS.DISPLAYHOOK
This contains an executable object and can be called to show the results in an 
interactive session.
>>> sys.displayhook
<ipykernel.displayhook.ZMQShellDisplayHook at 
0x15a70b56b48>
SYS.EXCEPTHOOK
This contains an executable object and can be called to handle any uncaught 
exception other than SystemExit.
SYS.STDIN
This contains the standard input file object; it is used by input().
SYS.STDOUT
It contains the standard output file object; it is used by print().
SYS.STDERR
This contains the standard error object; it is used for error messages.
SYS.LAST_TYPE
This contains the type of the last uncaught exception.
>>> sys.last_type
AttributeError
SYS.LAST_VALUE
This contains the value of the last uncaught exception.
>>> sys.last_value
AttributeError("module 'os' has no attribute 'chroot'")
SYS.LAST_TRACEBACK
This contains the traceback of the last uncaught exception.
	
Modules and Packages	
429
 https://doi.org/10.15215/remix/9781998944088.01
>>> sys.last_traceback
<traceback at 0x15a70ca9388>
The above three objects are only available in an interactive session after a 
traceback has been printed.
The next group of objects available from the sys module are called static objects, 
which means the values do not change for the given Python interpreter being 
used.
SYS.BUILTIN_MODULE_NAMES
This contains a tuple of built-­
in module names.
SYS.COPYRIGHT
This contains the copyright notice pertaining to the interpreter in use. sys.copy­
right in our case will produce the following, as an example:
Copyright (c) 2001–­
2022 Python Software Foundation.
All Rights Reserved.
 
Copyright (c) 2000 BeOpen​
.com.
All Rights Reserved.
 
Copyright (c) 1995–­
2001 Corporation for National Research 
Initiatives.
All Rights Reserved.
 
Copyright (c) 1991–­
1995 Stichting Mathematisch Centrum, 
Amsterdam.
All Rights Reserved.
SYS.EXEC_PREFIX
This contains the prefix used to find the machine-­
specific Python library.
SYS.EXECUTABLE
This contains the absolute path of the executable binary of the Python 
interpreter.
	430	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
SYS.FLOAT_INFO
This contains a named tuple with information about the float implementation.
SYS.FLOAT_REPR_STYLE
This contains a string indicating the style of repr() output for floats.
SYS.HASH_INFO
This contains a named tuple with information about the hash algorithm.
>>> print(sys.hash_info)
sys.hash_info(width = 64, modulus = 2305843009213693951, 
inf = 314159, nan = 0, imag = 1000003, algorithm = 
'siphash24', hash_bits = 64, seed_bits = 128, cutoff = 0)
SYS.HEXVERSION
This contains version information encoded as a single integer.
SYS.IMPLEMENTATION
This contains Python implementation information.
>>> print(sys.implementation)
namespace(cache_tag = 'cpython-­
37', hexversion = 
50792432, name = 'cpython', version =s ys.version_
info(major = 3, minor = 7, micro = 7, releaselevel = 
'final', serial = 0))
SYS.INT_INFO
This contains a named tuple with information about the int implementation.
>>> print(sys.int_info)
sys.int_info(bits_per_digit = 30, sizeof_digit = 4)
SYS.MAXSIZE
This contains the largest supported length of containers.
>>> print(sys.maxsize)
9223372036854775807
SYS.MAXUNICODE
This contains the value of the largest Unicode code point.
	
Modules and Packages	
431
 https://doi.org/10.15215/remix/9781998944088.01
>>> print(sys.maxunicode)
1114111
>>> print(chr(1114111))
􏿿
>>> print(chr(1114112))   # this is out of range and will 
cause an error
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
-­
ValueError   Traceback (most recent call last)
<ipython-­
input-­
81-­
1965bd6642f9> in <module>
-­
-­
-­
-­
> 1< print(chr<(1114112))
ValueError: chr() arg not in range(0x110000)
SYS.PLATFORM
This contains the platform identifier.
>>> print(sys.platform)
win32
SYS.PREFIX
This contains the prefix used to find the Python library.
>>> print(sys.prefix)
C:\ProgramData\Anaconda3
SYS.THREAD_INFO
This contains a named tuple with information about the thread implementation.
>>> print(sys.thread_info)
sys.thread_info(name = 'nt', lock = None, version = 
None)
SYS.VERSION
This contains the version of this interpreter as a string.
SYS.VERSION_INFO
This contains the version information as a named tuple.
SYS.DLLHANDLE
This is the integer handle of the Python DLL (Windows only).
	432	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
SYS.WINVER
This contains the version number of the Python DLL (Windows only).
SYS.__STDIN__
This is the original stdin.
SYS.__STDOUT__
This is the original stdout.
SYS.__STDERR__
This is the original stderr.
SYS.__DISPLAYHOOK__
This is the original displayhook.
SYS.__EXCEPTHOOK__
This is the original excepthook.
The following are functions also defined in the sys module.
SYS.DISPLAYHOOK()
This function prints an object to the screen and saves it in builtins.
SYS.EXCEPTHOOK()
This function prints an exception and its traceback to sys.stderr.
SYS.EXC_INFO()
This function returns thread-­
safe information about the current exception.
SYS.EXIT()
This function exits the interpreter by raising SystemExit.
SYS.GETDLOPENFLAGS()
This function returns flags to be used for dlopen() calls.
SYS.GETPROFILE()
This function returns the global profiling function.
	
Modules and Packages	
433
 https://doi.org/10.15215/remix/9781998944088.01
SYS.GETREFCOUNT()
This function returns the reference count for an object.
SYS.GETRECURSIONLIMIT()
This function returns the max recursion depth for the interpreter.
SYS.GETSIZEOF()
This function returns the size of an object in bytes.
>>> from datetime import datetime
>>> import sys
>>> dt1 = datetime.now()
>>> print(sys.getsizeof(dt1))
48
SYS.GETTRACE()
This function gets the global debug tracing function.
SYS.SETCHECKINTERVAL()
This function controls how often the interpreter checks for events.
SYS.SETDLOPENFLAGS()
This function sets the flags to be used for dlopen() calls.
SYS.SETPROFILE()
This function sets the global profiling function.
SYS.SETRECURSIONLIMIT()
This function sets the max recursion depth for the interpreter.
SYS.SETTRACE()
This function sets the global debug tracing function.
As can be seen, the sys module gives programmers a way to find out informa­
tion about the Python interpreter and the runtime environment in particular.
	434	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
8.9 Module for Logging Events During Program 
Runtime
In some applications, sometimes it’s necessary or desirable to keep a rec­
ord of what happened with the program for performance improvement, 
error debugging, security, and audit purposes. Examples of such events/
data include, but are not limited to, how many times a function/method has 
been called, how long a function call takes, how much memory it used, and 
so on. In Python, a package called logging is available for logging within its 
standard distribution.
Due to the variety of purposes stated above, logged events can be classified 
into the following five categories based on the nature or severity of the events, 
in the view of the users of the application, as shown in Table 8-­
3.
Table 8-­
3: Levels of logging
Category of logs
Description
Numeric value of 
the level
NOTSET
The level hasn't been set.
0
DEBUG
Events are useful for error 
debugging. This is the lowest 
level of severity.
10
INFO
Information can be useful for 
improving the performance 
of the application/program or 
for assurance of security and 
auditing.
20
WARNING
Something needs checking.
30
ERROR
These errors are often logical and 
should be checked.
40
CRITICAL
The event is critical for the program 
to perform correctly and should 
be checked and resolved. This is 
highest level of severity.
50
The logging library defines several classes and module-­
level functions, and it 
is the latter that you would be using directly in your programs and applications. 
The basicConfig() function is used to set up the logging file and other param­
eters for the logger. The logging() function is for logging messages describing 
events in each category, as shown in the following code sample:
	
Modules and Packages	
435
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
import logging
logging.debug('Everything logged with logging.debug is 
labelled as debug')
logging.info('Everything logged with logging.info is 
labelled as info')
logging.warning('Everything logged with logging.warning 
is labelled as warning')
logging.error('Everything logged with logging.error is 
labelled as error')
logging.critical('Everything logged with logging.
critical is labelled as critical')
The output of the code above is shown below:
Out [ ]:
WARNING:root:Everything logged with logging.warning is labelled as warning 
ERROR:root:Everything logged with logging.error is labelled as error 
CRITICAL:root:Everything logged with logging.critical is labelled as critical
You may have noted that output from the debug and info logging functions are 
missing from the output. This is because the default configuration of the logging 
module only logs events at warning level or higher. To change the default log-
ging level, you can call a function of the logging module named basicConfig(), as 

shown in the following example:
1
import logging
2
3
logging.basicConfig(level=logging.DEBUG,
4
filename='c:\\users\\james\\myapp.log',
5
filemode='w', format='%(name)s -­
 %(levelname)s -­
 %(message)
s')   # this line belongs to the basicConfig call as well
6
logging.debug('Everything logged with logging.debug is 
labelled as debug')
7
logging.info('Everything logged with logging.info is 
labelled as info')
8
logging.warning('Everything logged with logging.warning is 
labelled as warning')
9
logging.error('Everything logged with logging.error is 
labelled as error')
10
logging.critical('Everything logged with logging.critical 
is labelled as critical')
Instead of directly printing out to the terminal, this code writes the logs to a 
file named myapp.log, and the content of the generated logging file myapp.
log is as follows:
	436	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
root -­
 DEBUG -­
 Everything logged with logging.debug is labelled as debug
root -­
 INFO -­
 Everything logged with logging​
.info is labelled as info
root -­
 WARNING -­
 Everything logged with logging.warning is labelled as 
warning
root -­
 ERROR -­
 Everything logged with logging.error is labelled as error
root -­
 CRITICAL -­
 Everything logged with logging.critical is labelled 
as critical
Now as can be seen, DEBUG and INFO are recorded in the logging file 
because we changed the logging level to DEBUG.
Please note that for logging configuration to take full effect, all should be 
configured in a single basicConfig() method call. If the statement becomes too 
long to fit in a single line, the statement can take two or more lines, as long as 
newline is not within the string or word, as shown above.
In the basicConfig() function call shown above, keyword arguments are used 
to set the level of logging to DEBUG, the logging file name to c:\users\james\
myapp.log, and the log file mode to w for write, which means that everything 
in the log file will be overwritten by new logging messages. If you want to keep 
the old logs and add the new logs to the end of the old logs, you need to set the 
file mode to a for append, which is the default set by the logging mode.
It has been noted that the basicConfig() function for logging is not fully 
functional within Jupyter Notebook. To change the logging level within Jupyter 
Notebook, you can use the logging.getLogger().setLevel() method. However, you 
cannot set the logging file name and logging file mode within Jupyter Notebook.
8.10 Modules for Playing and Manipulating Audio 
and Video Files
This section covers how to develop sound-­
 and music-­
related applications with 
Python.
winsound
To play WAV files in your Windows applications, you can use the winsound 
module included in the standard Python distribution. You can import the mod­
ule and use the functions defined in it without installing the module. Using 
the following statements, you can get a list of names defined in the module:
>>> import winsound
>>> dir(winsound)
['Beep', 'MB_ICONASTERISK', 'MB_ICONEXCLAMATION', 'MB_
ICONHAND', 'MB_ICONQUESTION', 'MB_OK', 'MessageBeep', 
	
Modules and Packages	
437
 https://doi.org/10.15215/remix/9781998944088.01
'PlaySound', 'SND_ALIAS', 'SND_APPLICATION', 'SND_
ASYNC', 'SND_FILENAME', 'SND_LOOP', 'SND_MEMORY', 
'SND_NODEFAULT', 'SND_NOSTOP', 'SND_NOWAIT', 'SND_PURGE', 
'__doc__', '__file__', '__loader__', '__name__', '__
package__', '__spec__']
For more details about the module and functionalities provided, run 
help(winsound) in Python interactive mode, as shown below:
>>> import winsound
>>> help(winsound)
 Help on module winsound:
NAME
winsound
DESCRIPTION
PlaySound(sound, flags)—­
play a sound
SND_FILENAME—­
sound is a wav file name
SND_ALIAS—­
sound is a registry sound association name
SND_LOOP—­
play the sound repeatedly; must also specify 
SND_ASYNC
SND_MEMORY—­
sound is a memory image of a wav file
SND_PURGE—­
stop all instances of the specified sound
SND_ASYNC—­
PlaySound returns immediately
SND_NODEFAULT—­
Do not play a default beep if the sound 
cannot be found
SND_NOSTOP—­
Do not interrupt any sounds currently 
playing
SND_NOWAIT—­
Return immediately if the sound driver is 
busy
Beep(frequency, duration)—­
Make a beep through the PC 
speaker.
MessageBeep(type)—­
Call Windows MessageBeep.
FUNCTIONS
eep(frequency, duration)
A wrapper around the Windows Beep API.
frequency
Frequency of the sound in hertz.
Must be in the range 37 through 32,767.
duration
How long the sound should play, in milliseconds.
	438	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
MessageBeep(type = 0)
Call Windows MessageBeep(x).
x defaults to MB_OK.
PlaySound(sound, flags)
A wrapper around the Windows PlaySound API.
sound
The sound to play; a filename, data, or None.
flags
Flag values, ORed together. See module 
documentation.
DATA
MB_ICONASTERISK = 64
MB_ICONEXCLAMATION = 48
MB_ICONHAND = 16
MB_ICONQUESTION = 32
MB_OK = 0
SND_ALIAS = 65536
SND_APPLICATION = 128
SND_ASYNC = 1
SND_FILENAME = 131072
SND_LOOP = 8
SND_MEMORY = 4
SND_NODEFAULT = 2
SND_NOSTOP = 16
SND_NOWAIT = 8192
SND_PURGE = 64
FILE
s:\python\python311\dlls\winsound.pyd
Among the functions defined in the module, PlaySound is an important 
one for playing sound or music files. The following statement will play a WAV 
file named dj.wav.
>>> import winsound
>>> winsound.PlaySound("c:/users/comp218/
dj.wav",winsound.SND_FILENAME)
When using the PlaySound function to a play sound file, you must make 
sure the WAV file exists in the default or specified path. In the example above, 
an absolute path has been given. You can also use a relative path that makes 
	
Modules and Packages	
439
 https://doi.org/10.15215/remix/9781998944088.01
use of two special notations, a single dot (.) representing the current directory 
and a double dot (..) representing the parent directory; or you don’t need to 
specify the path at all if the WAV file is in the current directory. In any case, 
the rule is that you must be clearly aware of where the file is located. This rule 
is applicable whenever the file is used.
PyGame
The PlaySound function in the standard winsound module can play only WAV 
files. To play the popular MP3 music files in your Python applications, use the 
module called mixer in the PyGame package. Because the package is usually 
included in the standard Python distribution, you can install the package into 
your Python programming environment using the pip command, as shown 
below:
pip install pygame
Then you can import and use the mixer module to load and play MP3 files, as 
shown below:
>>> from pygame import mixer # load the required library
Hello from the pygame community. https://​
www​
.pygame​
.org/​
contribute​
.html
>>> mixer.init()
>>> mixer.music.load("../I_Will_Remember_You.mp3")
>>> mixer.music.play()
To learn more about how to use the mixer and mixer.music module, you 
can run the following commands in Python interactive mode as shown below, 
after the module has been imported:
>>> help(mixer)
You can then see the functions defined within the module, as further 
detailed below.
CHANNEL(ID)
This is used to create and return a Channel object for controlling playback.
FADEOUT(TIME)
This sets the time to fade out the volume on all sounds before stopping.
	440	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
FIND_CHANNEL(FORCE = FALSE)
This finds and returns an unused channel.
GET_BUSY()
This tests if any sound is being mixed and returns a Boolean value.
GET_INIT()
This tests if the mixer is initialized and returns a tuple (frequency, format, 
channels) representing the channel.
GET_NUM_CHANNELS()
This can be used to check and return the total number of playback channels.
INIT(FREQUENCY = 22050, SIZE = −16, CHANNELS = 2, BUFFER = 
4096, DEVICENAME = NONE, ALLOWEDCHANGES = AUDIO_ALLOW_
FREQUENCY_CHANGE | AUDIO_ALLOW_CHANNELS_CHANGE)
This can be used to initialize the mixer module.
PAUSE() -­
> NONE, TEMPORARILY STOP PLAYBACK OF ALL 
SOUND CHANNELS
PRE_INIT(FREQUENCY=22050, SIZE = −16, CHANNELS = 2, 
BUFFERSIZE = 4096, DEVICENAME = NONE)
These can be used to preset the mixer init arguments.
QUIT()
This can be used to uninitialize the mixer.
SET_NUM_CHANNELS(COUNT)
This can be used to set the total number of playback channels.
SET_RESERVED(COUNT)
This can be used to keep channels from being automatically used.
STOP()
This can be used to stop playback on all sound channels.
UNPAUSE()
This can be used to resume playback on sound channels after it has been 
paused.
	
Modules and Packages	
441
 https://doi.org/10.15215/remix/9781998944088.01
The mixer module has a submodule named music. To learn what func­
tions are available in the mixer.music submodule module, run the following 
statement:
>>> help(mixer.music)
You will then see the following information about the related functions.
FADEOUT(TIME)
This can be used to stop music playback after fading out.
GET_BUSY()
This can be used to check if the music stream is playing. It will return True 
or False.
GET_ENDEVENT()
This can be used to get the event a channel sends when playback stops.
GET_POS()
This can be used to get the music playtime.
GET_VOLUME() -­
> VALUE
This can be used to get the music volume.
LOAD(FILENAME) -­
> NONE, OR LOAD(OBJECT) -­
> NONE,
This can be used to load a music file/object for playback.
PAUSE() -­
> NONE
This can be used to temporarily stop music playback.
PLAY(LOOPS = 0, START = 0.0) -­
> NONE
This can be used to start the music stream playback.
QUEUE(FILENAME) -­
> NONE
This can be used to queue a music file to follow the currently playing file.
REWIND() -­
> NONE
This can be used to restart the music.
	442	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
SET_ENDEVENT() -­
> NONE
SET_ENDEVENT(TYPE) -­
> NONE
These can be used to have the mixer send events when playback stops.
SET_POS(POS) -­
> NONE
This can be used to set the position in the music file when starting playback.
SET_VOLUME(VALUE) -­
> NONE
This can be used to set the music volume.
STOP() -­
> NONE
This can be used to stop the music playback.
UNPAUSE() -­
> NONE
This can be used to resume paused music.
These functions in mixer.music are the ones used directly to handle music files. 
These functions are sufficient for you to develop a high-­
quality music player with 
what you will learn in Chapter 9 on developing GUI-­
based applications in Python.
Please note that the mixer module from the PyGame package can also play 
other types of music files including WAV, as shown below:
>>> from pygame import mixer   # import mixer module from 
PyGame
>>> mixer.init()   # initialize the mixer
>>> mixer.music.load("../I_will_Remember_you.mp3")   # 
load the mp3 file
>>> mixer.music.play(loops = 2)   # play the most recent 
loaded file twice
The functions listed above are needed if you are developing a music player 
with PyGame. For details on these functions, please refer to the official documen­
tation on the PyGame mixer at https://​
www​
.pygame​
.org/​
docs/​
ref/​
mixer​
.html.
8.11 Modules for Creating and Manipulating 
Graphics and Images
In computing and information processing, graphics are an important part of 
data and information. In this section, we learn how to create and manipulate 
graphics and images with Python.
	
Modules and Packages	
443
 https://doi.org/10.15215/remix/9781998944088.01
Create Graphics with Tkinter
The module built into the standard Python distribution for creating graphics 
is the Tkinter module, which is commonly used to develop graphical user 
interface (GUI) applications. However, Tkinter also provides a widget called 
Canvas for graphics and images. The following statements in Python interactive 
mode will produce a window containing a Canvas ready for drawing graphic 
objects—­
Canvas items:
>>> from tkinter import *
>>> d_board = Canvas()
Table 8-­
4 is a list of Canvas items we can draw on a Canvas.
Table 8-­
4: A list of functions that can be used to draw on a Canvas
Graphic object
Canvas method to 
create
Code sample
arc or arc-­
shaped 
region (such as a 
chord or pie slice)
create_arc(bbox, 
**options)
>>> d_board = Canvas()
>>> d_board.pack()
>>> d_board.create_arc(30, 
50, 100, 200)
1
bitmap (built-­
in or read 
from an XBM file)
create_bitmap(position, 
**options)
>>> d_board.create_
bitmap(30, 50)
image (a BitmapImage 
or PhotoImage 
instance)
create_image(position, 
**options)
>>> d_board.create_
image(30, 50)
line
create_line(coords, 
**options)
>>> d_board.create_
line(30, 50, 100, 200)
2
Figure 8-­
2: An example of TK Canvas
(continued on next page)
	444	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Graphic object
Canvas method to 
create
Code sample
oval (a circle or an 
ellipse)
create_oval(bbox, 
**options)
>>> d_board.create_
oval(30, 50, 80, 80, 
fill = "RED")
polygon
create_polygon(coords, 
**options)
>>> d_board.create_
polygon(30, 50, 80, 80, 
70, 90, fill = "RED")
rectangle
create_rectangle(bbox, 
**options)
>>> d_board.create_
rectangle(30, 50, 80, 
80, fill = "RED")
text
create_text(position, 
**options)
>>> d_board.create_
text(130, 150, text = 
"Hello!")
window
create_
window(position, 
**options)
Every method listed in Table 8-­
4 returns a unique ID for the created graphic 
object, which can be used later to manipulate the object.
Note that graphic objects created by the above methods will be stacked 

on the Canvas and will remain until being moved, lifted, lowered, or deleted, 
with the methods in Table 8-­
5.
Table 8-­
5: Other methods of Canvas within Tkinter
Method
Operation
Code sample
dchars(item, from, to 
= None)
Deletes text from an 
editable graphic 
item such as text: 
from is where to 
start deleting text, 
to is where to stop 
deleting text. If to is 
omitted, only a single 
character is deleted.
>>> d_board.create_
text(130, 150, text = 
"Hello Python!")
>>> d_board.dchars('text', 
1,2)
delete(item)
Deletes all matching 
items.
>>> h3 = d_board.
create_text(230, 150, 
text="Hello!")
>>> d_board.delete(h3)
>>> d_board.delete(3)
>>> d_board.delete(10)
>>> d_board.delete(11)
>>> d_board.delete(9)
Table 8-­
4: A list of functions that can be used to draw on a Canvas 
(continued)
	
Modules and Packages	
445
 https://doi.org/10.15215/remix/9781998944088.01
Method
Operation
Code sample
coords(item, *coords)
Returns or sets the 
coordinates of 
matching items.
>>> d_board.coords(o1, 30, 
150, 80, 250)
move(item, dx, dy)
Moves matching 
items by an offset.
>>> d_board.move(o1, 10, 
15)
Canvas has many other methods for accessing and manipulating graphic 
objects. Running the following statements in Python interactive mode will give 
you a list of names defined within the Canvas class.
>>> from tkinter import *
>>> dir(Canvas)
['_Misc__winfo_getint', '_Misc__winfo_parseitem', '__
class__', '__delattr__', '__dict__', '__dir__', '__doc__', 
'__eq__', '__format__', '__ge__', '__getattribute__', 
'__getitem__', '__gt__', '__hash__', '__init__', '__init_
subclass__', '__le__', '__lt__', '__module__', '__ne__', 
'__new__', '__reduce__', '__reduce_ex__', '__repr__', 
'__setattr__', '__setitem__', '__sizeof__', '__str__', 
'__subclasshook__', '__weakref__', '_bind', '_configure', 
'_create', '_displayof', '_do', '_getboolean', '_
getconfigure', '_getconfigure1', '_getdoubles', '_getints', 
'_grid_configure', '_gridconvvalue', '_last_child_ids', 
'_nametowidget', '_noarg_', '_options', '_register', '_
report_exception', '_root', '_setup', '_subst_format', 
'_subst_format_str', '_substitute', '_tclCommands', '_
windowingsystem', 'addtag', 'addtag_above', 'addtag_all', 
'addtag_below', 'addtag_closest', 'addtag_enclosed', 
'addtag_overlapping', 'addtag_withtag', 'after', 
'after_cancel', 'after_idle', 'anchor', 'bbox', 'bell', 
'bind', 'bind_all', 'bind_class', 'bindtags', 'canvasx', 
'canvasy', 'cget', 'clipboard_append', 'clipboard_clear', 
'clipboard_get', 'columnconfigure', 'config', 'configure', 
'coords', 'create_arc', 'create_bitmap', 'create_image', 
'create_line', 'create_oval', 'create_polygon', 'create_
rectangle', 'create_text', 'create_window', 'dchars', 
'delete', 'deletecommand', 'destroy', 'dtag', 'event_add', 
'event_delete', 'event_generate', 'event_info', 'find', 
'find_above', 'find_all', 'find_below', 'find_closest', 
'find_enclosed', 'find_overlapping', 'find_withtag', 
Table 8-­
5: Other methods of Canvas within Tkinter (continued)
	446	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
'focus', 'focus_displayof', 'focus_force', 'focus_get', 
'focus_lastfor', 'focus_set', 'forget', 'getboolean', 
'getdouble', 'getint', 'gettags', 'getvar', 'grab_
current', 'grab_release', 'grab_set', 'grab_set_global', 
'grab_status', 'grid', 'grid_anchor', 'grid_bbox', 
'grid_columnconfigure', 'grid_configure', 'grid_forget', 
'grid_info', 'grid_location', 'grid_propagate', 'grid_
remove', 'grid_rowconfigure', 'grid_size', 'grid_slaves', 
'icursor', 'image_names', 'image_types', 'index', 'info', 
'insert', 'itemcget', 'itemconfig', 'itemconfigure', 
'keys', 'lift', 'location', 'lower', 'mainloop', 'move', 
'nametowidget', 'option_add', 'option_clear', 'option_get', 
'option_readfile', 'pack', 'pack_configure', 'pack_forget', 
'pack_info', 'pack_propagate', 'pack_slaves', 'place', 
'place_configure', 'place_forget', 'place_info', 'place_
slaves', 'postscript', 'propagate', 'quit', 'register', 
'rowconfigure', 'scale', 'scan_dragto', 'scan_mark', 
'select_adjust', 'select_clear', 'select_from', 'select_
item', 'select_to', 'selection_clear', 'selection_get', 
'selection_handle', 'selection_own', 'selection_own_
get', 'send', 'setvar', 'size', 'slaves', 'tag_bind', 
'tag_lower', 'tag_raise', 'tag_unbind', 'tk_bisque', 
'tk_focusFollowsMouse', 'tk_focusNext', 'tk_focusPrev', 'tk_
setPalette', 'tk_strictMotif', 'tkraise', 'type', 'unbind', 
'unbind_all', 'unbind_class', 'update', 'update_idletasks', 
'wait_variable', 'wait_visibility', 'wait_window', 
'waitvar', 'winfo_atom', 'winfo_atomname', 'winfo_cells', 
'winfo_children', 'winfo_class', 'winfo_colormapfull', 
'winfo_containing', 'winfo_depth', 'winfo_exists', 'winfo_
fpixels', 'winfo_geometry', 'winfo_height', 'winfo_id', 
'winfo_interps', 'winfo_ismapped', 'winfo_manager', 'winfo_
name', 'winfo_parent', 'winfo_pathname', 'winfo_pixels', 
'winfo_pointerx', 'winfo_pointerxy', 'winfo_pointery', 
'winfo_reqheight', 'winfo_reqwidth', 'winfo_rgb', 'winfo_
rootx', 'winfo_rooty', 'winfo_screen', 'winfo_screencells', 
'winfo_screendepth', 'winfo_screenheight', 'winfo_
screenmmheight', 'winfo_screenmmwidth', 'winfo_screenvisual', 
'winfo_screenwidth', 'winfo_server', 'winfo_toplevel', 
'winfo_viewable', 'winfo_visual', 'winfo_visualid', 'winfo_
visualsavailable', 'winfo_vrootheight', 'winfo_vrootwidth', 
'winfo_vrootx', 'winfo_vrooty', 'winfo_width', 'winfo_x', 
'winfo_y', 'xview', 'xview_moveto', 'xview_scroll', 'yview', 
'yview_moveto', 'yview_scroll']
	
Modules and Packages	
447
 https://doi.org/10.15215/remix/9781998944088.01
You can then call help on each of the names in the list to learn more about 
the name defined. The following are just two examples:
>>> help(Canvas.addtag)
Running help on the function addtag in module tkinter outputs the following:
addtag(self, *args)
    Internal function.
>>> help(Canvas.after)
Running help on the function after in module tkinter outputs the following:
after(self, ms, func=None, *args)
    Call function once after given time.
    MS specifies the time in milliseconds. FUNC gives the
    function, which shall be called. Additional parameters
    are given as parameters to the function call. Returns
    identifier to cancel scheduling with after_cancel.
>>> help(Canvas.create_image)
Running help on the function create_image in module tkinter outputs the 
following:
create_image(self, *args, **kw)
    Create image item with coordinates x1, y1.
The following coding example will draw a line on a Canvas:
import tkinter
from tkinter.constants import *
tk = tkinter.Tk()
canvas = tkinter.Canvas(tk, relief = RIDGE, borderwidth = 2)
canvas.pack(fill = BOTH, expand=1)
ln1 = canvas.create_line(100, 100, 300, 300, width = 6)
tk.mainloop()
	448	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Manipulate Images with Pillow
Another way you can work with visual objects in Python is to manipulate images 
stored in files. These manipulations include the following:
•	 rotating
•	 converting from colour to grey-­
scale
•	 applying colour filtering
•	 highlighting a specific area of an image
•	 blurring an image or part of it
•	 sharpening an image or part of it
•	 changing the brightness of an image
•	 detecting the edge on an image
•	 scaling an image
•	 applying colour inversion to an image
•	 morphing one image into another image
How can all these manipulations be done within your computer? First, an image 
is made of pixels, which can be stored in an m × n matrix, or two-­
dimensional 
array, mapped to a rectangular area of the computer screen. The value of each 
cell of the matrix represents a pixel and contains all the information about it. 
All manipulations to the image can be done by manipulating the matrix or its 
values.
To manipulate an image with Python, you can use a package called Pillow 
(available from https://​
pypi​
.org/​
project/​
Pillow/​
2​
.2​
.1/ or https://​
github​
.com/​
python​
-pillow/​
Pillow). Because it is not a standard part of the Python library, 
you will need to install it with the following statement:
Figure 8-­
3: Drawing on TK Canvas
	
Modules and Packages	
449
 https://doi.org/10.15215/remix/9781998944088.01
pip install Pillow
Collecting Pillow
Downloading
wordhttps://​
files​
.pythonhosted​
.org/​
packages/​
70/​
21/​
04723e78916eff8e0
9901dbb7dc9705f4de8a0dfe7882a9ed56982bd128e/​
Pillow​
-­
6​
.0​
.0​
-­
cp37​
-­
cp37m​
-­
win32​
.whl (1.7MB)
|████████████████████████████████| 1.7MB 
1.3MB/s
Installing collected packages: Pillow
Successfully installed Pillow-­
6.0.0
Once this is done, you can import and then use the following two 
modules:
Image,
ImageFilter
The following is a coding sample:
from PIL import Image, ImageFilter
# read the image
im = Image.open('./resort.jpg')
im_sharp = im.filter( ImageFilter.SHARPEN )
# save the filtered image to a new file
im_sharp.save( './resort-­
sharp.jpg', 'JPEG' )
 
# display the image
im_sharp.show()
The sharpened image is shown in Figure 8-­
4.
Note that the Image module has a class with the same name as the module, 
Image, although it is more convenient to construct an object of Image with the 
open statement rather than the constructor of Image class.
Once an image object has been generated with the open statement, we can 
check its format, size, and mode by looking at the format, size, and mode attrib­
utes and using the following methods of the Image class to manipulate the image 
object:
•	 Image.convert(self, mode = None, matrix = None, dither = None, palette 
= 0, colors = 256) makes various conversions to the image object.
	450	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
•	 Image.copy(self) makes a copy and retains the original image object.
•	 Image.crop(self, box=None) returns a rectangular region of the image, 
defined by box.
•	 Image.draft(self, mode, size) returns a draft version of the image, such 
as a grey-­
scale version.
•	 Image.effect_spread(self, distance) returns an image with pixels 
randomly spread throughout the image.
•	 Image.filter(self, filter) filters this image using the given filter specified 
in the ImageFilter module.
•	 Image.paste(self, im, box=None, mask=None) pastes another image 
(im) into this image.
•	 Image.putalpha(self, alpha) adds or replaces the alpha layer in this image.
•	 Image.putdata(self, data, scale = 1.0, offset = 0.0) copies a sequence of 
pixel data to this image.
•	 Image.putpalette(self, data, rawmode = 'RGB') attaches a palette to this 
image.
•	 Image.putpixel(self, xy, value) modifies the pixel at the given position.
•	 Image.quantize(self, colors = 256, method = None, kmeans = 0, palette 
= None, dither = 1) converts the image to P mode with the specified 
number of colours.
Figure 8-­
4: Picture sharpened with Pillow (©Harris Wang, Athabasca University)
	
Modules and Packages	
451
 https://doi.org/10.15215/remix/9781998944088.01
•	 Image.emap_palette(self, dest_map, source_palette = None) rewrites 
the image to reorder the palette.
•	 Image.resize(self, size, resample = 0, box = None) returns a resized copy 
of this image.
•	 Image.rotate(self, angle, resample = 0, expand = 0, center = None, 
translate = None, fillcolor = None) returns a rotated copy of this 
image.
•	 Image.split(self), splits the image into individual bands, such as 
R, G, B.
•	 Image.tobitmap(self, name='image') converts the image to an X11 
bitmap.
•	 Image.tobytes(self, encoder_name = 'raw', *args) returns the image as a 
bytes-­
object.
•	 Image.toqimage(self) returns a QImage copy of this image.
•	 Image.toqpixmap(self) returns a QPixmap copy of this image.
•	 Image.transform(self, size, method, data=None, resample = 0, fill = 1, 
fillcolor = None) transforms this image to a given size but in the same 
mode as the original.
•	 Image.transpose(self, method) transposes the image (flips or rotates in 
90-­
degree steps).
There are other methods defined within the Image class for other purposes. 
You can find out more info about the Image class by running the following 
statement in Python interactive mode:
>>> from PIL import Image, ImageFilter
>>> help(Image.Image)
As we have seen from the above list, the Image class has provided a good 
set of methods to manipulate an image.
The ImageFilter module provides some filtering operations on images, as 
the name implies. These filtering operations include blurring, box blurring, 
contouring, colour transformation, detailing, edge enhancing, embossing, sharp­
ening, smoothing, and more.
8.12 Modules for Data Analytics
The modules often used for data analytics include pandas, NumPy, SciPy, 
and matplotlib. Among the four modules, pandas is mostly used to prepare 
	452	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
data; NumPy and SciPy are used for numeric analysis and science computing, 
respectively; and matplotlib is for visualization.
Since data analytics is a big topic, we will only give some examples of how 
the modules can be used.
The first example is to show how to use matplotlib to visualise the square 
root function in math.
import math
import matplotlib.pyplot as mpl
sqrt_data = {i+1 : math.sqrt(i+1) for i in range(100)}
x1 = list(sqrt_data.keys())
y1 = list(sqrt_data.values())
mpl.plot(x1, y1)
mpl.title("visualization of square root")
mpl.xlabel('x')
mpl.ylabel('y')
mpl.show()
The plot produced by the program is shown in Figure 8-­
5.
0
20
40
60
80
100
x
2
4
6
8
10
y
Visualization of Square Root
Figure 8-­
5: Visualization of square root
	
Modules and Packages	
453
 https://doi.org/10.15215/remix/9781998944088.01
Our next example is to visualize the world population changes in some 
regions as well as world total since 1960. The program code is as follows:
import pandas as pd
import matplotlib.pyplot as mplt
content = pd.read_excel("world-­
population.xls")
years = [1960, 1970, 1980, 1990, 2000, 2010, 2017]
mplt.plot(years, content.iloc[0, 1:])
mplt.plot(years, content.iloc[1, 1:])
mplt.plot(years, content.iloc[7, 1:])
mplt.plot(years, content.iloc[11, 1:])
mplt.plot(years, content.iloc[12, 1:])
mplt.plot(years, content.iloc[17, 1:])
mplt.plot(years, content.iloc[22, 1:])
mplt.title("Population -­
 World Total and Region Total")
mplt.xlabel("years")
mplt.ylabel("Populations (in millions)")
mplt.legend(["World Total", "Africa", "Latin America", 
"North America", "Asia", "Europe", "Oceana"])
mplt.show()
In the program, the pandas module is used to read and prepare the data. 
For details on how it works, please read the complete documentation at https://​
pandas​
.pydata​
.org/​
docs/—­
the user guide at https://​
pandas​
.pydata​
.org/​
docs/​
user​
_guide/​
index​
.html​
#user​
-guide in particular.
The rendered result of the program is shown in Figure 8-­
6.
NumPy allows you to do math manipulations on a data set, most often 
manipulations on a matrix. Here is an example:
import numpy as np # import numpy
 
a = np.array(range(21,25)) # create an array from a 
python list
print(a, a.shape) # print the array and its shape
 
# create a 2-­
D array from nested lists
b = np.array([[1, 2, 3, 4], [5, 6, 7, 8],
        [11, 12, 13, 14], [15, 16, 17, 18]])
 
print(b, b.shape)  # print the array and its shape
	454	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
c = a + b # perform element-­
wise addition on two arrays
 
print(c, c.shape)  # print the result and the shape
 
d = np.dot(a, b)  # perform matrix multiplication
 
print(d)  # print the result
 
e = np.cos(a) # apply a mathematical function to an array
 
print(e)  # print the result
 
f = np.sort(b, axis=0) # sort an array along a given axis
 
print(f)  # print the result
The output from the program is as follows:
[21 22 23 24] (4,)
[[ 1 2 3 4]
1960
1970
1980
1990
2000
2010
years
2000
1000
0
3000
4000
5000
6000
7000
Populations (in million)
Population - World Total and Region Total
World Total
Africa
Latin America
North America
Asia
Europe
Oceana
Figure 8-­
6: Visualization of world population changes
	
Modules and Packages	
455
 https://doi.org/10.15215/remix/9781998944088.01
 [ 5 6 7 8]
 [11 12 13 14]
 [15 16 17 18]] (4, 4)
[[22 24 26 28]
 [26 28 30 32]
 [32 34 36 38]
 [36 38 40 42]] (4, 4)
[ 744 834 924 1014]
[-­
0.54772926 -­
0.99996083 -­
0.53283302 0.42417901]
[[ 1 2 3 4]
 [ 5 6 7 8]
 [11 12 13 14]
 [15 16 17 18]]
More details on NumPy can be found at https://​
numpy​
.org/​
doc/​
stable/.
SciPy is built upon NumPy, including various functions often needed for 
scientific computing. The following example shows how integration function 
in SciPy is used to integrate a function.
import numpy as np # import numpy and scipy.integrate
from scipy.integrate import quad  # import quad integral 
function
 
# define a function to be integrated
def f(x):
  return np.exp(-­
x**2)  # use exp function from NumPy
 
# integrate the function from 0 to 1 using quad
result, _ = quad(f, 0, 1)
 
# print the result and the estimated error
print(result)
The result is 0.7468241328124271.
Chapter Summary
•	 In addition to functions and classes, modules and packages are 
important constructs that can be used to do modular programming in 
Python.
	456	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
•	 A module can be any file with a py extension that has legitimate Python 
program codes or scripts in it.
•	 A package is a file directory containing several Python modules.
•	 To identify the directories in which the Python packages reside, each 
such directory must contain a file named ​
_​
_init​
_​
_​
.py.
•	 The ​
_​
_init​
_​
_​
.py file defines what can be imported from the package. 
These may include variables, functions, and classes.
•	 Packages can be nested to any depth, just like file directories are 
nested. However, each directory for a package must have its own ​
_​
_init​
_​
_​
.py file.
•	 Dotted notation is used to refer to a package or module within a deep 
package hierarchy.
•	 To use variables, functions, and classes defined in a module, you 
have to import the module or the specific variables, functions, and/or 
classes, using the import statement or from … import statement.
•	 A large number of Python modules and packages have been developed 
and made available on the internet for Python programmers. Many 
of these modules and packages have been already installed with the 
standard Python distribution, such as the Anaconda package.
•	 A good Python programmer or software developer should have 
knowledge of existing modules and packages, including what they are 
developed for and what they do.
•	 Programmers can develop their own modules for their own 
applications and development.
Exercises
	
1.	 Open VS Code, create or open a Jupyter Notebook file (.ipynb), and 
select a Python virtual environment for the notebook file. Open a 
terminal and run the pip list command to see what library modules 
have been installed in the virtual environment.
In the output of your VS Code shell terminal, identify some 
interesting packages and modules, and write a summary of those 
packages and modules in a Word document, including what each is 
developed for, where it may be used, and so on.
	
2.	 In VS Code, open the Jupyter Notebook file named chapter-­
8.ipynb. 
Create a new cell and import the math module, run the help command 
to study each of the functions defined in the math module, and do 
some hands-­
on coding with the function.
	
Modules and Packages	
457
 https://doi.org/10.15215/remix/9781998944088.01
	
3.	 Search the internet for tutorials or other web documents related to 
web scraping with Python and choose some to watch or read. Take 
some coding samples to run in your Jupyter Notebook within VS Code, 
then develop your own application based on the code samples.
Projects
	
1.	 Rational numbers are those real numbers that can be represented as 
a quotient of two integers such as a/b, which can then be represented 
by the pair of integers a and b. For this project, define a module 
that contains the definition of a class named Rational, within 
which dunder methods for print, addition, subtraction, division, 
multiplication, and various comparisons are defined.
	
2.	 Develop an application using the math module to calculate and display 
a table of squares for integers from 0 to 99. The layout is illustrated in 
Table 8-­
6.
Table 8-­
6: The layout of the table to be produced
0
1
2
3
4
5
6
7
8
9
0
0
1
4
9
26
25
36
49
8
9
1
100
121
144
169
196
225
256
289
324
361
2
…
…
…
3
4
5
6
7
8
9
	
3.	 Develop an application to calculate and display a table showing the 
square roots of integers from 0 to 99 (similar to what you did for 
Project 2).
This page intentionally left blank
 https://doi.org/10.15215/remix/9781998944088.01
Chapter 9
Develop GUI-­
Based 
Applications
In terms of user interface, there are two types of computer systems or appli­
cations: terminal-­
based, which can be run from a terminal, and those with a 
graphical user interface (GUI), or GUI-­
based. So far, the applications we have 
programmed have all been terminal-­
based. In this chapter you will learn how 
to develop GUI-­
based applications in Python.
Learning Objectives
After completing this chapter, you should be able to
•	 explain terminal-­
based applications and GUI-­
based applications as 
well as their differences.
•	 explain which Python libraries are available for developing GUI-­
based 
applications.
•	 discuss the widgets, functions, other classes, and methods provided in 
the Tkinter module.
•	 use widgets, functions, classes, and methods provided in the Tkinter 
module to design and implement a graphical user interface for a given 
application.
•	 develop GUI-­
based applications using the Tkinter module.
•	 discuss the themed Tkinter(Ttk) module and how it differs from the 
Tkinter module.
	460	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
9.1 Terminal-­
Based Applications Versus GUI-­
Based 
Applications
A computer terminal is a device, often referring to a utility program in today’s 
Windows environment, that can receive and deliver data or commands. The 
following shows what a terminal on Windows 11 looks like:
(base) PS C:\Users\james>
A terminal-­
based application is a program that runs from the command line 
within a terminal. For that reason, terminal-­
based applications are also called 
applications with a command-­
line interface. The following shows a Python 
program with a command-­
line interface running within a terminal.
(base) PS C:\workshop\comp218\samples\project2> python 
'.\perfect number​
.py'
tell me the upper bound:33
6 = [1, 2, 3]    28 = [1, 2, 4, 7, 14]
(base) PS C:\workshop\comp218\samples\project2> python 
'.\perfect number​
.py'
tell me the upper bound:53
6 = [1, 2, 3]    28 = [1, 2, 4, 7, 14]
(base) PS C:\workshop\comp218\samples\project2>
The terminal-­
based program shown above takes an integer as upper 
bound from the user and then finds all perfect numbers between 1 and the 
upper bound. With a terminal-­
based application, only a keyboard can be used 

by users to interact with the application.
A GUI-­
based application provides users with a graphical interface so that 
users can interact with the application with keyboard and mouse. VS Code 
IDE is an example of a GUI-­
based application we have been using throughout 
this text.
The difference between terminal-­
based and GUI-­
based applications is 
obvious. Although GUI-­
based applications are more user-­
friendly and more 
common today, terminal-­
based applications still exist and are used by some 
IT professionals, such as system administrators.
In the next section, we will learn how to develop GUI-­
based applications 
with Python.
	
Develop GUI-­
Based Applications	
461
 https://doi.org/10.15215/remix/9781998944088.01
9.2 Designing and Developing GUI-­
Based 
Applications in Python
The key component of a GUI-­
based application is a graphical user interface 
(GUI) on which both mouse and keyboard can be used to interact with the appli­
cation on a two-­
dimensional graphic interface. As mentioned above, GUI-­
based 
applications are more user-­
friendly than terminal-­
based applications. This is 
why most computer applications used today are GUI-­
based.
In general, you need to ask yourself the following questions when designing 
a GUI app:
•	 What will be shown to users?
•	 What input will be taken from users?
•	 What actions will we allow users to take?
•	 What actions will be taken in response to the users’ input?
•	 Where do we display the results of the actions?
Several Python modules are available for developing GUI-­
based applications.
•	 Tkinter, a de facto GUI library for Python applications, comes with the 
standard Python distribution so that you can import and use it right 
away. Documentation on tkinter can be found at https://​
docs​
.python​
.org/​
3/​
library/​
tk​
.html. You learned how to use Python modules and 
packages, including tkinter, in Chapter 8.
•	 PyGObject is a Python implementation of GObject-­
based libraries such 
as GTK, GStreamer, WebKitGTK, GLib, GIO, and some others. If you 
have played with Linux, you will probably know the GTK-­
 and GNOME-­
based graphical user interfaces. The project is hosted at https://​
pygobject​
.readthedocs​
.io/​
en/​
latest/.
•	 PyQt5 is another GUI library for Python GUI-­
based application 
development that implements the well-­
known Qt graphic framework. 
Information about PyQt5 can be easily found on the internet, and its 
home is at https://​
pypi​
.org/​
project/​
PyQt5/.
We chose to use a module called tkinter for its popularity among Python 
application developers and because of its light weight. The tkinter module 
usually comes with the standard Python distribution. To test if you have it 
installed, run import tkinter as shown below to see if you will get the same 
output:
	462	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
>>> import tkinter
>>> dir(tkinter)
['ACTIVE', 'ALL', 'ANCHOR', 'ARC', 'BASELINE', 'BEVEL', 
'BOTH', 'BOTTOM', 'BROWSE', 'BUTT', 'BaseWidget', 
'BitmapImage', 'BooleanVar', 'Button', 'CASCADE', 
'CENTER', 'CHAR', 'CHECKBUTTON', 'CHORD', 'COMMAND', 
'CURRENT', 'CallWrapper', 'Canvas', 'Checkbutton', 
'DISABLED', 'DOTBOX', 'DoubleVar', 'E', 'END', 'EW', 
'EXCEPTION', 'EXTENDED', 'Entry', 'Event', 'EventType', 
'FALSE', 'FIRST', 'FLAT', 'Frame', 'GROOVE', 'Grid', 
'HIDDEN', 'HORIZONTAL', 'INSERT', 'INSIDE', 'Image', 
'IntVar', 'LAST', 'LEFT', 'Label', 'LabelFrame', 
'Listbox', 'MITER', 'MOVETO', 'MULTIPLE', 'Menu', 
'Menubutton', 'Message', 'Misc', 'N', 'NE', 'NO', 
'NONE', 'NORMAL', 'NS', 'NSEW', 'NUMERIC', 'NW', 
'NoDefaultRoot', 'OFF', 'ON', 'OUTSIDE', 'OptionMenu', 
'PAGES', 'PIESLICE', 'PROJECTING', 'Pack', 'PanedWindow', 
'PhotoImage', 'Place', 'RADIOBUTTON', 'RAISED', 
'READABLE', 'RIDGE', 'RIGHT', 'ROUND', 'Radiobutton', 
'S', 'SCROLL', 'SE', 'SEL', 'SEL_FIRST', 'SEL_LAST', 
'SEPARATOR', 'SINGLE', 'SOLID', 'SUNKEN', 'SW', 
'Scale', 'Scrollbar', 'Spinbox', 'StringVar', 'TOP', 
'TRUE', 'Tcl', 'TclError', 'TclVersion', 'Text', 
'Tk', 'TkVersion', 'Toplevel', 'UNDERLINE', 'UNITS', 
'VERTICAL', 'Variable', 'W', 'WORD', 'WRITABLE', 
'Widget', 'Wm', 'X', 'XView', 'Y', 'YES', 'YView', 
'__builtins__', '__cached__', '__doc__', '__file__', 
'__loader__', '__name__', '__package__', '__path__', 
'__spec__', '_cnfmerge', '_default_root', '_exit', '_
flatten', '_join', '_magic_re', '_setit', '_space_re', 
'_splitdict', '_stringify', '_support_default_root', 
'_test', '_tkerror', '_tkinter', '_varnum', 'constants', 
'enum', 'getboolean', 'getdouble', 'getint', 'image_
names', 'image_types', 'mainloop', 're', 'sys', 
'wantobjects']
A GUI application starts with a frame or window of a given size in terms of 
pixels, which is divided into rows and columns. Each of the grids is numbered 
from top to bottom, left to right, as shown in the following diagram:
	
Develop GUI-­
Based Applications	
463
 https://doi.org/10.15215/remix/9781998944088.01
(0,0)
(0,1)
(0,2)
(0,3)
(0,4)
(0,5)
(1,0)
(1,1)
(1,2)
(1,3)
(1,4)
(1,5)
(2,0)
(2,1)
(2,0)
(2,3)
(2,4)
(2,5)
(3,0)
(3,1)
(3,2)
(3,3)
(3,4)
(3,5)
(4,0)
(4,1)
(4,2)
(4,3)
(4,4)
(4,5)
(5,0)
(5,1)
(5,2)
(5,3)
(5,4)
(5,5)
Please note that although the frame size is measured in pixels, the coordinate 
of each grid above is only a relative location within the grid and has nothing to 
do with pixels. The size of each grid is dynamically determined by the object 
or widget placed in it.
Tkinter Module
The following code running from Python interactive mode renders a window/
frame (as shown in Figure 9-­
1):
>>> from tkinter import *
>>> f = Tk()
The following statements can be used to set the title and the size of the 
window:
>>> f.title("My First GUI App")
>>> f.geometry("300 x 200")
Figure 9-­
1: A window rendered by Python with Tkinter
	464	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Within this frame/window, we can place specific objects, called widgets, to 
serve their designated purposes, as detailed below:
•	 Label displays text and bitmaps.
•	 Entry displays simple text.
•	 Button displays a button and associates a command with the button that 
can be invoked.
•	 Checkbutton displays a button with only an on or off state. It is often 
used in groups to provide a number of options for users to select.
•	 Menu displays menu bars, pull-­
down menus, and pop-­
up menus.
•	 OptionMenu allows the user to select a value from a menu.
•	 PanedWindow is a container that may contain a number of panes.
•	 Radiobutton displays a radio button with an on/off state. It is used in 
groups, from which the user can select only one option at a time.
•	 Frame is a container to organize other widgets.
•	 LabelFrame is a spacer or container for complex window layouts.
•	 Text displays text in multiple lines.
•	 Canvas provides an area on which you can draw shapes such as lines, 
ovals, polygons, and rectangles in your application.
•	 Scale provides a slider showing numerical scale.
•	 Scrollbar adds scrolling capability to various widgets, such as text and 
list boxes.
•	 Spinbox is a variant of the standard Tkinter Entry widget and selects 
from a fixed number of values.
•	 Toplevel provides a separate window container.
The following is a code sample in Jupyter Notebook:
In [ ]:
f = Tk() # make an instance of Tk window
f.title("My First GUI App") # add a title to the window
f.geometry("300 x 200") # set the size
# add a label widget with text
lb = tkinter.Label(text = "This is my first label") # 
label
lb.grid(row = 0, column = 0) # place the window
f.mainloop() # render it up to show
Out [ ]:
The window will be rendered as shown in Figure 9-­
2:
In the above, the first statement creates a label object with the text “This 
is my first label” on it, whereas the second statement places the object in a 
specific grid of the window. If no arguments are specified for the grid, the 
	
Develop GUI-­
Based Applications	
465
 https://doi.org/10.15215/remix/9781998944088.01
default value is used, which is the next available grid in the window in order 
from top to bottom, left to right.
Similarly, we can add an Entry widget to the window using the following 
statements:
In [ ]:
 f = Tk()
 f.title("My first GUI app")
 f.geometry("300x200")
 lb = tkinter.Label(text = "Please input here")
 lb.grid(row = 0, column = 0)
 ent = tkinter.Entry()
 ent.grid(row = 0, column = 1)
 f.mainloop()
By now the window should look like the one shown in Figure 9-­
3.
Figure 9-­
3: A GUI example with added entry widget
Figure 9-­
2: A GUI example with more details
	466	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In addition to the Entry widget for taking single-­
line text input, the Button 
and Text widgets take mouse click and multiple-­
line text input, respectively, 
from users. We can add buttons and text boxes to the window with the follow­
ing statements:
In [ ]:
f = Tk()
f.title("My first GUI app")
f.geometry("300 x 200")
 lb = tkinter.Label(text = "Please input here")
 lb.grid(row = 0, column = 0)
 ent = tkinter.Entry()
 ent.grid(row = 0, column = 1)
 btn = Button(text = "Click me")
 btn.grid(column = 0, row = 1)
 txt = Text(width = 20, height = 10)
 txt.grid(column = 1, row = 2)
 f.mainloop()
The rendered window is shown in Figure 9-­
4.
Within the window, you can type in the entry field, type more in the text 
area, and click the button, but the app does not do anything in response, as 
shown in Figure 9-­
5.
Figure 9-4: A GUI example with more widgets added
Figure 9-­
5: A GUI example taking user input
	
Develop GUI-­
Based Applications	
467
 https://doi.org/10.15215/remix/9781998944088.01
How can we make the app respond to the user’s input and do what we want 
it to do? We need to attach an even handler to the intended object, such as a 
button, as shown below:
In [ ]:
 f = Tk()
 f.title("My first GUI app")
 f.geometry("300 x 200")
 lb = tkinter.Label(text = "Please input here")
 lb.grid(row = 0, column = 0)
 ent = tkinter.Entry()
 ent.grid(row = 0, column = 1)
 btn = Button(text = "Click me")
 btn.grid(column = 0, row = 1)
 txt = Text(width = 20, height = 10)
 txt.grid(column = 1, row = 2)
 def hdl():
 btn.config(text = "You clicked me!")
 btn.config(command = hdl) # add handler to act
 f.mainloop()
In the above, we first define a function as a handler, which simply 
changes the text on the button to “You clicked me,” then attaches the hand­
ler to the button using the config() method built into the button object. 

As expected, the text on the button changes after a click on the button, as 
shown in Figure 9-­
6.
To learn more details about each of the widgets listed above, we can call for 
help in Python interactive mode or Jupyter Notebook. The following example 
shows how to get help on the Frame widget in Jupyter Notebook:
Figure 9-­
6: Now the GUI is able to respond to user input
	468	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In [ ]:
from tkinter import *
help(Frame)
As always, you can also search the internet for any widget in the tkinter 
module to get help, including very detailed discussions on its use.
With what we have learned so far, we should be ready to develop a real 
GUI-­
based application, which is the GUI version of a grade conversion pro­
gram. The conversion is based on the data in Table 9-­
1, and the case study 
is in Table 9-­
2.
Table 9-­
1: Grade conversion table
Letter grade
%
Letter grade
%
A+
90–­
100
C+
67–­
69
A
85–­
89
C
64–­
66
A-­
80-­
84
C-­
60-­
63
B+
76–­
79
D+
55–­
59
B
73–­
75
D
50–­
54
B−
70–­
72
F
0–­
49
Table 9-­
2: Case study: How to convert grades in a GUI program
The problem
To develop a GUI-­
based application that can take the a numerical 
grade from a user and convert it to a letter grade.
The analysis 
and design
The application is meant to convert numerical grades to letter 
grades based on the conversion table shown as Table 9-­
1. The 
information flow is:
Get a numerical grade from user → convert to a letter grade → 
display the letter grade
In previous chapters, we showed how to develop a terminal-­
based 
application to do this conversion, where the input and output 
were all done on a standard terminal. In a GUI-­
based application, 
the input and output/display need to be done on a graphic 
interface.
Consider the widget in the tkinter module. We need an Entry widget 
for input and a Label widget to display the converted letter grade, 
a Button to start a conversion, and another Button to exit and 
close the application. Of course, we also need a function to do 
the actual conversion.
	
Develop GUI-­
Based Applications	
469
 https://doi.org/10.15215/remix/9781998944088.01
The code
"""
A GUI-­
based program using the Tkinter module
to convert numeric grades to alpha letter/grades.
"""
from tkinter import *
def n_to_l(n_g):
  n_g = round(float(n_g))
  if n_g in range(90, 101):
    lg = f"Letter grade of {n_g} is A+"
  elif n_g in range(85, 90):
    lg = f"Letter grade of {n_g} is A"
  elif n_g in range(80, 85):
    lg = f"Letter grade of {n_g} is A-"
  elif n_g in range(76, 80):
    lg = f"Letter grade of {n_g} is B+"
  elif n_g in range(73, 76):
  lg = f"Letter grade of {n_g} is B"
  elif n_g in range(70, 73):
    lg = f"Letter grade of {n_g} is B-"
  elif n_g in range(67, 70):
    lg = f"Letter grade of {n_g} is C+"
  elif n_g in range(64, 67):
    lg = f"Letter grade of {n_g} is C"
  elif n_g in range(60, 64):
    lg = f"Letter grade of {n_g} is C-"
  elif n_g in range(55, 60):
    lg = f"Letter grade of {n_g} is D+"
  elif n_g in range(50, 54):
    lg = f"Letter grade of {n_g} is D"
  elif n_g in range(0, 50):
    lg = f"Letter grade of {n_g} is F"
  else:
    lg = "invalid mark!"
  return lg
def hdl():
  n = int(ent1.get())
  lb2.config(text = f"{n_to_l(n)}")
  return -­
1
w = Tk()
w.title("My GUI-­
based grade converter")
w.geometry("500 x 200")
lb1 = Label(text = "Please input percentage grade:")
lb1.grid(column = 2, row = 1, rowspan = 3, pady = 30)
ent1 = Entry()
ent1.grid(column = 3, row = 1, rowspan = 3, pady = 30)
btn = Button(text = "Convert", background = "#00FF00")
btn.grid(column = 2, row = 5, rowspan = 3, pady = 30)
btn.config(command = hdl)
btn_quit = Button(text = "Quit", background = "#FF0000")
btn_quit.grid(column = 6, row = 5, rowspan = 3, pady = 
30)
btn_quit.config(command=quit)
lb2 = Label(text = "Letter grade will be displayed here")
lb2.grid(column = 2, row = 8, rowspan = 3)
mainloop()
# this statement must be placed here to keep the window 
alive
	470	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
In the coding example, the .grid() method positions a widget in the parent 
widget in a grid or cell. The options that can be used with the .grid() method 
are as follows:
column = number—­
uses cell identified with given column (starting 
with 0)
columnspan = number—­
spans several columns
in = master—­
uses master to contain this widget
in_ = master—­
uses master to contain this widget
ipadx = amount—­
adds internal padding in x direction
ipady = amount—­
adds internal padding in y direction
padx = amount—­
adds padding in x direction
pady = amount—­
adds padding in y direction
row = number—­
uses a cell identified with a given row (starting with 0)
rowspan = number—­
span several rows
sticky = NSEW—­
tells on which sides this widget will stick to the cell 
boundary if the cell is larger
Note that we placed a method of the imported tkinter module named 
.mainloop() at the very end of the program. The call to the method is neces­
sary to keep the window of the GUI-­
based app alive when running the code 
from the Python program file. Otherwise, the window will disappear as soon 

as the Python Virtual Machine (PVM) reaches the end of the program file.
You may wonder why the GUI window we created from the Python inter­
active shell stays alive without the .mainloop() statement. The reason is very 
simple: because PVM is still waiting for you to input a numeric grade, which 
means that the file (standard IO file) won’t reach the end as long as you have 
not quit the Python interactive shell.
The GUI application can also be placed in a frame. The result and the code 
are shown in Figure 9-­
7 and below. As you can see, it has become nicer.
Figure 9-­
7: A GUI application doing grade conversion
	
Develop GUI-­
Based Applications	
471
 https://doi.org/10.15215/remix/9781998944088.01
"""
You are required to design a GUI-­
based program using the 
Tkinter
module to convert numeric grades to alpha letter/grades.
"""
from tkinter import *
 
def n_to_l(n_g):
  n_g = round(float(n_g))
  if n_g in range(90, 101):
    lg = f"Letter grade of {n_g} is A+"
  elif n_g in range(85, 90):
    lg = f"Letter grade of {n_g} is A"
  elif n_g in range(80, 85):
    lg = f"Letter grade of {n_g} is A-"
  elif n_g in range(76, 80):
    lg = f"Letter grade of {n_g} is B+"
  elif n_g in range(73, 76):
    lg = f"Letter grade of {n_g} is B"
  elif n_g in range(70, 73):
    lg = f"Letter grade of {n_g} is B-"
  elif n_g in range(67, 70):
    lg = f"Letter grade of {n_g} is C+"
  elif n_g in range(64, 67):
    lg = f"Letter grade of {n_g} is C"
  elif n_g in range(60, 64):
    lg = f"Letter grade of {n_g} is C-"
  elif n_g in range(55, 60):
    lg = f"Letter grade of {n_g} is D+"
  elif n_g in range(50, 54):
    lg = f"Letter grade of {n_g} is D"
  elif n_g in range(0, 50):
    lg = f"Letter grade of {n_g} is F"
  else:
    lg = "invalid mark!"
  return lg
 
def hdl():
  n = int(ent1.get())
  lb2.config(text = f"{n_to_l(n)}")
	472	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
  return -­
1
 
w = Frame()
# to add frame widget
 
w.master.title("My GUI-­
based grade converter in Frame")
w.master.geometry("500 x 200")
lb1 = Label(text = "Please input percentage grade:")
lb1.grid(column = 2, row = 1, rowspan = 3, pady = 30)
ent1 = Entry()
ent1.grid(column = 3, row = 1, rowspan = 3, pady = 30)
btn = Button(text = "Convert", background = "#FF0000")
btn.grid(column = 2, row = 5, rowspan = 3, pady = 30)
btn.config(command = hdl)
btn_quit = Button(text = "Quit", background = "#FF0000")
btn_quit.grid(column = 6, row = 5, rowspan = 3, pady = 
30)
btn_quit.config(command = quit)
lb2 = Label(text = "Letter grade will be displayed here")
 
lb2.grid(column = 2, row = 8, rowspan = 3)
mainloop()
# this statement must be placed below all others to keep 
the window alive
If you don’t like placing widgets with the .geometry() method, you may 

use the .pack() method to let the PVM automatically place the widgets for you. 
The new GUI-­
based app and the revised Python code are shown in Figure 9-­
8 
and below.
Figure 9-­
8: Frame widget is used in the GUI application
	
Develop GUI-­
Based Applications	
473
 https://doi.org/10.15215/remix/9781998944088.01
"""Revised grade conversion: placing widgets with the 
.geometry() method."""
 
from tkinter import *
 
def n_to_l(n_g):
  n_g = round(float(n_g))
  if n_g in range(90, 101):
    lg = f"Letter grade of {n_g} is A+"
  elif n_g in range(85, 90):
    lg = f"Letter grade of {n_g} is A"
  elif n_g in range(80, 85):
    lg = f"Letter grade of {n_g} is A-"
  elif n_g in range(76, 80):
    lg = f"Letter grade of {n_g} is B+"
  elif n_g in range(73, 76):
    lg = f"Letter grade of {n_g} is B"
  elif n_g in range(70, 73):
    lg = f"Letter grade of {n_g} is B-"
  elif n_g in range(67, 70):
    lg = f"Letter grade of {n_g} is C+"
  elif n_g in range(64, 67):
    lg = f"Letter grade of {n_g} is C"
  elif n_g in range(60, 64):
    lg = f"Letter grade of {n_g} is C-"
  elif n_g in range(55, 60):
    lg = f"Letter grade of {n_g} is D+"
  elif n_g in range(50, 54):
    lg = f"Letter grade of {n_g} is D"
  elif n_g in range(0, 50):
    lg = f"Letter grade of {n_g} is F"
  else:
    lg = "invalid mark!"
  return lg
 
def hdl():
  n = int(ent1.get())
  lb2.config(text = f"{n_to_l(n)}")
  return -­
1
 
	474	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
w = Tk()
w.title("My GUI-­
based grade converter")
w.geometry("500 x 200")
lb1 = Label(text = "Please input percentage grade:")
lb1.pack(fill = Y, expand = 1)
ent1 = Entry()
ent1.pack(expand = 0)
btn_convert = Button(text = "Convert", background = 
"#33FF88")
btn_convert.pack(padx = 10, side = LEFT, expand = 0)
btn_convert.config(command = hdl)
btn_quit = Button(text = "Quit", background = "#FF0000")
btn_quit.pack(padx = 10, side = RIGHT, expand = 0)
btn_quit.config(command = quit)
lb2 = Label(text = "Letter grade will be displayed 
here")
lb2.pack(fill = Y, expand = 1)
mainloop()
# this statement must be placed at the end to keep the 
window alive
As you can see, the GUI-­
based app is rendered much more nicely with the 
.pack() method. The .pack() method is used to pack a widget in the parent 
widget. The options of the .pack() method and their meaning are as follows:
•	 after = widget—­
packs it after you have packed the widget
•	 anchor = NSEW (or subset)—­
positions widget according to a given 
direction
•	 before = widget—­
packs it before you pack the widget
•	 expand = bool—­
expands the widget if the parent size grows
•	 fill = NONE or X or Y or BOTH—­
fills the widget if the widget grows
•	 in = master—­
uses master to contain the widget
•	 in_= f—­
uses fx to contain the widget
•	 ipadx = amount—­
adds internal padding in x direction
•	 ipady = amount—­
adds internal padding in y direction
•	 padx = amount—­
adds padding in x direction
•	 pady = amount—­
adds padding in y direction
•	 side = TOP or BOTTOM or LEFT or RIGHT—­
indicates where to add the 
widget
	
Develop GUI-­
Based Applications	
475
 https://doi.org/10.15215/remix/9781998944088.01
Because all the widgets inherit behaviours from the Widget class, it is worth 
learning about the general methods available in the Widget class for manipu­
lating widgets.
tkinter.ttk—­
Tk-­
Themed Widgets
In the past, people have complained about the look of GUI and the widgets of 
tkinter, which led to the development of themed widgets of tkinter, or Ttk for 
short. Now the Ttk module is part of the standard Python distribution. To use 
it, all you need to do is to import the modules in the sequence shown below to 
make sure Ttk overrides definitions of classes as intended.
>>> from tkinter import *
>>> import tkinter.ttk
Because themed widgets is based on the tkinter module, it overrides defin­
itions of classes, widgets, and methods.
Again, once imported, you can use help(tkinter.ttk) to get a rather detailed 
documentation of the module, as summarized below:
As for all GUI libraries, the core of the module are the widgets and meth­
ods associated with the widgets. All widget classes inherit from a generic 
class called Widget. The following is a list of widgets defined in the themed 
Tk module.
BUTTON(WIDGET)
Ttk Button displays a textual label and/or image and evaluates a command 
when pressed. In addition to the methods inherited from Widget, it has 
method specific for its purpose, invoke(self), which invokes the command 
associated with the button.
CHECKBUTTON
Ttk Checkbutton will be either in an on or off state. It has a specific method 
called invoke(self) in addition to those inherited from Widget. The invoke(self) 
will switch the Checkbutton between on and off states, further invoke the asso­
ciated command, and return the result of executing the command associated 
with Checkbutton.
ENTRY(WIDGET, TKINTER.ENTRY)
Ttk Entry displays a one-­
line text string that allows that string to be edited by 
the user. It inherits from Widget and tkinter.Entry.
	476	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
COMBOBOX(ENTRY)
Ttk Combobox widget combines a text field with a pop-­
down list of values. It 
inherits from Ttk Entry, described above. It has two methods of its own:
	
1.	 current(self, newindex = None)—­
if newindex is supplied, it sets the 
combobox value to the element at position newindex in the list of 
values. Otherwise, it returns the index of the current value in the list 
of values or −1 if the current value does not appear in the list.
	
2.	 set(self, value)—­
sets the value of the combobox to “value.”
SPINBOX(ENTRY)
Ttk Spinbox is an Entry with increment and decrement arrows. It is commonly 
used for number entry or to select from a list of string values.
FRAME(WIDGET)
Ttk Frame is a container used to group other widgets together.
LABELEDSCALE(FRAME)
Ttk Scale is used with Ttk Label, indicating its current value. Ttk Scale can 
be accessed through instance.scale, and Ttk Label can be accessed through 
instance.label.
LABEL(WIDGET)
Ttk Label displays a textual label and/or image.
LABELFRAME(WIDGET)
Ttk Labelframe is a container used to group other widgets together. It has an 
optional label, which may be a plaintext string or another widget.
MENUBUTTON(WIDGET)
Ttk Menubutton displays a textual label and/or image. It will display a menu 
when pressed.
OPTIONMENU(MENUBUTTON)
Ttk OptionMenu allows the user to select a value from a menu.
NOTEBOOK(WIDGET)
Ttk Notebook manages a collection of windows and displays a single one at a 
time. Each child window is associated with a tab that the user may select to 
	
Develop GUI-­
Based Applications	
477
 https://doi.org/10.15215/remix/9781998944088.01
make the associated window show up. This gives us a way to implement tabs 
like those in web browsers.
PANEDWINDOW(WIDGET, TKINTER.PANEDWINDOW)
Ttk Panedwindow displays a number of subwindows stacked either vertically 
or horizontally. It has the following specific methods:
	
1.	 remove(self, child)
	
2.	 insert(self, pos, child, **kw)—­
inserts a pane at the specified positions.
	
3.	 pane(self, pane, option = None, **kw)—­
queries or modifies the options 
of the specified pane.
	
4.	 sashpos(self, index, newpos = None)—­
if newpos is specified, sets the 
position of sash number index and returns the new position of sash 
number index.
PROGRESSBAR(WIDGET)
Ttk Progressbar shows the status of a long-­
running operation. It can operate 
in two modes. Determinate mode shows the amount completed relative to the 
total amount of work to be done, and indeterminate mode provides an animated 
display to let the user know that something is happening.
RADIOBUTTON
Ttk Radiobuttons are used in groups to show or change a set of mutually exclu­
sive options. The specific method invoke(self) sets the option variable to the 
option value, selects the widget, and invokes the associated command. It returns 
the result of the command or an empty string if no command is specified.
SCALE(WIDGET, TKINTER.SCALE)
Ttk Scale is typically used to control the numeric value of a linked variable that 
varies uniformly over some range.
SCROLLBAR(WIDGET, TKINTER.SCROLLBAR)
Ttk Scrollbar controls the viewport of a scrollable widget.
SEPARATOR(WIDGET)
Ttk Separator displays a horizontal or vertical separator bar.
SIZEGRIP(WIDGET)
Ttk Sizegrip allows the user to resize the containing top-­
level window by press­
ing and dragging the grip.
	478	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
TREEVIEW(WIDGET, TKINTER.XVIEW, TKINTER.YVIEW)
Ttk Treeview displays a hierarchical collection of items. Each item has a textual 
label, an optional image, and an optional list of data values. The data values 
are displayed in successive columns after the tree label. It has the following 
specific methods:
•	 bbox(self, item, column = None)
It returns the bounding box (relative to the Treeview widget’s window) 
of the specified item in the form of x y width height. If a column is 
specified, it returns the bounding box of that cell. If the item is not 
visible (i.e., if it is a descendant of a closed item or is scrolled off-­
screen), it returns an empty string.
•	 column(self, column, option = None, **kw)
It queries or modifies the options for the specified column. If kw is not 
given, it returns a dictionary of the column option values. If option is 
specified, then the value for that option is returned. Otherwise, it sets 
the options to the corresponding values.
•	 delete(self, *items)
It deletes all specified items and all their descendants. The root item 
may not be deleted.
•	 detach(self, *items)
It unlinks all of the specified items from the tree. The items and all of 
their descendants are still present and may be reinserted at another 
point in the tree but will not be displayed. The root item may not be 
detached.
•	 exists(self, item)
It returns True if the specified item is present in the tree; returns False 
otherwise.
•	 focus(self, item = None)
if an item is specified, it sets the focus item to item. Otherwise, it 
returns the current focus item, or '' if there is none.
•	 get_children(self, item = None)
It returns a tuple of children belonging to item. If the item is not 
specified, it returns root children.
•	 heading(self, column, option = None, **kw)
It queries or modifies the heading options for the specified column. If 
kw is not given, it returns a dict of the heading option values. If option 
is specified, then the value for that option is returned. Otherwise, it sets 
the options to the corresponding values. Valid options/values include 
text, image, anchor, and a callback command.
	
Develop GUI-­
Based Applications	
479
 https://doi.org/10.15215/remix/9781998944088.01
•	 identify(self, component, x, y)
It returns a description of the specified component under the point 
given by x and y or the empty string if no such component is present at 
that position.
•	 identify_column(self, x)
It returns the data column identifier of the cell at position x. The tree 
column has ID #0.
•	 identify_element(self, x, y)
It returns the element at position x, y.
•	 identify_region(self, x, y)
For the given coordinator (x, y) of a point related to the widget, it 
returns a string indicating one of the following: nothing (not within any 
functional part of the widget), heading (a column heading), separator (a 
separator between columns), tree (the icon column), or cell (a data cell 
within an item row).
•	 identify_row(self, y)
It returns the item ID of the item at position y.
•	 index(self, item)
It returns the integer index of an item within its parent’s list of 
children.
•	 insert(self, parent, index, iid = None, **kw)
It creates a new item and returns the item identifier of the newly 
created item, where parent is the item ID of the parent item or the 
empty string to create a new top-­
level item and index is an integer 
or the value end, specifying where in the list of parent’s children to 
insert the new item. If index is less than or equal to 0, the new node 
is inserted at the beginning; if index is greater than or equal to the 
current number of children, it is inserted at the end. If iid is specified, 
it is used as the item identifier, but iid must not already exist in the tree. 
Otherwise, a new unique identifier is generated.
•	 item(self, item, option = None, **kw)
It queries or modifies the options for a specified item. If no options are 
given, a dict with options/values for the item is returned. If an option is 
specified, then the value for that option is returned. Otherwise, it sets 
the options to the corresponding values, as given by kw.
•	 move(self, item, parent, index)
It moves item to position index in parent’s list of children. It is illegal 
to move an item under one of its descendants. If an index is less than 
or equal to 0, the item is moved to the beginning; if greater than or 
	480	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
equal to the number of children, it is moved to the end. If the item was 
detached, it is reattached.
•	 next(self, item)
It returns the identifier of an item’s next sibling, or '' if the item is the 
last child of its parent.
•	 parent(self, item)
It returns the ID of the parent of an item, or '' if the item is at the top 
level of the hierarchy.
•	 prev(self, item)
It returns the identifier of an item’s previous sibling, or '' if the item is 
the first child of its parent.
•	 see(self, item)
It ensures that the item is visible and sets all of the item’s ancestors’ 
open options to True and scrolls the widget if necessary so that the item 
is within the visible portion of the tree.
•	 selection(self, selop = <object object at 0x000002122111D7F0>, 
items=None)
It returns the tuple of the selected items.
•	 selection_add(self, *items)
It adds all of the specified items to the selection.
•	 selection_remove(self, *items)
It removes all of the specified items from the selection.
•	 selection_set(self, *items)
It makes the specified items become the new selection.
•	 selection_toggle(self, *items)
It toggles the selection state of each specified item.
•	 set(self, item, column = None, value = None)
It queries or sets the value of a given item.
•	 set_children(self, item, *newchildren)
It replaces an item’s child with newchildren.
•	 tag_bind(self, tagname, sequence = None, callback = None)
It binds a callback for the given event sequence to the tag tagname. 
When an event is delivered to an item, the callbacks for each tag option 
of the item are called.
•	 tag_configure(self, tagname, option = None, **kw)
It queries or modifies the options for the specified tagname.
•	 tag_has(self, tagname, item = None)
If an item is specified, it returns 1 or 0 depending on whether the 
specified item has the given tagname. Otherwise, it returns a list of all 
items that have the specified tag.
	
Develop GUI-­
Based Applications	
481
 https://doi.org/10.15215/remix/9781998944088.01
The Treeview widget provides a way to use tree-­
like structures to visualize 
and manipulate data and information. The methods available for manipulating 
trees are versatile.
Among all the widgets provided in themed tkinter, the newly added Treeview, 
Progressbar, and Notebook are very powerful and can be very useful in develop­
ing today’s GUI applications, such as those in the exercises, and projects below.
The content above Ttk and Treeview in particular are mostly taken from 
the official documentation of Tkinter, for the purpose to prepare readers 

for the projects at the end of this chapter.
For details on how Ttk can be used to develop GUI applications, please 
read the Ttk documentation at https://​
docs​
.python​
.org/​
3/​
library/​
tkinter​
.ttk​
.html and tutorials online such as the one at https://​
www​
.pythontutorial​
.net/​
tkinter/​
tkinter​
-ttk/.
Instead of giving code samples for each widget like we previously did, we 
conclude this chapter with the following sample program to show how Ttk and 
Treeview can be used in GUI application development:
import tkinter as tk
from tkinter import ttk
 
class FileManager:
    def __init__(self):
        self.root = tk.Tk()
        self.tree = ttk.Treeview(self.root)
        self.tree.pack()
        self.tree["columns"] = ("one", "two", "three", 
"four")
        self.tree.heading("one", text="Path")
        self.tree.heading("two", text="File name")
        self.tree.heading("three", text="File size")
        self.tree.heading("four", text="Last modified")
        self.tree.insert("", "end", text="1", values=("/
home/james/", "a.txt","213","June 3, 2023" ))
        self.tree.insert("", "end", text="2", values=("/
home/james/", "b.txt","215","June 5, 2023" ))
        self.tree.insert("", "end", text="3", values=("/
home/james/", "c.txt","217","June 7, 2023" ))
        self.root.mainloop()
 
FileManager()
	482	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Chapter Summary
•	 Terminal-­
based applications are those started and rendered within a 
terminal.
•	 A terminal is a system command-­
line-­
based application in which you 
can interact with a computer.
•	 On the Windows platform, Windows terminal, Windows PowerShell, 
and command prompt are examples of terminals.
•	 Within a terminal-­
based application, pointing devices such as a mouse 
cannot be used to interact with the application.
•	 A graphical user interface is a two-­
dimensional graphic area in which 
graphic objects or widgets can be created, placed, located, and accessed 
with mouse and keyboard.
•	 GUI-­
based applications look nicer and are much more user-­
friendly.
•	 Python has some very well-­
developed library modules for the 
development of applications with graphical user interface.
•	 The Tk and Themed Tk (Ttk) are the modules covered in this text; both 
come with the Tkinter package.
•	 The Tk module provides the fundamental widgets and operations 
needed for a graphic interface.
•	 To use the Tk module, use import tkinter, import tkinter as tk, or from 
tkinter import. *.
•	 The Themed Tk (Ttk) module provides programmers with more styled 
widgets to develop applications with a nicer graphical user interface.
•	 To ensure you are using the Ttk module instead of Tk module, override 
Tk by running statements from tkinter import * and from tkinter.ttk 
import * in order.
•	 To build a graphical user interface, create a main frame or window 
first.
•	 Other widgets can be created and added to the main frame/window as 
needed.
•	 Each widget has certain properties/attributes such as size, colour, and 
more.
•	 The properties of a widget can be set when created and changed later.
•	 A widget can be placed at particular location within the main frame or 
subframe.
•	 A function/method can be bound to widgets, such as a button, to help 
users interact with the graphical user interface.
•	 A graphical user interface needs to be rendered by calling the 
mainloop() method of main frame object.
	
Develop GUI-­
Based Applications	
483
 https://doi.org/10.15215/remix/9781998944088.01
Exercises
	
1.	 Explore the relationship between Tk and Ttk, and explain what the 
following code does:
from tkinter import *
from tkinter.ttk import *
	
2.	 Write a script that will render a window as shown in Figure 9-­
9.
	
3.	 Write a script that will render a page for login or registration, as 
shown in Figure 9-­
10.
Figure 9-­
10: Required GUI interface for the project
Figure 9-­
9: Required GUI interface for the exercise
	484	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
Projects
	
1.	 For this project, develop a GUI-­
based music player with the module 
mixer.music as well as the os and os.path modules for file navigation. 
The player should have a panel for the navigation and selection of 
music files, as well as buttons to control play, stop, and pause.
	
2.	 For this project, develop a course management system with a 
graphical user interface that meets the following requirements:
	
a.	 Define a student class modelling a student, including their name, 
student id, and start date in the class, as well as the name of the 
tutor assigned to them and a list of their assessment records. Each 
assessment record will be a tuple containing a number to identify 
the assessment, the weight of the assessment, and the mark, which 
should be 0 for a newly added instance to a course.
	
b.	 Define a course class modelling a course, including its course 
number (such as comp218), title, and revision number, as 
well as the date of its initial offering and a list of its students, 
professor(s). Additionally, include an assessment schedule as a list 
of assessment items where each assessment item is represented as 
a tuple of (id, name, weight) in which the id is the assessment item 
id, the name is the assessment name such as assignment 1 or final 
exam, and the weight is the percentage of the assessment that will 
go toward the final grade.
	
c.	 The GUI program should include and do all of the following:
•	 There should be a button for adding a new course to the system, 
which will open a form for input and save the basic course info 
(previously mentioned), with the list of students as empty. Note 
that when saving the basic course info, the system should be 
able to check whether the weight of all the assessment items 
makes up 100%.
•	 When a new course is added to the system, a unique binary file 
will be created as permanent storage of the course data.
•	 At the start of the system, it should automatically load all 
courses from their respective binary files to restore their 
internal object representation.
•	 There should be a button to get a list of courses being offered to 
students.
•	 A user should be able to select a course from the list.
•	 A user should be able to add students to the selected course.
•	 A user should be able to see a list of students in the course.
	
Develop GUI-­
Based Applications	
485
 https://doi.org/10.15215/remix/9781998944088.01
•	 A user should be able to select a student from the list.
•	 A user should be able to record an assessment for the selected 
student.
•	 The system should be able to automatically calculate and display 
the final grade of the student for the course.
•	 A user should be able to see a list of assessments, including the 
calculated final grade for the selected student.
•	 There should be a button to shut down the system, but before 
shutting down the application, the system must save/pickle each 
piece of course data back to its binary file.
	
d.	 Your analysis and design of the system should be well documented 
in your assignment report.
	
e.	 Within each of your program files, there should be a docstring at 
the beginning stating the name and purpose of the file, as well as 
its ownership and revision history. One docstring is required for 
each class and function/method class. An end-­
of-­
line comment is 
desired when deemed necessary.
	
3.	 In Project 1 of Chapter 7, you developed a terminal-­
based quiz system. 
For this project, you are required to develop a GUI-­
based quiz system 
also using the Quiz_item and Quiz classes you wrote in Chapter 7’s 
Exercises 7 and 8. The system should have controls/widgets on the GUI 
that will allow a user to do the following:
	
a.	 Create a quiz.
	
b.	 Select a quiz and add new quiz items.
	
c.	 Select a quiz and preview all the quiz items.
	
d.	 Select a quiz and execute the quiz by presenting the quiz items one 
by one.
	
4.	 Modify the quiz system developed for Project 3 so that after the quiz, 
it will present to the user the score as a percentage and the correct 
answers to incorrectly answered questions. The quiz items should be 
displayed to the user one by one during the quiz. Add a timer to the 
quiz so that the entire quiz must be done within a given time. To make 
sense of the timer function, you will need to show the total number of 
quiz items, the number of items left to be answered, the total amount 
of time allocated for the entire quiz, and the amount of time left for 
the remaining quiz items.
	
5.	 Further modify the quiz system developed for Projects 3 and 4, so 
that not only is the quiz timed, but each quiz item is also timed too, 
meaning that the user must answer each quiz question within a given 
time. For simplicity, we can assume that the time allocated to each 
	486	
Introduction to Computer Programming with Python
 https://doi.org/10.15215/remix/9781998944088.01
quiz item is the same and equal to the total time allocated to the quiz 
divided by the total number of questions in the quiz. To make better 
sense of both timers now, the time (number of seconds) left for a quiz 
question also needs to be displayed, and the quiz will move to the 
next question as soon as the question is answered or the timer for the 
question has run out.


ID: https://leanpub.com/s/21266BDE86AA47EA8A2D75570C7C1193.pdf
Document: Your First Year in Code
A complete guide for new & aspiring developers
Isaac Lyman
This book is for sale at http://leanpub.com/firstyearincode
This version was published on 2022-02-17
This is a Leanpub book. Leanpub empowers authors and publishers with the Lean Publishing
process. Lean Publishing is the act of publishing an in-progress ebook using lightweight tools and
many iterations to get reader feedback, pivot until you have the right book and build traction once
you do.
© 2019 - 2022 Isaac Lyman
Contents
Foreword . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
About the editor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2
About this book . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4
Introduction: Code is the best, code is the worst . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
Different learning pathways into tech . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
How (not) to learn . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
14
How to code (in one chapter) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21
Steps to better code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
41
Programming tools . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
51
You are an interpreter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
56
What to learn first . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
61
Learning to learn . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
64
Make the most of side projects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
70
Getting your first job . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
76
My first job . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
83
I got my dream job. Now what? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
85
Burnout, part 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
89
Burnout, part 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
92
Do I fit in? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
95
Women in code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
CONTENTS
What to do when you’re stuck . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
Choosing a job title . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
The DevOps introduction I wish I had . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
A coder’s code of ethics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
Software development beyond the keyboard . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
Code reviews . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
Appendix A: A coder’s vocabulary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
Appendix B: To make this, learn that . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
Appendix C: Recommended reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158
Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
Foreword
Your first year in code is a whirlwind, I know it was for me. The more you learn, the more you learn
that there’s more to learn. Code is such an abstract problem that there’s no set of always-applicable
rules or rock-solid advice. Code powers the planet these days, but knowledge is still passed down
through our elders and cultivated via community.
There is no one true way to be a coder. Gone are the days, if ever they truly existed, of the archetypal
“programmer.” We all carry supercomputers in our pockets. Cloud service outages are front page
news; email servers and encryption can be everyday political topics. The nerds have won and code
has become mainstream.
The only way for code to be for the people is if it is created by the people. We cannot let this craft
become magic wielded by a select few. We must ensure that the discourse is accessible to all.
The fact that this book is such a true bottom-up community initiative speaks to the soul of the
material. Isaac and the rest of the incredible authors assembled in these pages represent the warmth,
humanity, and diversity of our industry. If you are in your first year of code, you’re lucky to have
discovered material like this. I wish I had. It’s still a tremendous read years into my career.
Happy coding!
Ben Halpern
Founder, The DEV Community
dev.to/ben
About the editor
I’m a self-taught programmer.
By that I mean a lot of different people taught me to code. Mostly strangers. When I was in middle
school, I found an ebook called C++ For Dummies that my brother had bought. I read it until the
chapter on pointers, where I got confused and gave up. Then a few months later I did it again. I read
the first several chapters of that book over and over until I practically knew them by heart. I wrote
a Fahrenheit-to-Celsius converter. I started thinking about classes and objects. I was so curious.
Part of that curiosity stemmed from the fact that I identified with code. Computer programming was
nerdy, and I was a nerd. I mean, I had friends who wore Naruto headbands and played Yu-Gi-Oh!
in the cafeteria, and I wasn’t quite that nerdy. But by my senior year of high school I was president
of the computer support team and co-president of the speech and debate team, so that should tell
you what kind of kid I was. Code was exactly the kind of thing I wanted to play with.
Anyway, I learned Python a year or two after I first picked up that C++ book, and then a bit of
HTML, and then Visual Basic, and before long I had filled up a folder on my family’s computer with
ebooks and CHM files (an old form of hyperlinked documentation) that all had ridiculous titles like
Learn PHP in 24 Hours. I had even written a couple of programs on my TI-84 calculator to save
time on calculus homework. But I had also written off computer programming as an unrealistic
career ambition. Back then coding just seemed like a fun hobby for a kid who didn’t get out much.
I had no way of knowing that over the next decade Silicon Valley would explode with tech startups,
web developers would command salaries comparable to corporate lawyers, cell phone apps would
become a 100 billion dollar market, and nerds would take over the world.
So I set a more attainable career goal: become a business lawyer, then a politician. And that’d be the
whole story if I hadn’t run out of money during my sophomore year of college. After a disappointing
job search, I managed to land a position as a technical support agent, fixing printers and upgrading
operating systems in a cubicle on the outskirts of campus. And on the days when all the computers
were working and the printers were attending to their queues, I was learning JavaScript. The first
version of my personal website, isaaclyman.com¹, was built almost entirely during downtime on
that job. And I have that first website to thank for the career I have now.
I love this career, and I’m happy to report that I’ve been cured of all my former political ambitions.
I’m now a senior software engineer at a billion-dollar company that helps hospitals save lives
through cutting-edge healthcare analytics. I didn’t know it was possible to have this much fun at
work. But coding is fun, and I think that’s the first thing I want to say about it: for all the negatives
in this field of work (and there are a few), I still get a thrill whenever I write a clever piece of code.
Looking back on my career, it’s clear that I’ve had an extraordinary amount of privilege on my
side. Tech is full of gatekeepers, unwritten rules, poor documentation, and unacknowledged bias.
¹http://isaaclyman.com
About the editor
3
Sometimes it seems that everywhere you look, there’s someone else telling you you’re “not a real
developer” unless you’re exactly like them. Many talented programmers have been squeezed out
by these institutional problems. It will take a generation’s combined efforts to fix them, but in the
meantime, I hope this book can make a difference. In its pages are the encouraging and persistent
voices of your colleagues, telling you that you can do this, you’re smart enough, others have been
where you are, and we’re all in it together. My co-authors and I have done our best to write the tech
industry’s unwritten rules, call attention to its blind spots, share the knowledge we wish we’d had
years ago, and open the gates.
I hope this book is useful to you. If you have questions about anything you read here or just want
to say hello, you can drop me a line on Twitter (@isaacdlyman).
Good luck!
Isaac Lyman
About this book
It all started with a question: what do you wish you had known during your first year as a
programmer? I asked this question online when I announced the book, and before I knew it almost
a hundred software developers from around the world had volunteered to help me answer it. Some
signed up as beta readers and others offered to write content. The whole thing came together at an
incredible pace. In the end, the work of 15 other authors was selected for inclusion. The following
chapters represent some of the best, most practical advice the development community has to offer.
The author of each chapter is listed underneath the title.
The goal of this book is to help you start your programming journey a year or two ahead of where
we were when we started. There’s a lot of how-to, a splash of career advice, and a bit of pep talk. It’s
a good read for Computer Science majors, dev bootcamp students, beginning devs on a self-learning
path, or anyone who wants to figure out if programming is for them.
More importantly, this is stuff you won’t easily find elsewhere. You won’t get it in a college course or
a bootcamp. It won’t be in the company manual for your first job. Most software books are extremely
technical; this one is different. It will apply to you regardless of what sector or programming
language you want to get into. It’s mostly about the squishy stuff: what happens around and
outside the code. This is important because writing code is only a small part of a programmer’s
job—researchers have² found³ that the average programmer only writes about 25 lines of code per
day. Code is really just the beginning.
So what do programmers actually do? They go to meetings. They draw diagrams. They learn. They
get stuck. They bang their heads on their desks. They help their teammates solve problems. They
wade through an ocean of self-doubt. They field messages from tech recruiters. They update their
resumes and negotiate for remote work options. They balance their three-month-old baby on one
knee and a book about C++ on the other. They think methodically and ask questions nobody else
has thought about.
These things aren’t code, and in many ways they’re more important than code. They’re what this
book is about. And it’s about you: your career, your journey, all the amazing options that will open
up to you as you learn to code.
The book is not cumulative; each chapter stands on its own, so read them in any order you like.
We’ve done our best to keep things simple and avoid jargon, but if you encounter an unfamiliar
term, you can refer to Appendix A for a definition.
Whoever you are, we’re excited that you’re here. We have the highest of hopes for you. And we
hope you enjoy Your First Year in Code.
²https://blogs.msdn.microsoft.com/philipsu/2006/06/14/broken-windows-theory/
³https://dzone.com/articles/programmer-productivity
Introduction: Code is the best, code is
the worst
Isaac Lyman
Code is the best
Coding is an act of pure creation. It’s often exhilarating: you type a sequence of words into the
void and, assuming you don’t mess up, entire worlds begin to exist. Software development is one of
the few fields where you can create something of extraordinary value without expending any raw
materials. In a way, coding more closely resembles the TV stereotype of witches and wizards than
the TV stereotype of coders (or developers, or engineers, or whatever they call themselves—see my
chapter “Choosing a job title” for more on that topic).
There are moments as a software engineer when you know exactly what you’re doing. You come
into a project, see a problem you’ve solved before, and every component of the solution springs into
your mind. Suddenly you are a being of unstoppable force; you are elemental. You are typing as fast
as you can, everything is working perfectly, every piece is elegant. You hand off the finished product
and take in the admiration of your peers. It’s a triumph.
There are other times where you come up against a challenge you don’t have the first idea how to
solve. And this makes you happy too, because learning is fun. You start exploring, surfing Q&A sites,
reading the 11th page of old forum threads, copying snippets, compiling and debugging code, and
before you know it you’ve figured it out. You tuck the solution safely away in your mind for next
time. You can’t wait to do it again.
In the right environment, code is the ultimate brain teaser. Every last scrap of intelligence, creativity,
determination, quirkiness, playfulness, intuition—none of it goes to waste when you’re writing code.
You get so close to your own potential that you feel like you could reach out and touch it. That’s not
to say you’ll always be recognized for it, but it’s satisfying in and of itself.
Programming is a science, as we all know. But it’s also an art. Like the painter who imagines beautiful
sun-dappled landscapes, or the musician who wakes up whistling a tune, many programmers find
their imagination filling up with code. They daydream of apps and libraries. Their GitHub profiles
are full of projects that never got finished, but only because they were so eager to start on something
else. Not everyone is so obsessed—you certainly don’t need to be to have a successful career in code—
but everybody is here for something, even if it’s just the salary and benefits. And whatever your
reason is, there’s a place for you.
Introduction: Code is the best, code is the worst
6
Code is the worst
Coding can be a real headache.
There’s a well-known cycle to fixing bugs. You examine the problem; you make a guess about what
might be causing it; you update the code based on your theory; you test the new code; if the problem
isn’t fixed, you start over. Sometimes this goes on for hours. Sometimes for days. Sometimes until it
just doesn’t seem worth it anymore.
In the best of circumstances, you’ll be on a team of compassionate and attentive people. They’ll
listen to you and make tactful suggestions. You’ll take their ideas back to your computer and ride
a wave of genius all the way to your next task. Your boss will drop by your office afterward to tell
you what a great job you did. You’ll go home at 4:30 and spend the evening relaxing at home.
You don’t always get to work in the best of circumstances. Someday you may find yourself struggling
to concentrate in an open floor plan office, sharing a desk with eight other programmers, drowning
in noise from phone calls and water-cooler conversations. The company will expect you to work
16-hour days if you’re not meeting their deadlines, which they never consulted you about in the
first place. Your manager will think coding is black magic. Your teammates won’t seem to think you
belong in tech, and some of them will have never learned how to hold a polite conversation. Some
days will be a nightmare of egotistical managers, unreadable error messages, burnout and anxiety.
Sometimes you’ll wonder if you chose the wrong career.
Code is just a tool
The truth is, most of the time coding isn’t amazing. And most of the time it isn’t miserable. Code
is a means to an end, and the ups and downs of your career will be more about people than about
lines of code.
For now other people will decide what you build, who’s on your team, and whether you feel
emotionally safe at the office. But you’ve still got a few responsibilities. To be a good teammate—to
say things like “you belong here” and “it’s okay to make mistakes” and “you deserve a break.” To
break stereotypes about programmers being insensitive and rude. To have the courage to quit if your
boss doesn’t treat you or your teammates well.
Later on, you’ll be the one making decisions. Code will be the best on some days and the worst on
others, and it’ll be because of you. You’ll set the tone for an entire team or department or company.
We’re trusting you to do the right thing.
Different learning pathways into tech
Clifford Fajardo
There are many industries (law, medicine, etc.) where a formal credential is required before you
begin work in the field. By contrast, the software development field, like many creative fields
(business, art, etc.), does not require that you have a formal credential to start working in the field.
Given this fact, there are different learning pathways you can take to reach your goal of becoming
a professional software developer.
In the pages that follow, I’ll outline the learning path I took to become a professional software
developer. I’ll start off by sharing how I began programming, then cover my self-learning path,
coding bootcamp path, and university path, then circle back to the self-learning path I’m on now.
My aim is to shed light on the thought process I used to inform which learning path to embark on,
based on my circumstances, and ultimately demonstrate that there are several paths you can choose.
The night I discovered code
It was mid-December. I had just finished a semester of classes at my community college, and now
I had two weeks of vacation before the beginning of the new year. On one of these evenings, while
browsing the web as usual, I discovered a free learn-to-code website called codecademy.com. A few
short minutes into using the site, I made a blue box with HTML and CSS. A few minutes later I
made an alert box pop up on my screen with the message, “Hello Clifford.” I was astonished that I
had just made my computer bring an idea to life before my eyes. Thus began my journey into the
world of software development and teaching myself how to code.
The path of self-learning
After discovering codecademy.com, I continued learning the fundamentals of web development
whenever I had free time after work or class.
In 2016, halfway through my second year of college, I had been teaching myself to code for almost a
year. At that point I became curious about this hobby of coding I had picked up and naively started
doing research online to see if programming was something I could do full time as a job. To my
surprise it was, and in my research I stumbled upon some coding bootcamps. I found out that this
was an alternative learning path to a traditional college degree.
After this discovery, I started following the blogs of several bootcamps and the blogs of their students
who were sharing their experiences. Despite the excitement I had about bootcamps at the time, I
continued teaching myself web programming, kept the idea of attending a bootcamp as a possibility
in the back of my mind, and continued through college.
Different learning pathways into tech
8
My decision between college and a coding bootcamp
When April 2016 came around, I had completed my general education requirements at community
college and my college transfer letters came in. I was fortunate enough to receive full scholarships to
study Sociology at UC Berkeley and many other flagship state colleges. Despite this accomplishment,
I knew deep down that I wanted to pursue computer programming. More specifically, I knew front-
end software engineering was what I enjoyed and wanted to focus on.
I had a decision to make. I was conflicted about which path to take so I asked myself: Do you want
to spend two more years as a transfer student to complete the remaining half of your undergraduate
degree, studying something you’re no longer enthusiastic about? Or would it be better to pursue
your dream now and maximize your personal growth and development?
I decided to make a seemingly risky but nonetheless well-calculated decision based on my
circumstances: to put my formal education on hold and do the Hack Reactor coding bootcamp,
an immersive 12-week course. Choosing Hack Reactor, I would later come to realize, was one of the
best decisions I had ever made in my life.
Why I chose a bootcamp
The bootcamp approach made the most of my circumstances. I didn’t want to switch majors and be
in a classroom for another four years, despite having had a fantastic experience in college. Instead,
I felt I could be gaining years of work experience, problem-solving skills, and personal growth, all
while getting paid to learn and earning income for my family.
I considered continuing on the self-learning pathway. However, I felt I could accelerate my learning
by being around other highly motivated peers and following a rigorous curriculum, which I probably
wouldn’t have had the courage to tackle alone at that time. Ultimately I wanted to obtain a high
degree of competency quicker, in a more structured environment, and kickstart my career.
Truthfully, another major factor that influenced my decision was the fact that I was tired of
struggling financially and living under the poverty line. I was tired of seeing my twin brother and
my parents, a janitor and a physically disabled stay-at-home mom, under financial strain. If I had
chosen to go major in computer science given my circumstances, I would still be finishing my last
year of college right now and my family would still be struggling, which is no longer the case.
Though I did have to combat thoughts about being a “dropout,” I believed I could break into the
software industry. Market conditions in my area were favorable (they generally still are across the
United States) and there was plenty of evidence and testimony that I could start a fantastic career
as a software developer without a degree, since thousands of other bootcamp graduates had done so
before me.
“Why didn’t you just change your major to computer science (CS) at community college?”
Different learning pathways into tech
9
Changing my major to CS would have meant staying another 2 - 2.5 more years at my community
college and taking several classes merely to complete prerequisites so I could qualify for the CS
major at the universities I was applying to.
Another consideration was that all of the colleges I was applying to transfer to didn’t offer a
curriculum covering the topics I was most interested in. I wanted to take courses where I could
learn about web applications, JavaScript and NodeJS, front-end web development, and responsive
design.
“Why didn’t you change your major to computer science (CS) at the four-year university,
UC Berkeley?”
I wouldn’t have been able to switch my major to CS without taking all the pre-requisite classes for
the major. Again, that would have meant two more years of classes just to qualify for the major.
On top of that, after qualifying, I would need another two years’ worth of upper division credits to
graduate. This meant it would take me four more years of school before obtaining a degree and my
first full-time entry-level job. The idea of spending four more years in large classrooms worrying
about my grades and studying a wide array of topics that weren’t immediately relevant to my goals
didn’t resonate with me.
In summary, I chose the bootcamp for three main reasons: (1) To get to my goal sooner by being in
a structured, immersive learning environment; (2) To support my family; and (3) To study the areas
of software development that I wanted, which weren’t offered at colleges in my area.
After beginning my career as a software engineer at Salesforce in San Francisco, I attended a semester
at UC Berkeley as a working student and took one of their most popular computer sciences classes. I
had the opportunity to experience what it was like to study computer science in a college setting, and
it validated what I felt previously. I preferred learning environments where I had more flexibility
to choose what to learn and where I didn’t need to worry about grades. Although the college path
wasn’t for me, for many people the college path is excellent and offers a lot of value.
A high-level overview of coding bootcamps
Coding bootcamps are immersive technical coding schools that teach the essential programming
skills and technologies that employers seek.
In terms of curriculum and learning structure, not all bootcamps are the same. Some are in-person,
others are online; the majority require a full-time commitment while others are part-time. The goals
and curriculum of each coding bootcamp may be different as well. For example, there are bootcamps
that focus on mobile development, data science, machine learning, full-stack web development, and
so on.
A few more considerations about bootcamps are:
• Instruction: There are bootcamps that help people with very little or almost no coding
experience get to a job-ready stage. In contrast, some coding bootcamps require candidates to
Different learning pathways into tech
10
have a minimum of a few months of self-study experience and meet a specific technical bar via
an admissions test. Most coding bootcamps require admitted students to complete pre-course
material before starting the program. This ensures every student is beginning with nearly the
same baseline knowledge and helps maximize the content that can be covered in the program’s
few months.
• Quality: Generally, the more rigorous the admissions standards are, the higher the quality of
instruction, curriculum, students, alumni network and job success outcomes.
• Alumni networks: Generally, the longer a bootcamp has been around, the more alumni you
have access to. For example, I’m part of an alumni network of several thousand graduates
who are working across nearly every subset of the software development industry. As a new
graduate or an experienced alumnus, this may be helpful since you have a large pool of people
you can connect with.
• Price: The tuition varies for each bootcamp. Many programs allow you to put down a small
down payment (or nothing at all) and pay back the rest of the program fee once you secure a
job as a software developer.
• The job hunt after the program: Similar to colleges that may have a career center to help guide
and support students in their job hunt, most bootcamps offer that as well. It’s important to
note that if you are coming into a bootcamp with the expectation that a job will be handed to
you after you graduate or that it’s the bootcamp’s responsibility to find you jobs, that’s not the
reality. You should leverage all of the resources that your bootcamp has to offer to maximize
your odds.
• How long it takes to obtain a job: Some of your peers will find jobs much faster than others,
due to varying circumstances. For example, it took me two and a half months of studying and
job hunting every day to secure my first software developer job, but it may be different for
you.
I want to highlight that bootcamps are not for everyone. It’s essential to evaluate your own goals
and learning style and make the choice that meets your needs best.
The cost of forsaking a computer science degree
It’s important to briefly address a few points concerning the cost of forsaking a computer science
degree, as to avoid any surprises:
• You will be competing for the same jobs that computer science graduates are applying for. You
will need to work hard to demonstrate that you have what it takes to do the job and have the
ability to fill any knowledge gaps for a role.
• It may be harder to initially demonstrate to employers the value you bring without a formal
credential. However, do not be discouraged. The good news is many (perhaps most) employers
nowadays have progressive hiring practices and will consider anyone who has the skills
required for the role and who they feel is a good match.
Different learning pathways into tech
11
• Some jobs and employers require a computer science degree, which is fair given that every
employer has different needs.
• Often, as a bootcamper or self-learner, you won’t get the broad exposure to software (operating
systems, compilers, distributed systems, etc.) that most computer science graduates obtain.
Some may doubt the importance of this; however, no one can dispute that knowing more
about what exists and what tools are available to you is beneficial. Of course, you can always
fill in gaps in knowledge if you’re deliberate about your learning.
Differences between bootcamps, colleges and self-taught
pathways
Below is a brief overview of the differences and similarities between the different learning paths
discussed in this chapter. At the end of this chapter, additional resources are provided for those who
would like more information.
Time Commitment
• Bootcamp: 3-9 months; varies depending on the bootcamp.
• College: 4 years; varies depending on the college or individual.
• Self-Taught: varies depending on the individual and whether they are studying part-time or
full-time. Some people qualify for a development job in a few months, others may take several
months and others a year or more.
Financial Cost
• Bootcamp: Varies depending on the reputation and duration of the program. Most immersive
bootcamps range from $9,000 - $20,000 USD.
• College: Varies depending on the college, reputation and duration of the program. According
to a 2019 statistical report on the average cost of a 4-year college in the United States:
– Public 4-year college: ∼$20,000 / year (assuming no financial aid or help at all). Subtract
∼$11,000 if you are living at home.
– Private 4-year college: ∼$46,950 / year. Subtract ∼$11,000 if you are living at home.
• Self-Taught: Cost varies depending on the courses and resources you purchase. It’s possible to
obtain most or all of the information you need for free, online or with a library card. Some
libraries have partnerships with paid services (e.g. Treehouse or LinkedIn Learning).
Learning Curriculum
• Bootcamp: Shorter length programs (∼12 weeks) focus on a very specialized curriculum to
help students develop expertise in only a few technologies. This tradeoff is intentional, as most
bootcamps assume and trust that their graduates will continue learning the necessary skills they
need throughout their career. Longer programs, like the Lambda School which is 9 months long,
not only teach highly marketable technologies but also do their best to bridge the gap between
the exposure computer science majors typically obtain and what shorter bootcamps often don’t
cover.
Different learning pathways into tech
12
• College: Given that there is more time to cover material, computer science graduates tend to
have a much broader view of the entire field of programming, especially when it comes to
theory. As one computer science graduate, Christian Charukiewicz, puts it:
Personally, as someone who has just finished their CS degree, I can tell you that I feel like
my learning has only begun. I think one of the most valuable aspects of my degree is that
it has lifted many of the “unknown unknowns” and turned them into “known unknowns.”
That means I may not be an expert in compilers, or system programming, or CS theory, or
any of the topics I studied in college. However, I know that they are out there, and I know
what most of them are so that I can research them and hone my skills as needed as my
career progresses.
• Self-Taught: With freedom comes a great deal of responsibility. You will need to dedicate lots
of time to curating your own learning material and continuously evaluate the quality of the
resources you are consuming, as opposed to a college student or bootcamper who is following
a structured learning curriculum. For the highly dedicated learner, being in complete control of
one’s education can be a source of great satisfaction. On the flip side, it’s easier to consciously
or unconsciously neglect learning topics that may be essential for your growth, since there is
less guidance. You don’t know what you don’t know.
Networking and Cultural Growth
• Bootcamp: The majority of my peers already had years of professional experience and degrees
in other industries, as many bootcampers are transitioning between careers. Bootcampers can
leverage their past experience to help them obtain new opportunities in the software field. For
example, I have a friend who was a DJ/audio engineer before becoming a programmer. He
went on to work for a music streaming company after bootcamp.
• College: Typically younger aged peers, 18-25, without full-time work experience. Colleges
usually offer internships, volunteer opportunities, and projects for students to gain practical
experience.
• Self-Taught: There’s no built-in network when you’re self-taught, so you’ll need to rely on
jobs, meetups, conferences, open-source projects, social media, and other self-driven forms of
outreach in order to build your network.
Similarities: bootcamps & college
Networking and Cultural Growth
• Your peers, instructors and alumni network are easily accessible since you typically see them
daily. This translates into having people close by to quickly learn and expand your worldview
from, not just in programming.
Different learning pathways into tech
13
Job Support
• Nearly all bootcamps and colleges have a career or job resources center for students and
alumni; they have a vested interest in your success. After all, what institution wouldn’t want
to showcase their graduates succeeding?
Learning Curriculum
• The material you are learning has been evaluated and selected by others. Thus, you can spend
your energy on learning, instead of hand-curating your learning resources.
Additional resources
• Teach Yourself Computer Science⁴ - An opinionated guide to Computer Science learning for
self-taught devs and bootcamp grads.
• CourseReport: Coding Bootcamp Cost Comparison⁵ - A list of coding bootcamps in the United
States and how much they cost.
• Average Cost of College in America: 2019 Report⁶ - An overview of the full cost of college
attendance in the United States.
• Coding Bootcamp vs. Computer Science Degree⁷ - An infographic comparing several aspects
of college degrees and development bootcamps.
• Bootcamps vs. College⁸ - A comparison of bootcamp and college grads from the perspective of
a company that specializes in developer job placement.
• Would you choose a coding bootcamp or a computer science related degree? Why?⁹ - A
collection of differing opinions on whether a bootcamp or college degree is the better choice.
• Treehouse for Libraries¹⁰ - Information on the availability of Treehouse’s software development
courses through your local library.
• The Odin Project¹¹ - A course in web development for self-taught developers.
⁴https://teachyourselfcs.com/
⁵https://www.coursereport.com/blog/coding-bootcamp-cost-comparison-full-stack-immersives
⁶https://www.valuepenguin.com/student-loans/average-cost-of-college
⁷https://www.whatsthehost.com/coding-bootcamp-vs-cs-degree/
⁸https://triplebyte.com/blog/bootcamps-vs-college
⁹https://www.quora.com/Would-you-choose-a-coding-bootcamp-or-a-computer-science-related-degree-Why
¹⁰https://join.teamtreehouse.com/libraries/
¹¹https://www.theodinproject.com/
How (not) to learn
Vlad Levin
Image licensed by Pixabay¹²
When I was younger, I remember having some odd ideas about what it meant to learn. In particular,
I recall that I thought learning meant reading a textbook very diligently from beginning to end. I
would even read the foreword. Maybe that was just me! Now I look back and wonder why I had
such strange and unproductive notions.
However, I think the education system at every level does tend to suffer from problems that prevent
people from learning effectively: students are shepherded through too many subjects at a time and
learn the material in a linear and rote manner. As a result, I think it’s not uncommon for people
to promptly forget much of what they “learned” in school, including at colleges and universities, as
soon as they pass their exams.
The following are some heuristics I’ve built up over time which have helped me when I’m learning
something new. If you have the luxury of learning something on your own, consider trying these
out. Even if you’re in school, I hope some of these ideas may be of help if you actually care about
learning instead of just getting through the classes.
¹²https://pixabay.com/es/illustrations/narrativa-la-historia-sue%C3%B1o-decir-794978/
How (not) to learn
15
Build intuition
With almost any technical subject, it’s easy to get involved in all of the complicated details. Doing so
prematurely can be a bad idea though. If we don’t understand the broader context, those technical
details can quickly overwhelm us.
When you’re first reading about a given topic, try to grasp the big picture. Why is this important or
useful? How does it fit with other topics or technologies? What’s the problem that it’s trying to solve?
Is there another way to look at this? Answering questions like these will give you a perspective that
will help motivate a deeper understanding as you dig into the more technical details.
Building intuition is a gradual process. Often clues can be found sprinkled through a given book
or other source of information. Keep an eye out for the clues and use them to build up a picture in
your mind of the high level principles and connections. Always keep asking yourself: “What’s the
big idea here?”
Intuition is something everyone works on, from novices to experts. As a novice programmer, I
remember learning C for the first time. At first I had difficulty understanding the starting and ending
conditions of for loops, e.g. for (int i=0; i<length; i++). I distinctly remember making notes
in a notepad, manually tracking the value of i, as well as sketching an array with arrows pointing
to the current index during and after each iteration. Eventually it became second-nature, but I still
remember that it wasn’t obvious to me in the beginning.
Later on, I used similar strategies to get familiar with increasingly complex recursive algorithms. I
would work through small examples manually. Again, I drew small sketches, showing everything
on the stack before and after each recursive call. This helped me to internalize what was really going
on with a given algorithm.
Here’s another real-world example of building intuition: fairly recently I needed to look up the
formula for standard deviation in statistics. It wasn’t my first time using it, but this time I suddenly
noticed that part of the formula looked a lot like the Pythagorean theorem. That had never occurred
to me before. I was able to work out that the standard deviation can be thought of geometrically, in
terms of the distance between two points. This was very exciting for me. Before, I had always taken
the formula for granted, as a black box. I knew how to use it, but I didn’t know why the equation was
what it was. Afterward, I felt that I understood it much better. I could visualize what was happening,
and I knew that from now on, it would be easy for me to derive the formula from scratch.
Once something becomes intuitive, you can visualize it, you know when it applies and how it works,
without needing to consciously think about it.
Knowledge debt
In the same way that there’s financial debt and technical debt, there’s also knowledge debt. If we’re
faced with something we don’t understand, often the temptation is to move ahead anyway, hoping it
won’t bite us later. In fact, sometimes that’s okay. Maybe an in-depth understanding isn’t necessary—
we just need to get a specific thing done. Or maybe going further into the material will elucidate the
point we’re stuck on right now.
How (not) to learn
16
Both of these things can be true at times, but it’s not a good approach to leave behind such gaps
as a matter of course. It will cause the foundations of our knowledge to get more and more shaky.
Eventually, that’s precisely what will stall progress completely. For instance, a lot of people think
math is “too hard.” I believe the reason is that they kept being pushed along in school to more
advanced topics, but all the while they were leaving more and more loose ends behind.
Any technical subject, including math, computer science, and programming, requires effort (at least
for us mortals), but if you take it one step at a time, and you make sure to master the individual
steps along the way, you can go a lot further than you might think.
PDL: Problem-Driven Learning
Just as test-driven development (TDD, see below) is about writing code to satisfy a measurable
criterion—making a test pass—I like applying the same notion to learning. Learning can seem like a
passive process of osmosis. However, we’re fooling ourselves if we think we understand that way. It’s
okay to read something lightly to get a broad overview of a topic, but if we really want to understand
how to apply our knowledge, we should make the learning a result of solving problems. This is the
best way to make the leap from theory to practice.
We can start with a simple problem and learn just enough to solve it, kind of like making a test
pass in TDD. Moving on to a similar, maybe slightly harder problem, can we solve it without doing
any extra reading? If so, great. Otherwise, we go back over our material to find what we need. This
makes our reading much more active and goal-oriented.
The more problems we can solve and the more diverse those problems are, the stronger and more
concrete our understanding becomes. This is the only real measure of how well we understand
something.
What is TDD? Test-Driven Development, or TDD, is a practice that’s used to improve the
quality of new code. The idea is to develop functionality in small steps. Each step starts
with a unit test (see Appendix A, “Automated test” and “Unit test”). Each test has 3 parts.
The first part describes the initial conditions for the test. The second part describes the
action to be taken by the test. The third part describes the changes that are expected as a
result of the action.
After you’ve written a test, you start things off by running it. It’s good practice to run a
test before you actually implement the behavior described in the test. Therefore, a brand
new unit test should generally fail when you run it for the very first time. Once you’ve
demonstrated that the test initially fails, you fill in the code that the test is targeting.
Having done this, you can confirm your code works correctly by running the test again.
This time it should pass. The last step is called refactoring. The idea is to look at the
code you’ve written to make the test pass and to clean it up. This is your opportunity to
remove duplicate logic and to clarify the naming of things like classes, functions, variables,
etc. Basically you can reorganize your code however you wish as long as the expected
behavior doesn’t change. Once you’re done refactoring, you can run the test once more to
How (not) to learn
17
make sure that it still passes. Unit tests are helpful when you’re initially developing a piece
of functionality, but they’re also useful in regression. That means you can periodically run
your entire test suite, say before committing your code to your repository. If anything
you’ve done breaks older tests, that alerts you to the possibility that you’ve introduced
bugs with your latest code, and gives you a chance to fix those bugs first. Making sure all
of the tests pass before checking in is a good practice. It gives you additional confidence
that your code is still all working properly.
Multiple sources of truth
Reading a single textbook or article is often a bad idea. Any source of information will be written
in a particular context. It will skip some steps and also make assumptions about what you know. If
you’re confused (and even if you’re not!), it’s good to look for additional sources.
If the material you’re reading seems too advanced, look for more beginner-friendly treatments. If
you’re reading about something in a particular programming language and it is not making sense,
try to find the same topic addressed in a language you’re more familiar with. Maybe what you’re
currently reading is too technical. In that case, look for high level descriptions to build intuition
about the subject. In that regard, I really like the idea of ExplainLikeImFive¹³, a tag used online for
articles that explain complex topics very simply.
Fewer subjects at a time
I’ve talked to a lot of graduates from schools in many fields about their experiences, including math,
science, medicine, dentistry, etc. Often enough, it’s the same story: Learn by memorization, pass the
exam, forget most of it, and repeat. I don’t think it’s the students’ fault either. Students are loaded
with so many classes to take each semester that it’s very hard to do even a halfway decent job of
learning. I think this is true in pretty much every field of study, and it’s certainly true in computer
science.
For most people, I think that cutting down the number of courses and focussing on fundamentals
would be much better. When a student completes a class, it should mean they have mastered the
material. The same idea applies for people learning on their own: Pick one or two subjects to work
on at a time, and pay careful attention to really figure them out.
Ask your own questions
While solving pre-defined problems and exercises is very useful, it can get monotonous. There’s
also something a bit passive about it. It’s better than merely reading, but we’re still leaving it up to
someone else to test our knowledge.
¹³https://dev.to/t/explainlikeimfive
How (not) to learn
18
How about coming up with our own problems? When you’re learning something new, ask yourself
questions about it. What does this imply? Is there a more general way of looking at it? Is it similar
to something else? Can it be applied like so?
With programming, you can write small programs to test your ideas. I highly recommend creating a
coding playground folder. Any time you are trying to understand something, create a small example
program to test it out in your playground. You can also come up with larger projects to work on.
Such larger projects will force you out of the tidy confines of well-defined exercises. You’ll need to
integrate disparate areas of knowledge and think creatively to make your way around roadblocks.
Often questions will arise naturally when you’re learning something new. It’s easy to let those
questions drift by and to forget about them. Or, a question may occur to you, but you’ll dismiss
it with negative self-talk, “oh that’s a dumb question.” That’s really a disservice to yourself though.
Being curious and making connections is a good thing. Censoring yourself, on the other hand, will
just slow down your learning process.
There are naive questions, tedious questions, ill-phrased questions, questions put after
inadequate self-criticism. But every question is a cry to understand the world. There is
no such thing as a dumb question.
∼Carl Sagan
You may find it helpful to have a notebook (or note app on your phone) always nearby. As soon as a
question comes up, make a note of it. Then see if you can figure out the answer yourself. If so, great.
If not, that’s okay too. It’s still good that you thought of your own brand new question! Now you
can practice your research skills to get an answer.
As an example, a while ago I was writing some JavaScript code using async functions. As I was
working, it occurred to me that it would be nice to combine a generator function and an async
function together. I didn’t know whether that was possible. After doing a bit of research, I found
out that asynchronous iterators and generators had been proposed as a new feature for JavaScript.
As of 2019, the new syntax is part of the ECMAScript 2020 Language Specification. It’s also already
supported by Node.js and by several major browsers.
When you take a hands-on approach to learning, I think you’ll find that questions will naturally
come up. If you want to practice though, try thinking about ways that an existing concept can be
extended or combined with something else. Asking yourself questions is like exercising a muscle.
The more you practice, the easier it will get.
Challenge your material
Whenever you’re learning something, challenge the material and look for mistakes. Don’t just take
everything as gospel. Even when there aren’t mistakes, this kind of active learning will ensure that
you really do get it. When you challenge the material, it makes you explore edge cases and counter-
intuitive possibilities. Doing so will make your understanding robust. You’ll know how something
How (not) to learn
19
works, and you’ll also know in a hands-on, concrete way, the limitations and exceptions that go
along with it.
A friend of mine told me a story from when she was in high school. She was learning special
relativity in physics, and kept pestering her teacher with examples that seemed to defy the principles
of relativity. I think her teacher was not equipped to answer those questions properly. It’s actually
well-known that there are a lot of scenarios in special relativity that initially seem to violate the
rules. Understanding those edge cases is essential to have a proper understanding of the subject. I
think what my friend was doing was great, and it’s too bad that her teacher didn’t understand the
material well enough to encourage her properly.
Go back and review
Sometimes we don’t realize that we missed something in our study until later. We start a new topic
and suddenly things we thought we understood become confusing. That’s a good time to stop and
go back to review that earlier subject matter. Don’t just re-read it passively though. Go hunting for
insights relative to the new information you’re grappling with. Real understanding is not a linear
process. It’s iterative. There is a continual need to go back and shore up gaps in our learning that
maybe we didn’t know were there, or that reappear over time as we forget things.
When I am studying something new myself, I find that I will regularly return to the same material
several times. The first time I may struggle with completely new concepts. The next time around,
I will start to get it. The third time, I begin to focus in on a smaller number of things that stand
out as being harder than the rest. As time goes on I come up with more of my own questions and
sometimes push the material in directions that are not mentioned in the book, article, or tutorial
that I’ve been reading.
It can also be okay to study something up to a point, put it away, and return to it later on. Often
we can acquire background knowledge in the meantime that makes us more prepared to tackle the
material again once we come back to it.
Fundamentals are important
Often, especially in the field of technology, there tends to be a bit of an obsession with specifics,
like a particular programming language, library, or framework. I think this is a tendency we should
resist, especially since technologies go through such incredible turnover. The darling of the moment
may be all but forgotten in a couple of years.
If you start your education with overly specific technologies, I believe it will limit your ability to
adapt, or to switch from one area to another. In addition, when we learn a particular technology in
isolation, it often makes our level of understanding more superficial. It means that as soon as we
leave the comfort zone of the context in which we learned the technology, we can quickly become
lost.
Focussing on fundamentals means trying to identify the core concepts and building blocks under-
lying any technology or paradigm. Doing so is like having a good understanding of how to build
How (not) to learn
20
things using lego blocks. It gives you the power to imagine any structure and build that from scratch
rather than having to follow the blueprint that comes with a pre-packaged set.
Here’s one possible example: Let’s say you’ve learned how to use several frameworks and libraries for
a front-end application. Perhaps you’ve used a CSS library like Bootstrap or a JavaScript framework
like React, Vue, or Angular. Do you know what problems these frameworks are trying to solve? It can
be helpful to develop a small browser application using only HTML, CSS, and plain Javascript—no
CSS framework, no JavaScript framework, nothing else. You’d be responsible for updating the page
yourself whenever something changes. You’d also be responsible for making sure your JavaScript
works properly for every browser that you want to support. Doing something like this can provide
insight into why we use certain technologies. It also tends to make it easier to learn a new technology
in the same general category, because you understand the underlying motivation of its developers.
More generally, it’s always good to delve into the basics of computer science. You can consider
investing some time learning about boolean logic, electronics, data structures, algorithms, operating
systems, networking protocols, databases, computer graphics, AI and machine learning, bioinfor-
matics and genomics, discrete math, linear and abstract algebra, probability and statistics, calculus,
etc. There are so many fascinating fields that computer programming touches or relies on. Building
up the depth of your knowledge in such fundamental areas will enrich your understanding and
appreciation. Don’t worry about trying to do this all at once though! (Unless you’re doing a C.S.
degree, that is.) If you can pick one or two areas at a time, and just build up your knowledge gradually,
that’s great. Over time, every small step will add up.
Any specific technology can be seen as some combination of fundamental ideas applied in a
particular way. Looking at things in this way is very powerful. It’s like a superpower, allowing
you to pick up new things quickly and leaving your colleagues wondering how you did it!
How to code (in one chapter)
Isaac Lyman
Note: This is the longest chapter by far. It also contains a fair amount of sarcasm. Many people
appreciate the light humor in such a long read, but be sure to take it with a grain of salt.
This chapter is not a complete coding manual. It’s a drive-through introduction to just enough coding
concepts and keywords to get you from zero to a basic script.
First of all: take a deep breath. The picture above isn’t real code. At least, it isn’t code that anyone
uses. Real code—what I write on the job—is mostly composed of English words, symbols, numbers
(all ten of ‘em, not just ones and zeros), and made-up names. Once you learn a bit of vocabulary, it’s
readable. I’m going to cover each of these later on.
Let’s get started.
What is a computer program?
A computer program—also known as an app, an application, or a piece of software—is a collection of
many lines of special text. They’re special because a computer can understand them, and computers
are incredibly dumb. The smallest practical apps have a hundred or so lines of text in them. The
largest apps have billions¹⁴.
¹⁴http://cacm.acm.org/magazines/2016/7/204032-why-google-stores-billions-of-lines-of-code-in-a-single-repository/fulltext
How to code (in one chapter)
22
We call this special text code. Code is a set of step-by-step instructions, like a recipe. It tells computers
what to do with data. Data is any piece of information that a computer can hold in its memory.
Modern computers are pretty good at holding things like dates and sentences. If you have a Twitter
account, then Twitter’s got some flat, ugly computers at a warehouse that are holding your birthday
and every tweet you’ve ever tweeted. Along with 300 million other people’s birthdays and tweets.
Source: https://commons.wikimedia.org/wiki/File:CERN_Server_03.jpg¹⁵. Unmodified image licensed
under CC BY-SA 3.0¹⁶ by Florian Hirzinger
That’s all data. Don’t worry, the computers aren’t sitting around reading your old tweets for fun.
And if they did, it wouldn’t be “fun,” anyway. It would be painful. Your tweets are dumb, just like
mine.
When you visit twitter.com, your computer borrows a whole bunch of code from one of those ugly
warehouse computers. It speed-reads the heck out of that code. And then it executes that code, which
means that the computer does exactly what the step-by-step instructions tell it to do.
If the instructions are written very carefully, it’s all peaches from here on out. Twitter will work. It
will publish your dumb tweets to the entire world. It will let you read other people’s dumb tweets.
It will let you “like” those tweets.
If there is any flaw in those instructions—anything from a typo to complete misinterpretation of
the data—then Twitter will not work. It will show an “Error” message, or crash the app, or suffer in
silence, secretly doing things with your data that you would prefer it not to.
That’s the catch. Coding isn’t very hard. It requires you to memorize a couple hundred terms and
¹⁵https://commons.wikimedia.org/wiki/File:CERN_Server_03.jpg
¹⁶https://creativecommons.org/licenses/by-sa/3.0/deed.en
How to code (in one chapter)
23
learn some grammar rules—you could do this with English (or your native language) by the time you
were two, and human languages are a mess. What is hard is being called out by an anal-retentive
computer every time you press a wrong key or misunderstand a concept. The hard part about coding
is the sheer amount of frustration you have to absorb.
The fun part is the problem-solving. In modern software, real-world problems become puzzles that
can be solved by code—but only after you truly understand them. Once you wrap your mind around
every possible permutation of a problem, you can write code that addresses it thoroughly, step by
step.
The tools of the trade
A programmer’s toolbox typically consists of a few things:
• A computer.
• An internet connection. You need an internet connection so you can use Google. When you
don’t know how to do something (which happens about 787283493857 times per day) you
Google it. When your app gives you an error message, you Google it. You Google everything.
• A code editor (or an IDE, which is a code editor on steroids). Think of it as Microsoft Word for
coding. It helps you organize and proofread your code.
• A compiler or interpreter. This is a program that reads your code, tries to find mistakes so it
can bug you about them, gathers your code into a nice little package, and then passes it on to
the computer to execute. It does a lot of other things, too, but these are the things you need to
know about right now.
• A good pair of headphones. These help you ignore people so you can focus.
You probably already have a computer. Since you downloaded this book, you definitely have an
internet connection and an interpreter (Firefox and Chrome have interpreters built in). There are
plenty of free code editors available online (like VS Code¹⁷ or Atom¹⁸). I can’t help you with the
headphones, but a good alternative is staring at people until they leave.
So you’re all set, right?
Programming languages
There are thousands of programming languages in the world. Many of them are dumb¹⁹ and useless²⁰.
You can have a long and happy career only knowing three or four—but don’t worry, this isn’t as hard
as learning three or four human languages.
Programming languages are often described by their paradigm, which is a way of categorizing the
kinds of features they have. For example, JavaScript is the language that all web browsers run, and
¹⁷https://code.visualstudio.com/
¹⁸https://atom.io/
¹⁹https://en.wikipedia.org/wiki/Esoteric_programming_language
²⁰https://en.wikipedia.org/wiki/Code_golf#Dedicated_golfing_languages
How to code (in one chapter)
24
possibly the most popular programming language in the world. It has a diverse feature set; I might
say that JavaScript supports imperative, structured, object-oriented, and event-driven paradigms.
And you might say I’m a pretentious geek.
You don’t need to know what all those words mean. What you do need to know is that programming
languages with similar paradigms usually have similar syntax—that is, vocabulary and grammar. So
once you’ve learned one language (like JavaScript), you’re already 75% of the way to learning similar
languages, like Python and Ruby.
The best coders understand problems in terms of an algorithm—a series of steps that can be used
to do a certain thing, even if the details are different each time. Have you ever bought something
on Amazon? The checkout experience is a sort of algorithm. No matter what you’re buying, the
steps are roughly the same: fill up your cart, choose your credit card and shipping address, pick a
shipping speed and place your order. The code, in fact, is the same for each purchase. The difference
is all in the data. Now get this: every algorithm that can possibly exist can be written in every
normal programming language. It’s a mathematical fact²¹. Once you learn to think in algorithms,
the programming language is secondary. Sure, it kicks and drags its feet a little. But in the end it’s
not about the keywords and symbols you’re using. It’s about the processes you’re describing.
From here on out, I’m going to use the JavaScript programming language to give examples. I’m
doing this for my benefit, not yours. I’m good at JavaScript.
Code examples will be printed in monospace²², which is a special typeface that looks like this.
Monospaced fonts give the same exact width to every letter, number, symbol and space. All code is
written in monospace even though it is harder to read than normal fonts. This is because it helps
align blocks of code and allows coders to give equal attention to every letter and symbol, which
helps them avoid errors. As an example, look at the following sentence in both a regular font and
monospace:
There are three mistakes in the sentence: the extra space after “for”, the extra apostrophe in “Alice’s”,
and Bob’s exploitation of Alice’s friendship and trust. Oh, and “without” is misspelled. You probably
saw all these mistakes in the first sentence, but they’re more obvious in the second one, and obvious
is your best friend when you’re scanning a 200-line code document.
Whenever you read something written in monospace, it’s okay if you do a robot voice in your head.
²¹https://en.wikipedia.org/wiki/Turing_completeness
²²https://en.wikipedia.org/wiki/Monospaced_font
How to code (in one chapter)
25
Putting data in code
Enough background: let’s write some code. The most basic building block of a computer program is
a variable. A variable is a name for a piece of data, like a number or a sentence. You have to name
your data.
There are two reasons you name your data:
1. You don’t know what it is beforehand. Does Facebook know your birthday before you type it
in? No, of course not. Facebook’s code is using a name like humans_birthday behind the scenes
(the underscore is there because variable names can’t have spaces in them). It attaches that
name to whatever birthday you type in. That way, the code can be exactly the same whether
your birthday is June 10th, September 9th, or December 86th. It just moves humans_birthday
around in the program until it reaches an ugly warehouse computer.
2. You don’t want to forget what it means. Suppose the computer program needs to know that
December 86th isn’t a real date. So somewhere you have to tell it that December has 31 days. 31
is a number, a piece of data. But if you’re using the number 31 all over your code, and also using
numbers like 30 and 28 (because, thank goodness, December isn’t the only month), your code is
going to be confusing to read. What are all those numbers for? So you name them. 31 becomes
the_number_of_days_in_december, and your code becomes self-explanatory. Beautiful.
Computers expect you to declare your variables. A variable declaration is like a birth certificate for
a piece of data. It looks like this:
1
var the_number_of_days_in_december
The operative word here is var. It’s short for “variable.” The abbreviation is nice because it’s faster
to type. It can also be typed with only one hand, so if all you’re doing is declaring variables all day,
your other hand is free to do awesome things like juice grapefruits and practice with a quarterstaff.
Another thing you do with variables is assign them. This is where you attach the name to a piece of
data. It looks like this:
1
the_number_of_days_in_december = 31
Easy stuff. You declare the variable, then you assign it, and then any time you want to use the
number 31 in your program, you can type the_number_of_days_in_december and the computer will
know what you mean.
You don’t have to assign every variable to an explicit piece of data when you write your program. You
can declare variables and assign them to things that don’t exist yet. For example, you can declare
var humans_birthday and tell the app to wait for the user to type it in. Whatever they type will
become humans_birthday. You don’t even have to worry about it.
Variables can hold way more than just numbers and dates. For example, you can declare a string, or
a piece of text:
How to code (in one chapter)
26
1
var great_song_lyrics = 'La la la, la la la tonight'
Whoa. Curveball. I just declared a variable and assigned it at the same time. I’m so hecking efficient.
Bring this man a grapefruit.
Now I can write great_song_lyrics in my code, wherever I want, and the computer will know that
I mean 'La la la, la la la tonight'. It’s like we’re talking…in code.
Don’t believe me? Try it right now. If you’re reading this on your phone, you’ll need to open a web
browser, like Chrome or Firefox, on a computer. Press the F12 key on your keyboard (if you’re using
Safari, you’ll have to find the developer tools in the menus). You’ll see something like this:
This may be aligned to the right or bottom edge of your browser.
Make sure the “Console” tab is selected. Click in the blank area next to the > symbol, type a variable
declaration and assignment, and press Enter:
The console is saying undefined because the line of code you typed didn’t produce any data. That’s
okay, it wasn’t supposed to. Now type the name of your variable and press Enter again:
How to code (in one chapter)
27
Hooray! The console (which is an interpreter) understands your variable. The variable great_song_-
lyrics evaluated (it was understood) as "La la la, la la la tonight". That’s perfect (by the way,
it doesn’t matter if you use single quotes ' or double quotes " as long as you use them in matching
pairs).
We’ll talk about other things variables can hold in just a second.
Many programming languages require you to be specific about what kind of variable you’re
declaring. In C++, for example, there is no var keyword. There’s an int keyword (for declaring small
whole numbers), a long keyword (for declaring big whole numbers), float and double keywords
(for declaring decimal numbers), a string keyword (for declaring pieces of text), and a few others.
Don’t worry about that right now. You can learn it later.
Complex types
Objects
An important part of coding is learning how to organize data. Take the birthday example: Facebook
has hundreds of millions of birthdays (and anniversaries and breakup dates) stored in computer
memory in its warehouse. How does it know what’s what? If I gave you a list of a billion dates,
would you know who they belong to and what they’re for? Of course you would, because you are
the great Calendifus, Greek god of randomly significant dates.
Luckily, Facebook doesn’t just have a pile of arbitrary dates sitting around. They connect your
birthday, your anniversary, your hometown, your employment history, your name, and everything
else they know about you together with a unique ID (like the one on your Social Security card or
your driver’s license). It’s probably a big number that they picked out of a hat, so to speak. That is,
you are number 12884002, and every piece of data they have on you has a label that says “12884002”,
and when you log in they look up everything with that number on it. It’s all organized just like that.
How to code (in one chapter)
28
In code, you would do this with an object. An object is a bunch of pieces of data all organized together.
We can also call this an associative array, a dictionary, or a map. But most often I just say object.
In JavaScript, objects are declared and assigned much like other variables. Here’s an example object:
1
var human = {
2
id: 12884002,
3
age: 28,
4
name: 'Bob',
5
favorite_song: 'Half Light, by Athlete'
6
}
Each piece of data in an object is like a seesaw. The name is on the left, the data is on the right,
and there’s a : in the middle to balance on. Really all we’ve done is declare four variables: the first
two are numbers, and the last two are strings. But they’re organized together so we can find them
whenever we need to know something about human. And instead of calling them “variables,” we call
them “properties” or “fields.” An object can have any properties you want, as long as you put them
all together inside of { curly brackets }.
We can move the human object around and refer to it just like any other variable. The computer
knows what we mean. If we ever want to refer to just one property of human, we use a dot, like this:
1
human.id
2
human.age
3
human.name
4
human.favorite_song
Each of these is just like any other variable. We can assign something to it and refer to it later. Want
to change Bob’s name? Easy:
human.name = 'Alice'
And that’s that. It’s a really good upgrade, isn’t it? From now on, whenever you type human.name, it
will refer to “Alice”.
Arrays
Sometimes you don’t want to think up a unique name for every property in an object, especially if
they’re all very similar. Or you don’t know how many there are going to be. That’s when it’s time
to use an array, which is a list of similar pieces of data. Arrays can grow or shrink as needed.
A good example is all your dumb tweets. Twitter doesn’t know how many tweets you’re going to
write. You started at 0, and look where you are now. Twitter could use an array to hold them all.
Arrays in JavaScript look like this:
How to code (in one chapter)
29
1
var dumb_tweets = [
2
'Hello, Twitter!',
3
'My friends are so cool',
4
'Does anyone want a LaCroix?'
5
]
Remember how objects used { curly brackets } ? Arrays use [ square brackets ]. This array has
three strings in it, separated by commas. And yes, it’s a variable just like anything else. You can use
dumb_tweets anywhere in your code, and it will refer to the array we defined just now.
If you want to refer to a specific string in the array, you’d do it like this:
1
dumb_tweets[0]
2
dumb_tweets[1]
3
dumb_tweets[2]
We use the name of the array, dumb_tweets, and then inside of [ square brackets ] we use the number
(or index) of the thing (or element) we want to refer to. I know it’s weird that the first element in the
array is number 0. But this is your life now. From this day forward, you will always begin counting
at 0. It’s the programmer way.
Each of the above expressions (an expression is any code that turns into a piece of data when you
run it) is a variable. You can assign something new to it, if you want.
1
dumb_tweets[2] = 'I regret literally everything I have ever said'
Whatever happened to 'Does anyone want a LaCroix?'? It’s gone forever. Swallowed by the abyss.
G’bye!
Arrays can hold strings, numbers, dates, objects, and even other arrays. You can put arrays inside
of arrays inside of arrays inside of arrays.
How to code (in one chapter)
30
Photo: Lachlan Fearnley²³. Unmodified image licensed under CC BY-SA 3.0²⁴
Any time code or data gets all Russian-doll-ish like that, we say it’s nested.
Arrays can also be properties of objects. An object can have a property that is an array of objects,
each of which has a property that is an array of objects…and I’ve done it again. It sounds like a tax
form, but it’s how data is structured. For example, your Twitter account could be an object that has
a property which is an array of tweets; each tweet could be an object that has properties that are
arrays of replies, likes, and retweets; each reply, like or retweet could be an object that has properties
that are the name, profile picture and bio of the user that gave them; and so on.
1
var nested_object = {
2
an_array: [
3
{
4
another_array: [
5
{
6
yet_another: [
7
{
8
message: 'Blink twice if you need help'
9
}
10
]
11
}
12
]
13
}
²³https://commons.wikimedia.org/wiki/File:Russian_Dolls.jpg
²⁴https://creativecommons.org/licenses/by-sa/3.0/deed.en
How to code (in one chapter)
31
14
]
15
}
To access message, you can write:
1
nested_object.an_array[0].another_array[0].yet_another[0].message
And the computer will know that you mean 'Blink twice if you need help.'
Objects (continued)
One more trippy part, and then we can move on to the fun stuff.
Everything in JavaScript is secretly an object (don’t tell! Its parents would be so mad). For example,
our dumb_tweets array has a property that we never declared:
1
dumb_tweets.length
What the heck is length? Well, it’s a property that JavaScript creates and updates for you
automatically. It tells you how many elements are in the array. In this case it would be 3. There
are 3 elements in the array. Go count ‘em, but don’t start from 0 this time because I lied and you’re
only supposed to start counting from 0 on special occasions. Dang it.
APIs
Time for a scary campfire story.
Once upon a time, in an alternate universe, there was a programmer named McChuck. He was the
only coder in the whole universe. He had to write all the code that would ever exist, all by himself.
How to code (in one chapter)
32
Photo: hannah k²⁵. Unmodified image licensed under CC BY 2.0²⁶
Sheesh, it was just a story. Calm down.
The truth is that no coder is an island. Nobody starts from scratch. We’re all constantly using code
we didn’t write—buckets of it, in fact.
Even if you are a prolific coder and write millions of lines of code in your lifetime, you will use far
more lines of code that someone else wrote. Most of this code will come from complete strangers.
Some of those strangers will be dead. Their code lives on, even though the fingers that typed it are
decomposing in a grave. It’s zombie code. But instead of eating your brain, it saves your brain from
doing a lot of hard work. Best. zombie. ever.
How do you use this zombie code? Copy and paste? Occasionally, yes, but not often. Most of the
time you’ll access it through an Application Programming Interface or API. An API is a bundled-up
set of properties and methods (purpose-built pieces of code) that are named, like variables, so you
can refer to them by their name and let them do their thing. They do all kinds of useful things for
you.
JavaScript arrays have their own API. The length property is part of this API. Another part of it is
the push method, which adds an element to the end of the array:
²⁵https://www.flickr.com/photos/90692443@N05/8239219385
²⁶https://creativecommons.org/licenses/by/2.0/
How to code (in one chapter)
33
1
dumb_tweets.push('Man I hate good attitudes')
A method is like a property because you access it with a dot. A method is different from a property
because you have to put ( parentheses ) after it. These parentheses are holding the data we want to
add to our array. Now dumb_tweets has four elements. It looks like this:
1
[
2
"Hello, Twitter!",
3
"My friends are so cool",
4
"I regret literally everything I have ever said",
5
"Man I hate good attitudes"
6
]
Remember, the index of this last element is 3 (because you started counting at 0). So you would refer
to it as dumb_tweets[3]. And dumb_tweets.length would now evaluate to 4.
The JavaScript array API has a lot of different methods in it, but it’s outside the purpose of this
chapter to explain them all. You can see them in their full glory at this link²⁷.
Web browsers have a huge API that JavaScript coders use every day. This API has methods for things
like animating stuff in a website, getting user input, communicating with other computers over the
internet, manipulating strings, and loads of other stuff. Building a working vocabulary in this API
is an essential part of becoming a web developer.
Functions
Function is another word for method. It’s just a piece of code that does something and (usually) has
a name. Functions are easy to declare in JavaScript:
1
function giveMeOne() {
2
return 1
3
}
We start with the keyword function. Then we give the function a name, just like if we were declaring
a variable (here I’ve used capitalization, instead of underscores, to separate words). Then we use
parentheses (you’ll see why in a second). Then we use { curly brackets }. Inside the curly brackets
are all the lines of code we want to execute whenever the function is called (whenever an expression
refers to it by name).
The word return is another special keyword. It makes a value (a piece of data) pop out of the function.
Then it ends the function (if you write any code after a return statement, that code won’t execute).
So you could do something like this:
²⁷https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array
How to code (in one chapter)
34
1
var the_loneliest_number = giveMeOne()
This isn’t too hard, right? We declare a variable named the_loneliest_number. The assignment
part of our statement calls giveMeOne(), and since that function says return 1, a 1 pops out. So our
variable will hold the number 1. Go ahead and execute both of these blocks of code in your browser’s
console. Then type the_loneliest_number, press Enter, and you’ll see that it evaluates to 1.
A function can be a property of an object. It can be an element of an array. It can return a number,
a date, a string, an object, an array, another function, an array full of functions, and so forth. This
stuff is like LEGO bricks. Put any kind of piece anywhere you want and it will fit.
giveMeOne() is kind of like dumb_tweets.push(). The main differences are:
1. giveMeOne() is a function we wrote by ourselves. push() is a function that some strangers
wrote. It’s okay, they don’t mind if we use it.
2. push() is a method of dumb_tweets (and any other array we’ll ever create). giveMeOne() is
global, meaning that we don’t need to refer to a specific object in order to use it.
You’ll notice one more thing that seems different about them: giveMeOne() uses empty parentheses,
but push() expects us to put a piece of data in the parentheses. In fact, push() would be useless
if we couldn’t tell it what to add to our array. The piece of data we give it is called an argument.
An argument is just a piece of data that we drop into a function. Declaring a function that expects
arguments looks like this:
1
function addTheseNumbersTogetherPlz(number1, number2) {
2
return number1 + number2
3
}
This function isn’t too different from giveMeOne(). But instead of empty parentheses, these have
variable names in them, separated by a comma. These are our arguments. The return statement
does exactly what it looks like it’s doing: it adds number1 and number2 together, then pops out the
result. You’d call the function like this: addTheseNumbersTogetherPlz(3, 4). And it would pop out
a 7.
Ooh! Math! Scary, right? Almost all coding languages let you write math expressions the same way
you used to write them in those bricky TI calculators you might have used in high school. You can
use + to add, - to subtract, / to divide, * to multiply, ( parentheses ) to enforce an order of operations,
% to get the remainder of division, and ^ to instantly grow a neckbeard (no, it doesn’t do exponents;
you need an API for that).
You could also write the function this way:
How to code (in one chapter)
35
1
function addTheseNumbersTogetherPlz(number1, number2) {
2
var sum = number1 + number2
3
4
return sum
5
}
This function does exactly the same thing. It just uses a variable named sum as a middleman, where
the result is stored so we can return it later.
There are many ways to write a function. You should choose the way that most clearly expresses
what the code is doing. Code that is concise and easy to understand is often called expressive or
elegant. There’s an artistic pleasure in writing this kind of code.
Programs must be written for people to read, and only incidentally for machines to
execute.
∼Harold Abelson
Logical branches and comparisons
This is where code gets extra fun. (It was fun already.)
Computer programs don’t do the same exact thing every time you run them. If they did, then video
games would play themselves. That would be a letdown. You’d have to just sit there and watch the
story play out on the screen, like a…I don’t know, but it would be boring. There definitely wouldn’t
be an entire industry²⁸ dedicated to it.
Programs have to respond to different situations. They have to make decisions. And that’s where
things like if statements come in.
Let’s say we’re writing an app that determines whether a particular person is allowed to enter
a nightclub. Pretend there’s a method in the JavaScript API that gets a user’s age. We’ll call it
getUserAge(). We’ll also imagine that there are two other methods, allowThemInTheNightclub()
and throwThemOutOnTheirButt(). How can we help our program decide which of these last two
methods to call, based on the returned value of the first method?
²⁸https://en.wikipedia.org/wiki/Film_industry
How to code (in one chapter)
36
1
var age = getUserAge()
2
3
if (age >= 21) {
4
allowThemInTheNightclub()
5
} else {
6
throwThemOutOnTheirButt()
7
}
See how nice the alignment is on the right side? Monospace is great.
You already know what the first line does. age will hold a value like 13 or 21 or 101. Now we need
to know: is age 21 or over? If so, they can party away. If not, they’ll need to leave.
We do that using an if statement. if is a keyword that looks a little bit like a method. The argument
it expects is an expression of some kind, usually a comparison. Comparisons take two values and
compare them to each other, resulting in a value of true (if the comparison is true) or false (if
it’s not true). These two values are called booleans and they’re the only two booleans in existence.
Lucky they’ve got each other. We can make six different kinds of comparisons:
• === (three equals signs) compares the values on either side to see if they are exactly equal. If
they are equal, the result is true. 6 === 6 would be true.
• !== compares the values on either side to see if they are not exactly equal. If they are not equal,
the result is true. 6 !== 3 would be true.
• > checks to see if the value on the left side is bigger than the value on the right side. 6 > 3
would be true.
• < checks to see if the value on the right side is bigger than the value on the left side. 3 < 6
would be true.
• >= checks to see if the value on the left side is bigger than, or equal to, the value on the right
side. 6 >= 6 and 6 >= 5 are both true.
• <= checks to see if the value on the right side is bigger than, or equal to, the value on the left
side. 6 <= 6 and 6 <= 7 are both true.
if statements evaluate the comparison you give them. If it evaluates to true, they execute the code
inside their block (the lines of code inside { curly brackets }). If it evaluates to false, they skip that
code.
if statements can also have an else statement attached to their tail end. The else statement has
a block that will be executed if the comparison is false. Look back at our nightclub app. It should
make a lot of sense to you now.
Hey, we just made a bouncer redundant (he was replaced by a computer program). Isn’t that a good
feeling?
How to code (in one chapter)
37
Loops
Sometimes, especially when you’re working with an array, you want to execute a block of code
several times in a row. This is not the time to use copy and paste. Instead, you should use a loop.
The simplest kind of loop in JavaScript is a while loop:
1
var knock_knock_joke = ['Knock knock', "Who's there?", 'Banana', 'Banana who?']
2
3
var index = 0
4
5
while (index < knock_knock_joke.length) {
6
say(knock_knock_joke[index])
7
8
index = index + 1
9
}
while loops use the same syntax as if statements. You use parentheses, you pass in a comparison,
you follow it up with a block. But an if block only executes the code inside of it once (or zero times,
if the comparison evaluates to false). A while block executes the code inside of it over and over
again until the condition is false. That is, it evaluates the condition; if it’s true, it executes the
block; then it evaluates the condition again; if true, it executes the block again; then it evaluates the
condition again; and so on, forever. I’ve invented an imaginary API here that has a say() method,
but everything else is regular JavaScript.
How many times will the loop execute? Well, the first time it evaluates the comparison, it checks to
see if index (which is 0) is smaller than knock_knock_joke.length (which is—go on, count them—4).
Since the comparison is true, it executes the code, which raps knock_knock_joke[0], because index
is still 0. Then the magic happens: it changes index to index + 1, or 0 + 1, which is 1. Then it
evaluates the comparison expression again. 1 is still less than 4, so it executes the block again—but
this time, since index is 1, it raps knock_knock_joke[1]. Get it? It will stop executing the block when
index equals 4, which is good because knock_knock_joke[4] doesn’t exist. When a loop operates on
multiple elements in an array, we say it’s iterating.
Null and undefined
If you declare a variable and do not assign a value to it, it will hold a special value called undefined.
This is a geeky word that means “move along, nothing to see here.” It’s mostly useless.
How to code (in one chapter)
38
JavaScript also has a special value called null. It means roughly the same thing as undefined. They
really shouldn’t have included both words in the language. But they did and it’s too late now.
Scopes
Functions are very selfish. If you declare a variable inside of a function, the function won’t let any
of the code outside of itself use the variable. For example:
1
function whatHappensInVegas() {
2
var wildIndiscretions = ['partied', 'danced']
3
4
return 'I admit nothing'
5
}
6
7
whatHappensInVegas()
8
whatHappensInVegas()
9
whatHappensInVegas()
10
11
if (wildIndiscretions.length > 0) {
12
getInTrouble()
13
}
We have a very simple function. It declares the variable wildIndiscretions, but it doesn’t return
it. The outside world knows nothing about it! We even run the function three times, because
we’re young and full of stamina. The if statement is trying to pry into the function’s personal
life, but it can’t. The code inside of the if block will never execute. In fact, the comparison
wildIndiscretions.length > 0 will throw an error (it won’t work and you’ll see a message explain-
ing why) because wildIndiscretions is undefined outside of the function whatHappensInVegas. It
doesn’t have any properties, let alone length.
However, if you move that if block inside the function block (before the return statement, of
course) then it will gain access to wildIndiscretions. Hope you have a good lawyer!
Comments
It isn’t always obvious what a piece of code is doing, or what still needs to be done with it. If you
need to break out of the computer language and have some real talk about what’s going on in the
code (or just drop some dope lyrics), you can use a comment, or a line of code that the computer will
ignore. You start a comment with // two forward slashes. Like this:
How to code (in one chapter)
39
1
function isEven(num) {
2
// This function determines if "num" is even or odd.
3
//
If even, it returns true. If odd, it returns false.
4
// TO DO: add a second argument that lets you specify
5
//
a message to display if "num" is odd.
6
7
return num % 2 === 0
8
9
// Hey, yo, do it like Isaac
10
// If you ain't with me, baby ain't wise-aac
11
}
Don’t worry about the maths in the return statement. I’m just demonstrating that you can use
comments to explain what’s going on, to leave a note for your future self, and to spit bars. The last
usage is probably frowned upon in serious codebases. But don’t let that hold you back. You were
born to do what you were born to do.
Searching for clues
The last and most important thing I can teach you is this: when you don’t know how to do something,
immediately go to google.com and ask. The generosity of the programming community will astound
you. Thousands of developers all around the world have freely shared their code and knowledge on
sites like GitHub²⁹ and Stack Overflow³⁰, which means that all you need to become an expert in any
programming language is a steady internet connection and the ability to read.
Good Google queries take a little bit of practice to write. A good template is something like this:
[programming language] how to [something]
For example, want to know how to remove an element from an array in JavaScript? I’m not gonna
teach you. Try typing this into Google: “JavaScript how to remove an element from an array”. The
first few results should give you all the information you need (with examples).
For more discussion of this topic, see Yechiel’s chapter “Learning to learn”.
What is an application?
Most large-scale apps use all the concepts and keywords I’ve described. Their code comprises
thousands upon thousands of lines of code, all built from these same basic elements. So what are
they doing?
On a basic level, they’re receiving inputs (data that enters the code from somewhere else, like a user’s
keyboard), transforming them (often by iterating over them, doing maths on them, or reorganizing
²⁹https://github.com/
³⁰http://stackoverflow.com/
How to code (in one chapter)
40
their properties), and providing outputs (data that leaves the code). Every computer program can be
described in terms of its inputs and outputs. Every programming language has methods in its API
for accepting inputs and providing outputs.
An ice maker is a good analogy for a computer program. Its inputs are water and electricity (they
come from an API known as “municipal utilities”). Its output is ice (which is submitted to an API
known as “a tall glass of Coke”). Do you care what happens in the middle? Not right now, as long
as you get your ice without too much trouble. But someday the ice maker will break down. And
whoever has to fix it will care a lot about how simple, robust and well-built its internal components
are.
A coder’s job isn’t just to provide the ice, although that’s important. A coder’s job is to make sure
that when the ice maker breaks, the person who has to fix it doesn’t develop an explosive headache
in the process. That’s the difference between an amateur coder and a pro.
Conclusion
You’ve done good. I’ve taught you enough programming basics that, with a little imagination and
plenty of Googling, you can teach yourself everything you need to know to write apps. If you want
to.
You may still feel like you’re missing some vital information. And you are. But you’ll never learn it
all, and this is a good start.
If you’re still shaky on your feet, go check out some more JavaScript tutorials. There are tons of free
ones online on sites like Codecademy³¹. And once you feel confident enough to write some code of
your own, go build something. There’s no substitute for getting your hands dirty.
³¹https://www.codecademy.com/learn/introduction-to-javascript
Steps to better code
Isaac Lyman
When you start out coding, you usually spend a year or two completely oblivious to the rules of
“good code.” You may hear words like “elegant” or “clean” tossed around, but you can’t define them.
That’s okay. For a programmer without any experience, the main metric worth keeping tabs on is
“does it work?”
Soon, though, you’ll need to raise your expectations. Good code doesn’t just work. It’s simple,
modular, testable, maintainable, thoughtful. Some of these terms may apply to your code without
you even knowing it, but probably not. If you’re lucky, your team carefully plans and architects
its code solutions and guides you gently, trusting that you’ll develop an intuition for well-written
software. If you’re not lucky, they wince³² or³³ complain³⁴ every time they see your code. Either
way, you can get a lot of mileage out of learning a few universal principles.
Take, for example, the global variable: a variable that can be used anywhere in the project. Suppose
your app has a username variable that’s set when the user logs in and can be accessed from any
function in the app just by referencing the variable name—that’s a global variable. Global variables
are universally despised by bloggers and style guides, but most entry-level coders don’t understand
why. The reason is—and pay attention, because this is the reason for almost all best practices in
coding—that it makes the code faster to write, but harder to understand. In this case, a global variable
makes it really easy to insert the user’s username into the app anywhere you want, which may mean
fewer lines of code and fewer minutes until you finish your current task. That’s false comfort, though:
you’ve sacrificed safety for convenience. If you discover a bug involving username, you will have to
debug not just a single file or function, but the entire project. I’ll talk more about this later.
The difference between “good code” and “bad code” isn’t usually based on the way it affects you as
you write it. Code is always a shared resource: you share it with other open-source contributors, or
with the other developers on your team, or with the person who will have your job in the future,
or with “future you” (who won’t have a clue what “present you” was thinking), or even just with
“debugging you,” who is going through your fresh code looking for bugs and is totally frustrated.
All of these people will be grateful if your code makes sense. It will make their job easier and less
stressful. In this way, writing good code is a form of professional courtesy.
You may still be skeptical, but read on—I’ll talk about several principles that lead to good code and
try to justify each one.
³²https://xkcd.com/1513/
³³https://xkcd.com/1695/
³⁴https://xkcd.com/1833/
Steps to better code
42
0. Naming things
There are only two hard things in Computer Science: cache invalidation and naming
things.
∼Phil Karlton
Well-written code tells a story, and is often readable even for someone who only has a passing
familiarity with code. An important part of this is well-named variables, classes, files, and methods.
When naming something, it’s far more important to be descriptive than brief: a variable name
like “elementarySchoolStudentLastNameFirstLetterRegEx” may have room for improvement, but
it’s much better than “b”. It’s useful to be able to know what something is immediately, right when
you look at it, even if you haven’t read the rest of the file or project. And that goes double for public
fields and methods. Any element of code whose name doesn’t fully communicate its purpose is one
more thing you have to think about every time you use or modify it.
Beyond descriptiveness, uniqueness is also valuable. Sometimes when modifying code, you’ll want
to do a project-wide search for a method or variable and find everywhere it’s being used. In this
situation it’s best if its name is unique. If you’ve been calling things method1 and stringA, your
search results will be full of irrelevant stuff and it will be hard to make changes without breaking
anything.
Renaming things is a great way to improve code quality as a junior developer. Make sure you
know the naming conventions of your team and project—if they use underscores or capital letters
to separate words, if they like to include a variable’s type in its name, and so on—then find a couple
of things with confusing names and suggest better ones.
1. Separation of concerns
A fair analogy for coding is writing a recipe. In simple recipes, each step depends on the one before
it, and once all the steps are complete, the recipe is done. But if you’ve ever tried to follow a more
complex recipe, you’ve probably experienced the stress of having two pots boiling on the stove, a
plate spinning in the microwave, three kinds of vegetables half-chopped on a cutting board, and a
smorgasbord of spice and herb shakers strewn across the countertop (and you can’t remember which
ones you’ve already added).
Having another cook in the kitchen complicates the problem as often as it simplifies it. You
waste time coordinating, handing things back and forth, and fighting over stove space and oven
temperature. It takes practice to figure out how to do it well.
If you know you’re going to have several cooks in the kitchen, wouldn’t it be more efficient for the
recipe to be split into mostly-independent sub-recipes? Then you could hand part of the recipe to
each cook and they could work with as little interaction as possible. One of them is boiling water
for pasta. One of them is chopping and cooking vegetables. One of them is shredding cheese. One
of them is making sauce. And the points of interaction are clearly defined, so each of them knows
when to hand off their work.
Steps to better code
43
The worst form of code is like a simple recipe: a bunch of steps in order, each written out in the
same space, and listed from top to bottom. In order to understand it and modify it, you have to read
the whole thing a couple of times. A variable on line 2 could affect an operation on line 832, and the
only way to find out is to read the entire program.
A slightly better form of code is like having a second cook in the kitchen. You hand off some
operations to other parts of the program, but your goal is mostly to make your files smaller, not
necessarily to organize and simplify your code. It’s an improvement, just not taken far enough.
The best form of code is like splitting a recipe into sub-recipes, usually called “modules” or “classes”
in code. Each module is concerned with a single simple operation or piece of data. The vegetable
chef shouldn’t have to worry about the sauce ingredients, and the person cooking pasta shouldn’t
have to worry about the cheese grater. Their concerns are separated (hence the term separation of
concerns).
The benefits to this are significant. Suppose a coder needs to modify the program later—to make
it gluten-free for a client with celiac disease or to add a seasonal vegetable. That coder will only
need to read, understand and modify one small part of the program. If all of the code dealing with
vegetables is contained in a single small class with a few well-defined inputs and outputs, the coder
never needs to worry that adding a vegetable will ruin the sauce.
The goal here is to make sure that, to make any given change, the coder has to think about as few
parts of the program as possible, instead of all the parts at once.
2. Global variables (are bad)
Let’s jump back to your username variable. When you built the login page for your app, you realized
you’d need to display the user’s username in a few other places, like perhaps the site header and the
settings page. So you take the path of least resistance: you create it as a global variable. In Python, it’s
declared with the global keyword. In JavaScript, it’s a property of the window object. It seems like
a good solution. Anywhere you need to show the username, you just pop in the username variable
and you’re on your way. Why aren’t all variables maintained like this?
Then things go sideways. There’s a bug in the code, and it has something to do with username.
Despite the availability of an instant search tool in most code editors, this is going to take a while to
fix. You’ll search username and there will be hundreds or thousands of results; some will be the global
variable you set up at the beginning of the project, some will be other variables that also happen
to be named username, and some will be the word “username” in a comment, class name, method
name, and so forth. You can refine your search and reduce the amount of noise, but debugging will
still take longer than it should.
The solution is to put username where it belongs: inside of a container (e.g. an object) that gets
imported or passed as an argument to the classes and methods that need it. This container can also
hold similar pieces of data—anything that’s set at login is a good candidate (but don’t store the
password. Don’t ever store a password without encryption). If you’re so inclined, you can make this
Steps to better code
44
container immutable, so that once username is set, it can’t ever be changed. This will make debugging
extremely easy, even if username is used tens of thousands of times in your app.
Coding this way will make your life easier. You’ll always be able to find the data you’re looking for,
in exactly one place. And if you ever need to track when a piece of data is used or changed, you
can add some functionality to your object (like a getter and setter—see Appendix A) and be on your
way.
3. DRY
Suppose you’re building a website that sells fancy hats. You build a page for the first hat and write
the code for adding it to someone’s shopping cart. You’ve got 24 more hats, so you build pages for
them, then copy the shopping cart code from the first page and paste it into each one. Everything is
working great. You make little modifications here and there: some of the hats have optional feathers
or lace, others have a lot of color options. After a while, that shopping cart code doesn’t look quite
the same on any two pages.
Then you learn there’s a bug in the original shopping cart code and it’s making your customers upset.
You need to fix it right away. And you realize you’ve made a huge mistake: since you copied and
pasted the code from one page to another, you have to fix it 25 times, once for each fancy hat. You
have to do it by hand, since the code is a little different on each page. That’s going to take forever.
You’re up late rubbing your eyes and coding fix after tedious fix, and your customers are buying
their fancy hats from competitors.
Ugh.
There’s a better way: next time you build a website, don’t be so quick to copy and paste. Write the
code for the first page, then if you need some of that code in other pages, put it in a class method or a
function and let each page refer to it, passing in arguments to handle any little differences between
them.
DRY stands for “Don’t Repeat Yourself.” It’s a good guideline to remember.
The goal is this: if an operation needs to change in some way, you should only have to modify a
single class or method. This is quicker and far more reliable than trying to maintain several copies
of the same code.
Don’t take it too far, though—if two operations are really different, let them be different. Trying to
force two distinct pieces of code into the same function can result in strange and confusing code.
Many programmers prefer the acronym WET, for “Write Everything Twice.” That is, go ahead and
copy something once, but if you find yourself with three copies of the same code, then it’s time
to refactor them into shared functionality. This is a very practical way to apply the spirit of DRY
without overdoing it.
4. Hiding complexity
Imagine I’m selling you a car. It will take some training for you to learn how to use it.
Steps to better code
45
To start the car, take red wire #2 and white wire #7 and touch them together while kicking the
engine-rev pinwheel with your foot and pouring an appropriate amount of fuel into the injector,
which you’ll find under the center console. Once the car has started, reach into the gearbox and
push the layshaft into place against the first gear on the differential shaft. To accelerate, increase the
flow of gasoline into the injector. To brake, hold your feet against the tires.
I’m sure this car frustrates you as much as it frustrates me. Now let’s channel that angst toward
code elements with over-complicated interfaces.
When you build a class or method, the first thing you write should be the interface: the part that
a different piece of code (a caller) would need to know about in order to use the class or method.
For a method, this is also called the signature. Every time you look up a function or class in API
documentation (like on MDN Web Docs³⁵ or the Python documentation³⁶), what you’re seeing is
the interface—only what you need to know to use it, without any of the code it contains.
An interface should be simple but expressive. It should make sense in plain English, without
expecting the caller to know about the order in which things happen, data that the caller isn’t
responsible for, or external variables.
This is a bad interface:
1
function addTwoNumbersTogether(
2
number1, number2, memoizedResults, globalContext, sumElement, addFn
3
) // returns an array
This is a good interface:
1
function addTwoNumbersTogether(
2
number1, number2
3
) // returns a number
If an interface can be smaller, it should be. If a value you’re providing with an argument could be
calculated from other values instead, it probably shouldn’t be an argument (or the others shouldn’t
be). If a method has more than a few parameters, you should ask yourself if you’re doing something
wrong (although you might make an exception for some class constructors).
Don’t take this too far. If you’re setting and using global variables in order to avoid passing
arguments to a function, you’re doing it wrong. If a method requires a lot of different pieces of
data, try splitting it out into more specific functions; if that’s not possible, create a class or object
specifically for passing this data around.
Remember that all methods and data that are in a class but can be accessed from outside of that
class are part of its interface. This means you should make as many methods and fields private as
you possibly can. In JavaScript, variables declared using var, let, or const are automatically private
³⁵https://developer.mozilla.org/en-US/
³⁶https://docs.python.org/3/
Steps to better code
46
to the function they’re declared in, as long as you don’t return them or assign them to an object; in
many other languages, there is a private keyword. This should be your best friend. Only make data
public on a need-to-know basis.
5. Proximity
Declare things as close as possible to where they’re used.
Your instinctive urge to organize can work against you here. You may think an organized method
looks like this:
1
function () {
2
var a = getA(),
3
b = getB(),
4
c = getC(),
5
d = getD();
6
7
doSomething(b);
8
doAnotherThing(a);
9
doOtherStuff(c);
10
finishUp(d);
11
}
getA() and its compatriots aren’t defined in this snippet, but imagine that they return useful values.
In a small method like this, you may be forgiven for thinking the code is well-organized and easy
to read. But it’s not. d, for some reason, is declared on line 5 even though it isn’t used until line 10,
which means you have to read almost the entire method to make sure it isn’t used anywhere else.
A better method looks like this:
1
function () {
2
var b = getB();
3
doSomething(b);
4
5
var a = getA();
6
doAnotherThing(a);
7
8
var c = getC();
9
doOtherStuff(c);
10
11
var d = getD();
12
finishUp(d);
13
}
Steps to better code
47
Now it’s clear when a variable is going to be used: immediately after it’s declared.
Most of the time the situation isn’t so simple; what if b needs to be passed to both doSomething()
and doOtherStuff()? In that case, it’s your job to weigh the options and make sure the method is
still simple and readable (usually by keeping it short and using more descriptive variable names than
a and b). In any case, make sure you don’t declare b until immediately before its first use, and use it
in the shortest possible code segment.
If you do this consistently, you’ll sometimes find that part of a method is completely independent
from the code above and beneath it. This is a good opportunity to extract it into its own method.
Even if that method is only used once, it will be valuable as a way to enclose all the parts of an
operation in an easily understandable, well-named block.
6. Deep nesting (is bad)
JavaScript is known for an uncomfortable situation known as “callback hell”:
1
function getSumOfLetters(callback, errorCallback) {
2
getA().then(a => {
3
getB().then(b => {
4
getC().then(c => {
5
getD().then(d => {
6
getE().then(e => {
7
getF().then(f => {
8
postSum([a, b, c, d, e, f]).then(
9
sum => callback(sum),
10
err => errorCallback(err)
11
)
12
})
13
})
14
})
15
})
16
})
17
})
18
}
See that trail of }) running down the last several lines? That’s the calling card of callback hell. It’s
avoidable, but that’s a subject that plenty of other writers have already addressed.
What I want you to consider is something more like “if hell.”
Steps to better code
48
1
callApi(function(result) {
2
try {
3
if (result.status === 0) {
4
model.apiCall.success = true
5
6
if (result.data.items.length > 0) {
7
model.apiCall.numOfItems = result.data.items.length
8
9
if (isValid(result.data)) {
10
model.apiCall.result = result.data
11
}
12
}
13
}
14
} catch (e) {
15
// ignore errors
16
}
17
})
Count the pairs of { curly braces }. Six, five of which are nested. That’s too many. This block of
code is hard to read, partially because the code is about to creep off the right side of the screen and
programmers hate horizontal scrolling, and partially because you have to read all the if conditions
to figure out how you got to line 10.
try and catch are keywords you may not have encountered yet. Any time an error occurs inside of
a try block, it will immediately skip the rest of the block and jump to the following catch block to
be processed. In this case, the catch block isn’t doing anything, so we’re ignoring errors completely.
This is a bad idea because if something goes wrong, we have no way of knowing.
Now look at this:
1
callApi(function(result) {
2
if (result.status !== 0) {
3
return
4
}
5
6
model.apiCall.success = true
7
8
if (result.data.items.length <= 0) {
9
return
10
}
11
12
model.apiCall.numOfItems = result.data.items.length
13
14
if (!isValid(result.data)) {
Steps to better code
49
15
return
16
}
17
18
model.apiCall.result = result.data
19
})
That’s a lot better. I removed the try/catch block, for starters (although it would have been equally
good to properly handle and report the error). We can clearly see the “normal path” for the code
to follow, and only in abnormal situations does the code stray off into an if block. Debugging is
much simpler. And if we want to add extra code to handle error conditions, it will be easy to add a
couple of lines inside those if blocks (imagine if the if blocks in the original code had else blocks
attached! That would be so confusing).
7. Pure functions
A pure function (or functional method) is a function that does not alter or use external data (it’s
stateless). In other words, for a given input, it will always provide exactly the same output, no
matter what has changed outside of it, and all your other variables will be completely unaffected
by what happens inside of it. All pure functions have at least one argument and return at least one
value.
This function is pure:
1
function getSumOfSquares(number1, number2) {
2
return Math.pow(number1, 2) + Math.pow(number2, 2)
3
}
And this one is not:
1
function getSumOfSquares() {
2
scope.sum = Math.pow(scope.number1, 2) + Math.pow(scope.number2, 2)
3
}
If you want to debug the first function, everything you need is right there in three lines of code. You
can paste it into a separate environment, like jsfiddle³⁷ or the browser console, and play with it until
you find out what’s wrong.
If you want to debug the second function, you may have to dig through the entire program in order
to make sure that you’ve found all the places where scope.sum, scope.number1 and scope.number2
are accessed. And if you ever want to move the function to another class or file, you’ll have to worry
about whether it has access to all the same data.
Not all methods can be pure; if your application didn’t have state, its usefulness would be limited.
But you should write pure functions often. This will make your program easy to maintain and scale.
³⁷https://jsfiddle.net/
Steps to better code
50
8. Automated tests
An automated test is a piece of code that executes another piece of code and checks the results to
make sure it’s working. This is much faster and more reliable than trying to test every feature of the
app on your own every time you make a change. Every major programming language has tools and
libraries to help you write these tests. Some are called unit tests, which test a small, self-contained
piece of code (like a class or method), and others are integration tests, which test the way different
pieces of code interact.
Writing automated tests for your own code is considered an essential part of being an effective
programmer. Any class or method that’s more than a bare wrapper over other code—that is, any
class or method that contains logic—should be accompanied by a unit test. That unit test should run
automatically whenever your team merges code to the main branch.
Unit tests, properly written, weed out false assumptions and make your code easier to understand.
If someone doesn’t know what a piece of code does, they can look at the unit test and see use cases.
Writing tests can be tedious, and there’s such a thing as too many tests, but if you ever go into a task
thinking, wow, this one’s tricky, that’s a sure sign that you should be writing tests along the way.
Conclusion
Good code is a joy to maintain, build upon, and solve problems with. Bad code is painful to work
with. Choose to write good code; you’ll thank yourself for it.
A good question to ask yourself when writing code is: will this be easy to delete when we don’t need
it any more? If it’s deeply nested, copied-and-pasted all over the place, dependent on various levels
of state and lines of code throughout the program, and otherwise confusing, people will be unable to
understand its purpose and impact and they’ll be uncomfortable deleting it. But if it’s immediately
clear how it’s used and what other code it interacts with, people will be able to delete it confidently
when its usefulness runs out. I know you love your code, but the truth is that the world will be better
off without it someday. And that’s okay.
Programming tools
Gianluca Fiore
In your climb to the highest peaks of the programming world, hopefully you will encounter a
plethora of languages, resources, conversations, and people. All of them will be accessible to you
through tools, whether they be a web browser, an editor, a compiler or something else, depending
on the task at hand. The choice of what tool to use for a given job may be daunting at the beginning
and is one you shouldn’t waste too much precious time on—that time is best spent actually learning
and coding. This chapter will help you to understand how important your choice of tools for coding
is, or is not, and why so many programmers care a great deal about theirs.
Programming is luckily extremely forgiving of not choosing the best tool for a specific task,
especially for advanced programmers who have learned how to “bend” tools and languages to their
will. Yet at the beginning a poor tool for what you’re trying to achieve could make you waste a lot
of time and possibly give up altogether. Please don’t.
The tool of choice will depend on your area of expertise. If you are doing front end web programming,
the choice of browser you’re developing on first is vital, since they differ in the features and
development tools they support; a back end programmer may care more about a good debugger
and compiler, if any, and so on.
Every programming language has its strengths and weaknesses. Some are truly fast, like C, but ask
you to do more math and be more careful with possible bugs in your code. Others are much easier,
like Python and Ruby, but will usually be slower unless heavily optimized—something that, at the
beginning, may be hard to master. If you need to write a website nowadays JavaScript is king so
trying to do it with a language not specifically designed for the web, like Go or Java, might increase
the difficulty for you. You could still do it, sure, but very few beginning programmers have the
knowledge to depart from the specific goal that a programming language was designed for.
Thus, it’s best to focus on what your project needs to achieve and what you would like your path
in the programming world to be and choose the right language for them. You will learn faster and
will meet less difficulties with your projects. There is always time to learn other languages later
and to expose yourself to their new concepts. No language is useless to learn. But don’t try to learn
language X because Y is using it and it sounds cool. Learn what is useful for you.
The same is valid for operating systems and editors. Pick the tool you feel most productive and
comfortable in. It may not be the best operating system ever nor the one with the best tools or
the editor that will make you type fastest, but it’s more important to get started and not waste
time fighting against the tool to make it behave like you want. There’s no need to make it more
complicated than it should be.
Programming tools
52
Wars? What wars?
Related to this, if you follow news or discussions about programming on social media or online
groups you may be surprised to find that the word “war” is used when discussing various tools.
It may be an “editor war” or “browser war” or the “tabs vs spaces” war. Or the “OSes war”, which
stands for “Operating Systems war”. They are not actual wars fought with weapons and soldiers,
luckily, but with words and interminable discussions on which tool is the best for a specific job or
task, or about which one is simply better or whether you should code in a specific way or not. These
“wars” date back decades, a few even before some of us were born, and show no signs of ever ending
in a truce.
So what are those wars then? And why should you care (or not)?
The origin of it all lays in the tendency of many programmers of average or high experience to stick
with a system, be it a language, a framework, or a tool, throughout their career—either because it is
the one they like the best, they find themselves the most comfortable coding with or in it, or simply
because it was the first one they truly mastered and don’t feel like learning a new one. There’s
absolutely nothing wrong with that and it’s part of the reason some languages have had such a long
life despite tens of newer languages having been developed after them.
In any case, some programmers may seem outraged that you use, let’s say, Windows instead of
MacOS. Or that you chose to start coding with a visual code editor like Atom or Visual Studio instead
of a text-based editor like Emacs or Vim. Or that your personal browser of choice doesn’t appeal to
them because it’s not up to date with modern web standards or is developed by EvilCompany™and
by using it you are contributing to their world dominance plans or something.
These are the “wars” you will definitely hear about. Some people will try to convince you to use
a different tool for your job, for practical or ideological reasons. Even ethical ones, sometimes.
Whatever you may think about them, they’re part of the history of computing and are part of
the folklore, along with countless jokes and memes, of the programming community as a whole.
Knowing a bit about them will help you navigate the references that may occasionally pop up in
threads on social media and forums and help you choose the right tools at the beginning of your
programming journey.
The ancient editor war
One of the most famous, and still going strong, is the religious war between Emacs and Vim
(“religious” as there actually is a Church Of Emacs, no joke). For those who don’t know them well,
Emacs and Vim are two ancient text editors that over the years have developed a vast community
around them, with thousands of plugins to increase their functionality and an array of different
themes to change their appearance. If you haven’t had the chance to read their history yet, Vim
stands for “Vi Improved” as it is the direct successor of a previous editor, Vi, which in turn was
inspired by an even older one, Ed. We’re talking early 70s here. Bram Moolenaar, the author of Vim,
ported it to various platforms and made it “modern” in its functionality for that time. Curiously,
Programming tools
53
Emacs was also indirectly inspired by Ed as its ancestor was TECO, which was similar to the Ed
editor. Later Richard Stallman improved it (see the pattern?) and renamed it Editor Macros, Emacs
for short. End of history lesson.
On the deepest level, the rivalry between the 2 editors is not a practical one: they both do their job
very well, in our case allowing us to code in an efficient way, and are great at not overwhelming a
new programmer with too many features—you won’t feel too lost at first as you can just learn what
you need to start coding without getting lost in a ton of menus and options. Actually, in their text
versions, neither has any menus at all.
Where they do differ is in the philosophy: Vim espouses the small is beautiful and do one thing
well tenets of the system it was originally developed for, Unix, while Emacs centers on supporting
development as an entire operational hub. Emacs tries to be the center of your coding experience,
providing you with all the features you need to develop with ease, whereas Vim tries to just edit
text very well and lets you add other features with plugins. Emacs is all-encompassing, Vim is
more focused. Both are very quirky by today’s standards and may seem extremely counterintuitive
at first. That in turn gives rise to a smaller “war” between those preferring more modern coding
environments, graphical ones usually, and those that stuck with Emacs or Vim.
The point of this particular war is how one prefers to code: with a single program, which you
probably never leave and contains all your code, debugger and text editing capabilities, or with
multiple programs that you open from time to time, when you need, and can keep in the background
of your work, occupying less hardware resources at the cost of being more minimal. Whether
you prefer one philosophy or another, or want to totally avoid both Emacs and Vim, it’s not
important when you are starting out as a coder. Your focus should be on learning to code. You
will develop preferences for one mainstream philosophy or another, or perhaps even develop your
own alternative, in the future. Right now these editors are just tools that can help you code better,
not necessarily faster. If you don’t feel at ease with them, postpone learning them until later. Stick to
solving problems and completing code projects, not getting to know all the idiosyncrasies of various
editors. If you prefer a beginner-friendly interface, editors like Atom or Visual Studio Code will
make you feel at home.
The Windows/Linux war
The same attitude can be held regarding the OS wars too. There are plenty of opinionated
programmers that will swear by using Windows or MacOS, and others that will laugh at them
as the “real” coding experience can be had only with more minimal, “barebone” operating systems
like Linux³⁸ and BSD³⁹. Either can be right of course, this isn’t the book to discuss which operating
system is the best for programming. The best one for you is the one that allows you to be the most
productive, that gets least in the way of your learning and improving as a programmer. If you are
already using one that you feel perfectly comfortable with, have no grudge against and have perhaps
explored a few alternatives but none have sparked any interest, keep using your current operating
³⁸https://en.wikipedia.org/wiki/Linux
³⁹https://en.wikipedia.org/wiki/Berkeley_Software_Distribution
Programming tools
54
system. Don’t get bogged down in perfecting what already works. The tools are for you to use and
if you aren’t more productive with a commonly reputed “better” one, stick with the one you have.
Browser and style wars
Of a slightly different nature, and here is where you should start to care more, are the “tabs vs
spaces” war and the browser war. The latter is easier to understand so let’s start there. If you are
heading towards being a front end web developer, you may already know that different browsers
have different rendering engines—how they create the actual pieces that a webpage is composed of,
and render or “show” them on the screen. That (as a really simplified explanation) is what browsers
do, they take instructions in the form of HTML, CSS or JavaScript code and process them through
their internal engine to produce a visual result, a webpage that can be read and interacted with
by users. Having different engines, the process by which they render the webpage is different and
thus the results can be different too. That means a webpage can look different depending on what
browser you use to access it. The same is true for mobile devices: a webpage is shown in a different
way depending on the size of the device the browser is installed on. That’s a well-known fact and
an intentional feature meant to adapt any webpage to any device, from the tiniest cell phones to the
largest quad-monitor setups.
The browser wars were born out of different browsers competing to capture the widest audience; in
ancient times they were sold on CDs and thus they had to be commercially successful. Nowadays all
browsers are free to download (except for Safari that is only available for Apple machines) and the
commercial incentive is not directly money but instead related to the rendering engines: if a browser
becomes so widespread that it has an absolute majority of the internet users, then it is easier for
developers to write their webpages targeting only its rendering engine, making sure it looks the best
on it and not considering minimal differences in appearance with other browsers. Thus, indirectly, a
browser that has a dominant share of the market can influence the development of the technologies
that compose the Web by implementing some of them earlier, or not implementing others at all,
knowing that many developers will follow their lead.
Over the course of the last 30 years since the Web was born, various browsers have reached a
dominant status over the others. Netscape, Internet Explorer, Firefox, and Chrome have all had their
share of the spotlight in these browser wars. Regardless of the reasons why each browser rose and
fell, what’s important to us as developers is that using one browser over the others will mean not
only having different tools for development (usually called “Dev Tools” or “Developer Tools”), but
running the risk of optimizing the websites we write for that browser and that browser only. It’s
way too common to be lazy and content with your website looking good on your browser of choice,
assuming that it’s okay for others too. Or, worse, noticing some small issue with the layout or an
oversized font or a slightly misplaced menu in another browser and ignoring it because “only a few
people use it”. That may be true, but if not, its users won’t have a good experience using the site and
this will increase the feeling that the most widespread browser is the “best” one. You are indirectly
and involuntarily creating a monopoly in the browser market. This is why I try to make sure I test
my webpages with all major browsers at the very least. If we keep the competition open and fair,
developers and users alike will benefit from it.
Programming tools
55
“Tabs vs spaces” is a more technical war. In the beginning, talking again of the early 70s, editors would
use a tab character to indent code. One tab character was the equivalent of eight space characters
and in the old days disk space was scarce, so one character was better than eight. Nowadays we have
disks in the order of terabytes so the difference is negligible. Yet the issue here is of interoperability:
Mac and Windows editors tend to make a tab character the equivalent of four spaces while on Linux
and BSD, it is still eight. Unless you change the preference in your editor of choice, of course. Because
of this, most fans of spaces instead of tabs will consider you wrong for using tabs because a space
character is always a space character, no matter the editor and system you are using. On the other
hand, tab fans claim that one tab is much less typing than four to eight spaces.
The issue is, if you are using four spaces, for instance, and your programming buddy uses eight,
then the code will be indented differently and some languages, like Python, will even bail out with
errors as the syntax of the language depends on the correct indentation of the code. And besides,
the resulting code will look messy and hard to read. Moreover, copying and pasting from a web
browser in a local editor will most definitely screw up the indentation as it will depend on which
browser, which website, which editor and which operating system you are copying and pasting
from/to. There’s far from a standard here.
So for portability, do consider what you prefer and stick to it, but not before having spent a little
bit of time to check what is the recommended way to indent in your programming language and
in the project you are coding on. There are guidelines about tabs vs spaces in all the most popular
languages. It will make everybody’s life easier and save you from arguing with older programmers
that will most surely believe their stance in this war is the “right” one.
Use what you like, focus on learning
In an ideal world, nobody would judge you because you have taken a specific stance in one of these
wars (or not) or because of your choice of tools. Some will joke about it and some will fake being
offended that you have a different opinion, but nobody should discriminate against you in your
path to becoming a good programmer, just because you use a specific editor or prefer a Mac to a PC.
Yet it will happen, so it’s important to be at least aware of each of these wars. They may influence
your choice of coding tools. And hopefully this bit of history will save you from endless discussions
about which side is right, if any. As Bertrand Russell famously said, “War does not determine who
is right—only who is left.”
You are an interpreter
Edaqa Mortoray
Programming is primarily about translation. You take the desires of a user and translate them into
source code. It’s a process requiring a strong understanding of technology, the users, and all the
people involved in development.
I know a lot of you may wish to keep your head in the code, but becoming a great programmer
depends on you becoming a great mediator. Imagination far outpaces our current technology,
leading to extreme mismatches in what users expect and what our computers can actually do. As a
programmer, you’ll be required to temper those expectations and produce a nonetheless desirable
product.
You’ll need to empathize with the user and consult with colleagues on their views. Development is
not a process that can be done by one person. Programmers represent the technology, which is a
cornerstone to the process, but still only one part. Our products entirely hinge on the software doing
something useful, but without teamwork working towards a shared vision, that’ll never happen.
Soft skills is often the term used to refer to this part of the job—interacting productively with users
and teammates in pursuit of a common goal. I don’t know if that term accurately represents this
skill set. The ability to communicate is an essential skill. Your ability to get inside the user’s head is
critical to the success of the project. The importance of you as a translator and mediator of technology
cannot be overstated.
Nobody cares about your code
Let’s back up for a second, and start at the code. While it is only part of our job, it is the domain where
a programmer’s presence dominates. We own this artifact of development. It is our responsibility to
create it, and we have to address all issues with the code.
The ability to write code is a significant competence that all programmers must develop. There is no
way you can translate requests into code if you don’t know how to write it. Your ability to translate
is limited by your vocabulary.
Imagine having to work with somebody who doesn’t share a language with you—say someone who
only speaks Italian, while you only speak English. You’d need an interpreter that can translate for
you. The quality of the translation is limited by the interpreter’s understanding of both English and
Italian. If they can speak only a bit of Italian, their interpretation won’t be natural, and your Italian
colleague will have a hard time understanding what you meant to say. Similarly, it doesn’t help if
the translator speaks Italian fluently but is weak with English. The translator can formulate great
sentences in Italian, but potentially from a misunderstanding of what you said.
You are an interpreter
57
In programming, you are an interpreter who must speak two languages. Code is one of the languages
you need to speak. But you also need to speak the language of users and other developers in your
company. It’s irrelevant that you weave wondrous structures of code if you’ve misunderstood what
you’re supposed to be building. It’s also pointless if you’re a master empath, and you can understand
the user perfectly, but you can’t figure out how to express that in code.
Source code is a work artifact. It’s there to support the high-level goals of the product. Ultimately,
other than you and a few other programmers on your team, nobody cares about the code. It’s all
about the product. The user cares about what you’ve built and how it solves their problem, not so
much about how you got there. Knowing this improves the appreciation of your work, and lets you
make the right decisions.
Sharing the journey of the user
But what goals does the code need to support? Here we look to the users of the products: the people
that will be installing the app on their phone, going to your web page, or downloading a desktop
program. Understanding the people using our software is the highest priority of development. The
user experience is our utmost goal.
You may have already heard about user stories, journeys, and personas. These are all tools that
capture what the user wants. They should be used on most projects. It’s actually hard to avoid them.
Even if you don’t use a strict method or have rigid formality, you will be considering the user’s
wishes in your project. Learning user tools, such as user stories and portraits, makes the process
easier and more robust. But just like code, they are not the purpose of the project.
The purpose of user portraits and stories is to keep the focus on the user. A portrait tells us what job
a user has, where they live, and what their goals are in life. We create these descriptions to better
empathize with people using our product. If these people remain nameless and abstract, it’s easy to
forget about who they are.
Having a bit of formality, such as writing down our ideas, allows us to communicate with other
teams. It’s more comfortable to talk to other departments in the domain of the user than of
technology. By talking about the product from the user’s viewpoint, we stick to a universal language
that everybody can understand.
This is more challenging than talking about code. Code has a strict structure and lack of ambiguity.
By contrast, human language is full of amorphous thoughts and wandering ideas. It’s this lack
of clarity that causes most issues within development. But as difficult as it may be, getting all
departments to talk in the language of the user is worth it. It’s how great software is made.
Much like the code isn’t the product, the product isn’t actually what the user wants. People have
real-world tasks they wish to perform. They are willing to use a tool to get them done, but that’s
all it is: a means to an end. They may not even know what kind of tool they need (see Appendix A,
“XY Problem”). This is why it’s essential to talk in the language of the user, not the product. This
subtle distinction in wording shifts the emphasis of development from technical requirements to
user expectations.
You are an interpreter
58
For example, most people don’t want a car for the purpose of having a car. Many people don’t even
want to drive, but they have a car to get to other locations. These drivers care primarily about how
they get somewhere with their vehicle. All the polish and extra features are pointless if it’s hard to
get somewhere. This is why things like public transit and taxis compete in the same market. When
stating requirements, there’s a significant difference between “wanting to own a car,” and “wanting
to travel between locations.”
As another example, we have apps that allow us to organize events, from large to small. As the
developer, you must keep in mind that the users are trying to hold an event. Your app is strictly a
tool the organizer and attendees will use. Adding features that don’t support the event organizers
may at best be ignored by the user, and at worst get in the way. I’m sure we can all think of numerous
apps that have nonsensical features in them.
Everything and yet nothing we want
Ensuring our high-level requirements stay in the domain of our users addresses a fundamental
problem. Technology can’t do everything. Indeed, it doesn’t come anywhere close to all the things we
want to do. It can neither do them the way we want to do them nor understand what we actually
want to do. Despite the extreme reliance we have on computers, they are still constrained when
compared to all that is possible.
People’s desires are not limited by technology. Their imagination shows no bounds. The expectations
placed on technology tend to grow faster than technology itself advances. The demands placed on
our computers, our gadgets, our networks, increase at alarming rates.
It’s your job as a programmer to translate these unbound ideas into the limited space of what
computers can actually do.
Losing track of the user’s desires means you run the risk of working on the wrong things. While
computers are limited in fulfilling user desires, they are unbound in their own domain. There’s a
wide variety of interesting, cool, and clever things we get a computer to do. It’s easy to go down the
road of technical beauty and stray far from the goals of the project.
Your focus on the user is what keeps you on track. For every line of code you write, for each module
you install, for every host you deploy, you should be thinking about why the user needs this. If you’re
unable to draw a clear connection from your work to those high-level user goals, then something is
wrong.
Part of a larger development community
This focus on the user isn’t only for programmers. No project can be done by programmers alone.
Beyond the users, there are numerous other departments in a development company—designers,
product owners, project managers, executives, quality assurance, and so on. You have to be able to
converse with all of them about the product. You need to all be working towards a shared vision.
You are an interpreter
59
When somebody is left out of the process two things happen. First, their ideas, concerns, and
requirements will be lost. This could result in a product of lower quality. Second, they feel
marginalized and may become demotivated. Continuing in that state, they may become bitter and
angry.
Tensions between teams are unfortunately all too familiar. A lot of this tension comes from people
not properly communicating. While two teams may both fully believe in the product, an inability
to share that vision can lead to hostility.
This discord can rapidly foment an unpleasant workplace. Nobody, including you, wants that. You
work there, so keeping everything pleasant is in your best interest.
When things turn sour, productivity suffers. Not only are people, including you, demotivated, but
they also end up working on the wrong things. The vision of the product becomes blurred, and
ultimately it will fail. Instead of working together, everybody starts complaining about the other
teams, how they don’t listen and don’t understand.
Always remember, communication is a two-way street. The best way to be misunderstood by
someone is by not talking to them. The best way to misunderstand someone is to close your ears to
them.
As technology and time are limited, development is all about compromise. Not everything can
be done. You, as a programmer, represent the technical side of the equation and must bring that
knowledge to the negotiating table. Learn when to speak up and how to bring your concerns to the
table.
If you can’t build a particular feature, you must make that clear. If you have an idea for a feature
that you think would help the user, but that nobody has mentioned yet, you should bring it up. If
teams have requests for features that would help them and cost little, it’s worthwhile to implement
them to improve relations. If a high-visibility defect isn’t getting fixed, you need to explain why that
is.
Your prioritization process must be transparent, or tension will build. People are better able to accept
the rejection of their ideas if they understand why they are being rejected. When people share a user-
focused vision of the product, it’s easier to identify high impact items and work on them first.
Deserving of trust and autonomy
By having open processes and taking the time to listen to other teams, you’ll build trust between
each other. We rely on other teams to do their job. Just as we translate others’ wishes into code, our
own requirements will be converted into work processes in various teams. A request for artwork
will be taken by a graphic artist and turned into images. We may ask marketing about our target
user, and they’ll come back with a persona. We have some idea of what they’re doing, but the details
of their work aren’t our concern.
Development is not an exact science, and we all need room to maneuver if we’re to get the system
right. This is why it’s crucial that requirements stay in the realm of users. The internals of the
software must be flexible.
You are an interpreter
60
If requirements specify how a system should work internally, they interfere with the job of the
programmer. The same goes for other departments. We aren’t going to tell the graphics team what
Photoshop layering technique they should be using, nor will we specify which ERP accounts the
finance team should create to handle microtransactions. All teams have an expected amount of
autonomy to perform their work.
This autonomy is based on everybody having a shared vision. We are all allowed, and expected, to
contribute to the product’s goals. That shared user domain is everybody’s responsibility. This goes
hand-in-hand with trust. There’s no way you can implement the system correctly if you don’t know
what those high-level goals are.
Your flexibility and trust in your work depend on your understanding of the user. And that’s tied to
how well you can communicate with other teams.
Becoming a great programmer
The emphasis for programming is often placed on coding. It’s a comfortable place to start learning.
Initially, it’s likely the place where you lack the most skills. You’ve grown up in the real world, so
to some degree, you’ve been working on your soft skills for years already.
Natural experience won’t be enough, however. The particular skills needed for communication as a
programmer require additional training. You need to take the time to learn the various techniques
used for translating user desires into code.
Don’t feel overwhelmed though. Nobody can naturally do everything, and it’ll take time to learn
both code and communication. You’ll be part of teams that will help you along. You and your
teammates will have strengths and weaknesses to compliment each other.
You won’t always act on your own. If you’re a junior programmer, it’s vital to have a mentor that
can help you along. It’s expected that programming teams discuss how the code should work. It’s
important to have a good leader who can make good decisions, and when needed, state precisely how
some system should work. The dynamics within a programming team differ; however, the dynamic
is always based on communication. And you should never let anybody hide the user’s wishes from
you.
Becoming a great programmer is primarily about your ability to act as an interpreter. You can’t be
ultra-productive only by being awesome at coding. Productivity is about choosing the right things
to work on and figuring out the best way to cover the product requirements. Your value will be
measured by how well you appear to be supporting the company. The better you perform with
other people, the better you can tailor your effort towards high impact items.
What to learn first
Isaac Lyman
I occasionally get a message from a brand-new developer who’s overwhelmed by all the technologies
and choices that exist in the world of software development. Where do you even start? Some of these
devs have seen job advertisements like the following:
This is for a standard, mid-level web development position. It lists 14 specific technologies, alludes
to many more, and if that weren’t enough, it has an “etc.” Even as a senior software engineer, I’m
not sure what that “etc.” refers to. Maybe I could Google it:
What to learn first
62
Oh, great. 16 more technologies. If I were brand-new to this, I’d be thinking, “you mean I have to
learn 30 different programming languages just to get a mid-level job?” And then I’d throw up my
hands and apply for a job in something less demanding, like brain surgery.
Let’s put that fear to bed: no, you don’t have to learn 30 different programming languages, now or
ever. You need to learn one. Then you need to learn a few tools that are commonly used with that
language. That will get you a junior position. Afterward, you’ve got options: get better and better
with the languages and tools you already know (you might call this the “expert in the room” route),
or learn several more (the “startup engineer” route). Either route will let you advance your career
and make more money, and neither is necessarily better than the other, but you’ll probably find that
you strongly prefer one of them.
So where should you start?
Make a list of technologies you’re considering. Then pick one, any way you like. If there’s a company
you want to work for and they recruit heavily for one of them, pick that one. Or if you know what
you want to build, pick the tech that goes with it (see Appendix B for ideas). Or go with your gut.
Or flip a coin, or roll a d20, or pick one out of a hat. There’s no “best” technology. What’s important
here is that you commit. Spend time getting to know the technology, building simple projects with
it, reading articles about it, finding GitHub repositories that use it.
Some people start second-guessing themselves after a day or two with a new technology, so they
switch to a different one, and then another one, and then another. This is like learning to say “Good
morning” in 50 different languages. It’s a party trick, not a marketable skill. Don’t let yourself do
this. Even if you spend five years with something and decide it’s not for you, it’s not a total loss; 75%
or more of the skills you’ve learned will transfer neatly to your next technology. The consequences
of choosing the “wrong” technology are tiny.
If you don’t know a programming language yet, I recommend starting with JavaScript, Python or
C#. All of these are extremely popular and in high demand. If you already know JavaScript, learn a
utility tool like Lodash and a web framework like React or Vue, or learn Node.js and a server-side
framework like Express or Hapi. If you know Python, learn a data science library like NumPy or
Pandas, or a web framework like Django or Flask. If you know C#, learn ASP.NET MVC to build
What to learn first
63
web applications, Xamarin to build native apps, or Unity to build video games.
Once you’ve picked some technologies, the best thing you can do is start a project (see Leonóra’s
chapter “Making the most out of side projects”). Think up something small and simple you want to
build, then put it together a step at a time, learning what you need to learn as you go along. This is
the best way to gain competence. It doesn’t much matter what you build, as long as it’s interesting
to you—to-do list apps are the cliche, but you could just as easily build a game, a unit conversion
calculator, a chat room, a conversation bot, or anything else that comes to mind. The only limit
is your imagination. For some free ideas, check out the graveyard tag⁴⁰ on dev.to, where several
developers have written about the projects they’ve built on their own over the years.
Once you finish your project you’ll have a nice portfolio piece, along with the confidence of knowing
you can see a project through from start to finish. And you’ll be well on your way to being an expert
in the technology of your choice.
I promise, as long as you don’t go out of your way to choose strange and obscure technologies,
anything you choose can lead to a successful career. There are plenty of jobs out there waiting for
you.
⁴⁰https://dev.to/t/graveyard
Learning to learn
Yechiel Kalmenson
“You need to learn how to learn” is a phrase you will often hear as you start on your journey.
Don’t worry about which language/framework resource X or course Y teaches, people will tell you,
what’s important is that they show you how to learn on your own.
There is truth to that. The majority of new developers don’t get a job using the first stack they
learned. Even if you are lucky enough to get a job using the frameworks you learned, the breakneck
pace of the tech world virtually guarantees that your knowledge will be outdated in no time and
you will have to learn the next shiny thing every few years.
Students who find themselves too focused on acquiring a particular technology, instead of focusing
on acquiring the skills needed to keep learning on their own, might find themselves blindsided when
tasked with learning a different technology just to get their first junior role. They may feel like the
experience they gained at their bootcamp or college (or the resources they spent self-teaching) was
a waste of time and money.
Changing your perspective from thinking that you need to learn Ruby, or JavaScript, or React, or
what have you, to realizing that you are really trying to learn how to learn those skills will leave you
better prepared for the task of finding your first job as a developer and for the lifetime of learning
and growth that will follow. Not to mention that it will help you learn whatever technology it is
that you decided to go with first more effectively.
But what does it mean to “learn how to learn”? What are the skills that developers use to help them
keep up with a never-ending stream of new frameworks and technologies?
After many conversations with both former and potential students and career changers, I believe I
was able to narrow it down to four skills that you need to acquire if you want to be able to learn on
your own after graduating:
1. How to read and understand error messages.
2. How to Google things.
3. How to read and understand technical documentation.
4. How and when to take a step back and ask for help.
From my experience as a developer, I can say that I spend 90% of my workday doing one of those four
things. If you can master these skills, you can be reasonably confident that there is no technology
you can’t pick up.
Learning to learn
65
Reading error messages
This was one of the first lessons I had to learn when learning to code, and, in my opinion, what
separates developers from the rest of society.
Back in my “civilian life” error messages were scary, they were opaque, they felt like the computer
was screaming at me in a foreign language and blaming me for something which it probably thought
was my fault.
When I started learning how to code I naturally ran into many error messages, and that felt very
discouraging; I felt like I must be doing something wrong.
Then one day it “clicked” for me. I was watching a lecture by one of the bootcamp instructors
where he was coding an app. At one point he ran the code and hit an error and instead of getting
embarrassed or flustered he exclaimed, completely unironically, “We hit an error! Great!” That’s
when I realized that error messages are far from our enemies. When we encounter an error message
as developers, it’s the computer’s way of letting us know what’s wrong with our code; it’s how it
provides clues on what we need to fix.
As a developer, you will be working exclusively with broken code (if the code already works then
who needs you?). Reading and analyzing error messages is how you will go about fixing it.
The kinds of error messages you get and how helpful they are will depend a lot on which
language/framework you are using. Some languages have more helpful errors than others, but some
elements are universal.
Every error message will usually contain:
1. The error message: what actually went wrong. These can vary from a few cryptic words to a
full paragraph containing suggestions on what you might be able to do to fix the bug.
2. The location where the error occurred: the file, line number, and sometimes the function name
where your program was when it crashed.
Learning to learn
66
3. The stack trace: all the lines in your code that the program executed until getting to the function
in number 2. This can help trace where your function was called and with which parameters.
Reading all that and getting comfortable with parsing the different parts of the error message can
take some practice, but that’s the first place to look when your code doesn’t behave the way you
expect it to.
A good bootcamp or Computer Science course will encourage you to play around with the code and
break things, and will celebrate error messages instead of just showing you how to fix them.
But error messages, helpful as they are, are limited in how much they can help you. After all, the
designers of the language can’t know in advance all of the different ways programs written in their
language can break. That’s when the next skill comes in handy.
How to Google stuff
As a developer, you will spend the majority of the time doing things you don’t know by heart. Google
(or DuckDuckGo, Bing, etc.) will be your best friend.
For beginners, it can be hard to know what to Google for, especially in the beginning when you
aren’t even sure what it is you’re trying to do, never mind verbalize it in a way that a search engine
can understand. Learning how to structure your query for best results is an art that comes with
experience, but some rules will help you get started:
• Include the language you are using: if you are learning Ruby and have an array you want to
sort, searching for “how to sort an array” will probably not be very helpful; when I just did
Learning to learn
67
it the first page of results contained only answers about how to do it in Java, Visual Basic,
and JavaScript. Always start your query with the name of the language you are searching for
(in our example, “ruby sort an array” will give you plenty of results that a Ruby programmer
would actually find useful).
• Use well-defined keywords: this comes more with experience, but knowing which keywords
represent the actual information you need will save you time filtering through unhelpful results.
As a general rule, don’t include words that aren’t necessary; crafting the shortest query that
contains all the keywords relevant to your search will help make sure that you get only the
results you want.
• Know which results are more likely to be helpful: again, this comes with experience, but some
results are more likely to be useful than others. You will develop a taste for this with time, but
in general, more recent results are less likely to be out of date, and an answer on Stack Overflow
with a hundred upvotes is more likely to be helpful than a blog-post from a no-name author
(which isn’t to say there aren’t great blog-posts by relatively unknown authors).
This last point brings us to the next skill.
How to read technical documentation
Languages/frameworks have many features and functions, and unless you use a particular function
on a semi-regular basis, it is unlikely that you will have the syntax memorized.
This doesn’t mean that you are a lousy programmer. Even accomplished programmers with many
years of experience find themselves Googling things like “concatenate a string” or “filter an array.”
Source: https://twitter.com/dhh/status/834146806594433025?lang=en⁴¹. DHH is the founder of Base-
camp and the creator of Ruby on Rails, one of the most popular frameworks for web development.
The documentation for most languages is usually the most comprehensive and concise reference for
language features, saving you the trouble of memorizing hundreds of obscure language features.
⁴¹https://twitter.com/dhh/status/834146806594433025?lang=en
Learning to learn
68
For example, Ruby has about 20 different ways to iterate over an array. If you are trying to learn
Ruby, you might think that you have to memorize all 20, but if your goal is to learn how to learn
then all you have to remember is that you can find all the ways of iterating over an array in the
documentation on Ruby’s Enumerable module⁴².
The problem for beginners is that the documentation can look dense and intimidating; its conciseness
means that the page can look like a scary wall of jargon and technical terms and symbols, but with
practice, you can learn the patterns and learn how to find the information you need. With time you
will see that the official docs will become your go-to reference for simple syntax.
Ask for help
Finally, there is another very crucial skill that is not exactly about self-learning, but it’s an essential
skill to have if you want to be an effective learner.
Photo: WOCinTech Chat⁴³. Unmodified image licensed under CC BY 2.0⁴⁴
The last skill is knowing when to step back and ask for help.
None of us ever did it on our own; the “self-taught developer” is a myth.
⁴²https://ruby-doc.org/core-2.6.1/Enumerable.html
⁴³https://www.flickr.com/photos/136629440@N06/25392428253
⁴⁴https://creativecommons.org/licenses/by/2.0/deed.en
Learning to learn
69
Surrounding yourself with a network of mentors and fellow learners, and knowing when/how to
leverage said network, will save you time best spent actually learning new things. It will mean that
you don’t have to spend hours banging your head against the keyboard over a simple typo that a
second, fresh pair of eyes would have caught right away (though we’ve all been there).
There are many online communities geared at beginners. If you are in a bootcamp they probably
have ways for students (both current and former) to connect. Dev Twitter is extremely friendly,
helpful, and supportive (some of my favorite communities are the #CodeNewbie⁴⁵ community
and @ThePracticalDev⁴⁶). Find your corner, your people you connect with, and you will see that
traveling together is 100 times better than traveling alone.
In conclusion
In conclusion, learning to code is a big decision. Many factors are involved in what makes a good
bootcamp, course, or resource. I hope that reading this chapter will give you an idea of which skills
are essential to focus on and which are just a passing fad.
Good luck!
⁴⁵https://twitter.com/CodeNewbies
⁴⁶https://twitter.com/ThePracticalDev
Make the most of side projects
Leonóra Dér
This chapter will be about side projects and I would like to convince all of you that they are great!
So what comes to your mind when I say “side projects”?
Maybe you know of CommitStrip. It’s a blog about the daily life of developers and I just love reading
their stuff, but one of my favorite strips⁴⁷ from them is about side projects. It shows a very typical
situation: a developer having millions of unfinished, never-going-to-end projects. Have you ever felt
like this? Not yet?
In some ways I’m writing to motivate you to do this. To start new side projects. To also finish them,
of course, but to be able to finish one, first you have to start it! But why would anyone want to do
that?
Famous examples
To get an idea of what side projects really are, first check out a few famous ones. I guess I have
to start with a couple of the most famous side projects, Gmail and AdSense. Both were created by
enthusiastic Googlers.
Twitter, ProductHunt and even GitHub were once side projects. And the list of side projects that
became million-dollar startups goes on…
My projects
But don’t tune out just yet! You might think that I’m crazy about side projects and the truth is, I am.
I’d like to show you a few of my own side projects so you can see how they’ve helped me. I picked
very different ones:
The very first of my side projects was an online tool where you could create, edit, and share a
business model. I used this project as an opportunity to learn Vue.js (a web framework) and Spring
Boot (a Java server framework). Now, I’ve struggled to find users, but I recently made some progress:
I spoke with a startup incubator who said they would love to use it! I’m more than happy with that.
If you’d like to take a look, you can find it online⁴⁸!
My current project is a challenge for developers. It will be a collection of challenges soon, but at the
moment there is only one. It’s called the Cretan Maze. You’re trapped in a maze and have to get out,
⁴⁷http://www.commitstrip.com/en/2014/11/25/west-side-project-story/
⁴⁸http://businessmodelcanvas.io
Make the most of side projects
71
but you have to collect three gold coins first and you control the game through a REST API. So as a
developer you have to write a program to find your way out of the maze. I shared it on a few sites
when I finished coding it. To tell the truth, it was a bit like testing in production. I mean…I checked
the functions, everything was working properly more or less, but when a lot of people started to use
it, bugs came out immediately. So I learned that I should conduct a beta test before I let everyone in
through the front door. Anyway, you can try your hand at the challenge here⁴⁹.
Last but not least, the project I am most proud of is my blog. It’s a blog for software developers,
written in Hungarian. It is called ‘fejlesztő lány’ and I started it as a personal challenge; I needed
something in my life I would have to spend at least 10-20 minutes with daily so I can keep track
of the days. It might sound a bit weird, but sometimes I lose track of time. This blog and Facebook
have helped me a lot and I know it’s not a traditional side project, but I truly recommend to any
developer to start a blog!
Cons
Now that we have an idea of what a side project can be, let’s ask an obvious question: Why would
anyone want to spend time on a side project?
I mean, you might say that you don’t have time. I guess most of you have full-time jobs. You could say
that after working for eight hours you are tired and you don’t care at all. Or you have a family you
would prefer to spend time with, and on the weekends you want to be far away from the keyboard,
hiking in the mountains or playing on your local football team.
But remember, people say that you have time for what you make time for. I know it’s a cliche but it
is very true. Once I read a post by a dad who learned how to program in the evenings, and couldn’t
even sleep much as he had a newborn daughter to look after, but a few months later he got his very
first developer job.
Think about that for a second. He put his time into it and he got a reward: a job offer. Sounds great,
doesn’t it?
You might also say that side projects are something that no one pays for, and no one will praise
you for the effort and time you put into a side project if you fail or abandon it. The bitter truth is,
undoubtedly, most side projects will fail. We all know this. The majority of them don’t even reach
the first release, and those that do often become abandonware, no longer supported by the developer.
GitHub is a graveyard for them.
You could also say that it’s useless to spend time on this stuff, creating another note-taking app, an
alternative to one used by millions or billions of people, whatever for?
Pros
Let me show you all the advantages!
⁴⁹https://coding-challanges.herokuapp.com/challanges/maze
Make the most of side projects
72
The first advantage I’d like to emphasize is learning new technologies and dev skills.
For example, if you’re a Java coder, why not try Python with a data science side project? Or if you’re a
backend developer, why don’t you try out a shiny new frontend framework? Or let’s say you usually
do coding stuff, but deploying your own app to Heroku and setting up a database, Jenkins jobs, or
code analysis with SonarQube could be a challenge for you!
We live in a world with constantly changing technologies. So if you want to keep up with the new
trends, the best tool for the job is side projects, making some useless or not-so-useless projects to try
out a new library, framework or tool.
Instead of staying updated on the latest frontend frameworks in the JavaScript universe, you could
also have a project focused on learning how to write clean code, how to refactor legacy code, or
how to do Test-Driven Development, because these things take a lot of time to master. You could try
reading a well-known book on the topic and implementing the knowledge at the same time.
Another great benefit of side projects is that you are practising outside of your office hours. If you
use the same technologies at work and for your hobby projects, you’ll meet the most typical bugs
and pitfalls beforehand so that you can feel more confident at work. You’ll get to know the best
practices, so you can help others make better decisions or give advice on using library A rather than
library B, saving time for you and money for your company.
The next advantage I’d like to mention here is simply the joy of building something. It’s fulfilling
when you can show your product to others, or take a look at something and know you’re the one
that created it. You should be proud of yourself if you’ve completed a project that others can use or
download. The feeling when other people are happily using your product is quite satisfying.
And there’s another skill that you can build using your old side projects: refactoring. Think about
it as working on legacy code that you have to make work by turning buggy, vulnerable code into
something beautiful, making changes line by line, starting small but making powerful improvements
in the long run.
Side projects are also great because they look great on your CV or resume. During the interview,
when they ask about projects you’ve worked on, you’ll be happily saying that you did this, that and
some other stuff too. They help build your online presence and that certainly won’t do any harm to
your CV, career, network, or professional growth either.
If one of your projects gets serious then you can even quit your job, start a business, and become an
entrepreneur. I’m not encouraging you to quit your job right now, but it might happen…
A friend of mine always says that a good side project makes you money while you sleep. But
sometimes that mentality can do harm, as some people get very anxious when their projects start
to make even a little money. Generally, the primary goal is not to make money, but to learn, to
advance, to grow.
I have a few more advantages of side projects to share with you. For example, if you collaborate on
an open source project or build something for a community, then you will be able to connect with
developers from all around the world and make some new friends and connections. That sounds
good, doesn’t it?
Make the most of side projects
73
Also, it’s refreshing. It’s a great way to get out of your comfort zone and do something different
from your day job.
Last but not least, I would say that it’s FUN! Think about it! You have the freedom to do whatever
you want—there’s no boss or client to tell you what to do and how to do it! You don’t have to spend
hours in useless meetings. You don’t have to convince anybody of your own point of view. Your
code will be super consistent and strictly follow all the best code conventions: yours.
How
Now that you know all the advantages and disadvantages of side projects, I would like to give you
some advice on how to get the most of the time you’re willing to spend on them.
Step 1: Find a topic
Usually when I want to learn a new technology, I build something. Getting your hands dirty is the
only way of actually making sure that you got it right. You need those “aha!” moments you can’t
have just by reading or watching tutorials. A lot of people build “To Do List” apps, which are nice
because they’re easy to get started with and everyone is familiar with them. But I personally don’t
want to make yet another To Do app! If I’m going to spend my super precious time on something, I
want to be making something that has a chance of creating value for someone. For me it’s best to
make something useful, but of course sometimes it’s nice to do something just for fun.
Another suggestion: use a note-taking app. Ideas can come anytime, so be prepared! Otherwise you
will forget them.
If you are clueless as to what to do, you can find millions of ideas on the internet!
Step 2: Make a plan
Don’t worry, I’m not saying that you should start by writing a detailed, 100-page document. I’d
guess you’re used to that because of your day job. Your plan can be a random text file a few lines
long, with core features, goals and milestones. It’s usually useful to make separate files for the first
version of the project and for changes, new features, etc. And don’t forget to limit the scope and set
a deadline!
Step 3: Find a community
You can find online forums and groups that are made for sharing and receiving constructive feedback
on side projects. One of my favorites is the r/SideProject subreddit⁵⁰. It’s very active and well-
moderated and you can even get some new ideas from there or use it for brainstorming.
⁵⁰https://www.reddit.com/r/SideProject/
Make the most of side projects
74
Step 4: Build something minimal, and I mean minimal
Believe me: even if you are an experienced developer, chances are that you’re going to overestimate
your own capacity. It’s common to feel like you’re more productive alone than you are inside your
organization, and this is true to a certain extent. But if you don’t keep your feature list short enough,
chances are that you won’t finish the project before you lose your motivation and interest.
Step 5: Become a finisher!
Despite your best intentions, things will come up. You’ll always have good reasons not to finish a
project, like going on holiday, taking German lessons, or reading funny stuff on the internet. But
sometimes you have to say to yourself, “Hey, you are going to finish this app and put it on the
Android app store. It doesn’t matter how long it takes, you are going to work on this app at least an
hour each day until it’s done.”
Step 6: Go live!
Going live isn’t just about publishing your app to the app store or deploying your website to the
web. It can be publishing a library to npm or even just open sourcing the code so people can see
it, use it and learn from it. Don’t forget to spread the word! Post about it on your blog, subreddits,
dev communities, even ProductHunt. You will love receiving feedback from your actual users and
contributors.
Pro Tip 1: Go to hackathons!
Hackathons are getting more popular and more frequently organized as they’re a great way to
bring people together. You’re usually closed up with a few people to work on a project for a while,
sometimes up to three or four days. By the end you’ll have a team, a detailed concept, even a demo
version of a product. Sounds good, doesn’t it?
Pro Tip 2: Find a supportive workplace
At the company a friend of mine works for, they have an ‘Experiment Day’ every month. It’s great
for trying out interesting technologies. Similar ideas are found across a lot of tech companies—and
it’s easy to see why. You could even be the person who organizes these events.
I’ve heard that at some companies they have a “Demo Day” where anyone from the company can
show what they’ve been working on in their free time.
There is also Google’s famous “20% policy”, which means their employees can work on anything they
want for up to 20% of their work time. Why would a company do that? Because they’ve recognized
that it’s beneficial for their employees and their company too.
Keep in mind that if you create something using company time or computers, it may legally belong
to your employer, so check your contract to make sure you’re aware of that possibility.
Make the most of side projects
75
So why not start one?
As you can see, your precious time spent working with side projects can be beneficial. Your small
ideas can even grow into big companies. I hope that you are all motivated now to start and to finish
one! In the end, the most important thing you can do is to grow and gain experience.
Getting your first job
Isaac Lyman with Clifford Fajardo
Getting hired is hard at first. I mean, eventually you’ll have an amazing resume and recruiters will
be flooding your inbox with interview requests, but for the first little while it can seem like an
incredibly tough market. Everyone’s looking for senior developers, interviews are all whiteboards
and obscure data structures, and some jobs turn out to be unpaid “internships” or “software farms”
that mistreat and devalue their employees.
Luckily, software development is a field where you can get a lot of valuable experience without even
having a job. And there are things you can do to improve your resume, grow your network, build
your skills, and interview at better companies, all without a heavy time investment.
Side projects
Coding in your spare time may not be appealing or even possible for everyone, but it’s an effective
way to add qualifications to your resume. Even a small project put together over the weekend can
add value to your portfolio. There are a few different sites where you can upload your projects for
free. The most popular⁵¹ is GitHub⁵², with over 100 million projects hosted, but BitBucket and GitLab
are also popular choices.
A side project can fulfill many purposes. It can help you learn a framework or tool that’s trending
in the market, explore a technique you want to apply at work, exercise your creativity, prototype a
product you want to start your own company with, and/or demonstrate your technical skills. And
because you’re building it for yourself, you may find that it’s far less frustrating than coding at your
day job. In fact, if my job is growing too tedious, I sometimes use a side project to remind myself
why I love code. Taking time to create without limits or rules is always refreshing.
Potential employers who review your projects will be looking for a few different things:
• Well-organized folders and files. Most programming languages and frameworks have conven-
tions for how things are organized. If your chosen technology doesn’t, use a consistent structure
that makes everything easy to find. Most files should be relatively small (a few hundred lines
or less).
• Consistent code style. It doesn’t matter what styles you choose (tabs or spaces, line lengths,
brackets on their own line), as long as you stick to them.
• Unit tests. Writing tests shows that you care about code quality and maintainability.
⁵¹https://en.wikipedia.org/wiki/Comparison_of_source-code-hosting_facilities#Popularity
⁵²https://github.com/
Getting your first job
77
• Documentation. The ability to describe and explain your code makes you a better teammate.
You should at least have a “Readme” file explaining how to set up the project and run the tests.
If you have trouble coming up with project ideas, start with something simple: a tic-tac-toe game,
an “About Me” web page, a metric unit converter.
Revising your resume
When you’re working on your resume, consider the following guidelines:
• Use standard, professional typefaces like Helvetica or Times New Roman. Don’t use more than
two.
• Use a professional-looking email address. Employers will think twice about interviewing you
if your email address is “doomslayer420@onlinedating.com”.
• Put the most impressive stuff at the top of your resume and the least impressive stuff at the
bottom. If that means your education and job experience are on page 2, that’s okay. Don’t let
fluff like a “personal statement” or “career goal” take the top spot unless it’s expected in the
industry or culture you’re applying in.
• Don’t overcomplicate. Unless you’re a visual designer, you should avoid using images,
illustrations, or multiple colors.
• People scan down the left side of the page when they’re in a hurry, so left-align everything and
put main points like categories, job titles, and project names in bold or capital letters.
• Be consistent. Make sure you’re using the same typeface, font size, emphasis, bullets, alignment
and spacing throughout your resume for headers and text at every level.
• Mention specific technologies, programming languages, and projects you’ve worked with.
Hiring managers love specifics.
• Hiring managers also love numbers. Quantify your work wherever you can. Even if your last
job was shift manager at a fast food place, you can say something like “Responsible for $2
million per year of physical product, serving over 180,000 customers.”
• Resumes aren’t only for job history. Include everything you’ve done that’s relevant to your
career. If you have a blog or GitHub profile, you’ve presented at a meetup or contributed to
open source projects, you were president of a coding club in high school, or you were top of
your class at development bootcamp, it belongs on your resume!
• Always provide your resume as a PDF.
• Don’t call your resume “Resume.pdf”. It will get lost too easily. Instead, use your name, job
title, and (optionally) the date of the most recent revision: “Isaac Lyman - Software Engineer -
Mar 2019.pdf”.
• If English isn’t your first language, ask a native speaker to review your resume and help you
with spelling and grammar. This can make a big difference in the number of interviews you
get.
Getting your first job
78
A resume doesn’t have to be complicated. Here’s mine (slightly anonymized):
Meetups, events and channels
The best way to meet other developers and find out about jobs that aren’t posted online is to go to
meetups and events. Meetups are easily found in most cities, and often associated with a specific
technology or product (for example, you can Google “Vue meetup” or “Adobe user group”). If you go
to a small meetup, you may be asked to introduce yourself, which is a great opportunity to mention
that you’re looking for work. By the time the meetup is over you should have a couple of new leads.
Larger meetups don’t usually do this, but you can still meet a lot of local developers and find new
opportunities if you attend.
Tech companies sometimes host events for developers to socialize and learn about their products,
so this can also be a good way to expand your job search. You can find out about these events by
following those companies and their employees on social media. (Programmers in particular have
a strong presence on Twitter.) Tech conferences can be good events for networking as well, but are
usually expensive (they assume your company is paying for the ticket).
It’s also pretty common for a city—or, in the case of Utah, an entire state—to have a Slack workspace
or other chat room for software developers. If you join, you can find out about open job opportunities
by searching the archives or asking around. If you belong to a minority group, you can find a relevant
Getting your first job
79
Slack channel (like latinos.slack.com⁵³ for Latinx people in tech, blacksintechnology.slack.com⁵⁴ for
black people, or womenintechto.com⁵⁵ for people who identify as women, genderqueer or non-
binary).
Learning about roles from other developers is ideal. They’ll usually tell you more about a company’s
work environment, benefits, and pay than you’d learn from an online posting or a recruiter.
Mentors
A strong connection to someone with a lot of industry experience can be game-changing. If you
don’t have a mentor, set a goal now to find one. “Professional generosity” is one of the unwritten
core values of the programming world, so if you reach out to a few developers you’ll likely find at
least one who’s willing to answer questions, introduce you to recruiters, and give you career advice.
(Others may be too busy or just not interested—don’t let that discourage you.)
In your search for a mentor and in your career in general, social media can be invaluable. If you
don’t have an account on Twitter or LinkedIn, setting one up is a great next step. An account on
dev.to⁵⁶ will also help you meet and learn from other programmers.
The best way to begin a mentoring relationship is to choose a programmer you know or admire,
introduce yourself if they don’t know you, and ask them a specific knowledge-based question, like
“how did you find your first job?” or “can you help me understand how to search an array?” If they
don’t respond, you can follow up later, but don’t be offended if they never get back to you (some
programmers get hundreds of requests like this). If they do respond and the interaction goes well,
you can ask another question or even ask for help with something bigger, like “can you help me
practice for my next interview?” or “can you introduce me to someone in your area who’s hiring?”
Be patient and let the relationship grow. If you are polite and thank them for their time, you could
end up with a connection that will transform your whole career.
Keep in mind that your mentor is just another developer and they don’t know everything. They
won’t be able to solve all your problems or tell you exactly what to do. But their encouragement and
advice can still make a big difference.
Interviewing
Interviewing is a skill that most people have to learn the hard way. The best way to get better at it
is to practice; apply for a variety of jobs, even jobs you don’t feel qualified for.
Companies vary widely by the way they vet candidates. Be prepared for multiple types of interviews:
• An unstructured interview is one of the most popular but least effective forms of screening.
Any interview where the questions aren’t chosen in advance is unstructured. These often
⁵³http://latinos.slack.com/
⁵⁴http://blacksintechnology.slack.com/
⁵⁵http://womenintechto.com/
⁵⁶https://dev.to
Getting your first job
80
include questions about your work experience, hobbies, problem-solving approach, and career
goals. I recently read a story about a CEO who hired someone on the spot after a brief, casual
conversation, claiming that he could tell more about a person from five minutes face-to-face
than from any amount of structured interviewing. This CEO was wrong. Multiple⁵⁷ studies⁵⁸
have⁵⁹ found⁶⁰ that selecting candidates using unstructured interviews is worse than choosing
them at random.
• A take-home project is a technical assignment candidates are expected to complete on their
own time, like creating a simple website or adding features to an example app. This usually
takes four to five hours. Be aware that some companies use this as a dishonest way to get free
work; if you’re being asked to spend an unreasonable amount of time, or to do work that an
employee would do, ask them to pay you for your time.
• A verbal technical interview is a structured interview including several questions about
programming languages, technologies, software architecture, and problem-solving. Many
companies make the mistake of asking questions that could easily be Googled on the job. You
can prepare for these using a Google query such as “JavaScript interview questions”.
• A whiteboard interview involves asking candidates to write code on a whiteboard without
consulting reference books or the internet. Whiteboarding is quickly falling out of style because
writing code on a board and writing code on the job are very different skills. If you are asked
to whiteboard, focus more on finding a solution than writing perfect code. Even pseudocode
(see Appendix A) is usually fine.
• A live coding interview is an interview where candidates are asked to write code while the
interviewer watches, either in person or on a screen-sharing call. Being watched while you
code can be nerve-wracking, but it’s also something you can easily practice with a friend.
• A short-term contract is like a “trial period” for employment. Candidates sign a limited contract
(usually for less than a month) during which they work like a regular employee and are paid by
the hour. When the contract is complete, the candidate may be hired as a full-time employee.
In every contact with a company, remember that it’s not about why you need them—it’s about why
they need you. Figure out what kinds of problems you’re good at solving, then communicate that to
them clearly and confidently.
Be sure not to let your interviews be one-sided. Take the opportunity to ask serious questions about
the company. Some of my favorite things to ask in an interview are:
• “What keeps you at this company when there are so many other opportunities for a software
developer like yourself?”
• “How much overtime have you worked in the last year?”
• “How hard is it to buy an educational book on company money?”
⁵⁷http://journal.sjdm.org/12/121130a/jdm121130a.pdf
⁵⁸https://blogg.hrsverige.nu/wp-content/uploads/2010/04/Stubborn1.pdf
⁵⁹https://www.nytimes.com/2017/04/08/opinion/sunday/the-utter-uselessness-of-job-interviews.html
⁶⁰https://hbr.org/2016/04/how-to-take-the-bias-out-of-interviews
Getting your first job
81
Depending on the culture and circumstances where you live, you may also want to ask about
company ethics, paid time off, parental leave, retirement savings plans, tuition reimbursement, or
anything else that’s important to you (for a longer list of values that might fit the bill, check out
keyvalues.com⁶¹). This is stuff you don’t want to be surprised by later on.
Keep in mind that some interview questions are illegal in many parts of the world. For example, in
the United States, an interviewer cannot ask certain questions⁶² about your marital or family status,
sexual identity, disabilities, or religion, among other things.
It’s worth checking the company’s reviews on Glassdoor before the interview to look for red flags—
every company will have a few negative reviews by former employees who had a bad experience
or got fired, but if a lot of reviews talk about similar issues, that may be something to keep in mind
or even ask about in your interview.
Negotiating
Getting your first job offer is exciting, but the process isn’t over yet. Negotiation is an important
opportunity to learn more about your value, the company’s benefits, and what’s important to them.
There are five basic rules of negotiation:
1. Always negotiate. Every offer is negotiable, but most candidates are too nervous to stand up
for themselves. Even if negotiating makes you anxious (like it does for me), the value is hard
to ignore—an hour or so of negotiation can get you tens of thousands of dollars more. Some
unfunded companies and nonprofits aren’t willing to budge on salary; all the same, bringing
it up will give you leverage to ask for other things you care about, like flexible hours, remote
work options, vacation time, sick leave, parental leave, or stock options. And almost nobody
will fault you for asking, even if they have to say no.
2. Don’t tell them how much you currently make. This makes it too easy for them to offer you
just a little bit more, instead of what they really think you’re worth. If they ask, say “out of
respect to my current employer and their policies, I can’t share that information.” Some places
(like California, USA) even have laws prohibiting employers from asking.
3. Take your time. Don’t let anyone rush you. If you start running out of steam in a negotiation,
or just aren’t getting the offer you want, say “that’s a generous offer and I appreciate it, but
I’m sure you understand this is a big decision and I need some time to think it over. I really
hope we can figure out an offer that makes sense to both of us.”
4. If they give you a salary number, say “that offer is interesting; can you do better?” (borrowed
from Patrick McKenzie⁶³). Really, that’s all you have to say. Then quietly wait for them to
respond. Count to 100 in your head if the silence grows uncomfortable.
5. If they ask you for a salary number, tell them the highest number you can say without laughing
(borrowed from Cindy Gallop⁶⁴). They may not meet that number, but they’ll probably offer
⁶¹https://www.keyvalues.com/
⁶²https://www.betterteam.com/illegal-interview-questions
⁶³https://twitter.com/patio11/status/1046569259743100928
⁶⁴https://www.bustle.com/articles/129373-how-to-get-a-raise-no-matter-what-according-to-businesswoman-cindy-gallop
Getting your first job
82
you more than they would have otherwise—whether it be in salary, job title, flexibility, or other
benefits. It helps if you’ve done some research already so you know what’s reasonable for your
job title and where you live—but whatever the salary range is, aim for the high end.
Negotiation is an uncomfortable and sometimes long process, but it can teach you a lot about the
company you’re applying to work with. And it can put you years ahead on salary increases and
career progression.
Growing and succeeding
It may take you a while to get your first job offer, and that’s okay. It doesn’t mean you’re a bad
candidate. It doesn’t mean you’re in the wrong profession. Keep trying, keep interviewing, keep
building your network. Good opportunities are out there.
My first job
Muhammad Arslan Aslam
My first job was at a small tech firm as a Junior Front End Developer. The salary was low, but I was
desperately needy and eager to get into the industry, learn, and work. I didn’t care about anything
in the contract. They asked me when I could join, and I went straight to the office the very next day.
I learned a lot there about many things. Design. User experience. Development. WordPress. It was
a good journey for a couple of months until they started asking me to stay late. I knew that on rare
occasions, if a project was past the deadline or close to it, putting in some extra hours to complete
it wasn’t gonna hurt. But an extra 5-6 unpaid hours per day? That was a lot to ask for, considering
I wasn’t even getting paid as much as the average intern.
I left the company after one year and they never paid me my last month’s salary.
A month later I got another job offer. This time I asked about company policies regarding overtime,
medical expenses, staying late, etc.
It worked very well for a few months but then it was the same story all over again. The manager
would force me to stay late and would even say he wasn’t going to let me leave until I was finished.
I’d get late night calls to get up and do something because the person who was responsible for it
wasn’t picking up the call. I would work from midnight until 8AM and couldn’t be late for work
afterward.
I actually blogged about it when I was getting frustrated with the situation and got a lot of feedback
from the community, including senior developers, which helped me a lot. Right after I published
that post and heard people’s advice, I decided to quit the job. I stood up for myself and told my
manager that putting in so many extra hours was affecting my personal life and I had started to get
depressed.
It felt like a prison (not that I’ve been to prison, but still). You know how you can sit in your room
watching Netflix all day and it doesn’t bother you, but if someone orders you to sit in your room
and watch Netflix all day, it becomes an awful chore.
I was worried at first about leaving the job. I was getting good money and the medical insurance
was a good thing (more or less) but I gained the courage to leave the job and move on.
There are a lot of things that happened as a beginner that I feel a little ashamed to share. I should’ve
stood up for myself right then but I didn’t. I thought I might not get another job. But fortunately for
me, everything worked out.
I have a stable job now which pays me well. The hours are flexible and the work environment
is great. Learning opportunities are abundant plus I get to work with people who are much more
experienced than I am and everyone here is eager to teach.
My first job
84
To summarize a few things that I learned from all of these experiences:
• When signing a contract at your first job (or any job as matter of fact), read it carefully. Ask
about the company’s policies regarding different aspects of normal everyday work. The ideal
would be if you could get some legal advice on it. If that’s not possible, just ask someone who
has been through the same process, a friend or family member. Be careful about what you sign.
• Stand up for yourself when there’s an issue. If you “let it pass this one time,” it’s gonna stick
forever. I ignored my boss being abusive once and he continued being abusive for the rest of
my time there. Don’t let that happen to you.
• In the tech industry, occasionally putting in extra hours to meet deadlines isn’t necessarily a
big deal. People do it a lot, some times more than others. But make sure it’s not because of
someone’s ego. I was asked to stay late because my boss “just felt like it”. That’s over the line.
Never settle for this kind of behavior.
• Know your rights. Workplace toxicity can affect your personal life and mental health. Unfor-
tunately, in many Asian countries, management doesn’t pay much attention to this serious
issue. If you’re not feeling well, you can’t work properly. Workplace toxicity comes in many
different forms. If you feel like you are suffering harassment from a co-worker, a manager or
anyone else, contact the people in charge. If they don’t do anything about it, reach out to other
organizations or the authorities. Someone else at your company might be facing the same issue.
Stand up for yourself and others too.
• Last but not least, know your worth, and never settle for less.
I got my dream job. Now what?
Desi Rottman
When I started my first job in tech, it was as a support team member at a website builder geared
toward musicians. My background made me ideal: years of retail and entertainment-industry
customer service, HTML and CSS experience with an interest in web design, a music business degree,
and the vocabulary to communicate with low-level tech users. I was pumped—a dream job that
felt created just for me. I’d never considered that there was a company out there that married my
disparate passions, let alone that I could land a job there.
In that position, I was doing a lot of intense troubleshooting for both clients and co-workers while
getting comfortable with how the tech industry works and how companies are structured. It was a
company with a QA department of one, and though I fell in love with troubleshooting and breaking
things, we already had a great employee in that position. I didn’t see myself having the opportunity
to transition over. A small, awesome company means low turnover, so I didn’t really give much
thought to if there would be additional positions on the QA team to transition to eventually. But
when our new CEO did some restructuring, she promoted the old QA guy to Project Manager, and
behold—I had the opportunity to train for my (new) dream job!
Over the course of a career, your dream job can change and shift—and that’s a good thing. As you
work you’ll learn more about the industry you’re in and see more facets of it, discovering positions
you never knew existed. In tech and dev, things are always changing. There’s always something
new to learn or a new startup being founded. That’s another reason you might have to continually
revisit and redefine your “dream job”: new positions and new fields are often being created, so your
eventual dream job might not even exist today, though your dream company might.
Advancing in your career also opens more opportunities—and once you start to stagnate, even the
perfect job can stop feeling perfect. That’s a good thing, but it can feel confusing to know how
to keep growing and keep going. After all, wasn’t this your ideal position? When this happens in
technology, we have a unique opportunity to shape and design our dream jobs.
Even if you’re not in a place to consider a transition right now, it’s beneficial to look around and
see what types of positions are open from time to time. Being aware of what else is out there and
interests you is important to keep in mind. Being able to clearly recognize the next great fit when
you see it can help stave off self-doubt, while staying prepared to apply when opportunities arise
can combat impostor syndrome.
What else is out there?
A great way to start considering what your new “dream job” might be is to review open positions
even before you’re ready to leave your company or position. Not only does this give you an idea of
I got my dream job. Now what?
86
what new skills or education you can focus on, it can also put new jobs, industries or technologies
on your radar. Specialties like Developer Relations and industries like the Internet of Things might
not have even been on the map when you started your tech career. As these categories get more
popular and more positions are being created, keeping abreast of what companies are looking for
lets you tailor your experience to a new, growing industry.
Case Study: Accessibility Expert
The web has long been developed with mainly able-bodied users in mind. In recent years,
accessible development and design have become hot topics and very important for many
companies, but as a relatively new priority, many experienced developers weren’t focused
on it in the past. Lindsey Kopacz of Acquia Professional Services is an Accessibility Expert,
and she also teaches others how to make their products more accessible.
Feeling unsure of where to start looking for other things that would interest you? Take a look around
at your co-workers. Is your project manager always asking the other dev team members interesting
questions about their projects? Is the support team consistently bringing up the same pain point
about accessibility? If those kinds of things interest you, keep your eye on them. See if there’s an
issue you can help the support team fix, or a project you can shadow the PM on. Not only will that
open your eyes to another facet of your company’s work, it could be something to add to your new
dream job resume.
Case Study: UX Engineering
UX Engineering is a relatively new position that many companies are hiring for. It
blends principles of UX/UI design with front-end development, and can really appeal to
developers who have a bent toward user experience. Emma Wedekind of LogMeIn blends
her past experience in engineering at IBM with her interest in design (which she exhibits
in her open source project, Coding Coach) to build accessible design systems and user
interfaces.
How to start preparing
Starting where you are is a good place to prepare. Look at your current company again, and take a
look at what your co-workers’ backgrounds are. See if anyone in an interesting position is willing
to meet with you for coffee, or even an informational interview. Connecting with someone who is
already doing what might be your next dream job will help you learn the real nitty-gritty of their
position. It’s also likely to help your confidence—it’s a fairly low-stakes networking opportunity
with someone you already share some commonalities with, and that can end up being a boost when
you do start going to interviews again.
Social media sites, particularly places like Twitter and StackOverflow, are also excellent places to
learn about emerging tech, connect with others in the space, and even find open positions. The same
principle applies here—if you see someone doing work that interests you, try to send them a DM
and ask some questions about what they do and how they got there.
I got my dream job. Now what?
87
Keep your resume and portfolio up to date as you continue to learn and grow your skills, putting
most of the focus on the tasks you hope to primarily work on in your next dream job. You’ll thank
yourself for this later when you don’t have to try to throw something together at the last minute
when the dream job gets posted.
As you continue to build your skills and learn more about technologies or areas you’re drawn to,
taking on a side project or signing up for a class to further your knowledge in that specialty will also
help you get that much closer to the new dream job. If you’re not sure what new skills to build, start
looking at job descriptions for other positions that interest you. You’ll get an idea of what employers
are looking for in hires for that position, and you’ll have some great experience and project examples
to add to your portfolio!
Case Study: User Experience Advocate
I always knew that advocating for users and keeping our product looking and working
well, while providing them the features they’re looking for, was where my passion was.
What I didn’t realize was that this is an actual position that many companies are looking
for! By doing research into what other types of opportunities are out there, it’s allowing
me to tailor my skills and experience so that when I am ready to leave (or get promoted),
I’ll be confident and ready.
More things to consider
As you start to think about what kind of work you might be interested in next, you’ll likely start
noticing some trends in the job postings. When you see another description that makes your heart
soar, take a look at a few things:
• Job Title: Job titles may not say much about the actual position duties, especially in tech—
“Rockstar Ninja” or “Smile Engineer” doesn’t say very much about the day-to-day. Focus on
the responsibilities listed rather than the hip titles.
• Education Requirements: Do they require a computer science degree, or a master’s degree? Do
they consider experience as an equivalent? If they do have a hard requirement for a degree,
and it’s not one you already have, consider if you’re willing to get that degree or endorsement.
(And if they aren’t interested in applicants with diverse experience and education, that may
be a red flag in itself.) Get in touch with someone who is already in that position and see if
that’s truly required for the kind of work you want, or if they use it as a screening funnel for
applicants. Furthering education is understood as a requirement for advancement these days,
and this can help you know where to focus to be ready for the next position.
Maybe the next move in your ideal career is less about the kind of work you’re doing, and more
about where you’re doing it. It’s becoming more and more common for “employment goals” to refer
to a company rather than a specific position, and that could be something else to consider if you’re
looking to move on from that first dream job.
I got my dream job. Now what?
88
• Lifestyle: Another big consideration in sussing out your next dream job is the intangible quality-
of-life factor. Maybe you’ve enjoyed being a full stack developer, but you’re feeling maxed out
on your career growth and want to make a transition to system administration. Is it worth
making a nice six-figure salary if you’re required to be on-call 24/7 to fix any issues? Are you
willing to sacrifice a big-city salary in order to have a remote position? These are more ethereal
issues that aren’t going to be nicely laid out in a job posting, so being prepared to know what
you will or won’t accept from a company can well prepare you.
One last (but no less important) facet to consider here is the culture of a prospective new company.
Similar to the lifestyle you’ll have, think about what’s important to you at work—a kitted-out game
room with arcade games and ping pong tables, with weekly happy hours in the break room, but
the understanding that you work closer to 50 hours a week? Or would you rather have less fancy
“perks,” but more flexibility and freedom? Do the employees seem to relish being there beyond
9-5 hours? In an effort to promote diversity and reduce harassment or abuse, codes of conduct are
growing in popularity. Does this company have one that reinforces the culture you want to associate
with? Another common “perk” for companies is providing philanthropic opportunities—paid days
off for volunteering, or matching employee donations to nonprofits. If possible, try connecting with
someone at the company you’re interested in to get some of your questions about these things
answered.
Does that company culture align with your values? If not, maybe it’s not actually your dream
company. If the company’s ethics don’t align with your own, you might not be taking pride in
your work, which can take a toll mentally.
Keeping these things in mind is important for any job change in your career, but it can also help you
really develop your dream job description.
Exercise
To start evaluating your next move, even if it feels far off, try to take a look every week or two at
open positions at your dream company. If you see one that particularly interests you, save it to your
computer. Highlight or circle aspects of the job that interest you, and you can update your resume
or portfolio using the same wording.
This also helps you to know what parts of the job you wouldn’t be interested in—your “dream job”
likely has parts that feel very dry to you, and that’s important to keep in mind as you continue
searching as well.
Keeping up to date and being educated on other current openings and industry growth will make
you confident that you’ll know when your new dream job pops up, and be ready to land it!
Burnout, part 1
James Turner
Editor’s Note: Burnout is so pervasive and harmful in tech that I’ve chosen to include two perspectives
on it. Programmers burn out for a lot of different reasons and you will either witness it or experience
it yourself at some point. When that happens, take some advice from these authors and make a
change.
You may have heard the phrase “burnout” before. I can assure you that in this context it has nothing
to do with cars laying down rubber.
Occupational burnout is a feeling of exhaustion, where what you previously enjoyed working on
becomes less enjoyable, where things get on your nerves more easily or even where you have feelings
of depression. One of the first uses of the phrase dates back as far back as 1974 when psychologist
Herbert Freudenberger used the term in one of his published works.
At the end of 2014, I had the opportunity to take on more responsibilities where I worked, being
promoted from a Web Developer to an Account Manager. While I was still programming, my new
responsibilities included liaising with clients, discussing business requirements as well as managing
current and upcoming projects. It was a great experience and I am grateful to have had that
opportunity, but it wasn’t without its problems.
I may not have been the “cool” or “fun” person in the office, but I’d say I was the “brains trust”—there
wasn’t a problem I wouldn’t try to help solve and most of the time I was successful. I may not have
even known anything about the topic beforehand but if someone asked me a question, I would as
quickly as possible research the topic to work out the answer. This eagerness to help my colleagues,
while an admirable trait, was one part of my problem. It took time to be thorough and I didn’t want
my colleagues to struggle on something that I could help them with.
I didn’t just want to avoid disappointing my colleagues, I didn’t want to disappoint my boss—I had
been given this great opportunity and trusted to do it well. I am a good programmer, and one day I’d
like to think I’ll be a good boss, but some of the traits that make me a good developer didn’t transfer
as well to this role as I hoped. Larger projects were coming in on top of the business-as-usual work
which led to work piling up. I was in meetings every other day, constantly liaising with clients and
managing projects while also still programming. Rather than tell anyone that I was struggling, I
decided I’d just work a few extra hours that week to make sure everything was done. Those few
extra hours in a week turned into a few extra hours each day till it even got as bad as working an
additional day on top of those extra hours.
While no one asked me to do those extra hours and I didn’t even want to do them, I still did them
because I believed it was just a short-term thing that would blow over soon. I was tired, I was
stressed, and every morning I didn’t even want to go to work yet the problems that led me here
were so simple.
Burnout, part 1
90
In mid-2015 the stress peaked and my colleagues were starting to take notice. Two of my colleagues
took me out to lunch to see how I was doing. They asked me if I was okay, knowing something was
going on, and I said no, I wanted to quit. I talked through what was happening with them, they
understood the issues and were sympathetic. They gave suggestions on how to make my workload
easier, helping me with anything I needed. Over the next few months, things were a little easier and
I stopped pushing myself as hard to please everyone.
It took just over 6 months to go from an employee happy to come to work to one who dreaded it
because I couldn’t stand the thought of disappointing others. It took a single lunch out for me to
admit how far I had gone and start the journey back to a happier me.
Identifying burnout from the point of view of the person experiencing it is hard—how do you know
if the stress you’re feeling about a situation is burnout or not? Burnout, however, isn’t black and
white; it is many shades of grey. Burnout may reach a tipping point but that is not a useful measure
to help prevent burnout in the future. With how the feelings of burnout can gradually build up, you
need to look at your own long-term trends in your life. From your mood, to sleep patterns, to diet,
to participation in social gatherings—these can all help indicate whether something is changing in
your life.
One of the more obvious indicators for me should have been realising that I didn’t want to go to
work when I woke up in the morning. While this feeling might happen for a lot of different reasons,
it is an indication that something is up in your life and it is best to evaluate what that might be.
Determining the cause for such feelings is incredibly important in trying to address them. When
trying to identify the cause, it is best to keep an open-minded approach as it really can be from
things you didn’t even realise. The causes that lead to burnout don’t even need to be exclusive to
your job, they can be events in your personal life or social circles.
The causes leading to my burnout came from my actions at my job, not from my personal life and
not from expectations by my colleagues or boss. I chose to accept the opportunity to take on more
responsibilities and I chose to work extra hard to make sure I would succeed. This may seem like I
am trying to carry the burden for the situation, but I don’t blame myself for burning out. Instead, I
take responsibility for the fact that my own actions allowed stress to build up.
Although I can say that about my situation, it doesn’t necessarily mean that your feelings of burnout
are caused by you. You may not be remotely the cause of the feelings; you are only responsible for
how you handle those feelings and what you are going to do about them.
The most appropriate action for handling burnout will vary widely depending on the cause. With
that being said, the one thing you can always do to help your state of mind is to talk to someone
about the situation. It may be best that this person is not involved in what you believe are the causes,
but the key here is that you are talking about it at all. The reason I see this being effective is the
same reason Rubber Duck Debugging (see Appendix A, “Rubber Ducking”) is effective: when you
talk through a problem aloud it can help you have a deeper understanding of it, leading to ways to
resolve it.
When you are on the path to resolving your feelings of burnout, I think it is important to consider
what you want your future self to be. Of course you want to be happy and healthy but is it at the
Burnout, part 1
91
same job? Are you wanting to stay in this industry? Do you see yourself living in the same location
or having the same friends? These questions might seem dramatic, but dramatic changes might be
what you need. The decisions you make here are wholly your own and it is important to weigh
everything in perspective to your own life.
If your causes are primarily job-related, it might be enough to try and move to a different team or
department. For situations where you see no resolution at your workplace, speaking with your feet
and finding a different job is the most powerful action. If your causes are primarily social life related,
work out what specific things you could do to have a positive impact. Maybe at the end of the day,
you may only need a break to do something else—only you will know if that is what is best for you.
When you have resolved your current feelings of burnout, it is important to stay vigilant as they
can always creep back. Look after yourself; you only live once.
What if you’re not the person experiencing burnout, but you want to make sure anyone you know
or work with isn’t having issues? While you can potentially identify it through a decrease in work
performance or long-term changes in mood, it can be as simple as asking if they are okay. I wouldn’t
recommend doing it over a Slack message or in front of a group of people but if you can have a one-
on-one conversation with them, don’t hesitate to ask. Asking someone that question may be exactly
what they are needing to hear, genuine support from a friend or colleague so they can evaluate
themselves and their situation.
At the end of the day, while burnout can be a serious topic, it isn’t an impossible problem to resolve
and isn’t something you need to handle alone.
Burnout, part 2
John Woodruff
Burnout: a hazard that the software industry is particularly prone to, and one that occurs far more
often than it should. Over the course of your career you’ll hear the stories of your co-worker’s friend
who burned out so badly they ended up changing careers. Perhaps it is closer to home and happens
to someone you personally know. We all tell ourselves that it won’t happen to us, that we love
programming far too much to burn out, so we don’t take the necessary steps to avoid it. But burnout
is a very real threat, and it will happen to some extent to many of us. I didn’t believe it could affect
me, yet I have dealt with episodes of burnout throughout my career. By understanding burnout, its
symptoms and causes, we can take concrete steps to avoid it altogether and to come back from being
burned out.
Burnout is a slow process. You don’t just wake up one day and suddenly you’re burned out. For me
it was a state that set in gradually, with the symptoms becoming worse over time. At the beginning,
they may be insignificant enough that you barely notice anything is amiss, which makes it difficult
to determine that you’re on the path to burning out. There are a variety of symptoms that may
manifest themselves. Please note that this is by no means an exhaustive list, these are simply some
of the most common issues related to burnout.
You may feel anxiety, often about your job, usually carrying over into your personal life. It’s also
common to experience depression, especially if you are already prone to it, but someone who has
never felt depressed before can experience it as a symptom of burnout. One of the most common
symptoms is a lack of attention span and motivation at your place of work. It becomes very difficult
to focus on tasks, in meetings, and during general workplace activities. You may feel constantly
exhausted, both at work and at home, whether or not you’ve gotten enough sleep. It can affect your
sleep too, possibly manifesting itself in new or worsening insomnia. You may find yourself becoming
more irritable or pessimistic in your interactions with friends and co-workers. You could experience
guilt for not feeling like you used to in your job, or like you perceive your co-workers feel.
All of this and more leads to the most common symptom: poor job performance. You are no longer
motivated to do your work. Tasks that once would have seemed small to you suddenly appear
enormous or insurmountable. You may find yourself coming in late, taking extra long breaks, or
leaving early because you feel like you can’t handle it. You aren’t paying attention or participating
in meetings where your input is wanted or required, which affects everyone involved. Unchecked
burnout can even lead to the need to stop programming altogether and change careers. Sadly, it’s
happened to many people before and it will continue to happen unless we as developers take the
proper steps to recover from and avoid burnout.
To understand how to avoid burnout, we need to first understand the common causes. There are
many reasons and ways one might get burned out. The most common ways are usually directly
Burnout, part 2
93
related to long term stress without relief. This could include any number of scenarios, including
working long hours for too long without a vacation; constantly working on projects that have
unrealistic deadlines set by others without your input; being stuck on project maintenance while
you watch other developers working with cool new tools and technologies; having an unhealthy
work-life balance that is skewed too far towards work; or working in a dysfunctional environment
that makes you feel unsafe. All of these contribute directly to your level of burnout.
I’ve experienced many of those scenarios, and unless you’re exceptionally lucky, you will too
throughout your career. My most recent episode of burnout was due to being on a project for two
years with no end in sight—a project I desperately wanted to succeed, but which seemingly had
everything thrown in its way to stop it from doing so. The stresses of that environment grew and
grew until I found myself dreading going to work. I couldn’t fall asleep at night for hours thinking
about this project. I no longer wanted to work on the previously enjoyable side projects I’d had
going on. In addition to that, the project was frequently put on hold for another project that had an
extremely short deadline imposed by others that I had no control over. So instead of finishing the
new project and being relieved to go back to my old project, it was simply more stress. It was a very
difficult time in my career.
The above situation boils down to several basic feelings you might relate to. You feel stuck or trapped
with no end in sight. You are dealing with impossible goals which makes you more depressed each
time you miss them. You’ve overworked yourself. When the mind has endured high levels of stress for
too long, it becomes exhausted and craves relief. This exhaustion is central to many of the symptoms
I listed previously, such as anxiety, depression, and lack of focus. If you let any of this get too far
without intervention, you risk burning yourself completely out of your career.
With all that in mind, let’s talk about avoiding burnout. If you’re currently suffering from burnout,
these principles apply to recovering from burnout as much as to avoiding it. In short, it’s about
taking control of your professional (and personal) life, which will help you to be a well-balanced
individual. Having proper balance in our lives leads to better mental and physical health, improved
mood and happiness, and increased productivity, whether that be at work or in other pursuits.
The first thing you need to do is make sure you set proper boundaries. You’re in a form of a
relationship with your work and employer, and as with any other type of relationship, good
boundaries exist to keep the relationship healthy and happy. While looking for a job, you should
know the limits of what you’re able and willing to do for the company. An employer may have the
expectation that you work 12 hour days, 6 days a week (rather than a standard 40 hour week) to
further the goals of the company. They may think you should forego using your vacation time to put
in more hours at work. While there may be people who are okay with that kind of an environment,
I see it as a form of abusive relationship between employer and employee. With the companies I’ve
worked for thus far, I’ve been very careful to research their culture and determine whether I would
be required to do things that are unreasonable and go past my established boundaries. This is not
to say, of course, that I refuse to work a minute past 40 hours. There have been many occasions
where I’ve worked long hours to meet a deadline, fix an issue, or help mentor someone else. In these
situations, however, I was usually able to recover adequately by (for example) taking a day off the
next week.
Burnout, part 2
94
The ability to take time off is key to avoiding burnout. Time off, even if that’s simply making sure
you don’t work on the weekend, is time our mind needs to be able to recover from the stresses of
the workplace. By working constantly with little to no breaks, that mental stress continues to build
without relief, slowly burning you out. It’s a common false belief that by working that much, you’ll
become a better programmer. I held that belief at the beginning of my career and have since changed
my attitude. In the long run, becoming burned out will severely harm, if not destroy, your ability
to work effectively. Taking a vacation where you completely disconnect from work (and coding in
particular) can be incredibly therapeutic for programmers who may be slowly burning out. Even
doing this during the weekends can help stave off the struggles that are associated with burnout,
so make sure to take the time for yourself to unplug and rejuvenate. Also take advantage of your
employer-provided vacation days; they’re given specifically as a benefit for you to use to recharge.
There are many other small things I recommend for helping to keep your work-life balance in check.
Engaging in non-work related hobbies and activities, for example, is a great way to keep your
personal life separate from your work life. Keeping your body healthy through regular exercise
is also important and helps keep your mind stimulated. Perhaps the most helpful thing to do is to be
consistent. Inconsistency causes stress, and if there’s anything we’ve learned thus far, it’s to reduce
the amount of stress we feel on a regular basis.
Occasionally more drastic measures are necessary. While most of my small burnout episodes were
solved by taking a couple days or a week off from work and totally disconnecting to rejuvenate,
the most recent episode I talked about required a different approach when my standard methods
had failed. It wasn’t so bad that I quit coding, but it was bad enough that I was no longer in an
environment conducive to a good career. I needed to find a new job and get out of that situation so I
could bring myself back. I’m very happy to report that at the time of writing I’m happily employed
at a new company working on a product that is much more stable and healthy than what I was on
previously. I also am part of an excellent team that highly values work-life balance and shows it
by example. I’ve never been happier in my career than I am right now, mere months after dreading
going in to work.
Burnout is a difficult trial to overcome, but if I can tell you anything, it’s that it can be recovered
from successfully. I can say that from experience, having felt varying levels of burnout at various
times throughout my career. Even better than recovering from burnout is avoiding it entirely,
something I’ve re-committed myself to more fully in recent months. By putting into practice the
recommendations mentioned above and taking control of our professional lives, we can make real
strides towards keeping our personal and work life in balance, and keeping burnout at bay.
Do I fit in?
Editor’s Note: Following are some true stories and advice from developers who have wondered if tech
is the right place for them. If you’ve had the same doubts, I hope their words will encourage you.
Sabrina’s story
Sabrina Gannon
Despite coming from what’s generally considered a traditional computer science background, “Do I
fit in?” is a question I’ve had to tackle many times in my programming career. The first time I asked
myself this question was when I was applying to university for Computer Science, because math
was the subject I performed lowest in and English was my highest. The most exposure I had to code
came in the form of customizing my Neopets HTML pages; it was just enough to make me curious
enough to take the leap and apply anyway.
I thought a University degree would give me a feeling of legitimacy that would put the nagging
question “Do I fit in?” to a stop. Instead, the work I did at a very research-focused University,
alongside many classmates who had far more coding experience than I did, exacerbated the feeling
to the point that I doubted I would even finish my degree, let alone have a sunny employment
outlook.
My first technical full-time role came in the form of an internship the summer after I’d finished
my degree; this was the next level of questioning my own sense of belonging and identity. I had
moved out of my family’s home and across the country, and I was surrounded by smart people and
learning about web development, a development specialization I had little to no experience in. It was
a whirlwind, and I spent far too much time convinced that my presence there was happenstance.
At the end of that internship, a full time job offer came through. My four month interview had
paid off, and what felt surreal became that much more so. This is a moment I come back to often
on the more difficult “Do I fit in?” days, because that was one day that I can look to as a source
of validation. I definitely recommend collecting these moments to remind yourself when the little
voice suggesting you don’t belong speaks up, because there will always be moments when it does
and being prepared to tell it off never hurts.
Being a woman does not help with managing this feeling; being reminded how rare you are because
of your gender in a group project does nothing positive for feelings of imposter syndrome. Nor
does the implication that you might get hired to inflate a company’s diversity numbers and be a
spokesperson for them. These were all said to me casually, as if they were stating the sky is blue,
which made them that much easier to internalize.
There will be jerks, and worse, there will be jerks who aren’t even self-aware enough to be called
jerks.
Do I fit in?
96
But in all these steps, I met good people too. People who encouraged me to take a chance on myself
when I otherwise would have backed down, people who listened to me unpack the self doubt and
negative thoughts that I’d internalized along the way. Without them, I wouldn’t have had the
opportunity to take the next step. I’ve been very fortunate to know them, and now am very fortunate
to be able to be this person for others as well.
Here’s what I’ve learned time and time again when I’m faced with the question “Do I fit in?”:
• A lot of what made me feel excluded was rooted in technical jargon I didn’t know and the fact
that everyone using it seemed so much smarter than me.
• Tech is a huge, vast field—no one knows everything, and adaptability is key. Taking the time
to figure out how I learn best and continually invest in that development has helped me offset
my experiences with imposter syndrome immensely.
• Be patient with yourself!
• Take note of and celebrate little wins and steps forward.
• Keep an ear to the ground on what’s going on in the industry, the types of conversations being
had. I find Twitter useful for this.
• There are jerks, but there are also good people out there. Don’t be afraid of seeking them out;
whether through local meetups or online communities, growing your support network really
helps you foster a sense of belonging for yourself and others.
• If you are coming from a non traditional background, that is an asset; don’t let anyone convince
you otherwise. Many of the skills that make me most effective at working with others and
communicating with stakeholders were gained working part-time jobs while I was in school.
My own answer to the question “Do I fit in?” is always shifting. I’ve found the more that you work
and engage with others to make a given environment a little warmer and more welcoming, the
more you’ll find yourself a place to fit into that process, and while tech might have a few characters
who seem resistant to this, every day there are more and more people like you—people who have
wondered if they fit in—writing their first line of code.
My software developer journey
Clifford Fajardo
At the beginning of 2016, I had just graduated from a coding boot camp, finished a long job search
and was starting my career as a software developer at Salesforce in San Francisco. I was excited
about the journey ahead and equally very nervous.
I felt as if I had stepped into a whole new world! I was starting my first full-time job; I was now
working in a corporate environment; I was working on a fully remote team; I was worried that I
didn’t fit the typical software developer profile and was concerned about how I would perform on
the job.
Do I fit in?
97
This new world I had stepped into felt like a long shot from where I had come from. Before this job,
I had been a student at community college and the only work experience I had at the time was as a
student tour guide and pizza chef.
It was still hard for me to believe that I, a kid from a first generation immigrant family from
Nicaragua who had been living on the poverty line for most of his life, was now the first person
in his family to work in a corporate environment and the first to become a software developer.
As I transitioned into that role, it felt like I was on a roller coaster ride. There were lots of great high
moments and low moments. I would have work days where I would create something or fix a bug
and feel complete joy. There were other days where I questioned if this was the right career for me
because of how challenging it felt or how long it was taking me to complete my work, relative to
my peers.
There was even a point during my first year as a developer when I seriously questioned whether I
fit in and belonged in this industry. I almost decided to go back to my old, easier but less fulfilling
life, which for me meant not confronting my fears head on and growing from them.
When I had these types of days what helped me push through were the thoughts of my family
and the vision I had when I first started to learn to code. The vision that one day I would become
knowledgeable enough to build out any idea I could envision and impact the lives of millions of
people.
Looking back, I’m so happy I didn’t give in to my fears. If I had, I wouldn’t have had the opportunity
to later work at LinkedIn, my second job, where I worked on apps impacting over half a billion people.
I would have missed out on the opportunity to gain the experience, knowledge, and confidence that
I needed to eventually venture out and start working full time on the business and app I work on
today.
Everyone is different, own your individuality
In retrospect, most of the low experiences and feelings I had about not belonging came from not
appropriately managing my own expectations, my lack of experience, oftentimes my impatience,
and being too hard on myself.
During tough times, it was easy to forget the reality of the situation I was in:
• I’m new to this job and industry, so it absolutely takes time to adjust.
• I’m taking longer than all my peers to complete tasks, but that’s normal at any new job or role.
• Just like me, everyone on my team was once new and inexperienced at something.
And equally as easy to forget the things I had control over:
• Though I’m not at the level I want to be at now, I can make a change and take ownership of
my learning and growth. It may require some extra time outside of work, but it’s doable.
• I don’t have to be the same person I was yesterday. I can learn to be a more effective leader,
communicator, and developer. Pushing myself out of my comfort zone little by little every day
will build my character and confidence.
Do I fit in?
98
• I don’t have to travel on my journey alone. I can find a mentor or employee resource group
and accelerate my learning and growth with the help of others.
Once I started realizing all of these things, all areas of my life quickly and dramatically improved.
I no longer spent time thinking about whether or not I fit in, regardless of where I was. I finally
internalized that I could carve out my own unique place, co-exist with everyone around me, and
bring a different perspective to the table.
Own your unique experiences. Own your individuality and be open-minded. Be ready to learn,
unlearn and relearn. Lastly, don’t be too hard on yourself.
LGBT
Casey Ocampo
Do you identify as an LGBT person? Are you in the process of applying for jobs? Are you concerned
with how you might fit in and want some tips on how to best go about including this information
in your application? If yes, then this section is for you.
There are many reasons why someone may want to include these personal details in their application,
the most important one being to avoid employment with a company that discriminates. The fact is,
discrimination among all kinds of minority groups is still a very real occurrence. Because of this, it’s
important to safeguard yourself against any potential threat that may happen, be it physical, mental
or emotional.
Everyone wants to work for a company where they are accepted and can work comfortably. The
good news is, there are steps we can take to ensure this outcome.
In this section, I’ll outline what I did to communicate my gender identity and other possible ways
to go about including this information. I’ll share with you how I went about arranging my portfolio
to “wave the flag” and express my gender identity.
What I did to be visible
The first question I asked myself was, “how can I go about this while staying relevant to the
application?” There were a couple steps I took to achieve this.
The first was to include one of my trans-related side projects in my portfolio—it was an online
transgender and allied apparel company. In 2016, I found myself with a unique opportunity to create
something, launch it, and see how the market responded. It was a success, I learned a lot, and I figured
it was as good a project (and as relevant) as any to showcase in my portfolio.
This checked off two relevance requirements, one being that it was something I created, and two, it
dealt with supporting transgender folks.
Do I fit in?
99
Now, I can’t tell you how every recruiter felt about this information, but I can tell you that the
subject of starting a company itself was a strong and positive talking point. And while I did worry
that being so visible might hurt my job prospects, I reasoned with it by telling myself if they didn’t
accept it, then I’m better off not being in that environment.
If someone reading this was worried about “waving the flag”, I’d tell them the same thing. Be strong
in your conviction to be yourself. Be unapologetic about it! Anywhere with anyone that stands to
discriminate against you isn’t a place you want to be. And on a positive note, anywhere with anyone
that stands to accept you and welcome you as you are is exactly the place you want to be!
Leaving more clues
Another approach I took was including personal details in my about/bio section of my portfolio
website. These are more simple and subtle steps you can take to ensure that the company is aware
of your identity.
I’m very transparent in mine, openly addressing my gender identity and my belief that it’s important
for minority groups to be visible. This is a great and appropriate way to be visible!
Visibility over 9000!
If you want to raise your visibility beyond those two methods, leave more digital footprints. Blog
about LGBT topics that matter to you. These could be published on any digital medium, including
your own personal website or on social media in microblog form. Just remember to include links to
your social media profiles in your portfolio website if you choose to be visible on them!
If the hiring manager is thorough with vetting their candidates, these thoughtfully sprinkled-in
details will surely catch their eye. And if they’re a super awesome, diversity-advocating company,
they’ll have all the more reason to welcome you with open arms.
During the initial interview
First, congrats on the interview! You’ve done great so far. Time to keep going!
At this stage in the interview process, the conversation should be fairly laid back with the recruiter’s
focus being to get acquainted with you. In my experience, you’ll find a lot of opportunities to speak
about what you’ve worked on and what you’re proud of so far. The recruiter usually sets the stage
for this.
Ideally, it’d be a good idea to bring up two or three pieces of work with either an LGBT project or
blog being casually looped in the mix. That way, if for whatever reason the recruiter overlooked that
detail in your portfolio, it’d be 100% clear and open now for you to assess how they respond to it.
If they respond negatively, you’ll know. I’ve never had this happen to me. But in case it does, stay
cool, be the bigger person, and exit the conversation. We can flip this unfortunate situation and
think of it as being one step closer to the right fit. The important thing here is to keep moving.
If they respond positively, you’ll know. This has happened 100% of the time for me. In this case,
stay cool (while having an internal celebration) and keep the conversation flowing. You’ll feel great
knowing that you were brave enough to bring it up and you’ll be more comfortable and confident
in the conversation.
Do I fit in?
100
Wrapping it up
The question of “Do I fit it?” can be a tough question to face, especially for individuals in historically
oppressed minority groups. But take solace in knowing that times have changed and are continuing
to change. We’ve come a long way as a society and you have the opportunity to allow it to keep
going just by being open about who you are.
You are a smart, capable, and highly skilled human being deserving of respect. Whether you’re
lesbian, gay, bisexual, or transgender, being visible is important in your journey to fitting in with
the right team.
I hope this section was able to help you in some way.
Best of luck to you, friend!
Women in code
Ilona Codes
Introduction
I got my first PC when I was 11 years old and it became everything to me. I remember that “after
computer” time when the real world didn’t seem as interesting anymore. Like many children, I
started spending hours playing video games, and with an internet connection, I went deeper into
the flow of information and ideas.
As the years went by my interest in computers and computer science only increased. This played the
main role in my career choice and selection of my university major. I was facing a choice between
computer science and medicine. I couldn’t decide what was more interesting to me. And as you’ve
guessed by now, I made the decision to pursue computer science.
Early in my career I remember thinking, “maybe this was a bad decision.” I tried to give up twice in
my first year in the IT industry. There were many reasons and people around me at the time that
made me strongly consider that. And I’m far from the only one who tried to quit the industry.
So, why do women turn away from technology careers?
Because there are spoken and unspoken barriers that make it difficult for women to advance in IT.
Talking to women in tech and code at different events, I’ve observed some common problems which
have forced women to leave engineering careers:
• Poor working conditions: too much travel, lack of advancement, low salary, etc.
• Lack of respect for women in male-dominated fields.
• Unhealthy workplace climate: closed-minded managers, dev teams that are difficult to work
with, or lousy company culture.
To boil it down to the most universal problem, we see that bias pushes women out of the industry.
Moreover, that bias can play out even worse depending on a woman’s race or ethnicity.
Nowadays coding is becoming one of the most in-demand skills across industries, and the milestones
I’ll discuss here will help you to “overcome” your first year in code if you are a woman. Because,
honestly, being a software engineer is one of the best jobs for women. We implement products and
make life easier for people who use them. Sometimes I feel like a hero doing it. Isn’t that amazing?
But because of that bias, you can miss out on all the benefits of a programming career. Here’s a list
of the advantages of being a software engineer at the company where I currently work:
Women in code
102
• We work five days a week. We have a flexible schedule and can even work from home.
• We learn new things constantly while solving problems, working with other software engi-
neers, watching webinars, doing courses, visiting conferences, etc.
• We celebrate all occasions with our teams. We go to team parties and do team-building
exercises.
• We make friends from different countries and cultures, and they enrich our life experience.
• We can easily switch from client to client or product to product. If we don’t find our work
challenging, we can change the type of work that we do.
It’s not my first job, but so far it is my best one.
Choosing a company with the right values
Only now do I understand that when I was looking for my first job and sent out lots of applications
for entry-level frontend positions, I didn’t pay enough attention to the companies I was applying to.
I didn’t even clearly understand the differences between types of companies: a startup? A consul-
tancy? An agency? A public company? A product company?
I knew HTML, CSS, and JavaScript. And I had made fancy web pages and implemented mini projects
to consolidate my technology stack knowledge and create a portfolio. My only focus was on getting
professional experience—and finding my first job.
As a result, out of 20-30 CVs sent to different companies, I got 2-3 invitations to interviews. I
didn’t much care about what kind of company they were with, what products/services the company
provided, the company’s values or the team lead/manager I was going to work with. And that was
a big mistake on my part. If I had known better, my first job could have been at a company I’d be
happy to work at.
You can always get insights about a company before applying for a position. For example, through
the company’s reviews on job search websites. You can meet current and former employees at
meetups or other events and get more details about the company’s purpose or vision or whether
the company has open positions at the moment.
Then Google the name of the company and check their job postings. After getting enough
information, you can understand whether the company is diversity-friendly and worth applying
at, how the company is organized, what the working process would be like for you there, etc.
Different types of software engineering jobs demand different kinds of preparation. If you’ve done
your research and decided which company you would like to join, then start by sharpening your
skills and focusing on your strengths and weaknesses. Do some side projects to learn the required
tech stack for the position. Add all these to your resume and send it to the company.
If it’s your first year in code, I would suggest you apply at startups and mid-size companies.
These companies are full of hands-on work. You’ll get good exposure to things to learn and, more
importantly, your ideas and suggestions will be taken into consideration. You’ll be able to challenge
Women in code
103
yourself, showcase your creativity and learn how to work on a team. These jobs can give you a
clearer picture of yourself regarding what skills and knowledge you need to get. Also, you’ll get the
chance to build your professional network.
The importance of telling the truth
As women in tech, we always face more problems at work than men. This observation comes not
only from my life experience but also from my women friends and acquaintances who work in IT.
I am lucky now to be working in a healthy environment, and along with a professional relationship
with management, we are building trust between the two sides: employer and employee.
Once, when I was visiting a meetup for women who code, I met Clara (name has been changed).
She is a junior software engineer at company X.
At that time she was a new employee. And you know how it’s difficult to adapt to company processes,
a new project, and your coworkers in your first weeks or even months, especially if it’s your first
year in the field.
Later I texted her to invite her to meet up for a cup of coffee. I wanted to hear her story. While we
were sitting in the cafe, drinking coffee and speaking about our jobs, Clara confessed that she was
afraid of saying “I don’t know” when in fact she didn’t know something. Instead of that, she was
trying to bluff her way through the situation and not lose control.
Her apparent reason was fear of looking stupid in front of her colleagues and managers at work.
She’s a competent professional and she must have an answer because it’s her job, isn’t it?
A year ago, I would have answered “Yes.” It is my job. And I must know the answer to any question
related to my expertise. But not now.
It took years for me to understand that when you are telling the truth, you can breathe easier. It’s
a straightforward and selfish reason, one I truly learned through my experience. There are many
pros to the truth: you don’t need to focus on backstories, and backstories of backstories, and relevant
details to make what you’re saying appear plausible, and making your body language match up with
what you are saying.
When you are telling the truth, you are at peace; you are honest. So much less energy needs to be
spent.
Don’t be afraid of telling your team or manager that you cannot finish your work on time. I’m sure
you had reasons, perhaps a specific problem or blocker. The best solution is to provide an explanation
and make your case as to why you couldn’t finish this task as planned.
If you are blocked by a problem and cannot find a workaround, don’t hesitate to ask for help. An
answer or some useful advice from a colleague or team member can easily unblock you and allow
you to continue solving your problem. And it will help you solve the same problem in the future if
it arises again.
In the end, you will only benefit from gaining new knowledge, learning how to work as a team, and
spending less time on figuring out a solution.
Women in code
104
Some people think that having a gap in knowledge is a weakness. But the real weakness is being
close-minded and dishonest.
How to grow a thick skin and handle complexities
During my university studies I noticed that most of the students were men. Even at that time I could
imagine how my future working environment would look. And I was right.
During my first year in code I worked with men as the only woman on my team, and to be honest,
at that startup, it was hard to work together, not just for me but also for my teammates.
There was that bias against accepting code produced by me—by a woman.
Yes, women are different from men. And yes, women can definitely code. But many have stopped
coding because someone once made them feel like they can’t code well.
Looking back on that time, maybe you’re a beginner without any practical working experience at
all, still confused about processes, teamwork and code bases with tens or hundreds of thousands of
lines of code. The combination of unknown things, complexity, and a new team where you’re only
an intern surrounded by middle-level/senior software developers—it can make you feel as though
there’s a massive amount of pressure on you.
In the beginning, it was a significant challenge to go to work. But I did it, even if I was crying. I
understood the importance of it. I was trying to see things positively and benefit from them by:
• Learning from my failures
• Distinguishing between personal and business
• Trying to get constructive feedback from the team
• Not complaining about things
For the time being I worked with men, learned from them, and built stamina. And I saw how easily
some men separate personal and business. They can be fighting with each other about a topic at
work and then behave as if nothing happened. It’s just work, nothing personal.
If you are in your first year in code, one of the first, most important things you have to do is start
to develop a thick skin.
That means you have to be able to go into work, even if your performance isn’t perfect, even if
sometimes you don’t completely understand what you are doing (or if you thought you did but in
the end everything went wrong). At the same time, don’t forget to appreciate yourself and your
progress (which may be noticeable only to you), regardless of what happens.
Here are three more ideas for women on developing a thick skin:
1. Cut down your contact with abusive people
If your direct manager or team members are just plain unbearable and always trying to bring you
down with their obsessive words or actions, then start looking to join a different team or switch jobs.
You won’t be able to stand this atmosphere for long and it can ruin your self-esteem and confidence.
Women in code
105
2. Don’t let harsh words hurt you
Sometimes we care too much about what others think.
This especially happens if you are the only woman on a team and worry about the image you are
portraying to others. If someone insults you or insists on something you completely disagree with,
it keeps repeating in your head over and over because we’re taught to deal with that stuff head-on.
The best way to handle this situation is to replace the thought with a more positive one. Why should
someone’s negative words ruin your day?
Focus on yourself in this situation. Don’t let the hurtful words of others make your day worse and
take control of your mind. Think positively, cheer yourself up, surround yourself with optimistic
and supportive people.
3. Use your words instead of your feelings
If someone is trying to wound your feelings, for example with passive-aggressive feedback, turn
their words around and engage with the offender in constructive dialogue.
Don’t forget you are allowed to interrupt and say: “Okay. I get it. There’s a problem here. You have
explained it very clearly. Can we talk about how to fix it? That’s more helpful for both of us.”
Overall, you are better off being a person who cares too much than a person who doesn’t care at all.
With luck, these sorts of workarounds can help provide cushions so that criticism doesn’t hurt you
too much.
Breaking stereotypes: educate men at work
I can imagine what it means for you to join a new dev team and be the only woman there—
because I did it, three times. We’re always being “welcomed” with the stereotypes. There is a general
impression that men are better at “tech things,” that they’re more systematic and nuanced, and that
on the other hand, women are more intuitive and better communicators, but their judgment isn’t as
solid.
A friend of mine works at the same digital media agency I used to work at. We often share our
experiences and observations from working with each other. Once she told me, “You know, today
when I was in a meeting about the project I’m working on, I sat at the table and said something. My
team, all men, ignored my comment. Then I noticed whenever the male backend engineer spoke,
everyone just stopped and listened. And I thought, that’s what I want. I want people to take me
seriously and respect my work.”
Here’s what she did next: she changed her job and started working for a company that values
diversity. Now half of her engineering team is women. There she continues to work hard, learn new
things and grow professionally. Based on my own experience, if you’re new in the industry, the
expectations placed on you can be burdensome. But if you’re willing to work hard and understand
that your first job probably won’t be your dream job then it gets easier.
Women in code
106
I firmly believe in diversity at work, not only of gender but also of experience level. For example,
I believe in creating junior developer positions and training those juniors up. When they are fully
integrated into the company, junior developers become loyal employees. By comparison, companies
that only hire the most senior developers find that they often already have their own vision of how
things have to work, which can be unproductive.
My friend’s way worked for her, but she could have done it differently—break stereotypes, that is—
by working to bring diversity to her former workplace. The following principles can help you do
that.
Become an expert in a specific technology/approach and start advocating it
Currently my official title in the workplace is “Frontend Software Engineer.” In my opinion, you
can’t be an expert front end developer just by knowing one thing. An expert developer is not
necessarily skilled in any specific set of technologies; instead, they demonstrate the ability to learn
new languages, frameworks and libraries as the need arises. The more they learn, the more they can
compare and make informed decisions about what tech to pick and when.
Know the requirements of each situation. Don’t be afraid of meeting a new challenge, even if you
haven’t solved that problem before. The more “unknown” things you learn and apply, the more your
expertise will grow.
If you are fascinated by a technology, you can start to advocate it. Convince others to try it and use
it. It will help you grow your credibility and break false stereotypes about women.
Increase your network of women and bring women engineers to the company
If you feel bad working on a team that’s all men, what’s stopping you from bringing a new woman
colleague to your team?
Finding a woman developer is easier than it seems. You can start going to local meetups, volunteering
at coding schools, joining university groups, and visiting other local tech events.
Companies are always passively looking for new people. It’s normal for some people to leave the
company and others to join, and someone will grow to the next level professionally and free up a
junior position.
Help onboard new employees
This is the best way to learn and understand a project more deeply. Keep in mind that if you’re a
software developer at a product company, it’s important to write clean and readable code so that
even an intern can understand it—and by the way, you too, in case you return to that code in a week,
a month or a year.
I want to talk about the mentor/mentee relationship, which isn’t always strictly business. You can
develop some real friendships when you take the time to advise someone and help them succeed.
Women in code
107
When you develop a relationship with someone over time—when you help them, coach them, and
guide them—that person’s success is tied to you. Time after time, success will come back to you as
the mentor.
Also, your protege can teach you from their own unique experiences and perspective, which may
be very different from yours. They may also have new skills they can teach you.
People never forget their mentors.
Think back to when you first started working at your company. Wouldn’t it have been nice to get
some coaching from someone who had already been through that process?
Build trusting and professional relationships with colleagues and managers
In a company which incorporates people from diverse backgrounds into its network, each person has
to trust the others to help them accomplish their own goals and the collective goal of the company.
That’s why it’s crucial to build trust within teams. It’s a long process; it doesn’t happen overnight.
The most likable and trustworthy people know that it’s not worth offending people by expressing
everything they know, even if they are correct. They’re good listeners when someone else is talking.
It’s also important to show empathy for your colleagues and keep an open mind. Do not judge—
try to understand. Those who close themselves off from others’ ideas are missing out not only on
personal growth but also on opportunities for advancing their career.
People are different, and depending on the situation we may express ourselves differently, sometimes
too emotionally. Try to learn how to maintain professional behavior in all circumstances. Overreact-
ing to things, either positively or negatively, will make a poor impression. Always remember that
silence may be much more useful than angry words.
Women in code are driven. We want to prove ourselves. We want to work hard and grow, and it’s
impossible to buy that kind of enthusiasm.
In parting, I’d like to say: be the change you wish to see in our industry!
What to do when you’re stuck
Isaac Lyman
Part of a programmer’s job is chasing down missing semicolons and complex caching issues,
scrutinizing and head-scratching over every line of code in an application. This is one of the most
frustrating things about code: we use it to offload complexity from our brains, but the inverse of this
benefit is that any useful program will be too complex for us to wrap our minds around completely.
Complexity creates unknowns, and every unknown is a bug waiting to happen.
Another frustrating thing about code is that it has to be learned by rote. You’re unlikely to discover
the keyword or API you need by blind experimentation. And every language and library has gotchas,
which may or may not be described in the documentation. There’s no substitute for experience in
situations like this.
Most programmers (I’d guess) are acquainted with the deep, hot, crushing frustration that ensues
after hours of being stuck on a problem and not knowing how to progress. On that subject, here’s a
tweet from the guy who created Stack Overflow:
Source: https://twitter.com/codinghorror/status/695143348521140225⁶⁵
This particular usage of my head has probably shortened my life expectancy by a few years. If
you’re a new programmer, you can avoid some of that by following a process similar to the one I’ll
recommend here. Each step builds on and escalates the one before it, and most of the time you’ll get
un-stuck long before you reach the last step.
1. Be self-aware
This will all go a lot better if you’re taking care of yourself and paying attention to the way you feel.
Sleep deprivation, hunger, a hostile work environment, or stressors in your personal life can directly
affect your ability to solve problems. Ideally, you should be in a peaceful frame of mind when you
start working. Then when you get frustrated, you can label the problem (“I’m stuck”), take a deep
breath, and start on the path to resolving it.
⁶⁵https://twitter.com/codinghorror/status/695143348521140225
What to do when you’re stuck
109
To get off on the right foot, consider a morning routine that includes meditation and/or journaling.
These can help you be more aware of your feelings.
2. Timebox your frustration
Once you’ve determined that you’re stuck, set a timer for 20 minutes. Turn off Slack and email,
put on your headphones, politely postpone questions and conversations with coworkers, and start
Googling the problem. Read as much as you can about it. Try several different search queries. You
may be surprised at how many other people have had your specific problem, even if it seems unique
or proprietary. If you’re lucky enough to have an error message, search it in quotes. Consider all the
systems (libraries, packages, frameworks, APIs, services, etc.) that interact with the faulty part of
the application, and ask yourself if the problem may be in a different place than you thought it was.
3. Rubber-duck it
Explain the problem to an imaginary coworker. Got a rubber duck or stuffed animal handy? Even
better. I have a stuffed animal on my desk at all times. Describe the issue in as much detail as you
can, and assume that your coworker isn’t intimately familiar with the code you’re talking about.
If this is hard for you, try composing an email or Slack message to a coworker that might be able
to help. Don’t send the message yet—just write it out and revise until you’re satisfied that you’ve
covered the problem in clear terms. Make sure to mention the research you’ve done and anything
you’ve ruled out as the possible cause.
4. Draw it
On a piece of paper or a whiteboard, sketch out a basic diagram of the methods, classes and files
that are interacting in the problem area. No fancy murals here—a bunch of circles and lines should
be fine. Draw a piece of data traveling through this system as well. If you need to dig through the
code a little to make sure your drawing is correct, take a minute to do so.
5. Take five
By now you should understand the problem pretty well (or know what you don’t understand about
it). At this point, put your computer to sleep and give your brain a rest. Anything that isn’t mentally
demanding will do. Strike up some light conversation with a friend or coworker, take a nap, go for
a walk, get some lunch, watch a funny video, hit the gym, or take a shower. The solution may occur
to you while you’re doing something else entirely.
What to do when you’re stuck
110
6. Ask for help
By now, you’re reaching the limit of what you can do alone; you’ve probably spent 30-90 minutes
on this problem. It’s time to bring in reinforcements. Find a coworker who has relevant experience
and ask for help. If you have no coworkers or none are available, reach out to your mentor. If you
don’t have a mentor, now’s a good time to put that on your to-do list.
Don’t worry about wasting their time. You’ve researched and thought through the problem, so you
can describe it completely and succinctly. And for you to keep trying on your own could turn into
a much more serious waste of time.
7. Isolate the problem
If you’re still stuck, it’s time to start from scratch. Create a small repository or use an online tool
(like Codepen⁶⁶, Repl.it⁶⁷, or Stackblitz⁶⁸) and see if you can add just enough code to reproduce the
problem. One piece at a time, replicate the environment and code around the issue until you see it
happen. Then try to remove various pieces, in turn, to make sure you haven’t included anything
unnecessary. What you’ll end up with is the smallest possible example of the problem (an MCVE⁶⁹),
which will make it easier for someone to help you solve it. Review this with the person you asked
for help in the previous step.
8. Write it up
Write a full description of the problem. Include code samples, a link to your repository or online
code sample, screenshots (if applicable), and a summary of the things you’ve tried and the research
you’ve done. Don’t include anything that would pose a security risk to your company if it were
posted publicly, because that’s the next step.
9. Get a buddy and ask the internet
Find a buddy (possibly the person from step 6) and ask them to read through your writeup from
step 8 to make sure it makes sense. Then post it on the internet. Stack Overflow and other Stack
Exchange sites (like Server Fault, Software Engineering, or Database Administrators) are your best
bet for getting a timely answer to your question, but their communities can be hostile to question
askers, so don’t go in alone—ask your buddy to upvote your question and help you defend against
rude commenters or votes to close the question. With any luck, you’ll get some good feedback and
ideas within a day or two.
⁶⁶https://codepen.io/
⁶⁷https://repl.it/
⁶⁸https://stackblitz.com/
⁶⁹https://stackoverflow.com/help/mcve
What to do when you’re stuck
111
10. Find a workaround
If you still haven’t solved your problem, it’s time for Plan B. You might consider altering the affected
functionality, adding some fallback code, or switching to a different software library. This sounds a
lot like giving up, but compromises are at the heart of all software, so don’t beat yourself up over it.
Finally, document the solution
Once you’ve solved the problem, consider writing some documentation about it in order to alleviate
someone else’s frustration. This might be a comment in the code, a page on your company’s internal
docs, an email, a post on your blog or dev.to⁷⁰, or a self-answered Stack Overflow question.
And once again, keep an eye on your mental health. Programming is inherently frustrating. We all
need breaks. If you’re constantly getting burned out, it’s time to take a day off, change your routine,
or look for another job.
⁷⁰https://dev.to/
Choosing a job title
Isaac Lyman
Are you a coder, programmer, developer, engineer, architect or
something else?
My first job was an underage, under-the-table weekend gig at a pizza parlor. I’d show up at the local
strip mall early Saturday morning, stash my bike, and clock in. For me, the work was grueling. I
would haul 50-pound bags of flour and 10-gallon buckets of water to a giant stand mixer, and once
it finished spinning I’d lift armfuls of incredibly heavy dough to a metal table where I’d cut and oil
portions weighed for each size of pizza that the shop sold. By noon, I’d be exhausted. I’d clock out
and head home. And once a month I’d pick up an envelope with about $100 cash in it. It was an
awesome first job.
My official job title was Dough Boy (yes, like the Pillsbury mascot). But “Dough Boy” isn’t very
impressive on a resume, so for a while I listed my job title as “Dough Chef.” A teenager’s got to have
some dignity, right? In the end, I don’t think anybody cared.
Little did I know, that was the least problematic job title I would ever have.
I became a programmer several years ago. In 21st-century America—especially in the tech sector—
job titles are surprisingly fluid. I haven’t had an employer dedicate any real thought to my job title
for a long time. In fact, my first employer in the industry told me I could put whatever I wanted
on my resume and if anyone called she’d back me up. Naturally, I was tempted to write “Senior
Department Lead QA III Technical Architect”, when in fact I was just writing Selenium tests in a
cubicle. Go figure.
I’ve often puzzled over the plethora of job titles I now fit under. I write web applications for a startup,
so I do something at every level of the stack, from SQL Server at the bottom to CSS at the top. There
are a lot of things I could call myself: coder, programmer, engineer, developer, boffin. In keeping
with my pizza-infused legacy, I could even call myself a Software Boy⁷¹. So what am I?
⁷¹https://twitter.com/ivetwodads/status/854358415799312384
Choosing a job title
113
Source: https://twitter.com/jenlooper/status/854345325032747009⁷²
I’ve discovered that I’m far from the only one who has this question. And there are a lot of variables
to consider, so it’s not an easy one. In some countries it’s illegal to call yourself an engineer unless
you have certain certifications. In some cultures, general words (like “consultant”) may be preferred
over technical jargon (like “application developer”). And in the United States, where I live, small
differences in a job title can make a significant difference in salary.
This is my attempt to aggregate all the data I can find about the swath of job titles that apply to
people who code. I’ve gathered average salary information and definitions for several job titles that
might apply (but surely not all of them).
I’ve ignored titles like hacker, ninja, and rockstar because they’re silly and meaningless.
Sources
I pulled salary information from the U.S. Bureau of Labor Statistics (BLS), Glassdoor, PayScale, and
Indeed. Definitions come from the BLS or Wikipedia where available. Where neither has a definition,
I’ve searched out the most succinct, authoritative source I can find.
Salary data
This data is categorized by job title. Job titles are ordered by a subjective estimate of their complexity,
from least complex to most complex. Data was gathered in May 2019.
Each entry has a definition, national (USA) median salary data from each source, an average of the
salary data points, and a variability assessment (how wide the range of salary estimates is). Where
a specific job title or equivalent was not found in a database, “N/D” is used.
Statistical Note: PayScale.com uses the words “average” and “median” interchangeably. That’s not
how math⁷³ works, but oh well. Glassdoor and Indeed don’t offer a median at all, preferring a much
⁷²https://twitter.com/jenlooper/status/854345325032747009
⁷³https://www.vocabulary.com/articles/chooseyourwords/mean-median-average/
Choosing a job title
114
less useful⁷⁴ average. In a perfect world everyone would use medians for data sets like this, since
they may or may not follow a normal curve.
Coder
[A] person who writes computer code; a computer programmer. ∼Dictionary.com⁷⁵
Source
Salary
BLS
N/D
Glassdoor
$46,930⁷⁶
Indeed
N/D
PayScale
N/D
Average
N/D
Variability
N/D
Notes: I’d usually avoid a site with so little street cred as Dictionary.com, but definitions for this
word are surprisingly scarce.
Programmer
Create, modify, and test the code, forms, and script that allow computer applications to run.
Work from specifications drawn up by software developers or other individuals. ∼BLS⁷⁷
Source
Salary
BLS
$84,280⁷⁸
Glassdoor
$68,478⁷⁹
Indeed
$73,643⁸⁰
PayScale
$61,527⁸¹
Average
$71,982
Variability
Medium. Range of ∼$22k.
Developer
[A] person or company that develops computer software. ∼Merriam-Webster⁸²
⁷⁴https://surveymethods.com/blog/when-is-it-generally-better-to-use-median-over-mean/
⁷⁵http://www.dictionary.com/browse/coder
⁷⁶https://www.glassdoor.com/Salaries/coder-salary-SRCH_KO0,5.htm
⁷⁷https://www.bls.gov/oes/current/oes151131.htm
⁷⁸https://www.bls.gov/oes/current/oes151131.htm
⁷⁹https://www.glassdoor.com/Salaries/programmer-salary-SRCH_KO0,10.htm
⁸⁰https://www.indeed.com/salaries/Programmer-Salaries
⁸¹http://www.payscale.com/research/US/Job=Computer_Programmer/Salary
⁸²https://www.merriam-webster.com/dictionary/developer
Choosing a job title
115
Source
Salary
BLS
N/D
Glassdoor
$80,394⁸³
Indeed
$93,386⁸⁴
PayScale
N/D
Average
$86,890
Variability
Medium. Range of ∼$13k.
Notes: Several people have pointed out that the term “developer” could refer to someone in real
estate as well as someone in software, so it’s hard to know if these results are meaningful.
Front End Developer
A front-end developer is a type of computer programmer that codes and creates the visual
front-end elements of a software, application or website. He or she creates computing
components/features that are directly viewable and accessible by the end user or client.
∼Techopedia⁸⁵
Source
Salary
BLS
N/D
Glassdoor
$77,908⁸⁶
Indeed
$102,297⁸⁷
PayScale
$69,773⁸⁸
Average
$83,326
Variability
Extreme. Range of ∼$32k.
Web Developer
Design, create, and modify Web sites. Analyze user needs to implement Web site content,
graphics, performance, and capacity. ∼BLS⁸⁹
Source
Salary
BLS
$69,430⁹⁰
Glassdoor
$75,487⁹¹
Indeed
$72,644⁹²
PayScale
$58,593⁹³
Average
$69,038.50
Variability
Medium. Range of ∼$15k.
⁸³https://www.glassdoor.com/Salaries/developer-salary-SRCH_KO0,9.htm
⁸⁴https://www.indeed.com/salaries/Developer-Salaries
⁸⁵https://www.techopedia.com/definition/29569/front-end-developer
⁸⁶https://www.glassdoor.com/Salaries/front-end-developer-salary-SRCH_KO0,19.htm
⁸⁷https://www.indeed.com/salaries/Front-End-Developer-Salaries
⁸⁸http://www.payscale.com/research/US/Job=Front_End_Developer_%2f_Engineer/Salary
⁸⁹https://www.bls.gov/oes/current/oes151134.htm
⁹⁰https://www.bls.gov/oes/current/oes151134.htm
⁹¹https://www.glassdoor.com/Salaries/web-developer-salary-SRCH_KO0,13.htm
⁹²https://www.indeed.com/salaries/Web-Developer-Salaries
⁹³http://www.payscale.com/research/US/Job=Web_Developer/Salary
Choosing a job title
116
Full Stack Developer
The term full-stack means developers who are comfortable working with both back-end
and front-end technologies. To be more specific, it means that the developer can work with
databases, PHP, HTML, CSS, JavaScript and everything in between, also, venturing as far
as converting Photoshop designs to front-end code. ∼George Fekete on SitePoint⁹⁴
Source
Salary
BLS
N/D
Glassdoor
N/D
Indeed
$111,117⁹⁵
PayScale
N/D
Average
N/D
Variability
N/D
Notes: There’s⁹⁶ significant⁹⁷ doubt⁹⁸ as to whether this is a “real” job title, insofar as it refers to being
an expert in several different layers of web technology. Given that Indeed is the only site to cough
up a salary value, it seems that the industry shies away from it, whether for this reason or another
one.
Software Developer
Develop, create, and modify general computer applications software or specialized utility
programs. Analyze user needs and develop software solutions. ∼BLS⁹⁹
Source
Salary
BLS
$103,620¹⁰⁰
Glassdoor
$80,018¹⁰¹
Indeed
N/D
PayScale
$69,928¹⁰²
Average
$84,522
Variability
Extreme. Range of ∼$33k.
Software Engineer
A software engineer is a person who applies the principles of software engineering to the
design, development, maintenance, testing, and evaluation of the software and systems
⁹⁴https://www.sitepoint.com/full-stack-developer/
⁹⁵https://www.indeed.com/salaries/Full-Stack-Developer-Salaries
⁹⁶https://dev.to/remotesynth/theres-no-such-thing-as-a-full-stack-developer-2fp9
⁹⁷https://vitamintalent.com/blog/what-the-heck-is-a-full-stack-developer
⁹⁸https://medium.com/@alexkatrompas/the-hard-truth-about-the-full-stack-developer-myths-and-lies-945ffadeeb8c
⁹⁹https://www.bls.gov/oes/current/oes151132.htm
¹⁰⁰https://www.bls.gov/oes/current/oes151132.htm
¹⁰¹https://www.glassdoor.com/Salaries/software-developer-salary-SRCH_KO0,18.htm
¹⁰²http://www.payscale.com/research/US/Job=Software_Developer/Salary
Choosing a job title
117
that make computers or anything containing software work. ∼Wikipedia¹⁰³
Source
Salary
BLS
N/D
Glassdoor
$103,035¹⁰⁴
Indeed
$107,366¹⁰⁵
PayScale
$84,023¹⁰⁶
Average
$98,141.33
Variability
Medium. Range of ∼$23k.
Notes: In classic Wikipedia style, this definition is bafflingly circular. However, if you ignore the
“principles of software engineering” part, the definition becomes useful.
This concludes a nearly-complete list of job titles that apply to regular devs. However, I’m going
to go a bit further and see what “Junior”, “Senior” and “Architect” do to a job title, even though these
terms lie outside the mainstream.
Junior Software Developer
An entry-level engineer with limited exposure to development and development practice
who will need strong mentoring and support to grow their skills. ∼James Turnbull on
Kartar.Net¹⁰⁷
Source
Salary
BLS
N/D
Glassdoor
$64,962¹⁰⁸
Indeed
$59,913¹⁰⁹
PayScale
$59,579¹¹⁰
Average
$61,484.67
Variability
Very low. Range of ∼$5k.
Senior Software Developer
…either someone with a deep specialised knowledge beyond their peers or someone who
leads or instructs other developers. ∼Robert Rees on The Guardian¹¹¹
¹⁰³https://en.wikipedia.org/wiki/Software_engineer
¹⁰⁴https://www.glassdoor.com/Salaries/software-engineer-salary-SRCH_KO0,17.htm
¹⁰⁵https://www.indeed.com/salaries/Software-Engineer-Salaries
¹⁰⁶http://www.payscale.com/research/US/Job=Software_Engineer/Salary
¹⁰⁷https://kartar.net/2015/09/so-what-exactly-is-a-junior-software-engineer/
¹⁰⁸https://www.glassdoor.com/Salaries/junior-software-developer-salary-SRCH_KO0,25.htm
¹⁰⁹https://www.indeed.com/salaries/Junior-Software-Developer-Salaries
¹¹⁰http://www.payscale.com/research/US/Job=Junior_Software_Engineer/Salary
¹¹¹https://www.theguardian.com/info/developer-blog/2014/aug/28/what-does-it-mean-to-be-a-senior-developer
Choosing a job title
118
Source
Salary
BLS
N/D
Glassdoor
$95,791¹¹²
Indeed
N/D
PayScale
$101,732¹¹³
Average
$98,761.5
Variability
Very low. Range of ∼$6k.
Software Architect
A software architect is a software expert who makes high-level design choices and
dictates technical standards, including software coding standards, tools, and platforms.
∼Wikipedia¹¹⁴
Source
Salary
BLS
N/D
Glassdoor
$132,510¹¹⁵
Indeed
$142,078¹¹⁶
PayScale
$121,645¹¹⁷
Average
$132,077.67
Variability
Medium. Range of ∼$20k.
Analysis
Salaries
Job titles by salary from lowest to highest are:
• Junior Software Developer
• Web Developer
• Programmer
• Front End Developer
• Software Developer
• Developer
• Software Engineer
• Senior Software Developer
• Software Architect
¹¹²https://www.glassdoor.com/Salaries/senior-software-developer-salary-SRCH_KO0,25.htm
¹¹³http://www.payscale.com/research/US/Job=Sr._Software_Engineer_%2f_Developer_%2f_Programmer/Salary
¹¹⁴https://en.wikipedia.org/wiki/Software_architect
¹¹⁵https://www.glassdoor.com/Salaries/software-architect-salary-SRCH_KO0,18.htm
¹¹⁶https://www.indeed.com/salaries/Software-Architect-Salaries
¹¹⁷http://www.payscale.com/research/US/Job=Software_Architect/Salary
Choosing a job title
119
Coder and Full Stack Developer were lacking data. Since the BLS probably has the largest and least-
biased data set, I’ve bolded the job titles that had BLS data available. Incidentally, the ordering of
the list holds when BLS data is considered alone.
This data should be taken with a grain of salt for several reasons:
• I don’t have access to the original data sets. I don’t know the size of those data sets or the
algorithms used to calculate their average/median. I don’t have access to demographics data,
so important variables like race, gender, orientation and class aren’t considered here. A data
set of known size and diversity would yield better analysis.
• Glassdoor and Indeed are fundamentally job boards, not public data sets. Their data is based on
volunteered information: self-reported salaries and job postings. This makes it prone to several
forms of survey bias.
• PayScale, Glassdoor and Indeed are private companies and their data isn’t public. Any private
company is accountable to its shareholders, not the general public, and may be incentivized to
gather and calculate data in a way that increases the value of their product to customers. For
example, employers posting jobs on Indeed may prefer the site to report lower average salary
data, which would make their salary offers seem more competitive. Indeed could do this by
focusing its marketing on regions with low cost of living and low average salary, which would
skew its self-reported salary data toward the lower end of the scale. I’m not saying they do this,
but it could be profitable for them to do so.
The difference in average salary between a Developer and a Software Developer is about $3k,
which probably is not statistically significant. On the other hand, the difference between a Software
Developer and a Software Engineer is $13k, which may be meaningful. The biggest leap in salary is
from Senior Software Developer to Software Architect, with a difference of about $33k.
There are several more slight variations in wording that I could have looked into. A Senior Software
Engineer, for example, probably makes a little bit more than a Senior Software Developer, and a
Senior or Chief Software Architect surely makes more than a Software Architect. But this should be
enough to provide insight into a general trend.
Definitions
Enough with the cash: what’s the qualitative difference between these roles?
First of all, some titles to avoid (or at least approach with caution):
• Coder had the lowest Glassdoor salary of any position I looked at, even lower than Junior
Software Developer. It’s hard to argue in its favor. First of all, it’s much too brazen—it’s like a
construction worker calling himself a Nailer or a doctor calling herself a Scalpeler. “Code” is
better as a noun than a verb; it’s a tool you use to achieve a goal. If a candidate for a position
at my company billed themself as a Coder, it would give me the impression that they like to be
told what to do and how to do it—that is, they’ll write the code, but they won’t make decisions,
interact with people, or suggest ways to improve. That sounds like an unfulfilling way to build
Choosing a job title
120
software. What’s worse, an employer who creates a job posting for a Coder probably isn’t
looking for someone who engineers elegant solutions to complex problems—they probably
have only a shallow understanding of what software is, and want to hire the cheapest person
they can find to “just build a really simple app.”
• Full Stack Developer seems to beg the question, “but what are you good at?” As I’ve mentioned,
people tend to be incredulous of a candidate who claims to be an expert at every level of the
stack. There’s simply no way a normal person can keep up with everything. And knowing a
single technology at each layer (say, JavaScript, REST, .NET and SQL Server) probably doesn’t
cut it. Sure, those are the technologies in your stack, but someone else’s stack may consist of
Dart, Falcor, Python and Couchbase. You’re not a Full Stack Developer where they’re concerned.
At best you’re a regular Developer who’s willing to learn some new tech.
• (Computer) Programmer is a term that’s gone the way of the dinosaur, along with the
stereotype of the shirt-and-tie-wearing geek in a cubicle. All the word really means¹¹⁸
is someone who knows a programming language. This used to be a rare skill (and only
moderately in demand). But modern software construction demands more than just syntax
and vocabulary—the essential domains of “programming”—because modern software is more
than just a command-line interface and a set of database files on a floppy disk. Apps have to be
beautiful, accessible, user-friendly, fast, and above all, competitive. The word “Programmer”
doesn’t evoke any of that.
• Developer is, as previously noted, an unnecessarily ambiguous title. If your job involves
building condominiums, you’re reading the wrong book. If your job involves computer code,
you should call yourself a Software Developer. Anything built with code is software, so this is
more about clarification than qualification.
• Front End Developer is a very volatile title. Not only does it have almost the highest salary
variability of all the job titles researched, but anecdotally I’ve heard it defined in contradictory
ways. For some people, Front End Developer refers to a person who knows HTML and CSS
but not JavaScript; for others, a Front End Developer is someone who has a deep knowledge of
JavaScript and its most popular frameworks and libraries. The solution, in my mind, is to call
yourself a JavaScript Developer if that’s where your expertise lies, and to call yourself a Web
Designer or CSS Developer if you specialize in HTML and CSS.
The remaining titles differ semantically, but not in ways that necessarily make any of them superior.
You should determine which one best describes your career path:
• Software Developer and Software Engineer are, by many accounts, equivalent. Both mean that
a person knows the best practices in their field, is comfortable with multiple technologies,
and has transferable skills that allow them to recognize and write good code in any language.
These titles also indicate the ability to make smart decisions about software design and
implementation, and a willingness to participate in the software lifecycle above and beyond
writing code (see “Development beyond the keyboard” for more on this topic). Developers and
engineers are creative, thoughtful, knowledgeable people who deserve a place at the table in
¹¹⁸http://chrislema.com/programmer-developer-engineer/
Choosing a job title
121
every discussion about a product. “Engineer” connotes more seniority and preciseness than
“Developer”, so some would say that younger or less credentialed developers run the risk of
sounding pretentious if they bill themselves as Engineers. But considering that the average
salary difference between them is about $14k, I’d recommend using the term “Engineer” as
long as there aren’t any legal barriers to doing so.
• Web Developer is a title that flirts with ambiguity, if less dangerously than Front End Developer.
I’ve seen the term used to mean “a person who builds web applications, including the server
side” or just “a person who knows JavaScript.” But as unclear as it is to industry insiders,
it may be perfect for freelancers who cater to the “just make me a website” clientele. Most
individuals and small business owners don’t understand the complexities of front-end and
back-end; if they hire a developer, it’s to create an attractive single-purpose site that will show
up in Google results. I suspect that Web Developer is exactly what they’re looking for. If you’re
not a contractor, Software Developer may describe you more efficiently (and give you a $15k
bump in average salary).
• Junior and Senior are prefixes that make a big difference in salary. Generally speaking, you’re a
Junior Developer for your first few years or so in the industry, and you’re not a Senior Developer
until a few years after that. But most developers agree that graduating from Junior Developer
to Developer and from Developer to Senior Developer has less to do with the length of your
career and more to do with your humility, leadership, versatility, and experience (especially
the number of catastrophic failures under your belt).
• Software Architect is the most highly-paid job title on this list, and with good reason. It
represents a high standard and has a stable definition industry-wide. The Software Architect is
the ultimate technological resource—the person who’s “been there and done that” so many
times they can practically predict the future. At the last company where I worked, the
Enterprise Architect was equal in status to the CTO. It’s a position of extreme responsibility
and respect. You probably already know if this is you.
• One more title I didn’t investigate in depth is x Developer or x Engineer, where x is a specific
language, framework or technology. For example, I could call myself a JavaScript Developer,
a Vue Developer, or a .NET Engineer, and this would remove the ambiguity about what I’m
primarily good at. I would choose one of the above based on my career goals, or combine two
of them, e.g. Vue / .NET Developer. To look at every kind of x Developer would have increased
the scope of this chapter far beyond its original purpose, but in my opinion it’s the most useful
job title there is for someone who codes. Of course, if you don’t feel comfortable associating
yourself with a specific technology, Software Developer is a totally acceptable alternative.
I hope the data I’ve provided helps you in the process of choosing your job title.
Bibliography & further reading
• The role of a Senior Developer, by Matt Briggs¹¹⁹. This is an excellent take on the skill metrics
that various levels of developers should measure themselves against, rather than composing
job titles based on years of experience.
¹¹⁹http://mattbriggs.net/blog/2015/06/01/the-role-of-a-senior-developer/
Choosing a job title
122
• When should you call yourself a senior developer? on Stack Exchange¹²⁰. A few different takes
on what makes a “senior” versus “junior” developer.
• What’s the difference between Entry Level/Jr/Sr developers? on Stack Exchange¹²¹. Some
worthy additions to the above.
• What does it mean to be a senior developer? on The Guardian¹²². What an above-average set
of qualifications looks like.
• Programmer, Developer, Engineer: What’s in a name? by Chris Lema¹²³. A brief (and fairly
representative) interpretation of the three main nouns in development job titles.
• Developer, Programmer or Engineer? on Stack Overflow Talent¹²⁴. Some survey data and well-
considered quotes from industry insiders.
• Job Titles in the Web Industry, by Chris Coyier on CSS-Tricks¹²⁵. I think the distinctions here
may be a little too rigid, but to ignore Coyier’s take on the subject would be a significant
omission. At the very least, this is a good reference on what various titles should mean.
• What Does a Software Architect Do? by Yegor Bugayenko¹²⁶. This article proposes that
being a software architect isn’t just about smarts or experience, it’s about accountability and
responsibility.
• The Role of Software Architect, by Bredemeyer Consulting¹²⁷. Frames the architect as part
technologist, part business strategist—meaning that the sharpest dev in the company may or
may not be a good fit for the job.
¹²⁰https://softwareengineering.stackexchange.com/q/25564
¹²¹https://softwareengineering.stackexchange.com/questions/14914/whats-the-difference-between-entry-level-jr-sr-developers
¹²²https://www.theguardian.com/info/developer-blog/2014/aug/28/what-does-it-mean-to-be-a-senior-developer
¹²³http://chrislema.com/programmer-developer-engineer/
¹²⁴https://www.stackoverflowbusiness.com/blog/developer-programmer-or-engineer
¹²⁵https://css-tricks.com/job-titles-in-the-web-industry/
¹²⁶http://www.yegor256.com/2014/10/12/who-is-software-architect.html
¹²⁷http://www.bredemeyer.com/who.htm
The DevOps introduction I wish I had
Periklis Gkolias
Buzzwords are common in this industry. They’re used everywhere (sometimes in the wrong way)
and because of that, people are often afraid to ask 101-level questions as they don’t want to sound
ignorant.
Some years ago, my manager asked me if I wanted to do some DevOps work as part of my software
engineer job. Of course, I was young and afraid to ask what that meant so I just said “yeah, let’s give
it a try. Worst case scenario, I will die and you can take a day off to grieve.”
Thank God, I am still alive, as you have probably noticed. So now I want to give you a nice round
overview of the terms I encountered in my initial foray into DevOps and wish I knew back then.
Till not many years ago…
As software engineers, we write software on our computers for other people. And that is problem
number one. The software will eventually have to run on someone else’s computer because the end
user doesn’t have access to our computer. And this is a good thing; imagine the security implications
if anyone could access your computer.
But the end user doesn’t care how well the software works on our computer. They care how it works
on theirs. If we want to do something meaningful and maybe make some money, we have to put our
software out in public.
But who will do this job? Till not many years ago, it was up to the “operations people” of the company.
I might be oversimplifying here, but you can think of them as colleagues from the IT department that
had a technical background but weren’t coders or managers. For example, server administrators¹²⁸
and database experts¹²⁹.
Can you see a problem here? Think about that and I’ll explain in a moment.
DevOps
The DevOps discipline was created to bridge the gap between developers and operations people, the
groups discussed above. The goal is for the transition from a developer’s computer to the public to
be mostly quick, flawless, trackable, and repeatable, with as little as possible manual work. You may
hear this transition referred to as the deployment of the application.
¹²⁸https://en.wikipedia.org/wiki/Server_administrator
¹²⁹https://en.wikipedia.org/wiki/Database_administrator
The DevOps introduction I wish I had
124
Before that, deployments caused constant disagreement and blame between the two tribes. They
were slow and painful and required lots of working hours. This is the problem I mentioned in the
previous section.
The operations people often had no clue why the app couldn’t be deployed even though they were
doing everything they were supposed to do; after all, they didn’t write it or understand the internals.
And the developers were blaming the operations people because “it works on my computer.”
Starting in 2001 there was huge movement (called the Agile manifesto¹³⁰) to improve the way we
produce software and provide it to the public. The DevOps discipline was born as a side effect of
that.
The public
What is this terrifying “public” that led all those poor operations people to exhaust themselves
working overtime? At the time of writing, when people are speaking about deployments, they usually
mean deploying an application to a cloud server so that anyone with a URL (more or less) can access
it.
The cloud? What is the cloud?
When it comes to software engineering, it basically means “another company’s computer.” Giant
companies like Microsoft (with Azure¹³¹), Amazon (with AWS¹³²) and Google (with Google Cloud¹³³)
have thousands of servers running to support their business, as do some smaller companies.
Some of those computers are rented out for others to use and the users (usually companies that don’t
have such high-quality infrastructure and don’t want to buy it) are charged accordingly, based on
how much time they occupy it for. This offers a few advantages and disadvantages, but those are
outside the scope of this chapter.
What is the main problem when deploying to the cloud?
A major problem, as mentioned before, was that there was no guarantee that if a feature was running
on the computer of the original developer then it would run equally well on the cloud.
This can happen because of missing libraries, different library versions between the two machines,
or even because the local computer runs on a different operating system than the server, to name a
few examples.
Running an application in various operating systems
This is actually very common. Let’s say you’re at a company where the CTO used to work for
Microsoft, so having Windows workstations is something they are not willing to negotiate.
¹³⁰https://agilemanifesto.org/principles.html
¹³¹https://azure.microsoft.com
¹³²https://aws.amazon.com/
¹³³https://cloud.google.com/
The DevOps introduction I wish I had
125
Let’s also say one of your major customers is a giant Linux software company. As you can imagine,
they’re guaranteed to have Linux servers on their infrastructure.
What do you do? Do you switch to Linux or make them switch to Windows? Neither scenario is
viable. What if you had hundreds of customers which all had different operating systems in their
infrastructure? How do you make your applications run well for all of them?
There are various approaches to solve this problem. It’s one of the main concerns of not only a
DevOps engineer but also the whole team.
Docker and containers in general
The most popular solution goes by the name “containerization.” Containerization is an approach
where you enclose everything you need (literally everything) in a software “box” (or container) in
order for the software to run smoothly.
The container, for the sake of simplicity, can be thought of like a tiny operating system that runs on
top of your existing one and is completely portable.
You can move a container from computer to computer (and of course to a cloud server). If it works
on one computer, it will also work on another, equally well, with no strings attached. The only
prerequisite is to have the appropriate container technology like Docker¹³⁴ installed.
So for example, in order to solve the aforementioned issue, we could follow this approach (which is
very common):
• Create a container using your preferred operating system.
• Include the source code of our app in the container.
• Include the libraries our application needs, along with any other piece of software our app
relies on.
• Configure the container so that when it is accessed, the app starts automatically.
• Test the application thoroughly from inside the container.
• Once happy, send it to the customer(s). You are now confident that it will work on their side
too, regardless of the operating system they use.
Note: When it comes to Docker, we distinguish between a container and the file that runs inside of
it with the terms “Docker container” and “Docker image.”
Another famous solution is Packer¹³⁵ by Hashicorp¹³⁶. Feel free to read about them and see what
works best for you when the time comes.
¹³⁴https://www.docker.com/
¹³⁵https://www.packer.io/
¹³⁶https://www.hashicorp.com/
The DevOps introduction I wish I had
126
Docker vs. virtual machines
A virtual machine or VM is a standalone operating system that is treated as a normal application by
the host operating system. You can interact with it as if it were your actual environment and forget
about the host.
Yes, Docker¹³⁷ and VMs solve similar problems. They don’t work in the same way though, and
Docker is often the preferred approach nowadays.
The most important differences lie in their size and the way they utilize the host operating system.
For example, Docker is usually much more lightweight and tends to share more functionality with
the host operating system than a VM.
Provisioning
“Provisioning” is another term you might encounter and be too afraid to ask what it is.
In the DevOps context, it means to set up the infrastructure needed for an application to work. This
work is often automated and done in the cloud.
So if someone wants to provision a test environment, they probably have to allocate some server
space in order to put the containers inside and run them. If done manually, this can be a tedious
process.
Thankfully, there are provisioning tools on the market that do the job for you fairly easily, or at least
with minimal input (apart from the initial configuration).
Continuous Integration and Continuous Delivery (CI/CD)
Those two terms refer to an organization’s need to know if newly-written code has problems and if
not, to be able to send it to the customer in an automated way, whenever they want. It’s a common
practice and you should have a high-level understanding of it.
Here is how this works:
• You create a new feature requested by a customer.
• Your code gets reviewed and tested by members of your team.
• You add your changes to the code that will be delivered to the customer (the “release branch,”
as devs call it).
• An automated process notices what you did and starts doing various things with the new
version of the app, like trying to compile it, run any automated tests, and (you guessed it)
prepare your Docker image. This is the “Continuous Integration” step.
• If everything works, the process sends this image to the customer’s servers. This is the
“Continuous Delivery” step.
¹³⁷https://www.docker.com/
The DevOps introduction I wish I had
127
Some of the most well-known CI/CD tools are Jenkins¹³⁸, Travis¹³⁹, and Bamboo¹⁴⁰.
Tips for the future
Before closing this chapter, I would like to give you a couple of tips that you might find helpful
during your first years in tech.
• If you don’t understand something, Google it. If you can’t figure it out easily, ask. No one
expects you to know everything and you never have to. If someone has told you otherwise,
you’re in the wrong company.
• Automate as much as you can. Anything that has to be done manually is error-prone and far
more time consuming.
• Never stop learning. DevOps is a great field and is evolving rapidly. You need to keep your
knowledge up to avoid becoming outdated or obsolete.
¹³⁸https://jenkins.io/
¹³⁹https://travis-ci.org/
¹⁴⁰https://www.atlassian.com/software/bamboo
A coder’s code of ethics
Isaac Lyman
Code can do amazing things. We’re all the beneficiaries of it: computers, cell phones, the internet,
MRI machines—it’s hard to imagine a world without software.
Code can also do bad things. It can lie, steal, murder, surveil and discriminate. In fact it’s done
all of these things, wielded by programmers like you and me, programmers who sometimes didn’t
understand what they were being asked to do and other times didn’t care. Unless you’re very lucky,
at some point in your career you’ll be asked to develop a feature that seems questionable or even
just plain wrong. What will you do?
Will you rationalize it to yourself? It’s not like the feature was your idea. Your bosses sign the
paychecks, so they call the shots. It would be them in trouble, not you. Right?
Or will you take a stand? You’re not some mindless soldier.
The decision is up to you, but you may find that “I was just following orders” isn’t a very good
defense in a courtroom, much less against your own conscience.
Several writers have considered the need for a code of ethics in programming. In my research for this
chapter I studied the Hippocratic Oath, perhaps the most famous ethical code in any profession. Its
ideals include knowledge-sharing, humility, and good citizenship. (If you’re interested, check it out
on Wikipedia¹⁴¹.) These are great things to start with, but there is much more to discuss. Following
are some of the things to watch out for as you strive to be an ethical programmer.
Privacy
Privacy advocates have been railing against Facebook since the beginning¹⁴². Even the News Feed,
which we now take for granted, was once seen as invasive—and one reason we take it for granted
is because much bigger problems are rocking the social media platform on a regular basis, like the
still-fresh Cambridge Analytica scandal¹⁴³. And Facebook isn’t the only company in the doghouse:
Google¹⁴⁴, Amazon¹⁴⁵, Uber¹⁴⁶ and many others have spent time in the news for failing to protect
user data.
How did they go so wrong? There are a few factors at work here.
¹⁴¹https://en.wikipedia.org/wiki/Hippocratic_Oath#Modern_versions_and_relevance
¹⁴²https://www.nbcnews.com/tech/social-media/timeline-facebook-s-privacy-issues-its-responses-n859651
¹⁴³https://en.wikipedia.org/wiki/Facebook%E2%80%93Cambridge_Analytica_data_scandal
¹⁴⁴https://en.wikipedia.org/wiki/Privacy_concerns_regarding_Google
¹⁴⁵https://www.washingtonpost.com/technology/2018/12/20/amazon-alexa-user-receives-audio-recordings-stranger-through-human-
error/?noredirect=on
¹⁴⁶https://www.theverge.com/2017/8/15/16150902/uber-ftc-complaint-mishandle-privacy-data
A coder’s code of ethics
129
First, collecting user data is incredibly easy—you can collect a user’s name, phone number, home
address, government ID number or anything else they’re willing to give you in only a few lines of
code. Storing and retrieving data is so essential to computer applications that enormous sums of
money have been spent engineering APIs and platforms to make it easier. It’s almost the default
thing to do in most cases, only a couple steps behind displaying words on a screen.
Second, protecting user data is much harder, requiring both expertise and intent. In order to prevent
a password from being stolen, you have to know at least a few things about databases, cryptography,
one-way hashes, and secure transmission. And then you have to apply them consistently across an
entire system, no matter how large or complex it becomes. An application’s security is only as strong
as its weakest point, so this requires continuous investment. And security is generally inconvenient;
if a customer calls in because they forgot their password, it may seem easier to just tell it to them
rather than making them follow a password reset process over email. But no secure system will ever
allow you to see their password, let alone tell it to them.
Third, for businesses, “hard” and “expensive” are synonyms. And if no one in leadership is willing
to make a principled stand, a corporation will always choose money over human rights. This is
exacerbated by the fact that user data is worth a lot on the open market. Advertisers will do almost
anything to obtain people’s private information, and much of the software we use (especially free
software) is wholly dependent on advertising.
These factors in combination make a perfect storm: it’s cheap, easy, convenient, and profitable to
collect oodles of user data and store it practically in the open. And the consequences, although
certain, are never immediate. It’s easy to forget that there are consequences at all.
Ethics demands more of us. As programmers, we should refuse to collect more data than our
applications need. We should take users’ trust seriously and protect what they give us. We should
be sensitive to the kinds of data that are especially private and be especially diligent in protecting
them. We should educate ourselves in security best practices. When hackers come looking for easy
pickings (and they will) we should be confident that they’ll leave empty-handed.
Preventing bugs and outages
Most software is “line of business” software: applications people use on a daily basis to do their jobs.
When you write this kind of application, you’re holding a workforce’s productivity in your hands.
A bug, outage, or unnecessarily slow algorithm can cost someone several working days. That’s a lot
of responsibility.
Additionally, you probably know the frustration of buying an app or video game only to find that
it doesn’t work very well—maybe there are tons of bugs, or the servers go down a lot, or it loses
all your data for no reason. You feel cheated, and rightly so. The developer made you an unspoken
promise when they sold you the software, and now you’re left to deal with their carelessness.
Some software does damage when it works. Most software does damage when it’s broken. There
are many things we can do to avoid shipping broken software, but in general we should test every
release ahead of time with the assumption that it’s broken in some way. Then we should fix it before
A coder’s code of ethics
130
releasing. Automated tests, quality assurance, redundancy, monitoring, and automated rollbacks can
help reduce the frequency and impact of severe bugs (see Appendix A for definitions of these terms).
There’s a huge difference between teams that take this seriously and teams that don’t. And it isn’t
always the developers’ fault; if your boss is setting impossibly tight deadlines, making you work
overtime, or demanding you ship new features as quickly as possible, everything is going to be
broken every day. You simply won’t have the time or energy to keep your software bug-free. A
company that runs like this is in serious trouble. But in most situations, you can make a difference
by advocating for quality assurance and testing best practices. And this helps you keep your promises
to your users.
Avoiding dark patterns
A “dark pattern” is any feature of a user interface (UI) intended to trick users into doing (or not
doing) something. Many dark patterns rely on users not paying close attention to every detail and
every block of text in an application—and seriously, who does? If you’ve ever opted into something
you didn’t want because there was a “big green button,” or accidentally clicked an ad when you
were trying to make it go away, you’re the victim of a dark pattern.
The first rule of UI design is “users don’t read” (or, alternately, “users don’t think”¹⁴⁷). This can be
an inconvenience—we can’t just use paragraphs of text to tell users exactly what to do. We have to
make it obvious what the user should do through the careful use of color, contrast, sizing, positioning,
and iconography (and yes, text, but usually only a word or two at a time). This is hard, which is
one reason why designers are so valuable. But generally a dark pattern isn’t the result of a simple
oversight or design mistake. It’s an intentional attempt to take advantage of users’ trust in order to
hijack their time, attention, or wallet. And it’s incredibly common.
File sharing and download sites are full of dark patterns. Sometimes there are so many “Download”
buttons it’s nearly impossible to figure out which ones are ads in disguise and which one is real.
And many news and media sites are almost as bad, with so many ads and newsletter signup forms
you can’t see the content you came for. But even the most well-known sites on the web—Facebook,
LinkedIn, and TurboTax, for example—are notorious for their use of dark patterns to get users to
give up personal information, share contact lists, or pay for a service advertised as free.
Another kind of dark pattern relies not on tricking the user into doing something they don’t mean to,
but on making it difficult to do something they do mean to. Several major brands—like Blue Apron,
Marriott Hotels, and the New York Times—have recently been called out for making it incredibly
hard to unsubscribe from their emails or services, often requiring a lengthy phone call and identity
verification even though they allow you to sign up online with only a few clicks. If that isn’t bad
enough, most advertisers and data brokers will collect information about your internet browsing
habits without your permission or knowledge, effectively “signing you up” for a service you didn’t
even know existed—and you usually can’t close your account with them, regardless of how much
you may want to.
¹⁴⁷http://sensible.com/dmmt.html
A coder’s code of ethics
131
We may not be designing the apps we write, but we should still insist on ethical design standards.
There’s no excuse for employing underhanded tactics to trick our users or trap them into an
arrangement they want to leave.
Impartiality and accessibility
We’re tempted to think of computers as completely unbiased and objective, but this assumption
is problematic: it leads to systems that perpetuate our own biases and those of the world around
us. Computers may not be born with an understanding of racism, sexism, ableism, or classism, but
unfortunately, you can’t avoid bias just by being ignorant of it.
Our default approach to algorithms that deal with people may be to treat each of them as a data point,
completely equal in the eyes of the code. But this lofty ideal falls apart as soon as we introduce a
user interface, business logic, or artificial intelligence. Technical equality is not the same as fairness.
A blind user and a sighted user might be treated as equal data points by our code, but if we don’t
build accessibility into our UI, the blind user will be unable to use the software. Our equality is their
disadvantage. This isn’t the computer’s bias, it’s ours, manifested in code.
An application’s database might not store information about sexual identity, race, or social class, but
due to differences and biases in the real world, the software can effectively discriminate on any of
these bases by making assumptions about the user’s physical size, sexual preference, skin contrast,
living arrangements, or access to a cell phone.
Artificial intelligence is especially prone to bias. Amazon learned this the hard way¹⁴⁸ in 2018, when
it tried teaching an AI to select job candidates similar to the people they had already hired. The AI
quickly learned that most of their employees were men, so it started discounting resumes with the
word “women” or the names of certain women’s colleges on them. This was an egregious case of
sexual discrimination. But AI can be even more insidious, using much less obvious data points as
proxies for race and sex. Something as innocuous as a zip code can enable discrimination unless
careful controls are in place.
It’s our job to watch for and avoid these issues. And we’re likely to fail unless we have people on
our development teams who don’t look like us—people of other races, sexes, levels of ability, and
socioeconomic backgrounds. A combination of awareness, diversity, and broad user testing is the
best way to ensure our applications are truly impartial and accessible to all kinds of users.
Do no harm
The famous phrase primum non nocere (“first do no harm”) is a core tenet of the medical profession.
It should also be a tenet of ours. It’s important to consider the human cost of every development
project. Some software, whether by design or by lack of foresight, does harm in real and immediate
ways.
¹⁴⁸https://www.aclu.org/blog/womens-rights/womens-rights-workplace/why-amazons-automated-hiring-tool-discriminated-against
A coder’s code of ethics
132
Weapons are a case in point. No modern missile takes flight without a team of engineers behind
it. That’s a heavy responsibility, to write code knowing that it will end lives. No one would blame
you for refusing to be part of such a project. The ethics of military force are a topic of debate, but
wherever human casualties are involved, we’d better be prepared to account for our decisions.
Malware is a more clear-cut example: few of us would attempt an ethical argument to justify the
creation of viruses and ransomware. Yet malware is a fixture in the modern world, a constant threat
to our digital well-being. WannaCry¹⁴⁹, a piece of ransomware that made headlines in 2017, infected
thousands of computers throughout Great Britain’s National Health Service and forced hospitals
to turn some patients away. It also halted production at certain factories and automotive plants.
Thanks to some high-quality security research and a few lucky breaks, the impact of WannaCry was
relatively low. But it’s easy to imagine a much worse scenario: unusable MRI machines, hundreds
dead from health complications, frozen supply chains, mass layoffs, abrupt economic collapse in
some sectors, and so on. The creators of WannaCry appeared to be spreading it for their own financial
gain, requesting a few hundred dollars per victim. But there are credible allegations that they were
agents of the North Korean government, which makes the attack a potential act of war.
Make no mistake, you don’t need to be programming a ballistic missile to be dealing with life and
death.
Of a less catastrophic nature (but still decidedly bad) is software that uses your computer’s
resources in ways you wouldn’t appreciate, like 2018’s spate of cryptojacking¹⁵⁰—a word describing
applications that secretly use your processor to mine Bitcoin, enriching their creator while leaving
you with an inflated electricity bill, wear and tear on your hardware, and a slower computer. This
is more petty theft than high crime, but that doesn’t make it victimless.
Perhaps the trickiest time to apply “do no harm” is when we’re making tools that rely on user-
generated content. Twitter and Facebook, for example, are irreplaceable parts of many peoples’
personal and professional lives. The amount of good-natured media and humor generated daily on
the sites is impressive. But they’re also used daily to harass women, LGBT people, and people of color.
They’re used to encourage acts of group violence and suicide. They’re depressing and addictive¹⁵¹
to users. There are tools that allow users to report the worst cases of abuse, but moderation is spotty
at best—and the people who do it suffer severe mental and emotional consequences¹⁵². In these
circumstances, we’d be justified in asking if social media should exist at all.
Even in the simplest of situations “do no harm” is an essential standard. Any software that helps a
doctor do their job, even something as innocuous as a file-sharing server or document editor, can
become urgently important in a patient’s life during a medical crisis. A bug or bad UX could lead
to injury or death. The same goes for air traffic controllers, taxi drivers, manufacturers—even small-
time retailers stand to lose a great deal if their software is broken. Regardless of what you’re building,
the user’s worst case scenario may only be a few lines of code away.
These are concerns you should take with you to each job interview and each project. We should insist
¹⁴⁹https://en.wikipedia.org/wiki/WannaCry_ransomware_attack
¹⁵⁰https://www.nbcnews.com/tech/tech-news/your-computer-could-be-quietly-mining-bitcoin-someone-else-n922101
¹⁵¹https://www.marketwatch.com/story/new-study-claims-facebook-instagram-and-snapchat-are-linked-to-depression-2018-11-09
¹⁵²https://www.cnet.com/news/facebook-content-moderation-is-an-ugly-business-heres-who-does-it/
A coder’s code of ethics
133
on writing applications that are reliable, make the world better, earn users’ trust, and are thoughtful
about the ways they allow people to interact.
The golden user story
I often hear stories of CEOs who refuse to let their kids use software produced by their own
companies. And this illustrates perhaps the most essential principle of all: if you wouldn’t want
an app to do something to your child or significant other or friend, then don’t make that app.
We have the ability to make software that enriches lives and creates opportunities. And as Marc
Andreessen famously said, software is eating the world. We, the next generation of programmers,
can decide what the future looks like. It all depends on the code we write today.
Software development beyond the
keyboard
Isaac Lyman
One of the greatest paradoxes of software development is the relative unimportance of code. As
engineers we study code, we teach about code, we agonize over code, we go to conferences
and debate each other and dream vivid dreams about code. Yet there is no line of code in any
programming language that will make a company profitable or an idea successful. Applications are
of course valuable, and largely responsible for the experiences that shape the modern world, but
most applications could be equally useful if they were written in a different programming language,
under a different paradigm, using different techniques and algorithms. There are infinite ways to
write a program. Sometimes one way is faster than another, sometimes more readable, sometimes
more error-resistant. But usually it’s just different.
In many people’s minds, then, the difference between a good developer and a great developer
isn’t about how quickly or correctly they write code. It’s about skills beyond the keyboard:
communication, leadership, reasoning. Following are a few skills you can learn to raise your value
in the workplace.
Asking hard questions
Code hates ambiguity, which is one of the main reasons coding is hard. If you want to code an
idea, you have to convert it to an algorithm, which requires imagining it on a deep level: what are
the steps from beginning to end? How will you accommodate different users, different privileges,
different devices? How will the application know what it needs to know? What if something goes
wrong? What if the user does something unexpected? What if a hacker is trying to get in?
CEOs and managers usually think about products and features on a high level (and they should).
They’ll say something like “we need a button that lets people export their data as an Excel
spreadsheet.” They see this feature as if it were under a spotlight in a dark room; it seems so simple.
Your job as a programmer is to listen to them, stand in the spotlight with them and understand their
vision, and then grab a flashlight and explore the dark, dusty corners of the room. What should
the spreadsheet be called? What columns should it have? Does it need access controls? Should the
application warn the user if their data is empty, or corrupt, or larger than 100 megabytes? Is Excel
even the best way to handle this kind of data? Would a CSV file be acceptable instead, since it’s
easier to generate?
Sometimes the questions need to dig even deeper. Is this feature worth two months of our team’s
time and effort? What problem are we actually trying to solve (see Appendix A, “XY Problem”)?
Software development beyond the keyboard
135
Are we sure this will solve it? Are customers asking for this? What problem are they trying to
solve? And so on. Some questions you can answer on your own, but many will need to be discussed
by management. Sometimes you’ll have to explain your question several times before anyone
understands it. Sometimes they never will, and you’ll need to ask a different one.
This may not be coding, but it’s software development in the truest sense. It’s part of the painful
but necessary process of making software real, and it’s something that can only be done by people
like us: people who are methodical and thoughtful, people who see the smallest details and sense
problems before they happen. It’s a talent that runs strong among coders, and one you can develop
if you haven’t yet.
As a new programmer, you may feel nervous about asking questions that risk putting your lack of
experience on display. It’s normal to feel that way, but don’t let it silence you. If you prefer, you can
take the questions you’re most insecure about to your dev lead, mentor, or manager, one-on-one.
But keep in mind that your inexperience is in many ways an asset—you have a fresh perspective
and haven’t developed the same blind spots that many of your senior colleagues may have. And
even the most senior of programmers asks a dumb question now and then.
Contributing to UX and feature discussions
Some managers see developers as nothing more than code-producing machines, relegating them to
the last step in a lengthy design process. This often backfires. Without a developer in the room, it’s
difficult to know what is easy and what is impossible, what adds complexity and what reduces it,
what it costs to build something good enough versus perfect.
Developers are master problem-solvers. Coding is, after all, an exercise in working with constraints,
tradeoffs, and outcomes. The best companies recognize this skill and ask for developers’ input
throughout the entire product development process, from design to delivery.
If you can, take the opportunity to sit in on high-level product discussions. If you pitch in now and
then with “that’s an expensive feature—could we do it like this instead?” or “that’s a great idea, but
it will take some effort. Could we validate it with a few users first?” or “that’s simple, I can build it
in an afternoon,” you’ll quickly find yourself indispensable in the process. This is perhaps the place
where your skills make the biggest difference: not hunched over a keyboard, staring at an IDE until
your eyes blur, but at the table with product managers and executives, representing the possibilities
and limitations of code as everyone plans ways to improve customers’ lives.
Talking to users
A famous moment in the tech world occurred in 2001, when a group of 17 software professionals
gathered in Utah, USA, and agreed on a set of core principles to guide the development of software
in the Internet Age.
…we have come to value:
Software development beyond the keyboard
136
Individuals and interactions over processes and tools
Working software over comprehensive documentation
Customer collaboration over contract negotiation
Responding to change over following a plan
∼Manifesto for Agile Software Development
The last two values, “customer collaboration” and “responding to change,” point to one of the most
important processes a software company can adopt: regularly speaking to customers about their
needs, then updating priorities and plans to accommodate them better. Companies that fail to do this
may produce high-quality software but most of the time it won’t be very useful. Developers spend a
lot of time worried about “building things wrong”—writing bugs or misunderstanding specifications,
for example—but an even bigger problem is “building the wrong things.” If your app doesn’t solve
my problem, I don’t care if it’s the most beautiful and bug-free app in the universe.
As a developer, you could argue that it’s not your job to speak to users and gather feedback. The
problem is that in too many organizations, nobody thinks it’s their job (although good UX designers
or product owners will usually take it on). In reality it should be everyone’s job: every part of the
process exists to provide a better experience for users, so everyone has a stake in understanding
them. For a deeper discussion of this topic, see Edaqa’s chapter “You are an interpreter”.
Writing documentation
Poor, out-of-date or nonexistent documentation is the status quo for much of the tech industry. This
causes endless headaches for managers. When a developer leaves after a long employment, they
take knowledge with them that no one else has. When a new developer joins the team, it takes them
months to get up to speed. When two teams work together, they end up spending tens of hours
sharing knowledge face to face. Even in a small company with low turnover, “mental turnover” is
still expensive—I don’t remember the details of what I was working on a year ago, do you? It might
as well have been another life.
If you know how to write clear and organized documentation, you can reduce these expenses
dramatically. Documenting the setup process for new developers can help a recently-hired teammate
contribute much sooner. Documenting the architecture of a system and its core assumptions and
constraints can create an invaluable roadmap for developers tackling complex issues. Creating an
FAQ for bugs or error messages that frequently appear can save your teammates days of unnecessary
debugging. Whenever you or one of your teammates asks “how does that work again?” that’s a sure
sign documentation is needed.
Writing is hard, so don’t be afraid to take the easy route: use lots of bullet points, throw in a drawing
or diagram here and there, overexplain things a little, and ask your team to review and edit what
you’ve written.
One of the most powerful and respectful ways to leave your job is with a digital stockpile of excellent
documentation behind you. Once you give notice, insist on taking the time to write things down:
Software development beyond the keyboard
137
everything you built alone, everything you were the expert on, everything people asked you to
explain on a regular basis. Your coworkers will be thanking you until long after you’re gone.
Code design
Speaking of documentation, one of the best ways to develop both faster and smarter is to plan
out your solutions ahead of time. At a previous job, we called this a “dev design.” The developer
assigned to a task would write a summary of the code they planned to write, including a breakdown
of sub-tasks, a list of every file they planned to change, method signatures, class and field names,
table schemas, and—for especially tricky situations—even a few lines of pseudocode (see Appendix
A for definitions of these terms). Then they would take 20 minutes to review it with the team. This
was the most productive meeting of our day. More often than not, we’d save each other hours of
development time by saying things like “we already have a class that does that, we can reuse it” or
“that’s a tricky procedure, watch out for race conditions” or “I don’t think that’s what was intended
with that feature, let’s talk to our manager and clarify it.”
At that company, we further justified the time spent on dev designs by doing away with formal code
reviews. If our dev design turned out to be inadequate once we started coding, we would update
it and notify the team. This way, the actual code being written was never a surprise—it was “pre-
approved.” Replacing code reviews may not make sense for most teams, but when building new
products and features, I tend to believe that code design ahead of time is more valuable than code
review after the fact. Of course, it doesn’t have to be an either/or situation. On my current team we
do both.
Even if your team isn’t friendly to the idea, doing code design on your own has compelling benefits.
It helps you avoid rewrites by making sure all the parts of your solution work together conceptually.
It helps you find blockers sooner, so you can stay productive while they’re being resolved. It gives
you a record of why you coded things the way you did, so in six months when you’re refactoring
or extending a feature, you can remember the constraints you were working with.
Development isn’t just code
To call yourself a software developer is to claim the whole development process as your own. Don’t
forget that code is only one step of many in that process, and it’s near the end. Becoming proficient
in the other steps will make you a more well-rounded and valuable asset at every job you take.
Code reviews
Rosalind Thuy Pham
What is a code review?
Code Review is an activity performed by developers after finishing a feature or bug fix. A developer
requests a review from their peers. Depending on the impact of the code to the current code base, it
may require more than one developer to review.
Why do we do code reviews?
In software development, an application is broken down by features. A feature can be isolated or
depend on another feature. To ensure each feature is added without defects or side effects, developers
request a code review from their peers or voluntarily review each other’s code.
In most cases, reviewing code means validating and checking for code quality violations. However,
in many collaborative companies, code review is also seen as a way to share domain knowledge
within a team. Through code review, senior developers can share high-level understanding with
junior developers to avoid duplicate code and improve performance. Junior developers can also
review others’ code. It’s an excellent chance to see how others have applied code guidelines and to
learn best practices.
Who should review a junior developer’s code?
Any developer on their team. If the code is implementing a new feature, the junior developer should
pick a senior developer who recently worked on a related area of the code. Early involvement of a
senior developer can make the code review go more smoothly. If the code is a bug fix or improvement,
like a typo, missing variable, or wrong type, the reviewer can be any available team member.
How should you review someone’s code?
Ideally, the developer who wrote the code and their peers should have discussed the feature or bug
fix and designed the overall solution before the code was written. Understanding the context and
conceptualizing the solution are far more important than making the code pretty. Good planning
helps to avoid wasted time and effort if the requirements change or a solution already exists.
There are many possible solutions to most problems. At this point, reviewers and code authors should
feel that they both understand and agree on the chosen solution. Next, they should both agree on
the logic of that solution.
Code reviews
139
When viewing the code for the first time, reviewers refer back to the written product requirements to
get some context around the code and use a diff tool to identify the logic of the solution. For example,
say the solution is an input field for a user to type their name. The logic could be a function which
captures each key press and its value. This is a simple example, but the logic of a solution can span
multiple functions in different files. Reviewers should ask questions or leave comments based on
their impression of the code.
For many junior developers, this might be their first time receiving feedback on their work.
Therefore, some questions and comments may sound more sarcastic and offensive than they are.
Here are some example questions:
• “Why do you need these?”
• “I don’t think it makes sense to add this line.”
• “I don’t understand what this function is trying to do.”
Discussing someone else’s work is not easy, and not all developers are excellent communicators. My
best advice for junior developers is to focus on what you’ve learned at the end of the day, not what
people might think about you. The fact is the more feedback you receive, the more you learn, and
the better you figure things out. It’s hard to take criticism, but it’s better than no feedback at all.
The developer who submitted the pull request (the author) should read and respond to each question
and comment. If necessary, the author and reviewers can have a discussion in person, over the phone,
or while pair programming to explain the solution to reviewers.
At the end of this step, the author and reviewers should agree on the logic for the solution. With the
logic-first approach, the reviewers may remember some existing logic and suggest that the author
reuse it. In a smaller code base where there isn’t much existing logic, the reviewers might suggest
making a piece of code more generic so other developers can reuse it in the future. Everything other
than logic, such as typos and naming conventions, reviewers should note and save for later.
After reviewing the logic, reviewers should pull the code, run tests, and check for errors. After
resolving errors, the author should write new tests to cover those error cases. Reviewers should
double-check for basic mistakes such as syntax errors and infinite loops. After all tests are passing,
the author should revisit earlier feedback for any refactoring suggestions and improvements, such as
removing dead code or adding documentation. Before asking for another round of review, the author
should also validate their code with the team’s code guidelines. Here are some standard things to
check:
• Are function and method names clear and descriptive?
• Is the code consistent across different files?
• Do functions accept the same types of parameters and behave the same every time they
execute?
At this point, authors who are junior developers might ask their reviewers about ways to optimize
and improve code performance if needed.
Code reviews
140
Once each step has been completed—planning, reviewing logic, fixing bugs, and refactoring—the
process is complete and the code is ready to merge.
Appendix A: A coder’s vocabulary
Following, in alphabetical order, are some terms that are commonly used among software developers.
You may have learned some of them already. Note that these definitions aren’t intended to be
comprehensive, but rather to help you understand and participate in online and offline conversations
about code as quickly as possible. Many of them are based on the most common situations and may
not apply to every company or tool (e.g. the definitions relating to version control are specific to Git,
the most popular version control system).
Agile - A philosophy for creating and releasing high-quality software gradually (as opposed to
Waterfall, where software is delivered all at once). Even though the entirety of the Agile manifesto is
available online (https://agilemanifesto.org/¹⁵³) and takes less than ten minutes to read, most people
in the technology sector severely misunderstand it or ignore it altogether. If a company says they “do
Agile,” this generally means that they have a lot of meetings and sell subscriptions to their products,
not that they follow Agile principles like valuing simplicity and trusting their developers. Agile is
one of the most popular buzzwords in the technology sector.
Algorithm - A set of steps for doing something. An algorithm is the concept that drives a piece of
code, not the code itself.
Antipattern - Something that seems like an easy or obvious solution to a problem, but has hidden
negative consequences. In other words, “lots of people do this, but it’s a bad idea.” Be wary of
developers who use this to describe any pattern they dislike.
Application Programming Interface (API) - All the parts of a piece of software that are public in
a given context - for example, if you’re coding something that uses the software, the API is all the
parts you can refer to from your own code. The commands in a programming language are part of
its API. The methods you import from a third-party library are part of its API. If you write a web
server, all the methods that can be accessed via an HTTP request are part of its API. In your own
software, every public method and field you create is part of the internal API.
Argument - see “Parameter”.
Array - A collection of one or more pieces of data, together in the same group. An array can be as
simple as [1, 2, 3] or much more complicated—arrays can contain objects or even other arrays.
Assign - To set or change the value of a variable.
Associative array - See “Object”.
Asynchronous (async) - Refers to processes that don’t necessarily happen in order and could finish
at any time (or not at all). Different coding languages handle this in different ways, but usually
¹⁵³https://agilemanifesto.org/
Appendix A: A coder’s vocabulary
142
by letting you give them a function to execute when a process is finished, and another function to
execute if the process throws an error.
Automated test - A piece of code that executes another piece of code and makes sure it does what
it’s supposed to do. Automated tests include unit tests, integration tests, and end to end tests, among
others.
Back end - The server in a web application. This includes the database and all the server-side code.
Many developers specialize in back end development.
Best practice - Any standard that a group of experts have decided is the “best way” to do something.
Knowing the best practices of a programming language, framework, or business process can help
you develop quickly and avoid expensive mistakes. It’s also valuable to know when to ignore a best
practice in favor of something that’s faster or more practical.
Big O notation - A way of measuring the efficiency of an algorithm, like sorting an array or
retrieving data from an object. In Big O notation, O represents a function whose output is the amount
of time (or space) it takes to run the algorithm, and n represents the number of items the algorithm
is operating on. Since every computer is different, we don’t measure in absolute units, but for the
following examples I’ll use seconds. O(n) could mean “this algorithm will take 1 second to operate
on 1 item, 2 seconds to operate on 2 items, 3 seconds to operate on 3 items, and so forth.” You can
think of it as a line graph, like y = x. And O(2n) would mean the algorithm will take two seconds to
operate on each item. O(1) would mean the algorithm takes the same exact amount of time regardless
of how many items it operates on—this is usually the best case scenario. And O(n²) would mean the
algorithm takes as long as the number of items squared—this is one of the worst case scenarios, since
the algorithm will get exponentially slower as the number of items increases linearly.
Blocker - Anything outside of your control that is preventing you from moving forward with your
work. Blockers are a common topic of standup meetings.
Branch - One copy of a repository that can be worked on without affecting everyone else’s copy.
This is managed via version control. When you’ve finished doing a piece of work in a branch, you
merge it back to the main branch (the “trunk”). “Branch” can also refer to a logical possibility in a
piece of code—if a piece of code has an “if” statement, one logical branch is the code that executes
if the statement is true, and the other logical branch is the code that executes if the statement is
false.
Boolean - A data type that contains either true or false. A boolean variable is also called a bit or
a flag. Booleans are one of the most essential and useful data types.
Bug - When an application doesn’t behave the way it’s expected to. This is almost always due to
a mistake made by a developer while coding the application, or a miscommunication from their
manager when describing the requirements for the application. On rare occasions it’s due to a
deficiency in the programming language itself. Bugs are common and developers learn to expect
them in every piece of code. The term “bug” was coined by programming pioneer Grace Hopper, who
once traced a malfunction in a computer program to an actual moth trapped in an electromagnetic
relay.
Appendix A: A coder’s vocabulary
143
Build - A compiled version of a codebase, or the process that compiles it and prepares it for delivery
to the user or production server.
Caching - A way of speeding up access to data by storing it in memory. Generally, anything you
assign to a variable in code is cached, and retrieving it from that variable is much faster than reading
it from a database or a remote API call. Back-end developers tend to use caching liberally, since
memory is cheap and cached data scales extremely well.
Character - A letter, number, symbol, space, or other indivisible piece of a string. Some programming
languages have a specific data type for characters and represent strings as arrays of characters.
Class - The blueprint or instruction manual for an object. You can use a class to create an object,
usually with the new keyword. The class tells you what data the object can hold and what methods
it has.
Clean code - Code that has minimal dependencies and is easy to read, well-tested, and error-
resistant. Truly clean code is a standard that isn’t often achieved in the real world. The best
developers strive for this ideal in a pragmatic way, improving existing code while making realistic
compromises.
Client - In a web application, the computer on the user’s side (as opposed to the server). Can also
refer to an application that communicates with another computer over the internet.
Cloud - A general term for computers or servers that are owned by someone else and only accessible
via the internet, usually paid for by the consumer on a monthly basis. Your emails and Dropbox files
live in the cloud, as do most websites.
Codebase - All the code in a project or repository, or any collection of interconnected files that
together form the source code of an application.
Code quality - A measure of the usefulness and readability of a piece of code. See the chapter “Steps
to better code”.
Code review - When one developer reviews another developer’s code and provides feedback.
Code smell - A behavior in code that isn’t necessarily wrong, but is an obvious red flag for low-
quality code or hidden bugs. For example, a variable named x is a code smell, not because it doesn’t
work, but because it doesn’t describe what the variable contains and could easily be misinterpreted.
Code style - A matter of preference in how code is formatted. Code style includes topics like tabs
versus spaces, maximum line length, and bracket placement. Code style doesn’t matter much but is
still hotly debated on some teams. Ideally, a development team should set up an auto-formatter with
rules chosen by any arbitrary method. As a developer, you should conform to the style conventions
of whatever team or project you’re working in.
Command Line Interface (CLI) - Often called a “console.” A CLI is a text interface for using software.
The user (often a programmer) types a command and presses Enter, and the software responds and
puts the result on the next line. Bash, Powershell, Command Prompt on Windows, and Terminal on
Mac are popular examples of CLIs.
Commit - See “Git”.
Appendix A: A coder’s vocabulary
144
Compile - To transform code into lower-level code, like turning C++ code into machine language.
One way or another, this has to be done before the code can execute. Many programming languages
come with a compiler that does this transformation quickly and efficiently. Compilation is often
done ahead of time, before the software is released to users, but some languages have “JIT” (Just In
Time) compilation that happens while the software is being used; still other languages are interpreted
rather than compiled (See “Interpret”). Depending on the language and the environment it runs in,
a combination of compilation techniques may be used.
Concurrency - When multiple things can happen at once in code.
Constructor - A class method that is called the moment a new object is created. The constructor is
usually in charge of assigning default values to the object’s fields and setting up its dependencies.
Continuous Integration (CI) - On a software development team, the practice of merging each
developer’s code to a shared repository frequently and testing it after each merge. Any CI tool on
the market will allow you to automatically compile new code and run unit tests on it whenever it is
merged, then notify the development team if the tests fail.
Continuous Delivery (CD) - The practice of making sure a piece of software is always ready to
release, and releasing it frequently. This requires a little extra work to make sure that half-finished
or untested features aren’t released by accident. This can be done by hiding unfinished work behind
feature flags or by releasing a feature gradually in small but fully-implemented layers.
Convention - Tradition. Programmers speak of “the conventional approach” or “style conventions,”
by which they mean “the way things have always been done around here.” Here in this phrase could
mean your company, your city, a programming language, or the field of computer science as a whole.
Sometimes conventions are a useful shortcut to code and techniques that have stood the test of time;
other times, they’re obstacles that prevent you from seeing a better way to do things.
Create, Read, Update, Delete (CRUD) - Some of the most common behaviors in interactive
applications. A word processor app, for example, will have the ability to Create, Read, Update or
Delete documents. An app with little to no logic other than what’s required to store and retrieve
data is often described as a CRUD app.
Culture fit - This can usually be understood as “someone who looks or talks like us.” When a
company’s culture isn’t well defined, this is too often used to shut out job candidates for personal
reasons that have no correlation to competence or success in a given role. Using job interviews
as a chance to communicate specific cultural values, such as teamwork, inclusion and tactfulness,
can reverse these negative effects and produce “culture add” candidates who preserve a company’s
values while increasing diversity and reducing bias.
Data - Any piece of information that a computer can keep in its memory. Numbers, dates, strings,
booleans, and objects are all examples of data.
Database - A set of data stored in memory, usually on a hard drive. Applications almost always
have some kind of database where they store data they’ll want to use later. For example, an app can
store the name and email address of every person who signs up to use it.
Appendix A: A coder’s vocabulary
145
Dead code - Code that is unreachable; that is, it can never be executed. For example, if a function
is never called, or if code appears after a return statement, it’s considered dead code. In some cases
your IDE will automatically find dead code and bring it to your attention.
Debugging - Finding and fixing bugs in code. Bugs are very common. You should expect to spend
far more time debugging code than writing it.
Declare - To give a variable a name (and possibly a type). A variable declaration is like a birth
certificate for a piece of data.
Dependency - Anything that is required for a class to be constructed or for an application to run.
Dependency injection - The practice of passing a class’s dependencies to it as parameters to
the constructor, rather than making it responsible for gathering everything it needs. Dependency
injection is a best practice in most programming languages and makes it easier to write unit tests.
Deploy - To move resources from one environment to another. Deploying software is a process that
may include moving files to a server, compiling them, and running automated tests. Most companies
automate this process to make it predictable and convenient. See also “Release”.
Design pattern - A popular way to solve a particular problem in code. These often have odd names
like “the decorator pattern” or “the adapter pattern”. Sometimes language-specific patterns are called
design patterns, but generally a design pattern should be applicable to an entire family or paradigm
of languages. As you explore a codebase, you’ll notice the patterns that exist in it without necessarily
learning their names. It’s more important to know what a pattern does and why it’s useful than to
know what it’s called.
Dev - Short for “developer.” Someone who develops software, including the work of writing code.
DevOps - An abbreviation combining “development” and “operations”. DevOps describes the
overlap between development tasks—defining and creating a product—and operations tasks like
deploying software to an environment. Someone who works in DevOps will generally have
experience in both areas.
Dictionary - See “Object”.
Diff - The result of running a “diff tool.” A diff tool is a piece of software that compares two code files
and displays the differences between them, much like the “View Changes” tool in a word processor.
Code that was added will be shown in green and/or with a “+” symbol, while code that was removed
will be shown in red and/or with a “-“ symbol. Diffing is often done while merging code, to make
sure that changes made by different developers are all integrated together correctly.
Documentation - Written instructions, descriptions, or historical records related to a team or a piece
of software.
Edge case - Something that’s unlikely to happen in a particular application, but should be planned
for anyway. For example, the user of an email application could decide to forward an email to
themself, and while this isn’t something most users will ever do, the application should still be able
to handle it without breaking.
Appendix A: A coder’s vocabulary
146
Elegant - Code that is well-written, even beautiful. If two pieces of code do the same task and are
both performant and bug-free, the more elegant one is the one that is easier to understand or makes
better use of the programming language and its standard library. Calling someone’s code “elegant” is
a compliment. Elegance shouldn’t be confused with “cleverness,” which can sometimes mean using
language features in a confusing way to get shorter or faster code.
Encapsulation - Taking data and logic that belong together and putting them in a self-contained
unit of code. This makes it easy to hand them out to any code that wants to use them, and to control
the way they are used.
Encryption - The use of a secret cypher to make important data difficult or impossible for hackers
to read.
End to end (e2e) test - An automated test that runs an application as if it were a real user, including
clicking, tapping, typing, scrolling, or anything else a real user might do. These tests are time-
consuming but they’re also the only way to ensure the application actually works without testing it
manually. For that reason, they tend to provide a lot of value.
Estimating - The practice of trying to guess how long it will take to develop something. These
guesses are usually wrong. The more specific a guess is, the less accurate it’s likely to be. Nonetheless,
managers desperate for control will often try to get developers to give highly specific estimates for
all their work.
Evaluate - To execute a piece of code. If the code produces a value, we can say the code “evaluated
to” that value.
Expression - A piece of code that produces a value. Expressions can be made of smaller expressions.
The number 2 is an expression in code, as is 120 / 1 + 1 and getUserData().
Feature flag - A boolean value that determines whether a feature is visible or usable to the end user.
This is useful when a feature isn’t finished yet but the current latest version of the code needs to be
released. It can be as simple as placing a piece of code inside an if block, or as complex as using
different data types across multiple files based on a value in a database.
Flag - See “Boolean”.
Foo, bar, baz, qux - Generic, meaningless variable names often used in code samples or documen-
tation. They’re equivalent to a, b, c, and d. They shouldn’t be used in actual application code.
Framework - A generic piece of software that makes certain common tasks easier; this is meant to
be used as the foundation for an application. A web framework, for example, can simplify the work
of creating websites by providing methods for updating web pages when data changes, sharing data
between pages, and communicating with a web server.
Front end - In a web application, the code that runs on the user’s computer (generally a website
or an app). The opposite of “back end.” Many developers specialize in front end development. Front
end development often includes elements of graphic design.
Full stack - Both the front end and the back end in a web application. The term “full stack developer”
is contentious because many people believe that a developer can’t effectively specialize in both the
Appendix A: A coder’s vocabulary
147
front end and the back end. However, most web developers know some of both.
Function - One or more lines of code that are grouped together in the same block and share data with
each other. A function usually has a name so you can call it from another piece of code. Functions
can accept arguments and return values (but they don’t have to do either). They’re a good way to
break down a long process into simpler steps or share logic between several pieces of code.
Functional programming (FP) - A paradigm that describes programming languages or techniques
where all data is immutable, all functions are pure, and the core concepts are based on advanced math.
Haskell, Elm and F# are examples of functional programming languages. However, a functional
programming “style” can be used in many other languages, including JavaScript and C#.
Garbage collection (GC) - A feature in many programming languages that keeps track of data you
aren’t using anymore and automatically deletes it to free up memory. This is a major convenience
for developers. In languages without garbage collection, you have to keep track of all your data and
delete it yourself to avoid memory leaks.
Getter - A function that controls what happens when a variable is accessed. Getters are sometimes
used to control who can access a variable and what value they receive. The code referring to the
variable probably doesn’t know that it’s calling a function, so getters should be used carefully. See
also “Setter”.
Git - The most popular version control system. Git keeps track of a series of “commits,” each of which
is a collection of file changes or “deltas.” These commits exist in one or more “branches”. When one
branch is merged into another, Git tries to take all the changes in each file and weave them together.
It often can’t figure out how to do so without losing anyone’s changes; this results in merge conflicts.
Gotcha - A pitfall. Anything about a programming language, library, design pattern, or apparent
solution that can have unexpected effects, often without the developer realizing it.
Hard-coding - When data is written into code as a shortcut, forcing the code to use that data instead
of getting it from whatever “real” source it’s supposed to use. This is a form of technical debt. It’s
often done on purpose when building a new app or feature. For example, when you build a new
web page, you might hard-code some fake data for it to display (like a username, profile picture, and
map location) so you can focus on the design and interface. Every time you load the page, the same
fake data will be shown. Once the design work is finished, then you’ll need to refactor so that the
page uses data from a real logged-in user, maybe by fetching that data from the application’s server.
Hard-coding can also be called “stubbing.”
Graphical User Interface (GUI) - A visual interface for using software, generally accessed with a
mouse and keyboard. Ubuntu Linux, Mac OS, and Windows all come with GUIs installed, as does
every major internet browser and almost every other application meant for end users.
Idempotent - Describes a method that can be called once, twice, or multiple times, and the result is
always the same—that is, it doesn’t matter how many times you call it.
Idiomatic - The most obvious or normal way to do something in a programming language. Idiomatic
code takes advantage of a language’s built-in features and standard library to complete a task in
Appendix A: A coder’s vocabulary
148
an expectable way, rather than writing unnecessary methods or misusing language features to do
something they weren’t intended for.
Immutable - Refers to data that can’t or shouldn’t be altered. A changed version of that data could
be created and stored in a different variable, but the original data should always stay the same.
Immutable data can be nice to work with because it’s unlikely to surprise you.
Infinite loop - A loop, such as a while or for loop, that has a bug causing it to repeat forever.
This often happens when the programmer forgets to increase a value on each iteration, or when the
condition of the loop is written incorrectly. while(true) {} is an example of an infinite loop.
Integrated development environment (IDE) - A code editor that includes code-specific features,
like a compiler, a test runner, a debugger, and/or autocomplete. Visual Studio, IntelliJ, and WebStorm
are examples of IDEs.
Integration test - An automated test that makes sure two or more pieces of code work together
correctly.
Interface - The way you interact with a piece of code. This can refer to the input boxes and buttons
of a Graphical User Interface, the hardware buttons on a microwave, or the public parts of a class. In
code, the interface keyword is used to describe a collection of public fields and method signatures
which describe the interactivity an object is expected to have without specifying the exact logic it
should be using under the hood.
Interpret - Refers to the process of executing code without compiling it to machine language first
(see “Compile”). This requires a special piece of software called an interpreter. Languages that are
interpreted instead of compiled are often called “scripting” languages. JavaScript is an example of
an interpreted language; every major web browser comes with a JavaScript interpreter.
It works on my machine - Often said by a developer when an application is broken for the QA
team, managers, or users, but doesn’t seem to have any issues when they run it on their computer.
There are many reasons this can happen, including out-of-date code, a race condition, concurrency
bugs, differences in data, differences in environment, unforeseen user behavior, or bugs in the build
and delivery system.
Kanban - A set of processes that are often used in software development. Kanban is most easily
recognized by the presence of a “Kanban board,” a grid representing tasks that are available, in
progress, or finished, often with intermediate steps in between. See also “Scrum” and “Agile”.
Keyword - See “Reserved word”.
Legacy code - Any code that no longer brings joy to the developers that maintain it. Legacy code
may have been written ten years ago or last week; the point of the phrase isn’t necessarily to describe
the code’s age, but to indicate that it’s obsolete in some way and needs to be updated.
Library - See “Package”. Can also refer to a collection of related packages.
Linter - A tool that detects style issues or common mistakes in code without actually compiling or
running it. Linting is a form of static analysis.
Appendix A: A coder’s vocabulary
149
Load test - An automated test that simulates heavy usage of an application (e.g. by a lot of different
users at the same time). The goal is to measure the performance of the application “under load,” or
in other words, to find out how much it slows down or stops working in worst case scenarios.
Logic - What an application does or how it makes decisions.
Memory - See “Random access memory”.
Memory leak - When an application fails to free up memory it doesn’t need anymore, it can
gradually use more and more memory until the computer runs out. This can happen in any
programming language, whether or not it has garbage collection.
Merge - See “Git”.
Merge conflict - When two developers have modified the same code and the version control system
can’t figure out how to weave their changes together, the result is a merge conflict. A developer then
needs to resolve the conflict, usually by opening the file and modifying it so neither developer’s work
is lost.
Method - A function that lives inside of an object. It’s often defined in a class.
Minimum viable product (MVP) - The smallest and simplest version of a software product or
feature that could be valuable to a user. Releasing an MVP is a good way to find out what’s important
to users and learn about their needs without a lot of development effort.
Mob programming - Often called “mobbing”. When more than two developers gather around a
single computer and focus on a single task, with the entire group contributing to discussion about
how to do it.
Mock - A “fake” version of a dependency (like an object or method) that can be used during unit
testing, so the test won’t fail for reasons outside of the piece of code being tested.
Mockup - See “Prototype”.
Modular - Refers to a piece of code that is self-contained, making it portable between codebases.
Module - See “Package”.
Monitoring - Use of a system that keeps track of different events and metrics for an application.
You can use monitoring to learn what kinds of errors are happening for your users or how fast or
slow your app is. Monitoring can also notify you when a server crashes or a database takes too long
to perform an operation.
Mutable - Refers to data that can be altered. The opposite of immutable.
Namespace - A name that groups one or more pieces of code together under the same umbrella
for the programmer’s convenience. Some programming languages require every class to be in a
namespace. When one class refers to another, you can use its namespace to help the compiler find
it, or to differentiate between multiple classes with the same name.
Object - A piece of data that holds other pieces of data and/or logic. Organizing data like this is
a good way to describe a complicated real-world concept, like a person or a subscription. Objects
Appendix A: A coder’s vocabulary
150
are usually organized into keys and values. The keys are like words in a real-life dictionary; the
values are like the definitions of those words. Therefore, you use the keys (which you usually know
beforehand) to retrieve the values from the object or to change them. An object can be created by
using a class. Objects can also be called dictionaries or associative arrays.
Object-oriented programming (OOP) - A paradigm that describes programming languages where
the code is organized around mutable data objects. OOP languages generally use classes and each
class has methods for operating on its own data.
Open source - Describes a project or application whose code is publicly available. Open source
coding is extremely popular, and tens of millions of open source repositories can be found on sites
like GitHub and BitBucket. Developers value open source code because of the communities that
form around it, the way it propagates ideas, the transparency it offers, and the fact that most open
source code is free to use.
Package - A bundle of code intended to be used by other code. A package may depend on other
packages, but it usually handles those dependencies on its own. In the simplest situations, you can
add a package to your project and use it without worrying about how it works.
Pair programming - When two developers share a computer. One of them, the “driver”, controls
the mouse and keyboard; the other one tells them what to do or type. The goal is to reduce mistakes
and increase development speed by having two people focused on the same task.
Paradigm - A category of programming language, or a certain way of programming regardless of
language. Functional programming and object-oriented programming are examples of paradigms.
Parameter - A piece of data you provide to a function when you call it. It’s assumed that the function
will use and/or alter that data.
Performance - How fast or slow an application or part of an application is. Something that’s
relatively fast is called “performant.”
Premature optimization - When someone tries to make an application faster without knowing how
fast it is already. Most of the time, “fast enough” is good enough. Almost any piece of code can be
fine-tuned and worked over until it’s lightning-fast, but this is wasted effort if a user will never
notice the difference.
Primitive - A simple, “pure” data type that isn’t an object. What’s considered a “primitive” can vary
by programming language. Numbers, booleans and characters are usually primitives.
Production - In a web application, the server that is interacting with real users. This is the last stop
for any piece of code that’s been merged into the main branch.
Proof of Concept (PoC) - A small example of working software to demonstrate that a particular
idea or technique is feasible.
Prototype - An application design that represents both the appearance and the interactivity of the
app, usually put together by a designer. Usually a prototype is purely visual and doesn’t contain any
code or do any work under the hood.
Appendix A: A coder’s vocabulary
151
Pseudocode - Fake code written as an example or to describe how an algorithm might be written.
Pseudocode may look like a specific programming language or no programming language at all.
Many programmers like to write pseudocode when planning their approach to a problem, so they
can figure out the solution without worrying about syntax, spelling, code style, and errors.
Pull request (PR) - In version control, a proposal for one branch to be merged into another. A pull
request usually includes a written description of the changes the developer has made and a list of all
the commits that would need to be applied. Most online code repositories have a way to read through
all the code changes that a pull request is proposing, and a method for approving or rejecting the
request.
Pure function - A function that doesn’t change anything outside of itself and doesn’t use any data
aside from its arguments. A function that accepts a Fahrenheit value and returns the equivalent
Celsius value, doing the conversion with a simple mathematical formula, is an example of a pure
function. Pure functions are easy to use and very predictable, which makes them a useful tool for
any developer.
Quality assurance (QA) - Testing software to find bugs. Depending on the organization, this can be
a person or team’s full-time job, or a responsibility shared by everyone. It’s an extremely valuable
role that often prevents catastrophic bugs from affecting users.
Race condition - A bug that occurs when two or more things happen at the same time and are
expected to finish in a certain order, but might not. Race conditions are common in asynchronous
code and in web applications that expect data to be delivered from the server in a particular order.
Random access memory (RAM) - Often just called “memory”. The place where the computer stores
data temporarily. RAM is very fast and easy to access. All variables in a computer program are stored
in RAM.
Read–eval–print loop (REPL) - See also “Command Line Interface”. A text interface for evaluating
expressions in a programming language. Most languages ship with a REPL. The developer console
in Chrome, Firefox and Safari includes a JavaScript REPL.
Read the fucking manual (RTFM) - An abusive way to suggest that someone is asking an
excessively simple question, and instead of bothering you they should read the documentation for
the programming language or tool they’re struggling with. RTFM is an unhelpful response regardless
of the situation, and generally only used by people who are exceptionally difficult to work with.
Recursion - When a function calls itself. This is often done when a function is working with data
like an array or tree of indefinite length or depth. The function can operate on the first part of the
data, then call itself with the rest of the data. Eventually it will be called with the last piece of data,
and then it can finish.
Refactor - To change a piece of code without changing how the application behaves on the surface.
The purpose of refactoring can be to make code easier to read, to organize it better, to make it easier
to add new behavior in the future, or to take advantage of new features in a programming language
or library.
Appendix A: A coder’s vocabulary
152
Reference - The memory address of a variable. When you create a variable and use it, the code is
keeping track of its reference (usually behind the scenes). If you delete the variable or the compiler
notices you’re not using it anymore, it can “free” the reference so that memory can be used by
something else. If something is “passed by reference” to a function, that means its actual memory
address is provided, so modifying it within the function will modify it for the entire application.
Reflection - The ability of code to modify itself at runtime. In practical terms, this usually refers to
the ability in certain programming languages to look at an object and access any of its fields and
methods that are created at runtime or would usually be hidden. This is especially useful if you don’t
know what the object is going to look like ahead of time.
Relational database - A database consisting of tables that can refer to each other. You can think of a
database table like a spreadsheet. It commonly has an ID column and other columns that describe a
complex piece of data; in this way the table definition (or “schema”) is like a class and each row is like
an object of that class. If you have a table called “Orders” and a table called “Products”, the “Orders”
table could have a “ProductID” column that refers to the ID column of “Products”. Then each order
could be related to a product (usually by using the numerical ID of a single row). Relational databases
are the best choice for most applications. Most relational databases are created, queried and updated
via SQL, a programming language made for this purpose.
Release - To publish code to an environment, usually production; or, a version of code that is ready
to be released.
Repository - A collection of files that are all kept in the same place. Often abbreviated to “repo”.
Reserved word - In a given programming language, any word that has special meaning and
therefore can’t be used for variable or function names. For example, the word if is usually a reserved
word, and if you try to declare a variable named if you’ll get an error.
Representational state transfer (REST) - By strict definition, this is a set of rules for web server
APIs that dictates, among other things, how APIs are structured and what information the client
must provide. In common usage, a REST API is any web API that uses common HTTP request
bodies and HTTP verbs like GET, POST and PUT.
Retrospective - A meeting during which developers and managers consider the work they’ve done
recently and discuss ways to improve. This is the only meeting that is actually part of Agile: “At
regular intervals, the team reflects on how to become more effective, then tunes and adjusts its
behavior accordingly.” (https://agilemanifesto.org/principles.html¹⁵⁴)
Rollback - A process by which a piece of software is “un-updated”; any changes in the latest release
are undone and the software reverts to an older state. This is usually done when a severe bug or
security flaw that didn’t exist in previous versions is discovered. Software companies generally plan
for this possibility by (for example) setting up an automated way to do a rollback with a single click.
Rubber ducking - The practice of explaining a problem to an inanimate object (it’s called a “rubber
duck” for illustrative purposes). As you describe the issue out loud in your own words, the solution
will often become obvious. This is an especially effective tool for debugging.
¹⁵⁴https://agilemanifesto.org/principles.html
Appendix A: A coder’s vocabulary
153
Runtime - The time during which the code is actually running (not being written or compiled); or,
the environment in which the code runs.
Scaling - A set of strategies and considerations around the question, “how could our application or
organization handle a significant increase in the number of customers we serve?” Scaling can also
refer to challenges with increasing amounts of data or organizational growth.
Schema - See “Relational database”.
Scope - The boundary between what you intend to build and what you don’t intend to build. If
you’re planning to build a feature in a certain period of time, that feature is “in scope.” Otherwise
it’s “out of scope.” If you’ve already made plans but extenuating circumstances cause you to do more
work than you were planning, that’s called “scope creep.”
Scrum - A set of meetings and processes that are a popular way to “do Agile.” The most common
mark of Scrum is the “standup”, a daily meeting where members of a team report what they’re
working on. Some organizations wrongly believe that they are Agile solely because they have sprints
and standup; see “Agile”.
Setter - A function that controls what happens when a variable is changed. A setter can be used to
track changes to a variable, prevent it from being changed, or determine if the user has permission
to change it. The code referring to this variable probably doesn’t know that it’s calling a function,
so setters should be used carefully. See also “Getter”.
Ship - To release a version of a product, usually the latest version.
Signature - Everything you need to know in order to use a method: its name, the types of arguments
it expects, and what type of argument it returns.
Soft skills - Refers to non-technical skills that are essential in the workplace, like communication,
respectfulness, compromise, time management, and creativity. The phrase has some unfortunate
connotations, like wrongly implying that “soft” skills are less important than “hard” (technical) skills,
or that they’re a sign of intellectual weakness. Many programmers prefer to call them “catalytic
skills,” since they enable and facilitate every kind of work.
Software - Applications built with code that run on a computer.
Software as a Service (SaaS) - A way of delivering software on a subscription basis. Customers
usually pay monthly and receive regular, automatic updates. SaaS is a popular way to sell software
on the internet.
Software development kit (SDK) - The software and APIs necessary to develop an application that
works on a particular platform, like Windows 10, iPhone, or the Java Virtual Machine (JVM).
SOLID - An acronym for five principles that are common in the study of object-oriented program-
ming: Single responsibility principle, Open-closed principle, Liskov substitution principle, Interface
segregation principle, and Dependency inversion principle. These aren’t defined here because some
of them are relatively advanced, but you should study them once you feel confident with the basics
of object-oriented programming.
Appendix A: A coder’s vocabulary
154
Spaghetti code - Code that is disorganized, spread out, and hard to follow, as if the code were
noodles in a bowl of spaghetti. Developers who are in a rush to meet deadlines or don’t have the
guidance of a senior developer will often produce spaghetti code. An application made of spaghetti
code is a nightmare to debug, refactor, and build upon. Be wary of developers who use the term to
describe any code they dislike.
Specification - A detailed human-language description of a software or programming language
feature, including details on how it works and how to use it.
Sprint - A period of time during which software is built. The Agile principles state, “Deliver working
software frequently, from a couple of weeks to a couple of months, with a preference to the shorter
timescale” (https://agilemanifesto.org/principles.html¹⁵⁵). Sprints are a popular implementation of
this principle. A sprint often begins with a planning meeting and ends with a retrospective.
Stack - A memory structure where pieces of data are “stacked” on top of each other. Only the top
piece of the stack can be accessed or removed at any given time. The “stack” also refers to all the
lines of code that are active when a specific line of code is executed. If code A calls code B, which
calls code C, then A, B and C are all part of the stack. If C throws an error, you’ll usually see a “stack
trace” listing C, then B, then A.
Staging - The environment where an application is released before it goes to production. Staging
is where all the final testing and verification happens and often has similar data to production. If a
bug isn’t caught in staging, it will go to production and affect users.
Standard library - All the functionality that comes built-in with a programming language, even
though it isn’t part of the syntax itself. The standard library usually includes functions for
manipulating strings, handling input and output, and doing advanced math.
Standup - See “Scrum”.
State - The data kept in memory as an application runs.
Statement - A basic unit of code that describes an action. In programming, we often talk about “if
statements,” “return statements,” and several others. An “if statement” is a statement that uses the
if keyword, such as if (x == 2).
Static - A keyword in many programming languages that refers to a method or field that exists on
the class itself, not on objects of that class.
Static analysis - A type of debugging that can be done without compiling or running the code.
Linting is a form of static analysis. Most IDEs will do static analysis to let you know about bugs as
soon as possible.
String - A data type that holds text. In code, strings are usually put inside of quotes. "John Smith"
is a string, as is " " (a string full of spaces), "" (an empty string) and "￿".
Style guide - A set of rules documenting a group or project’s preferred code style. Some teams have
unwritten style guides; in this case, the best thing to do is explore the project beforehand and try to
make your code look like theirs.
¹⁵⁵https://agilemanifesto.org/principles.html
Appendix A: A coder’s vocabulary
155
Syntax - The grammar of a programming language, including all its reserved words and the way
numbers, symbols, and other tokens are used.
Technical debt - The gradual buildup of confusing, disorganized or buggy code in an application.
This is inevitable over time, especially if the team is rushed, the work environment is hostile, or
there’s a lot of pressure to produce new features. Technical debt can only be controlled by regularly
setting aside development time to refactor. If technical debt is allowed to grow too large, it can cause
mental exhaustion for developers, seriously slow down feature development, and make bugs hard
or impossible to fix.
Test-driven development (TDD) - The practice of writing unit tests for a piece of code before that
code is even written. The process can be remembered as “red-green-refactor”: first the test is written,
and it fails (red) because no code has been written. Then code is implemented so that the test passes
(green). Then the code can be refactored to improve quality.
Throw - If a piece of code runs into an error it can’t or shouldn’t handle on its own, it can throw the
error (or do nothing, in which case the error will usually be thrown automatically). Then the code
that called it will receive the error. That code can also handle, throw, or ignore the error. If the error
is thrown enough times, it can reach the user.
Type - The kind of data stored in a variable, e.g. a whole number, a decimal number, a boolean, a
string, or an object.
Unicorn - A privately-held tech company whose total stock value is over one billion dollars.
Sometimes this word is also used to indicate something incredibly rare and precious, like certain
types of developers.
Unit test - An automated test that makes sure a single, isolated piece of code (like a class or method)
does what it’s expected to do. Unit tests usually run very quickly and can help build confidence in
a tricky piece of code. The best unit tests verify a unit’s behavior, not its implementation—that is,
they test what it does, not how it does it. This way the code can be refactored without breaking the
test.
Usability testing - The practice of having someone (usually a person from outside of the team or
company) use an application or prototype while a member of the team watches. Ideally, the team
member shouldn’t tell the person how to do anything; instead, they should give them an objective
and see if they can figure out how to complete it in the application. This helps the team understand
what parts of the application are confusing or unintuitive.
User interface (UI) - The part of an application that a user looks at and interacts with; or, the work
of designing this part of an application, often done by a graphic designer or someone with artistic
training.
User experience (UX) - The field of study focused on improving the interactions between users and
applications. UX designers may build prototypes or design interfaces, but they’re generally more
concerned with usefulness and user-friendliness than with appearance.
Value - A piece of data. If we say something is “passed by value” to a function, then we mean the
data itself is provided, not the memory address of the variable that holds it. This way the function
Appendix A: A coder’s vocabulary
156
can modify it without affecting the rest of the application.
Variable - A named piece of data in memory. In the statement int x = 1, the variable is x.
Velocity - A measure of development speed based on estimates. Velocity is generally impossible to
measure in a useful way. Incompetent managers often try to increase velocity by making developers
work longer hours and meet shorter deadlines; this always results in a worse product and long-term
damage to the company.
Version control system (VCS) - A system for managing several different versions of a codebase.
Usually there is a main or “master” branch which contains the latest and most official version of
the code, and then several other branches containing work in progress. These other branches can be
merged into the master branch when they’re complete.
Vulnerability - A weakness or bug in an application that hackers could use to steal user data,
crash the application, or gain unauthorized access. Vulnerabilities can be avoided through the use
of security best practices, encryption, input sanitization, and penetration testing.
Waterfall - A development process for software that is delivered all at once, like on a CD. This was
popular in the days before the internet became the primary medium for software distribution. In
Waterfall, planning and design are all done at the beginning of the project, which can make the
process inflexible and prone to error.
Whiteboard interview - A popular but ineffective interview method where candidates are asked to
write code on a whiteboard, chalkboard or sheet of paper. This often includes asking them to solve
complex mathematical or data structure problems with code. Since this doesn’t resemble the work
they’d be doing on a day-to-day basis if they were hired, it’s almost irrelevant to the task of selecting
the most competent candidate.
Workaround - A less-than-ideal way to work when some issue makes the normal way impossible.
If the “Send” button on your email client is broken, but pressing Ctrl + Enter sends the email, that’s
a workaround. You can continue to use the software, but it definitely needs to be fixed.
XY Problem - When a user has a problem (“X”), thinks they know the solution (“Y”), and asks
for help with that solution (“Y”) instead of the original problem (“X”). People sometimes do this to
avoid looking naive (“I have a problem but no idea how to solve it” can be a hard thing to say), or
because they think asking about Y is a smaller or less intrusive question. Sometimes they may not
even recognize that X is their real problem. This often results in confusion and frustration, especially
when the user’s Y isn’t a good solution to X (or isn’t even related to it). For example, suppose your
computer won’t turn on and you decide—for good reasons or bad ones—that the problem is the
power cord. You might call a friend who’s good with computers and ask them where to buy a new
cord. If you’re lucky, they’ll ask some broader questions and find out what’s really going on. If not,
you may find out the hard way that a new cord doesn’t solve the problem, and lose a lot of time and
money in the process.
Appendix B: To make this, learn that
Deciding what to learn can be easier if you know what you want to build. To that end, below are
some things you might be interested in building and some of the most popular tools used to make
them. Note that this isn’t a complete or comprehensive list—there are many more things a developer
can make and many tools used to make them.
To make this
Learn that
Android apps
Java or Kotlin; Android Studio
Cross-platform apps
C# and Xamarin or HTML, CSS,
JavaScript and Phonegap or a front-end
framework and Ionic or Dart and Flutter
or a front-end framework and
NativeScript
Embedded systems, like ATM machines,
gas pumps and credit card readers
C or C++
iOS apps
Swift or Objective-C; Xcode
Video games
C# and Unity or C++ and Unreal Engine
or Lua and Amazon Lumberyard
Web apps
HTML; CSS; SASS or LESS; JavaScript;
Vue or React or Ember; Webpack or
Rollup; TypeScript
Web servers
C# and .NET Framework or JavaScript
and Node.js or Python and Django or
Erlang and Elixir or Ruby and Rails or
PHP and Laravel
Appendix C: Recommended reading
Code Complete by Steve McConnell. A several-hundred-page deep-dive on how to write clean, bug-
free code.
CSS-Tricks (https://css-tricks.com/¹⁵⁶). A website offering simple and extremely well-written guides
for many different web development topics (not just CSS).
Emotional Intelligence for Engineers by April Wensel (https://www.youtube.com/watch?v=yD0kzU4Pu-
Q¹⁵⁷). A discussion of oft-neglected but incredibly important skills in software development.
#firstyearincode on The DEV Community (https://dev.to/t/firstyearincode¹⁵⁸). A collection of posts
related to this book. May include book reviews, chapters from the book, unpublished chapters, and
more.
How to Manage Conflicts by Isaac Lee (https://dev.to/ijlee2/how-to-manage-conflicts-listen-4kmb¹⁵⁹).
A three-part series about effective teamwork, applying the principles of Crucial Conversations to
software development.
How to Think Like a Computer Scientist by Allen Downey, Jeffrey Elkner and Chris Meyers. A very
good how-to-code guide for beginners using the Python language.
It Doesn’t Have to be Crazy at Work by David Heinemeier Hansson and Jason Fried. A manifesto for
running a business, especially a software business, in a sensible way that respects employees and
clients.
Learn You a Haskell for Great Good! by Miran Lipovaca. An introduction to functional programming
with the Haskell programming language.
MDN Web Docs by Mozilla (https://developer.mozilla.org¹⁶⁰). The web’s most well-maintained and
up-to-date source for information about web technologies, including complete documentation for
HTML, CSS, JavaScript, and browser APIs.
The Nature of Software Development by Ron Jeffries. A brief overview of how Agile principles can
be applied to a real-world development team.
Refactoring UI by Adam Wathan and Steve Schoger. A brief introduction to the rules of good user
interface design, written for software developers.
SOLID on Wikipedia (https://en.wikipedia.org/wiki/SOLID¹⁶¹). A starting point for learning about
the most famous principles of good object-oriented code.
¹⁵⁶https://css-tricks.com/
¹⁵⁷https://www.youtube.com/watch?v=yD0kzU4Pu-Q
¹⁵⁸https://dev.to/t/firstyearincode
¹⁵⁹https://dev.to/ijlee2/how-to-manage-conflicts-listen-4kmb
¹⁶⁰https://developer.mozilla.org
¹⁶¹https://en.wikipedia.org/wiki/SOLID
Appendix C: Recommended reading
159
Structure and Interpretation of Computer Programs by Harold Abelson, Gerald Jay Sussman and
Julie Sussman. A classic computer programming manual used at MIT. The full text is available
online at https://mitpress.mit.edu/sites/default/files/sicp/index.html¹⁶².
Three Virtues by Larry Wall (http://threevirtues.com/¹⁶³). A summary of the tongue-in-cheek “great
virtues” of a programmer: laziness, impatience, and hubris.
¹⁶²https://mitpress.mit.edu/sites/default/files/sicp/index.html
¹⁶³http://threevirtues.com/
Acknowledgments
Thanks to everyone who supported this book. It was very much a group effort, and it’s been amazing
to work with all of you.
Thanks to the wonderful DEV Community¹⁶⁴ team for their help organizing and promoting the book.
Thanks to Dylan for your support during long hours of writing and editing. Love you always.
Each of our contributors and beta readers has written a brief message, which you can read below.
Guest authors
I am very thankful to Isaac Lyman for giving us this opportunity to contribute in this
great book. Find more about me @ arslanaslam.me
∼Muhammad Arslan Aslam
My name is Ilona and I am a Frontend Software Engineer based in Berlin. I develop web
apps, study psychology and help #womenwhocode live a life they don’t need a vacation
from. Read my blog at ilonacodes.com and say “Hi” on Twitter: @ilonacodes
∼Ilona Codes
I am a web application developer and passionate about functional programming and
open source. Having multiple side projects going on at the same while trying to fulfill
my entrepreneurial dreams… :) Follow me on Twitter @leonorader and check my blog:
https://fejlesztolany.hu
∼Leonóra Dér
Thank you mom, dad & friends for your support & Isaac Lyman for this opportunity to
help contribute to an amazing cause.
Readers: if you have questions or would like to follow my new journey as I build my new
company (rawpido.com), connect with me at cliffordfajardo.com
∼Clifford Fajardo
Hi, I’m Gianluca Fiore, a software developer from Italy. On the spare time between
tasting coffee, making pizza, travelling, blogging (on https://papersounds.eu) and reading,
I actually do develop software (mostly in Python, Go and JS).
∼Gianluca Fiore
¹⁶⁴https://dev.to
Acknowledgments
161
I would like to thank Kieran for believing in me and supporting me when life felt too
heavy. Thank you for always encouraging me to take the next step.
∼Sabrina Gannon
I would tell you a UDP joke, but you may not get it. I am a passionate software engineer,
dedicated to continuous personal/professional improvement and in the meanwhile, I am
torturing people with my jokes. I am glad to assist you in your first year in code.
∼Periklis Gkolias
I’m a career changer and bootcamp grad. I was helped along the way by so many awesome
people and I’m always trying to pay it forward. Please feel free to reach out!
∼Yechiel Kalmenson
“Simple things should be simple, complex things should be possible.” - Alan Kay
∼Vlad Levin
Thank you for joining the fabulous world of programming. Let’s keep it rich and
interesting, as my own career has been.
Check out my book, “What is Programming?” a further companion to your journey as a
programmer.
Find me at https://edaqa.com/
∼Edaqa Mortoray
During the moments of time where there are crucial decisions to be made, often you
already know what path you feel is the right one to take. I urge you to trust your gut. It’s
the one true compass you can always count on. Trust your compass.
∼Casey Ocampo
I run my life with three words: Build, Test, Launch.
∼Rosalind Thuy Pham
Hi, I’m Desi! I love UX research, finding bugs, and helping people find their dream jobs.
I’m on Twitter @desilove and my portfolio is www.desidoes.dev. Special thanks to my
partner, Evan, for relentless editing of chapter drafts!
∼Desi Rottman
A programmer and entrepreneur with a love of cars, music and technology. https://turnerj.com/
∼James Turner
Acknowledgments
162
I live in Utah and am currently a Senior Software Engineer at GoReact. I have been
programming as a hobby since 2009, professionally since 2012. I’ve contributed to the
community through open source, blog posts garnering over 100,000 reads, as well as
presenting at meetups.
∼John Woodruff
Beta readers
I am Mohammed and I am a Software Developer. I am passionate about social media
analytics and mentoring new or aspiring developers. Special thanks to Isaac Lyman for
the opportunity to participate in this interesting book. Please feel free to follow me on
Twitter @MohammedAlMarh
∼Mohammed Almarhoon
Hi there! I love learning about Web Development, drawing and doing a little bit of exercise
- just a bit! -. I’ll definitely use what I learned with the book to enter the Dev arena and
improve this https://github.com/john-angel. See ya!
∼John Angel
Hi, I’m Glenn, an android developer from Belgium and a huge open source fan. Checkout
my blog posts and projects on https://glennmen.dev
∼Glenn Carremans
I’m a Software Engineer, Entrepreneur and Investor. You’ll find all of my contact info at
http://www.jeremiahcooper.com. Feel free to reach out if you think we can work together
on something.
∼Jeremiah Cooper
I’m a self-taught email & front-end developer. I am passionate about open source
software and encouraging developers to participate. I can be found Tweeting about tech
(https://twitter.com/shannon_crabill) or speaking at conferences. My internet home is
http://shannoncrabill.com.
∼Shannon Crabill
I am a full stack web developer who loves learning and sharing knowledge. Firmly believe
“life is a marathon, not a sprint”. I enjoy sharing web development knowledge on a website
I run called dev-diaries.com
∼Khaliq Gant
Acknowledgments
163
FOR x equals one to ten;
Loop and do it again;
Not sure what to write, I truly am vexed;
This BASIC loop ends with a NEXT.
Doug is a coder, leader, innovator, and teacher. Engage with him at http://www.dougjenkinson.net.
∼Doug Jenkinson
I appreciate to Isaac Lyman, all the authors, and big thank you to Jiyoon. I’m working at
Emotion AI company, “GenesisLab” from South Korea who started a career 2.5 years ago.
I want to say to me in 2009 (when I started). “Please find Isaac and ask him to write this.”
∼Junhong Kim
Shoutout to Udacity and all the awesome people at Sovos who have helped me break into
software engineering, especially Dirk Diegnau!
Thinking about ordering pork online from from a small farm in Minnesota? I got you
covered! tfponline.squarespace.com
ericmiller.dev
@TFP_eric
∼Eric C. Miller, PhD
I am a Tech Writer and YouTuber who explains technology for a living!
∼Amruta Ranade
Thank you Isaac from your help and your support to the community, specially to newbies
like me and also to the authors who beautifully contributed to this great guide.
∼Adrian Skar
https://sysa.la
∼Jan Sysala
Cover design
Cover art created by Cover Story Book Design. Email us at coverstorybookdesign@gmail.com
for your own custom book cover, or to browse our gallery of premade ebook covers! We
design for all genres, fiction and nonfiction.


ID: https://www.mta.ca/~rrosebru/oldcourse/263114/Dsa.pdf
Document: DSA
D a t a  S t r u c t u r e s  a n d  A l g o r i t h m s
Annotated Reference with Examples
Granville Barne!
Luca Del Tongo
Data Structures and Algorithms:
Annotated Reference with Examples
First Edition
Copyright c
⃝Granville Barnett, and Luca Del Tongo 2008.
This book is made exclusively available from DotNetSlackers
(http://dotnetslackers.com/) the place for .NET articles, and news from
some of the leading minds in the software industry.
Contents
1
Introduction
1
1.1
What this book is, and what it isn’t
. . . . . . . . . . . . . . . .
1
1.2
Assumed knowledge
. . . . . . . . . . . . . . . . . . . . . . . . .
1
1.2.1
Big Oh notation
. . . . . . . . . . . . . . . . . . . . . . .
1
1.2.2
Imperative programming language . . . . . . . . . . . . .
3
1.2.3
Object oriented concepts
. . . . . . . . . . . . . . . . . .
4
1.3
Pseudocode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4
1.4
Tips for working through the examples . . . . . . . . . . . . . . .
6
1.5
Book outline
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6
1.6
Testing
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
1.7
Where can I get the code? . . . . . . . . . . . . . . . . . . . . . .
7
1.8
Final messages
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
I
Data Structures
8
2
Linked Lists
9
2.1
Singly Linked List
. . . . . . . . . . . . . . . . . . . . . . . . . .
9
2.1.1
Insertion . . . . . . . . . . . . . . . . . . . . . . . . . . . .
10
2.1.2
Searching . . . . . . . . . . . . . . . . . . . . . . . . . . .
10
2.1.3
Deletion . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11
2.1.4
Traversing the list
. . . . . . . . . . . . . . . . . . . . . .
12
2.1.5
Traversing the list in reverse order . . . . . . . . . . . . .
13
2.2
Doubly Linked List . . . . . . . . . . . . . . . . . . . . . . . . . .
13
2.2.1
Insertion . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15
2.2.2
Deletion . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15
2.2.3
Reverse Traversal . . . . . . . . . . . . . . . . . . . . . . .
16
2.3
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17
3
Binary Search Tree
19
3.1
Insertion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20
3.2
Searching
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21
3.3
Deletion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
22
3.4
Finding the parent of a given node . . . . . . . . . . . . . . . . .
24
3.5
Attaining a reference to a node . . . . . . . . . . . . . . . . . . .
24
3.6
Finding the smallest and largest values in the binary search tree
25
3.7
Tree Traversals . . . . . . . . . . . . . . . . . . . . . . . . . . . .
26
3.7.1
Preorder . . . . . . . . . . . . . . . . . . . . . . . . . . . .
26
I
3.7.2
Postorder . . . . . . . . . . . . . . . . . . . . . . . . . . .
26
3.7.3
Inorder
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
29
3.7.4
Breadth First . . . . . . . . . . . . . . . . . . . . . . . . .
30
3.8
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
4
Heap
32
4.1
Insertion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
33
4.2
Deletion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
37
4.3
Searching
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
38
4.4
Traversal
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
41
4.5
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
42
5
Sets
44
5.1
Unordered . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
46
5.1.1
Insertion . . . . . . . . . . . . . . . . . . . . . . . . . . . .
46
5.2
Ordered . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
47
5.3
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
47
6
Queues
48
6.1
A standard queue . . . . . . . . . . . . . . . . . . . . . . . . . . .
49
6.2
Priority Queue
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
49
6.3
Double Ended Queue . . . . . . . . . . . . . . . . . . . . . . . . .
49
6.4
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
53
7
AVL Tree
54
7.1
Tree Rotations
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
56
7.2
Tree Rebalancing . . . . . . . . . . . . . . . . . . . . . . . . . . .
57
7.3
Insertion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
58
7.4
Deletion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
59
7.5
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
61
II
Algorithms
62
8
Sorting
63
8.1
Bubble Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
63
8.2
Merge Sort
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
63
8.3
Quick Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
65
8.4
Insertion Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
67
8.5
Shell Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
68
8.6
Radix Sort
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
68
8.7
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
70
9
Numeric
72
9.1
Primality Test
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
72
9.2
Base conversions
. . . . . . . . . . . . . . . . . . . . . . . . . . .
72
9.3
Attaining the greatest common denominator of two numbers
. .
73
9.4
Computing the maximum value for a number of a speciﬁc base
consisting of N digits . . . . . . . . . . . . . . . . . . . . . . . . .
74
9.5
Factorial of a number
. . . . . . . . . . . . . . . . . . . . . . . .
74
9.6
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
75
II
10 Searching
76
10.1 Sequential Search . . . . . . . . . . . . . . . . . . . . . . . . . . .
76
10.2 Probability Search . . . . . . . . . . . . . . . . . . . . . . . . . .
76
10.3 Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
77
11 Strings
79
11.1 Reversing the order of words in a sentence . . . . . . . . . . . . .
79
11.2 Detecting a palindrome
. . . . . . . . . . . . . . . . . . . . . . .
80
11.3 Counting the number of words in a string . . . . . . . . . . . . .
81
11.4 Determining the number of repeated words within a string . . . .
83
11.5 Determining the ﬁrst matching character between two strings . .
84
11.6 Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
85
A Algorithm Walkthrough
86
A.1 Iterative algorithms
. . . . . . . . . . . . . . . . . . . . . . . . .
86
A.2 Recursive Algorithms . . . . . . . . . . . . . . . . . . . . . . . . .
88
A.3 Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
90
B Translation Walkthrough
91
B.1
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
92
C Recursive Vs. Iterative Solutions
93
C.1 Activation Records . . . . . . . . . . . . . . . . . . . . . . . . . .
94
C.2 Some problems are recursive in nature . . . . . . . . . . . . . . .
95
C.3 Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
95
D Testing
97
D.1 What constitutes a unit test? . . . . . . . . . . . . . . . . . . . .
97
D.2 When should I write my tests?
. . . . . . . . . . . . . . . . . . .
98
D.3 How seriously should I view my test suite? . . . . . . . . . . . . .
99
D.4 The three A’s . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
99
D.5 The structuring of tests
. . . . . . . . . . . . . . . . . . . . . . .
99
D.6 Code Coverage . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
D.7 Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
E Symbol Deﬁnitions
101
III
Preface
Every book has a story as to how it came about and this one is no diﬀerent,
although we would be lying if we said its development had not been somewhat
impromptu. Put simply this book is the result of a series of emails sent back
and forth between the two authors during the development of a library for
the .NET framework of the same name (with the omission of the subtitle of
course!). The conversation started oﬀsomething like, “Why don’t we create
a more aesthetically pleasing way to present our pseudocode?”
After a few
weeks this new presentation style had in fact grown into pseudocode listings
with chunks of text describing how the data structure or algorithm in question
works and various other things about it. At this point we thought, “What the
heck, let’s make this thing into a book!” And so, in the summer of 2008 we
began work on this book side by side with the actual library implementation.
When we started writing this book the only things that we were sure about
with respect to how the book should be structured were:
1. always make explanations as simple as possible while maintaining a moder-
ately ﬁne degree of precision to keep the more eager minded reader happy;
and
2. inject diagrams to demystify problems that are even moderatly challenging
to visualise (. . . and so we could remember how our own algorithms worked
when looking back at them!); and ﬁnally
3. present concise and self-explanatory pseudocode listings that can be ported
easily to most mainstream imperative programming languages like C++,
C#, and Java.
A key factor of this book and its associated implementations is that all
algorithms (unless otherwise stated) were designed by us, using the theory of
the algorithm in question as a guideline (for which we are eternally grateful to
their original creators). Therefore they may sometimes turn out to be worse
than the “normal” implementations—and sometimes not. We are two fellows
of the opinion that choice is a great thing. Read our book, read several others
on the same subject and use what you see ﬁt from each (if anything) when
implementing your own version of the algorithms in question.
Through this book we hope that you will see the absolute necessity of under-
standing which data structure or algorithm to use for a certain scenario. In all
projects, especially those that are concerned with performance (here we apply
an even greater emphasis on real-time systems) the selection of the wrong data
structure or algorithm can be the cause of a great deal of performance pain.
IV
V
Therefore it is absolutely key that you think about the run time complexity and
space requirements of your selected approach. In this book we only explain the
theoretical implications to consider, but this is for a good reason: compilers are
very diﬀerent in how they work. One C++ compiler may have some amazing
optimisation phases speciﬁcally targeted at recursion, another may not, for ex-
ample. Of course this is just an example but you would be surprised by how
many subtle diﬀerences there are between compilers. These diﬀerences which
may make a fast algorithm slow, and vice versa. We could also factor in the
same concerns about languages that target virtual machines, leaving all the
actual various implementation issues to you given that you will know your lan-
guage’s compiler much better than us...well in most cases. This has resulted in
a more concise book that focuses on what we think are the key issues.
One ﬁnal note: never take the words of others as gospel; verify all that can
be feasibly veriﬁed and make up your own mind.
We hope you enjoy reading this book as much as we have enjoyed writing it.
Granville Barnett
Luca Del Tongo
Acknowledgements
Writing this short book has been a fun and rewarding experience. We would
like to thank, in no particular order the following people who have helped us
during the writing of this book.
Sonu Kapoor generously hosted our book which when we released the ﬁrst
draft received over thirteen thousand downloads, without his generosity this
book would not have been able to reach so many people. Jon Skeet provided us
with an alarming number of suggestions throughout for which we are eternally
grateful. Jon also edited this book as well.
We would also like to thank those who provided the odd suggestion via email
to us. All feedback was listened to and you will no doubt see some content
inﬂuenced by your suggestions.
A special thank you also goes out to those who helped publicise this book
from Microsoft’s Channel 9 weekly show (thanks Dan!) to the many bloggers
who helped spread the word. You gave us an audience and for that we are
extremely grateful.
Thank you to all who contributed in some way to this book. The program-
ming community never ceases to amaze us in how willing its constituents are to
give time to projects such as this one. Thank you.
VI
About the Authors
Granville Barnett
Granville is currently a Ph.D candidate at Queensland University of Technology
(QUT) working on parallelism at the Microsoft QUT eResearch Centre1. He also
holds a degree in Computer Science, and is a Microsoft MVP. His main interests
are in programming languages and compilers. Granville can be contacted via
one of two places: either his personal website (http://gbarnett.org) or his
blog (http://msmvps.com/blogs/gbarnett).
Luca Del Tongo
Luca is currently studying for his masters degree in Computer Science at Flo-
rence. His main interests vary from web development to research ﬁelds such as
data mining and computer vision. Luca also maintains an Italian blog which
can be found at http://blogs.ugidotnet.org/wetblog/.
1http://www.mquter.qut.edu.au/
VII
Page intentionally left blank.
Chapter 1
Introduction
1.1
What this book is, and what it isn’t
This book provides implementations of common and uncommon algorithms in
pseudocode which is language independent and provides for easy porting to most
imperative programming languages. It is not a deﬁnitive book on the theory of
data structures and algorithms.
For the most part this book presents implementations devised by the authors
themselves based on the concepts by which the respective algorithms are based
upon so it is more than possible that our implementations diﬀer from those
considered the norm.
You should use this book alongside another on the same subject, but one
that contains formal proofs of the algorithms in question. In this book we use
the abstract big Oh notation to depict the run time complexity of algorithms
so that the book appeals to a larger audience.
1.2
Assumed knowledge
We have written this book with few assumptions of the reader, but some have
been necessary in order to keep the book as concise and approachable as possible.
We assume that the reader is familiar with the following:
1. Big Oh notation
2. An imperative programming language
3. Object oriented concepts
1.2.1
Big Oh notation
For run time complexity analysis we use big Oh notation extensively so it is vital
that you are familiar with the general concepts to determine which is the best
algorithm for you in certain scenarios. We have chosen to use big Oh notation
for a few reasons, the most important of which is that it provides an abstract
measurement by which we can judge the performance of algorithms without
using mathematical proofs.
1
CHAPTER 1. INTRODUCTION
2
Figure 1.1: Algorithmic run time expansion
Figure 1.1 shows some of the run times to demonstrate how important it is to
choose an eﬃcient algorithm. For the sanity of our graph we have omitted cubic
O(n3), and exponential O(2n) run times. Cubic and exponential algorithms
should only ever be used for very small problems (if ever!); avoid them if feasibly
possible.
The following list explains some of the most common big Oh notations:
O(1) constant: the operation doesn’t depend on the size of its input, e.g. adding
a node to the tail of a linked list where we always maintain a pointer to
the tail node.
O(n) linear: the run time complexity is proportionate to the size of n.
O(log n) logarithmic: normally associated with algorithms that break the problem
into smaller chunks per each invocation, e.g. searching a binary search
tree.
O(n log n) just n log n: usually associated with an algorithm that breaks the problem
into smaller chunks per each invocation, and then takes the results of these
smaller chunks and stitches them back together, e.g. quick sort.
O(n2) quadratic: e.g. bubble sort.
O(n3) cubic: very rare.
O(2n) exponential: incredibly rare.
If you encounter either of the latter two items (cubic and exponential) this is
really a signal for you to review the design of your algorithm. While prototyp-
ing algorithm designs you may just have the intention of solving the problem
irrespective of how fast it works. We would strongly advise that you always
review your algorithm design and optimise where possible—particularly loops
CHAPTER 1. INTRODUCTION
3
and recursive calls—so that you can get the most eﬃcient run times for your
algorithms.
The biggest asset that big Oh notation gives us is that it allows us to es-
sentially discard things like hardware. If you have two sorting algorithms, one
with a quadratic run time, and the other with a logarithmic run time then the
logarithmic algorithm will always be faster than the quadratic one when the
data set becomes suitably large. This applies even if the former is ran on a ma-
chine that is far faster than the latter. Why? Because big Oh notation isolates
a key factor in algorithm analysis: growth. An algorithm with a quadratic run
time grows faster than one with a logarithmic run time. It is generally said at
some point as n →∞the logarithmic algorithm will become faster than the
quadratic algorithm.
Big Oh notation also acts as a communication tool. Picture the scene: you
are having a meeting with some fellow developers within your product group.
You are discussing prototype algorithms for node discovery in massive networks.
Several minutes elapse after you and two others have discussed your respective
algorithms and how they work. Does this give you a good idea of how fast each
respective algorithm is? No. The result of such a discussion will tell you more
about the high level algorithm design rather than its eﬃciency. Replay the scene
back in your head, but this time as well as talking about algorithm design each
respective developer states the asymptotic run time of their algorithm. Using
the latter approach you not only get a good general idea about the algorithm
design, but also key eﬃciency data which allows you to make better choices
when it comes to selecting an algorithm ﬁt for purpose.
Some readers may actually work in a product group where they are given
budgets per feature. Each feature holds with it a budget that represents its up-
permost time bound. If you save some time in one feature it doesn’t necessarily
give you a buﬀer for the remaining features. Imagine you are working on an
application, and you are in the team that is developing the routines that will
essentially spin up everything that is required when the application is started.
Everything is great until your boss comes in and tells you that the start up
time should not exceed n ms. The eﬃciency of every algorithm that is invoked
during start up in this example is absolutely key to a successful product. Even
if you don’t have these budgets you should still strive for optimal solutions.
Taking a quantitative approach for many software development properties
will make you a far superior programmer - measuring one’s work is critical to
success.
1.2.2
Imperative programming language
All examples are given in a pseudo-imperative coding format and so the reader
must know the basics of some imperative mainstream programming language
to port the examples eﬀectively, we have written this book with the following
target languages in mind:
1. C++
2. C#
3. Java
CHAPTER 1. INTRODUCTION
4
The reason that we are explicit in this requirement is simple—all our imple-
mentations are based on an imperative thinking style. If you are a functional
programmer you will need to apply various aspects from the functional paradigm
to produce eﬃcient solutions with respect to your functional language whether
it be Haskell, F#, OCaml, etc.
Two of the languages that we have listed (C# and Java) target virtual
machines which provide various things like security sand boxing, and memory
management via garbage collection algorithms. It is trivial to port our imple-
mentations to these languages. When porting to C++ you must remember to
use pointers for certain things. For example, when we describe a linked list
node as having a reference to the next node, this description is in the context
of a managed environment. In C++ you should interpret the reference as a
pointer to the next node and so on. For programmers who have a fair amount
of experience with their respective language these subtleties will present no is-
sue, which is why we really do emphasise that the reader must be comfortable
with at least one imperative language in order to successfully port the pseudo-
implementations in this book.
It is essential that the user is familiar with primitive imperative language
constructs before reading this book otherwise you will just get lost. Some algo-
rithms presented in this book can be confusing to follow even for experienced
programmers!
1.2.3
Object oriented concepts
For the most part this book does not use features that are speciﬁc to any one
language. In particular, we never provide data structures or algorithms that
work on generic types—this is in order to make the samples as easy to follow
as possible. However, to appreciate the designs of our data structures you will
need to be familiar with the following object oriented (OO) concepts:
1. Inheritance
2. Encapsulation
3. Polymorphism
This is especially important if you are planning on looking at the C# target
that we have implemented (more on that in §1.7) which makes extensive use
of the OO concepts listed above. As a ﬁnal note it is also desirable that the
reader is familiar with interfaces as the C# target uses interfaces throughout
the sorting algorithms.
1.3
Pseudocode
Throughout this book we use pseudocode to describe our solutions. For the
most part interpreting the pseudocode is trivial as it looks very much like a
more abstract C++, or C#, but there are a few things to point out:
1. Pre-conditions should always be enforced
2. Post-conditions represent the result of applying algorithm a to data struc-
ture d
CHAPTER 1. INTRODUCTION
5
3. The type of parameters is inferred
4. All primitive language constructs are explicitly begun and ended
If an algorithm has a return type it will often be presented in the post-
condition, but where the return type is suﬃciently obvious it may be omitted
for the sake of brevity.
Most algorithms in this book require parameters, and because we assign no
explicit type to those parameters the type is inferred from the contexts in which
it is used, and the operations performed upon it. Additionally, the name of
the parameter usually acts as the biggest clue to its type. For instance n is a
pseudo-name for a number and so you can assume unless otherwise stated that
n translates to an integer that has the same number of bits as a WORD on a
32 bit machine, similarly l is a pseudo-name for a list where a list is a resizeable
array (e.g. a vector).
The last major point of reference is that we always explicitly end a language
construct.
For instance if we wish to close the scope of a for loop we will
explicitly state end for rather than leaving the interpretation of when scopes
are closed to the reader. While implicit scope closure works well in simple code,
in complex cases it can lead to ambiguity.
The pseudocode style that we use within this book is rather straightforward.
All algorithms start with a simple algorithm signature, e.g.
1) algorithm AlgorithmName(arg1, arg2, ..., argN)
2) ...
n) end AlgorithmName
Immediately after the algorithm signature we list any Pre or Post condi-
tions.
1) algorithm AlgorithmName(n)
2)
Pre: n is the value to compute the factorial of
3)
n ≥0
4)
Post: the factorial of n has been computed
5)
// ...
n) end AlgorithmName
The example above describes an algorithm by the name of AlgorithmName,
which takes a single numeric parameter n. The pre and post conditions follow
the algorithm signature; you should always enforce the pre-conditions of an
algorithm when porting them to your language of choice.
Normally what is listed as a pre-conidition is critical to the algorithms opera-
tion. This may cover things like the actual parameter not being null, or that the
collection passed in must contain at least n items. The post-condition mainly
describes the eﬀect of the algorithms operation. An example of a post-condition
might be “The list has been sorted in ascending order”
Because everything we describe is language independent you will need to
make your own mind up on how to best handle pre-conditions. For example,
in the C# target we have implemented, we consider non-conformance to pre-
conditions to be exceptional cases. We provide a message in the exception to
tell the caller why the algorithm has failed to execute normally.
CHAPTER 1. INTRODUCTION
6
1.4
Tips for working through the examples
As with most books you get out what you put in and so we recommend that in
order to get the most out of this book you work through each algorithm with a
pen and paper to track things like variable names, recursive calls etc.
The best way to work through algorithms is to set up a table, and in that
table give each variable its own column and continuously update these columns.
This will help you keep track of and visualise the mutations that are occurring
throughout the algorithm.
Often while working through algorithms in such
a way you can intuitively map relationships between data structures rather
than trying to work out a few values on paper and the rest in your head. We
suggest you put everything on paper irrespective of how trivial some variables
and calculations may be so that you always have a point of reference.
When dealing with recursive algorithm traces we recommend you do the
same as the above, but also have a table that records function calls and who
they return to. This approach is a far cleaner way than drawing out an elaborate
map of function calls with arrows to one another, which gets large quickly and
simply makes things more complex to follow. Track everything in a simple and
systematic way to make your time studying the implementations far easier.
1.5
Book outline
We have split this book into two parts:
Part 1: Provides discussion and pseudo-implementations of common and uncom-
mon data structures; and
Part 2: Provides algorithms of varying purposes from sorting to string operations.
The reader doesn’t have to read the book sequentially from beginning to
end: chapters can be read independently from one another. We suggest that
in part 1 you read each chapter in its entirety, but in part 2 you can get away
with just reading the section of a chapter that describes the algorithm you are
interested in.
Each of the chapters on data structures present initially the algorithms con-
cerned with:
1. Insertion
2. Deletion
3. Searching
The previous list represents what we believe in the vast majority of cases to
be the most important for each respective data structure.
For all readers we recommend that before looking at any algorithm you
quickly look at Appendix E which contains a table listing the various symbols
used within our algorithms and their meaning. One keyword that we would like
to point out here is yield. You can think of yield in the same light as return.
The return keyword causes the method to exit and returns control to the caller,
whereas yield returns each value to the caller. With yield control only returns
to the caller when all values to return to the caller have been exhausted.
CHAPTER 1. INTRODUCTION
7
1.6
Testing
All the data structures and algorithms have been tested using a minimised test
driven development style on paper to ﬂesh out the pseudocode algorithm. We
then transcribe these tests into unit tests satisfying them one by one. When
all the test cases have been progressively satisﬁed we consider that algorithm
suitably tested.
For the most part algorithms have fairly obvious cases which need to be
satisﬁed. Some however have many areas which can prove to be more complex
to satisfy. With such algorithms we will point out the test cases which are tricky
and the corresponding portions of pseudocode within the algorithm that satisfy
that respective case.
As you become more familiar with the actual problem you will be able to
intuitively identify areas which may cause problems for your algorithms imple-
mentation. This in some cases will yield an overwhelming list of concerns which
will hinder your ability to design an algorithm greatly. When you are bom-
barded with such a vast amount of concerns look at the overall problem again
and sub-divide the problem into smaller problems. Solving the smaller problems
and then composing them is a far easier task than clouding your mind with too
many little details.
The only type of testing that we use in the implementation of all that is
provided in this book are unit tests. Because unit tests contribute such a core
piece of creating somewhat more stable software we invite the reader to view
Appendix D which describes testing in more depth.
1.7
Where can I get the code?
This book doesn’t provide any code speciﬁcally aligned with it, however we do
actively maintain an open source project1 that houses a C# implementation of
all the pseudocode listed. The project is named Data Structures and Algorithms
(DSA) and can be found at http://codeplex.com/dsa.
1.8
Final messages
We have just a few ﬁnal messages to the reader that we hope you digest before
you embark on reading this book:
1. Understand how the algorithm works ﬁrst in an abstract sense; and
2. Always work through the algorithms on paper to understand how they
achieve their outcome
If you always follow these key points, you will get the most out of this book.
1All readers are encouraged to provide suggestions, feature requests, and bugs so we can
further improve our implementations.
Part I
Data Structures
8
Chapter 2
Linked Lists
Linked lists can be thought of from a high level perspective as being a series
of nodes. Each node has at least a single pointer to the next node, and in the
last node’s case a null pointer representing that there are no more nodes in the
linked list.
In DSA our implementations of linked lists always maintain head and tail
pointers so that insertion at either the head or tail of the list is a constant
time operation. Random insertion is excluded from this and will be a linear
operation. As such, linked lists in DSA have the following characteristics:
1. Insertion is O(1)
2. Deletion is O(n)
3. Searching is O(n)
Out of the three operations the one that stands out is that of insertion. In
DSA we chose to always maintain pointers (or more aptly references) to the
node(s) at the head and tail of the linked list and so performing a traditional
insertion to either the front or back of the linked list is an O(1) operation. An
exception to this rule is performing an insertion before a node that is neither
the head nor tail in a singly linked list. When the node we are inserting before
is somewhere in the middle of the linked list (known as random insertion) the
complexity is O(n). In order to add before the designated node we need to
traverse the linked list to ﬁnd that node’s current predecessor. This traversal
yields an O(n) run time.
This data structure is trivial, but linked lists have a few key points which at
times make them very attractive:
1. the list is dynamically resized, thus it incurs no copy penalty like an array
or vector would eventually incur; and
2. insertion is O(1).
2.1
Singly Linked List
Singly linked lists are one of the most primitive data structures you will ﬁnd in
this book. Each node that makes up a singly linked list consists of a value, and
a reference to the next node (if any) in the list.
9
CHAPTER 2. LINKED LISTS
10
Figure 2.1: Singly linked list node
Figure 2.2: A singly linked list populated with integers
2.1.1
Insertion
In general when people talk about insertion with respect to linked lists of any
form they implicitly refer to the adding of a node to the tail of the list. When
you use an API like that of DSA and you see a general purpose method that
adds a node to the list, you can assume that you are adding the node to the tail
of the list not the head.
Adding a node to a singly linked list has only two cases:
1. head = ∅in which case the node we are adding is now both the head and
tail of the list; or
2. we simply need to append our node onto the end of the list updating the
tail reference appropriately.
1) algorithm Add(value)
2)
Pre: value is the value to add to the list
3)
Post: value has been placed at the tail of the list
4)
n ←node(value)
5)
if head = ∅
6)
head ←n
7)
tail ←n
8)
else
9)
tail.Next ←n
10)
tail ←n
11)
end if
12) end Add
As an example of the previous algorithm consider adding the following se-
quence of integers to the list: 1, 45, 60, and 12, the resulting list is that of
Figure 2.2.
2.1.2
Searching
Searching a linked list is straightforward: we simply traverse the list checking
the value we are looking for with the value of each node in the linked list. The
algorithm listed in this section is very similar to that used for traversal in §2.1.4.
CHAPTER 2. LINKED LISTS
11
1) algorithm Contains(head, value)
2)
Pre: head is the head node in the list
3)
value is the value to search for
4)
Post: the item is either in the linked list, true; otherwise false
5)
n ←head
6)
while n ̸= ∅and n.Value ̸= value
7)
n ←n.Next
8)
end while
9)
if n = ∅
10)
return false
11)
end if
12)
return true
13) end Contains
2.1.3
Deletion
Deleting a node from a linked list is straightforward but there are a few cases
we need to account for:
1. the list is empty; or
2. the node to remove is the only node in the linked list; or
3. we are removing the head node; or
4. we are removing the tail node; or
5. the node to remove is somewhere in between the head and tail; or
6. the item to remove doesn’t exist in the linked list
The algorithm whose cases we have described will remove a node from any-
where within a list irrespective of whether the node is the head etc. If you know
that items will only ever be removed from the head or tail of the list then you
can create much more concise algorithms. In the case of always removing from
the front of the linked list deletion becomes an O(1) operation.
CHAPTER 2. LINKED LISTS
12
1) algorithm Remove(head, value)
2)
Pre: head is the head node in the list
3)
value is the value to remove from the list
4)
Post: value is removed from the list, true; otherwise false
5)
if head = ∅
6)
// case 1
7)
return false
8)
end if
9)
n ←head
10)
if n.Value = value
11)
if head = tail
12)
// case 2
13)
head ←∅
14)
tail ←∅
15)
else
16)
// case 3
17)
head ←head.Next
18)
end if
19)
return true
20)
end if
21)
while n.Next ̸= ∅and n.Next.Value ̸= value
22)
n ←n.Next
23)
end while
24)
if n.Next ̸= ∅
25)
if n.Next = tail
26)
// case 4
27)
tail ←n
28)
end if
29)
// this is only case 5 if the conditional on line 25 was false
30)
n.Next ←n.Next.Next
31)
return true
32)
end if
33)
// case 6
34)
return false
35) end Remove
2.1.4
Traversing the list
Traversing a singly linked list is the same as that of traversing a doubly linked
list (deﬁned in §2.2). You start at the head of the list and continue until you
come across a node that is ∅. The two cases are as follows:
1. node = ∅, we have exhausted all nodes in the linked list; or
2. we must update the node reference to be node.Next.
The algorithm described is a very simple one that makes use of a simple
while loop to check the ﬁrst case.
CHAPTER 2. LINKED LISTS
13
1) algorithm Traverse(head)
2)
Pre: head is the head node in the list
3)
Post: the items in the list have been traversed
4)
n ←head
5)
while n ̸= 0
6)
yield n.Value
7)
n ←n.Next
8)
end while
9) end Traverse
2.1.5
Traversing the list in reverse order
Traversing a singly linked list in a forward manner (i.e. left to right) is simple
as demonstrated in §2.1.4. However, what if we wanted to traverse the nodes in
the linked list in reverse order for some reason? The algorithm to perform such
a traversal is very simple, and just like demonstrated in §2.1.3 we will need to
acquire a reference to the predecessor of a node, even though the fundamental
characteristics of the nodes that make up a singly linked list make this an
expensive operation. For each node, ﬁnding its predecessor is an O(n) operation,
so over the course of traversing the whole list backwards the cost becomes O(n2).
Figure 2.3 depicts the following algorithm being applied to a linked list with
the integers 5, 10, 1, and 40.
1) algorithm ReverseTraversal(head, tail)
2)
Pre: head and tail belong to the same list
3)
Post: the items in the list have been traversed in reverse order
4)
if tail ̸= ∅
5)
curr ←tail
6)
while curr ̸= head
7)
prev ←head
8)
while prev.Next ̸= curr
9)
prev ←prev.Next
10)
end while
11)
yield curr.Value
12)
curr ←prev
13)
end while
14)
yield curr.Value
15)
end if
16) end ReverseTraversal
This algorithm is only of real interest when we are using singly linked lists,
as you will soon see that doubly linked lists (deﬁned in §2.2) make reverse list
traversal simple and eﬃcient, as shown in §2.2.3.
2.2
Doubly Linked List
Doubly linked lists are very similar to singly linked lists. The only diﬀerence is
that each node has a reference to both the next and previous nodes in the list.
CHAPTER 2. LINKED LISTS
14
Figure 2.3: Reverse traveral of a singly linked list
Figure 2.4: Doubly linked list node
CHAPTER 2. LINKED LISTS
15
The following algorithms for the doubly linked list are exactly the same as
those listed previously for the singly linked list:
1. Searching (deﬁned in §2.1.2)
2. Traversal (deﬁned in §2.1.4)
2.2.1
Insertion
The only major diﬀerence between the algorithm in §2.1.1 is that we need to
remember to bind the previous pointer of n to the previous tail node if n was
not the ﬁrst node to be inserted into the list.
1) algorithm Add(value)
2)
Pre: value is the value to add to the list
3)
Post: value has been placed at the tail of the list
4)
n ←node(value)
5)
if head = ∅
6)
head ←n
7)
tail ←n
8)
else
9)
n.Previous ←tail
10)
tail.Next ←n
11)
tail ←n
12)
end if
13) end Add
Figure 2.5 shows the doubly linked list after adding the sequence of integers
deﬁned in §2.1.1.
Figure 2.5: Doubly linked list populated with integers
2.2.2
Deletion
As you may of guessed the cases that we use for deletion in a doubly linked
list are exactly the same as those deﬁned in §2.1.3. Like insertion we have the
added task of binding an additional reference (Previous) to the correct value.
CHAPTER 2. LINKED LISTS
16
1) algorithm Remove(head, value)
2)
Pre: head is the head node in the list
3)
value is the value to remove from the list
4)
Post: value is removed from the list, true; otherwise false
5)
if head = ∅
6)
return false
7)
end if
8)
if value = head.Value
9)
if head = tail
10)
head ←∅
11)
tail ←∅
12)
else
13)
head ←head.Next
14)
head.Previous ←∅
15)
end if
16)
return true
17)
end if
18)
n ←head.Next
19)
while n ̸= ∅and value ̸= n.Value
20)
n ←n.Next
21)
end while
22)
if n = tail
23)
tail ←tail.Previous
24)
tail.Next ←∅
25)
return true
26)
else if n ̸= ∅
27)
n.Previous.Next ←n.Next
28)
n.Next.Previous ←n.Previous
29)
return true
30)
end if
31)
return false
32) end Remove
2.2.3
Reverse Traversal
Singly linked lists have a forward only design, which is why the reverse traversal
algorithm deﬁned in §2.1.5 required some creative invention. Doubly linked lists
make reverse traversal as simple as forward traversal (deﬁned in §2.1.4) except
that we start at the tail node and update the pointers in the opposite direction.
Figure 2.6 shows the reverse traversal algorithm in action.
CHAPTER 2. LINKED LISTS
17
Figure 2.6: Doubly linked list reverse traversal
1) algorithm ReverseTraversal(tail)
2)
Pre: tail is the tail node of the list to traverse
3)
Post: the list has been traversed in reverse order
4)
n ←tail
5)
while n ̸= ∅
6)
yield n.Value
7)
n ←n.Previous
8)
end while
9) end ReverseTraversal
2.3
Summary
Linked lists are good to use when you have an unknown number of items to
store. Using a data structure like an array would require you to specify the size
up front; exceeding that size involves invoking a resizing algorithm which has
a linear run time. You should also use linked lists when you will only remove
nodes at either the head or tail of the list to maintain a constant run time.
This requires maintaining pointers to the nodes at the head and tail of the list
but the memory overhead will pay for itself if this is an operation you will be
performing many times.
What linked lists are not very good for is random insertion, accessing nodes
by index, and searching. At the expense of a little memory (in most cases 4
bytes would suﬃce), and a few more read/writes you could maintain a count
variable that tracks how many items are contained in the list so that accessing
such a primitive property is a constant operation - you just need to update
count during the insertion and deletion algorithms.
Singly linked lists should be used when you are only performing basic in-
sertions. In general doubly linked lists are more accommodating for non-trivial
operations on a linked list.
We recommend the use of a doubly linked list when you require forwards
and backwards traversal. For the most cases this requirement is present. For
example, consider a token stream that you want to parse in a recursive descent
fashion. Sometimes you will have to backtrack in order to create the correct
parse tree.
In this scenario a doubly linked list is best as its design makes
bi-directional traversal much simpler and quicker than that of a singly linked
CHAPTER 2. LINKED LISTS
18
list.
Chapter 3
Binary Search Tree
Binary search trees (BSTs) are very simple to understand. We start with a root
node with value x, where the left subtree of x contains nodes with values < x
and the right subtree contains nodes whose values are ≥x. Each node follows
the same rules with respect to nodes in their left and right subtrees.
BSTs are of interest because they have operations which are favourably fast:
insertion, look up, and deletion can all be done in O(log n) time. It is important
to note that the O(log n) times for these operations can only be attained if
the BST is reasonably balanced; for a tree data structure with self balancing
properties see AVL tree deﬁned in §7).
In the following examples you can assume, unless used as a parameter alias
that root is a reference to the root node of the tree.
23
14
31
7
17
9
Figure 3.1: Simple unbalanced binary search tree
19
CHAPTER 3. BINARY SEARCH TREE
20
3.1
Insertion
As mentioned previously insertion is an O(log n) operation provided that the
tree is moderately balanced.
1) algorithm Insert(value)
2)
Pre: value has passed custom type checks for type T
3)
Post: value has been placed in the correct location in the tree
4)
if root = ∅
5)
root ←node(value)
6)
else
7)
InsertNode(root, value)
8)
end if
9) end Insert
1) algorithm InsertNode(current, value)
2)
Pre: current is the node to start from
3)
Post: value has been placed in the correct location in the tree
4)
if value < current.Value
5)
if current.Left = ∅
6)
current.Left ←node(value)
7)
else
8)
InsertNode(current.Left, value)
9)
end if
10)
else
11)
if current.Right = ∅
12)
current.Right ←node(value)
13)
else
14)
InsertNode(current.Right, value)
15)
end if
16)
end if
17) end InsertNode
The insertion algorithm is split for a good reason. The ﬁrst algorithm (non-
recursive) checks a very core base case - whether or not the tree is empty. If
the tree is empty then we simply create our root node and ﬁnish. In all other
cases we invoke the recursive InsertNode algorithm which simply guides us to
the ﬁrst appropriate place in the tree to put value. Note that at each stage we
perform a binary chop: we either choose to recurse into the left subtree or the
right by comparing the new value with that of the current node. For any totally
ordered type, no value can simultaneously satisfy the conditions to place it in
both subtrees.
CHAPTER 3. BINARY SEARCH TREE
21
3.2
Searching
Searching a BST is even simpler than insertion. The pseudocode is self-explanatory
but we will look brieﬂy at the premise of the algorithm nonetheless.
We have talked previously about insertion, we go either left or right with the
right subtree containing values that are ≥x where x is the value of the node
we are inserting. When searching the rules are made a little more atomic and
at any one time we have four cases to consider:
1. the root = ∅in which case value is not in the BST; or
2. root.Value = value in which case value is in the BST; or
3. value < root.Value, we must inspect the left subtree of root for value; or
4. value > root.Value, we must inspect the right subtree of root for value.
1) algorithm Contains(root, value)
2)
Pre: root is the root node of the tree, value is what we would like to locate
3)
Post: value is either located or not
4)
if root = ∅
5)
return false
6)
end if
7)
if root.Value = value
8)
return true
9)
else if value < root.Value
10)
return Contains(root.Left, value)
11)
else
12)
return Contains(root.Right, value)
13)
end if
14) end Contains
CHAPTER 3. BINARY SEARCH TREE
22
3.3
Deletion
Removing a node from a BST is fairly straightforward, with four cases to con-
sider:
1. the value to remove is a leaf node; or
2. the value to remove has a right subtree, but no left subtree; or
3. the value to remove has a left subtree, but no right subtree; or
4. the value to remove has both a left and right subtree in which case we
promote the largest value in the left subtree.
There is also an implicit ﬁfth case whereby the node to be removed is the
only node in the tree. This case is already covered by the ﬁrst, but should be
noted as a possibility nonetheless.
Of course in a BST a value may occur more than once. In such a case the
ﬁrst occurrence of that value in the BST will be removed.
23
14
31
7
9
#1: Leaf Node
#2: Right subtree
      no left subtree
#3: Left subtree
      no right subtree
#4: Right subtree
      and left subtree
Figure 3.2: binary search tree deletion cases
The Remove algorithm given below relies on two further helper algorithms
named FindParent, and FindNode which are described in §3.4 and §3.5 re-
spectively.
CHAPTER 3. BINARY SEARCH TREE
23
1) algorithm Remove(value)
2)
Pre: value is the value of the node to remove, root is the root node of the BST
3)
Count is the number of items in the BST
3)
Post: node with value is removed if found in which case yields true, otherwise false
4)
nodeToRemove ←FindNode(value)
5)
if nodeToRemove = ∅
6)
return false // value not in BST
7)
end if
8)
parent ←FindParent(value)
9)
if Count = 1
10)
root ←∅// we are removing the only node in the BST
11)
else if nodeToRemove.Left = ∅and nodeToRemove.Right = null
12)
// case #1
13)
if nodeToRemove.Value < parent.Value
14)
parent.Left ←∅
15)
else
16)
parent.Right ←∅
17)
end if
18)
else if nodeToRemove.Left = ∅and nodeToRemove.Right ̸= ∅
19)
// case # 2
20)
if nodeToRemove.Value < parent.Value
21)
parent.Left ←nodeToRemove.Right
22)
else
23)
parent.Right ←nodeToRemove.Right
24)
end if
25)
else if nodeToRemove.Left ̸= ∅and nodeToRemove.Right = ∅
26)
// case #3
27)
if nodeToRemove.Value < parent.Value
28)
parent.Left ←nodeToRemove.Left
29)
else
30)
parent.Right ←nodeToRemove.Left
31)
end if
32)
else
33)
// case #4
34)
largestV alue ←nodeToRemove.Left
35)
while largestV alue.Right ̸= ∅
36)
// ﬁnd the largest value in the left subtree of nodeToRemove
37)
largestV alue ←largestV alue.Right
38)
end while
39)
// set the parents’ Right pointer of largestV alue to ∅
40)
FindParent(largestV alue.Value).Right ←∅
41)
nodeToRemove.Value ←largestV alue.Value
42)
end if
43)
Count ←Count −1
44)
return true
45) end Remove
CHAPTER 3. BINARY SEARCH TREE
24
3.4
Finding the parent of a given node
The purpose of this algorithm is simple - to return a reference (or pointer) to
the parent node of the one with the given value. We have found that such an
algorithm is very useful, especially when performing extensive tree transforma-
tions.
1) algorithm FindParent(value, root)
2)
Pre: value is the value of the node we want to ﬁnd the parent of
3)
root is the root node of the BST and is ! = ∅
4)
Post: a reference to the parent node of value if found; otherwise ∅
5)
if value = root.Value
6)
return ∅
7)
end if
8)
if value < root.Value
9)
if root.Left = ∅
10)
return ∅
11)
else if root.Left.Value = value
12)
return root
13)
else
14)
return FindParent(value, root.Left)
15)
end if
16)
else
17)
if root.Right = ∅
18)
return ∅
19)
else if root.Right.Value = value
20)
return root
21)
else
22)
return FindParent(value, root.Right)
23)
end if
24)
end if
25) end FindParent
A special case in the above algorithm is when the speciﬁed value does not
exist in the BST, in which case we return ∅. Callers to this algorithm must take
account of this possibility unless they are already certain that a node with the
speciﬁed value exists.
3.5
Attaining a reference to a node
This algorithm is very similar to §3.4, but instead of returning a reference to the
parent of the node with the speciﬁed value, it returns a reference to the node
itself. Again, ∅is returned if the value isn’t found.
CHAPTER 3. BINARY SEARCH TREE
25
1) algorithm FindNode(root, value)
2)
Pre: value is the value of the node we want to ﬁnd the parent of
3)
root is the root node of the BST
4)
Post: a reference to the node of value if found; otherwise ∅
5)
if root = ∅
6)
return ∅
7)
end if
8)
if root.Value = value
9)
return root
10)
else if value < root.Value
11)
return FindNode(root.Left, value)
12)
else
13)
return FindNode(root.Right, value)
14)
end if
15) end FindNode
Astute readers will have noticed that the FindNode algorithm is exactly the
same as the Contains algorithm (deﬁned in §3.2) with the modiﬁcation that
we are returning a reference to a node not true or false. Given FindNode,
the easiest way of implementing Contains is to call FindNode and compare the
return value with ∅.
3.6
Finding the smallest and largest values in
the binary search tree
To ﬁnd the smallest value in a BST you simply traverse the nodes in the left
subtree of the BST always going left upon each encounter with a node, termi-
nating when you ﬁnd a node with no left subtree. The opposite is the case when
ﬁnding the largest value in the BST. Both algorithms are incredibly simple, and
are listed simply for completeness.
The base case in both FindMin, and FindMax algorithms is when the Left
(FindMin), or Right (FindMax) node references are ∅in which case we have
reached the last node.
1) algorithm FindMin(root)
2)
Pre: root is the root node of the BST
3)
root ̸= ∅
4)
Post: the smallest value in the BST is located
5)
if root.Left = ∅
6)
return root.Value
7)
end if
8)
FindMin(root.Left)
9) end FindMin
CHAPTER 3. BINARY SEARCH TREE
26
1) algorithm FindMax(root)
2)
Pre: root is the root node of the BST
3)
root ̸= ∅
4)
Post: the largest value in the BST is located
5)
if root.Right = ∅
6)
return root.Value
7)
end if
8)
FindMax(root.Right)
9) end FindMax
3.7
Tree Traversals
There are various strategies which can be employed to traverse the items in a
tree; the choice of strategy depends on which node visitation order you require.
In this section we will touch on the traversals that DSA provides on all data
structures that derive from BinarySearchTree.
3.7.1
Preorder
When using the preorder algorithm, you visit the root ﬁrst, then traverse the left
subtree and ﬁnally traverse the right subtree. An example of preorder traversal
is shown in Figure 3.3.
1) algorithm Preorder(root)
2)
Pre: root is the root node of the BST
3)
Post: the nodes in the BST have been visited in preorder
4)
if root ̸= ∅
5)
yield root.Value
6)
Preorder(root.Left)
7)
Preorder(root.Right)
8)
end if
9) end Preorder
3.7.2
Postorder
This algorithm is very similar to that described in §3.7.1, however the value
of the node is yielded after traversing both subtrees. An example of postorder
traversal is shown in Figure 3.4.
1) algorithm Postorder(root)
2)
Pre: root is the root node of the BST
3)
Post: the nodes in the BST have been visited in postorder
4)
if root ̸= ∅
5)
Postorder(root.Left)
6)
Postorder(root.Right)
7)
yield root.Value
8)
end if
9) end Postorder
CHAPTER 3. BINARY SEARCH TREE
27
23
14
31
7
17
9
23
14
31
7
9
23
14
31
7
9
23
14
31
7
9
23
14
31
7
9
23
14
31
7
9
(a)
(b)
(c)
(d)
(e)
(f)
17
17
17
17
17
Figure 3.3: Preorder visit binary search tree example
CHAPTER 3. BINARY SEARCH TREE
28
23
14
31
7
17
9
23
14
31
7
9
23
14
31
7
9
23
14
31
7
9
23
14
31
7
9
23
14
31
7
9
(a)
(b)
(c)
(d)
(e)
(f)
17
17
17
17
17
Figure 3.4: Postorder visit binary search tree example
CHAPTER 3. BINARY SEARCH TREE
29
3.7.3
Inorder
Another variation of the algorithms deﬁned in §3.7.1 and §3.7.2 is that of inorder
traversal where the value of the current node is yielded in between traversing
the left subtree and the right subtree. An example of inorder traversal is shown
in Figure 3.5.
23
14
31
7
17
9
23
14
31
7
9
23
14
31
7
9
23
14
31
7
9
23
14
31
7
9
23
14
31
7
9
(a)
(b)
(c)
(d)
(e)
(f)
17
17
17
17
17
Figure 3.5: Inorder visit binary search tree example
1) algorithm Inorder(root)
2)
Pre: root is the root node of the BST
3)
Post: the nodes in the BST have been visited in inorder
4)
if root ̸= ∅
5)
Inorder(root.Left)
6)
yield root.Value
7)
Inorder(root.Right)
8)
end if
9) end Inorder
One of the beauties of inorder traversal is that values are yielded in their
comparison order. In other words, when traversing a populated BST with the
inorder strategy, the yielded sequence would have property xi ≤xi+1∀i.
CHAPTER 3. BINARY SEARCH TREE
30
3.7.4
Breadth First
Traversing a tree in breadth ﬁrst order yields the values of all nodes of a par-
ticular depth in the tree before any deeper ones. In other words, given a depth
d we would visit the values of all nodes at d in a left to right fashion, then we
would proceed to d + 1 and so on until we hade no more nodes to visit. An
example of breadth ﬁrst traversal is shown in Figure 3.6.
Traditionally breadth ﬁrst traversal is implemented using a list (vector, re-
sizeable array, etc) to store the values of the nodes visited in breadth ﬁrst order
and then a queue to store those nodes that have yet to be visited.
23
14
31
7
17
9
23
14
31
7
9
23
14
31
7
9
23
14
31
7
9
23
14
31
7
9
23
14
31
7
9
(a)
(b)
(c)
(d)
(e)
(f)
17
17
17
17
17
Figure 3.6: Breadth First visit binary search tree example
CHAPTER 3. BINARY SEARCH TREE
31
1) algorithm BreadthFirst(root)
2)
Pre: root is the root node of the BST
3)
Post: the nodes in the BST have been visited in breadth ﬁrst order
4)
q ←queue
5)
while root ̸= ∅
6)
yield root.Value
7)
if root.Left ̸= ∅
8)
q.Enqueue(root.Left)
9)
end if
10)
if root.Right ̸= ∅
11)
q.Enqueue(root.Right)
12)
end if
13)
if !q.IsEmpty()
14)
root ←q.Dequeue()
15)
else
16)
root ←∅
17)
end if
18)
end while
19) end BreadthFirst
3.8
Summary
A binary search tree is a good solution when you need to represent types that are
ordered according to some custom rules inherent to that type. With logarithmic
insertion, lookup, and deletion it is very eﬀecient. Traversal remains linear, but
there are many ways in which you can visit the nodes of a tree.
Trees are
recursive data structures, so typically you will ﬁnd that many algorithms that
operate on a tree are recursive.
The run times presented in this chapter are based on a pretty big assumption
- that the binary search tree’s left and right subtrees are reasonably balanced.
We can only attain logarithmic run times for the algorithms presented earlier
when this is true. A binary search tree does not enforce such a property, and
the run times for these operations on a pathologically unbalanced tree become
linear: such a tree is eﬀectively just a linked list. Later in §7 we will examine
an AVL tree that enforces self-balancing properties to help attain logarithmic
run times.
Chapter 4
Heap
A heap can be thought of as a simple tree data structure, however a heap usually
employs one of two strategies:
1. min heap; or
2. max heap
Each strategy determines the properties of the tree and its values. If you
were to choose the min heap strategy then each parent node would have a value
that is ≤than its children. For example, the node at the root of the tree will
have the smallest value in the tree.
The opposite is true for the max heap
strategy. In this book you should assume that a heap employs the min heap
strategy unless otherwise stated.
Unlike other tree data structures like the one deﬁned in §3 a heap is generally
implemented as an array rather than a series of nodes which each have refer-
ences to other nodes. The nodes are conceptually the same, however, having at
most two children. Figure 4.1 shows how the tree (not a heap data structure)
(12 7(3 2) 6(9 )) would be represented as an array. The array in Figure 4.1 is a
result of simply adding values in a top-to-bottom, left-to-right fashion. Figure
4.2 shows arrows to the direct left and right child of each value in the array.
This chapter is very much centred around the notion of representing a tree as
an array and because this property is key to understanding this chapter Figure
4.3 shows a step by step process to represent a tree data structure as an array.
In Figure 4.3 you can assume that the default capacity of our array is eight.
Using just an array is often not suﬃcient as we have to be up front about the
size of the array to use for the heap. Often the run time behaviour of a program
can be unpredictable when it comes to the size of its internal data structures,
so we need to choose a more dynamic data structure that contains the following
properties:
1. we can specify an initial size of the array for scenarios where we know the
upper storage limit required; and
2. the data structure encapsulates resizing algorithms to grow the array as
required at run time
32
CHAPTER 4. HEAP
33
Figure 4.1: Array representation of a simple tree data structure
Figure 4.2: Direct children of the nodes in an array representation of a tree data
structure
1. Vector
2. ArrayList
3. List
Figure 4.1 does not specify how we would handle adding null references to
the heap. This varies from case to case; sometimes null values are prohibited
entirely; in other cases we may treat them as being smaller than any non-null
value, or indeed greater than any non-null value. You will have to resolve this
ambiguity yourself having studied your requirements. For the sake of clarity we
will avoid the issue by prohibiting null values.
Because we are using an array we need some way to calculate the index of a
parent node, and the children of a node. The required expressions for this are
deﬁned as follows for a node at index:
1. (index −1)/2 (parent index)
2. 2 ∗index + 1 (left child)
3. 2 ∗index + 2 (right child)
In Figure 4.4 a) represents the calculation of the right child of 12 (2 ∗0 + 2);
and b) calculates the index of the parent of 3 ((3 −1)/2).
4.1
Insertion
Designing an algorithm for heap insertion is simple, but we must ensure that
heap order is preserved after each insertion. Generally this is a post-insertion
operation. Inserting a value into the next free slot in an array is simple: we just
need to keep track of the next free index in the array as a counter, and increment
it after each insertion. Inserting our value into the heap is the ﬁrst part of the
algorithm; the second is validating heap order. In the case of min-heap ordering
this requires us to swap the values of a parent and its child if the value of the
child is < the value of its parent. We must do this for each subtree containing
the value we just inserted.
CHAPTER 4. HEAP
34
Figure 4.3: Converting a tree data structure to its array counterpart
CHAPTER 4. HEAP
35
Figure 4.4: Calculating node properties
The run time eﬃciency for heap insertion is O(log n). The run time is a
by product of verifying heap order as the ﬁrst part of the algorithm (the actual
insertion into the array) is O(1).
Figure 4.5 shows the steps of inserting the values 3, 9, 12, 7, and 1 into a
min-heap.
CHAPTER 4. HEAP
36
Figure 4.5: Inserting values into a min-heap
CHAPTER 4. HEAP
37
1) algorithm Add(value)
2)
Pre: value is the value to add to the heap
3)
Count is the number of items in the heap
4)
Post: the value has been added to the heap
5)
heap[Count] ←value
6)
Count ←Count +1
7)
MinHeapify()
8) end Add
1) algorithm MinHeapify()
2)
Pre: Count is the number of items in the heap
3)
heap is the array used to store the heap items
4)
Post: the heap has preserved min heap ordering
5)
i ←Count −1
6)
while i > 0 and heap[i] < heap[(i −1)/2]
7)
Swap(heap[i], heap[(i −1)/2]
8)
i ←(i −1)/2
9)
end while
10) end MinHeapify
The design of the MaxHeapify algorithm is very similar to that of the Min-
Heapify algorithm, the only diﬀerence is that the < operator in the second
condition of entering the while loop is changed to >.
4.2
Deletion
Just as for insertion, deleting an item involves ensuring that heap ordering is
preserved. The algorithm for deletion has three steps:
1. ﬁnd the index of the value to delete
2. put the last value in the heap at the index location of the item to delete
3. verify heap ordering for each subtree which used to include the value
CHAPTER 4. HEAP
38
1) algorithm Remove(value)
2)
Pre: value is the value to remove from the heap
3)
left, and right are updated alias’ for 2 ∗index + 1, and 2 ∗index + 2 respectively
4)
Count is the number of items in the heap
5)
heap is the array used to store the heap items
6)
Post: value is located in the heap and removed, true; otherwise false
7)
// step 1
8)
index ←FindIndex(heap, value)
9)
if index < 0
10)
return false
11)
end if
12)
Count ←Count −1
13)
// step 2
14)
heap[index] ←heap[Count]
15)
// step 3
16)
while left < Count and heap[index] > heap[left] or heap[index] > heap[right]
17)
// promote smallest key from subtree
18)
if heap[left] < heap[right]
19)
Swap(heap, left, index)
20)
index ←left
21)
else
22)
Swap(heap, right, index)
23)
index ←right
24)
end if
25)
end while
26)
return true
27) end Remove
Figure 4.6 shows the Remove algorithm visually, removing 1 from a heap
containing the values 1, 3, 9, 12, and 13. In Figure 4.6 you can assume that we
have speciﬁed that the backing array of the heap should have an initial capacity
of eight.
Please note that in our deletion algorithm that we don’t default the removed
value in the heap array. If you are using a heap for reference types, i.e. objects
that are allocated on a heap you will want to free that memory. This is important
in both unmanaged, and managed languages. In the latter we will want to null
that empty hole so that the garbage collector can reclaim that memory. If we
were to not null that hole then the object could still be reached and thus won’t
be garbage collected.
4.3
Searching
Searching a heap is merely a matter of traversing the items in the heap array
sequentially, so this operation has a run time complexity of O(n). The search
can be thought of as one that uses a breadth ﬁrst traversal as deﬁned in §3.7.4
to visit the nodes within the heap to check for the presence of a speciﬁed item.
CHAPTER 4. HEAP
39
Figure 4.6: Deleting an item from a heap
CHAPTER 4. HEAP
40
1) algorithm Contains(value)
2)
Pre: value is the value to search the heap for
3)
Count is the number of items in the heap
4)
heap is the array used to store the heap items
5)
Post: value is located in the heap, in which case true; otherwise false
6)
i ←0
7)
while i < Count and heap[i] ̸= value
8)
i ←i + 1
9)
end while
10)
if i < Count
11)
return true
12)
else
13)
return false
14)
end if
15) end Contains
The problem with the previous algorithm is that we don’t take advantage
of the properties in which all values of a heap hold, that is the property of the
heap strategy being used. For instance if we had a heap that didn’t contain the
value 4 we would have to exhaust the whole backing heap array before we could
determine that it wasn’t present in the heap. Factoring in what we know about
the heap we can optimise the search algorithm by including logic which makes
use of the properties presented by a certain heap strategy.
Optimising to deterministically state that a value is in the heap is not that
straightforward, however the problem is a very interesting one. As an example
consider a min-heap that doesn’t contain the value 5. We can only rule that the
value is not in the heap if 5 > the parent of the current node being inspected
and < the current node being inspected ∀nodes at the current level we are
traversing.
If this is the case then 5 cannot be in the heap and so we can
provide an answer without traversing the rest of the heap. If this property is
not satisﬁed for any level of nodes that we are inspecting then the algorithm
will indeed fall back to inspecting all the nodes in the heap. The optimisation
that we present can be very common and so we feel that the extra logic within
the loop is justiﬁed to prevent the expensive worse case run time.
The following algorithm is speciﬁcally designed for a min-heap. To tailor the
algorithm for a max-heap the two comparison operations in the else if condition
within the inner while loop should be ﬂipped.
CHAPTER 4. HEAP
41
1) algorithm Contains(value)
2)
Pre: value is the value to search the heap for
3)
Count is the number of items in the heap
4)
heap is the array used to store the heap items
5)
Post: value is located in the heap, in which case true; otherwise false
6)
start ←0
7)
nodes ←1
8)
while start < Count
9)
start ←nodes −1
10)
end ←nodes + start
11)
count ←0
12)
while start < Count and start < end
13)
if value = heap[start]
14)
return true
15)
else if value > Parent(heap[start]) and value < heap[start]
16)
count ←count + 1
17)
end if
18)
start ←start + 1
19)
end while
20)
if count = nodes
21)
return false
22)
end if
23)
nodes ←nodes ∗2
24)
end while
25)
return false
26) end Contains
The new Contains algorithm determines if the value is not in the heap by
checking whether count = nodes. In such an event where this is true then we
can conﬁrm that ∀nodes n at level i : value > Parent(n), value < n thus there
is no possible way that value is in the heap. As an example consider Figure 4.7.
If we are searching for the value 10 within the min-heap displayed it is obvious
that we don’t need to search the whole heap to determine 9 is not present. We
can verify this after traversing the nodes in the second level of the heap as the
previous expression deﬁned holds true.
4.4
Traversal
As mentioned in §4.3 traversal of a heap is usually done like that of any other
array data structure which our heap implementation is based upon. As a result
you traverse the array starting at the initial array index (0 in most languages)
and then visit each value within the array until you have reached the upper
bound of the heap. You will note that in the search algorithm that we use Count
as this upper bound rather than the actual physical bound of the allocated
array. Count is used to partition the conceptual heap from the actual array
implementation of the heap: we only care about the items in the heap, not the
whole array—the latter may contain various other bits of data as a result of
heap mutation.
CHAPTER 4. HEAP
42
Figure 4.7: Determining 10 is not in the heap after inspecting the nodes of Level
2
Figure 4.8: Living and dead space in the heap backing array
If you have followed the advice we gave in the deletion algorithm then a
heap that has been mutated several times will contain some form of default
value for items no longer in the heap.
Potentially you will have at most
LengthOf(heapArray) −Count garbage values in the backing heap array data
structure. The garbage values of course vary from platform to platform. To
make things simple the garbage value of a reference type will be simple ∅and 0
for a value type.
Figure 4.8 shows a heap that you can assume has been mutated many times.
For this example we can further assume that at some point the items in indexes
3 −5 actually contained references to live objects of type T.
In Figure 4.8
subscript is used to disambiguate separate objects of T.
From what you have read thus far you will most likely have picked up that
traversing the heap in any other order would be of little beneﬁt.
The heap
property only holds for the subtree of each node and so traversing a heap in
any other fashion requires some creative intervention. Heaps are not usually
traversed in any other way than the one prescribed previously.
4.5
Summary
Heaps are most commonly used to implement priority queues (see §6.2 for a
sample implementation) and to facilitate heap sort. As discussed in both the
insertion §4.1 and deletion §4.2 sections a heap maintains heap order according
to the selected ordering strategy. These strategies are referred to as min-heap,
CHAPTER 4. HEAP
43
and max heap. The former strategy enforces that the value of a parent node is
less than that of each of its children, the latter enforces that the value of the
parent is greater than that of each of its children.
When you come across a heap and you are not told what strategy it enforces
you should assume that it uses the min-heap strategy.
If the heap can be
conﬁgured otherwise, e.g. to use max-heap then this will often require you to
state this explicitly. The heap abides progressively to a strategy during the
invocation of the insertion, and deletion algorithms. The cost of such a policy is
that upon each insertion and deletion we invoke algorithms that have logarithmic
run time complexities. While the cost of maintaining the strategy might not
seem overly expensive it does still come at a price. We will also have to factor
in the cost of dynamic array expansion at some stage. This will occur if the
number of items within the heap outgrows the space allocated in the heap’s
backing array. It may be in your best interest to research a good initial starting
size for your heap array. This will assist in minimising the impact of dynamic
array resizing.
Chapter 5
Sets
A set contains a number of values, in no particular order. The values within
the set are distinct from one another.
Generally set implementations tend to check that a value is not in the set
before adding it, avoiding the issue of repeated values from ever occurring.
This section does not cover set theory in depth; rather it demonstrates brieﬂy
the ways in which the values of sets can be deﬁned, and common operations that
may be performed upon them.
The notation A = {4, 7, 9, 12, 0} deﬁnes a set A whose values are listed within
the curly braces.
Given the set A deﬁned previously we can say that 4 is a member of A
denoted by 4 ∈A, and that 99 is not a member of A denoted by 99 /
∈A.
Often deﬁning a set by manually stating its members is tiresome, and more
importantly the set may contain a large number of values. A more concise way
of deﬁning a set and its members is by providing a series of properties that the
values of the set must satisfy. For example, from the deﬁnition A = {x|x >
0, x % 2 = 0} the set A contains only positive integers that are even. x is an
alias to the current value we are inspecting and to the right hand side of | are
the properties that x must satisfy to be in the set A. In this example, x must
be > 0, and the remainder of the arithmetic expression x/2 must be 0. You will
be able to note from the previous deﬁnition of the set A that the set can contain
an inﬁnite number of values, and that the values of the set A will be all even
integers that are a member of the natural numbers set N, where N = {1, 2, 3, ...}.
Finally in this brief introduction to sets we will cover set intersection and
union, both of which are very common operations (amongst many others) per-
formed on sets. The union set can be deﬁned as follows A ∪B = {x | x ∈
A or x ∈B}, and intersection A ∩B = {x | x ∈A and x ∈B}. Figure 5.1
demonstrates set intersection and union graphically.
Given the set deﬁnitions A = {1, 2, 3}, and B = {6, 2, 9} the union of the two
sets is A∪B = {1, 2, 3, 6, 9}, and the intersection of the two sets is A∩B = {2}.
Both set union and intersection are sometimes provided within the frame-
work associated with mainstream languages.
This is the case in .NET 3.51
where such algorithms exist as extension methods deﬁned in the type Sys-
tem.Linq.Enumerable2, as a result DSA does not provide implementations of
1http://www.microsoft.com/NET/
2http://msdn.microsoft.com/en-us/library/system.linq.enumerable_members.aspx
44
CHAPTER 5. SETS
45
Figure 5.1: a) A ∩B; b) A ∪B
these algorithms. Most of the algorithms deﬁned in System.Linq.Enumerable
deal mainly with sequences rather than sets exclusively.
Set union can be implemented as a simple traversal of both sets adding each
item of the two sets to a new union set.
1) algorithm Union(set1, set2)
2)
Pre: set1, and set2 ̸= ∅
3)
union is a set
3)
Post: A union of set1, and set2 has been created
4)
foreach item in set1
5)
union.Add(item)
6)
end foreach
7)
foreach item in set2
8)
union.Add(item)
9)
end foreach
10)
return union
11) end Union
The run time of our Union algorithm is O(m + n) where m is the number
of items in the ﬁrst set and n is the number of items in the second set. This
runtime applies only to sets that exhibit O(1) insertions.
Set intersection is also trivial to implement. The only major thing worth
pointing out about our algorithm is that we traverse the set containing the
fewest items. We can do this because if we have exhausted all the items in the
smaller of the two sets then there are no more items that are members of both
sets, thus we have no more items to add to the intersection set.
CHAPTER 5. SETS
46
1) algorithm Intersection(set1, set2)
2)
Pre: set1, and set2 ̸= ∅
3)
intersection, and smallerSet are sets
3)
Post: An intersection of set1, and set2 has been created
4)
if set1.Count < set2.Count
5)
smallerSet ←set1
6)
else
7)
smallerSet ←set2
8)
end if
9)
foreach item in smallerSet
10)
if set1.Contains(item) and set2.Contains(item)
11)
intersection.Add(item)
12)
end if
13)
end foreach
14)
return intersection
15) end Intersection
The run time of our Intersection algorithm is O(n) where n is the number
of items in the smaller of the two sets. Just like our Union algorithm a linear
runtime can only be attained when operating on a set with O(1) insertion.
5.1
Unordered
Sets in the general sense do not enforce the explicit ordering of their mem-
bers. For example the members of B = {6, 2, 9} conform to no ordering scheme
because it is not required.
Most libraries provide implementations of unordered sets and so DSA does
not; we simply mention it here to disambiguate between an unordered set and
ordered set.
We will only look at insertion for an unordered set and cover brieﬂy why a
hash table is an eﬃcient data structure to use for its implementation.
5.1.1
Insertion
An unordered set can be eﬃciently implemented using a hash table as its backing
data structure. As mentioned previously we only add an item to a set if that
item is not already in the set, so the backing data structure we use must have
a quick look up and insertion run time complexity.
A hash map generally provides the following:
1. O(1) for insertion
2. approaching O(1) for look up
The above depends on how good the hashing algorithm of the hash table
is, but most hash tables employ incredibly eﬃcient general purpose hashing
algorithms and so the run time complexities for the hash table in your library
of choice should be very similar in terms of eﬃciency.
CHAPTER 5. SETS
47
5.2
Ordered
An ordered set is similar to an unordered set in the sense that its members are
distinct, but an ordered set enforces some predeﬁned comparison on each of its
members to produce a set whose members are ordered appropriately.
In DSA 0.5 and earlier we used a binary search tree (deﬁned in §3) as the
internal backing data structure for our ordered set. From versions 0.6 onwards
we replaced the binary search tree with an AVL tree primarily because AVL is
balanced.
The ordered set has its order realised by performing an inorder traversal
upon its backing tree data structure which yields the correct ordered sequence
of set members.
Because an ordered set in DSA is simply a wrapper for an AVL tree that
additionally ensures that the tree contains unique items you should read §7 to
learn more about the run time complexities associated with its operations.
5.3
Summary
Sets provide a way of having a collection of unique objects, either ordered or
unordered.
When implementing a set (either ordered or unordered) it is key to select
the correct backing data structure. As we discussed in §5.1.1 because we check
ﬁrst if the item is already contained within the set before adding it we need
this check to be as quick as possible. For unordered sets we can rely on the use
of a hash table and use the key of an item to determine whether or not it is
already contained within the set. Using a hash table this check results in a near
constant run time complexity. Ordered sets cost a little more for this check,
however the logarithmic growth that we incur by using a binary search tree as
its backing data structure is acceptable.
Another key property of sets implemented using the approach we describe is
that both have favourably fast look-up times. Just like the check before inser-
tion, for a hash table this run time complexity should be near constant. Ordered
sets as described in 3 perform a binary chop at each stage when searching for
the existence of an item yielding a logarithmic run time.
We can use sets to facilitate many algorithms that would otherwise be a little
less clear in their implementation. For example in §11.4 we use an unordered
set to assist in the construction of an algorithm that determines the number of
repeated words within a string.
Chapter 6
Queues
Queues are an essential data structure that are found in vast amounts of soft-
ware from user mode to kernel mode applications that are core to the system.
Fundamentally they honour a ﬁrst in ﬁrst out (FIFO) strategy, that is the item
ﬁrst put into the queue will be the ﬁrst served, the second item added to the
queue will be the second to be served and so on.
A traditional queue only allows you to access the item at the front of the
queue; when you add an item to the queue that item is placed at the back of
the queue.
Historically queues always have the following three core methods:
Enqueue: places an item at the back of the queue;
Dequeue: retrieves the item at the front of the queue, and removes it from the
queue;
Peek: 1 retrieves the item at the front of the queue without removing it from
the queue
As an example to demonstrate the behaviour of a queue we will walk through
a scenario whereby we invoke each of the previously mentioned methods observ-
ing the mutations upon the queue data structure. The following list describes
the operations performed upon the queue in Figure 6.1:
1. Enqueue(10)
2. Enqueue(12)
3. Enqueue(9)
4. Enqueue(8)
5. Enqueue(3)
6. Dequeue()
7. Peek()
1This operation is sometimes referred to as Front
48
CHAPTER 6. QUEUES
49
8. Enqueue(33)
9. Peek()
10. Dequeue()
6.1
A standard queue
A queue is implicitly like that described prior to this section. In DSA we don’t
provide a standard queue because queues are so popular and such a core data
structure that you will ﬁnd pretty much every mainstream library provides a
queue data structure that you can use with your language of choice. In this
section we will discuss how you can, if required, implement an eﬃcient queue
data structure.
The main property of a queue is that we have access to the item at the
front of the queue. The queue data structure can be eﬃciently implemented
using a singly linked list (deﬁned in §2.1). A singly linked list provides O(1)
insertion and deletion run time complexities. The reason we have an O(1) run
time complexity for deletion is because we only ever remove items from the front
of queues (with the Dequeue operation). Since we always have a pointer to the
item at the head of a singly linked list, removal is simply a case of returning
the value of the old head node, and then modifying the head pointer to be the
next node of the old head node. The run time complexity for searching a queue
remains the same as that of a singly linked list: O(n).
6.2
Priority Queue
Unlike a standard queue where items are ordered in terms of who arrived ﬁrst,
a priority queue determines the order of its items by using a form of custom
comparer to see which item has the highest priority. Other than the items in a
priority queue being ordered by priority it remains the same as a normal queue:
you can only access the item at the front of the queue.
A sensible implementation of a priority queue is to use a heap data structure
(deﬁned in §4). Using a heap we can look at the ﬁrst item in the queue by simply
returning the item at index 0 within the heap array. A heap provides us with the
ability to construct a priority queue where the items with the highest priority
are either those with the smallest value, or those with the largest.
6.3
Double Ended Queue
Unlike the queues we have talked about previously in this chapter a double
ended queue allows you to access the items at both the front, and back of the
queue. A double ended queue is commonly known as a deque which is the name
we will here on in refer to it as.
A deque applies no prioritization strategy to its items like a priority queue
does, items are added in order to either the front of back of the deque. The
former properties of the deque are denoted by the programmer utilising the data
structures exposed interface.
CHAPTER 6. QUEUES
50
Figure 6.1: Queue mutations
CHAPTER 6. QUEUES
51
Deque’s provide front and back speciﬁc versions of common queue operations,
e.g. you may want to enqueue an item to the front of the queue rather than
the back in which case you would use a method with a name along the lines
of EnqueueFront. The following list identiﬁes operations that are commonly
supported by deque’s:
• EnqueueFront
• EnqueueBack
• DequeueFront
• DequeueBack
• PeekFront
• PeekBack
Figure 6.2 shows a deque after the invocation of the following methods (in-
order):
1. EnqueueBack(12)
2. EnqueueFront(1)
3. EnqueueBack(23)
4. EnqueueFront(908)
5. DequeueFront()
6. DequeueBack()
The operations have a one-to-one translation in terms of behaviour with
those of a normal queue, or priority queue. In some cases the set of algorithms
that add an item to the back of the deque may be named as they are with
normal queues, e.g. EnqueueBack may simply be called Enqueue an so on. Some
frameworks also specify explicit behaviour’s that data structures must adhere to.
This is certainly the case in .NET where most collections implement an interface
which requires the data structure to expose a standard Add method. In such
a scenario you can safely assume that the Add method will simply enqueue an
item to the back of the deque.
With respect to algorithmic run time complexities a deque is the same as
a normal queue.
That is enqueueing an item to the back of a the queue is
O(1), additionally enqueuing an item to the front of the queue is also an O(1)
operation.
A deque is a wrapper data structure that uses either an array, or a doubly
linked list. Using an array as the backing data structure would require the pro-
grammer to be explicit about the size of the array up front, this would provide
an obvious advantage if the programmer could deterministically state the maxi-
mum number of items the deque would contain at any one time. Unfortunately
in most cases this doesn’t hold, as a result the backing array will inherently
incur the expense of invoking a resizing algorithm which would most likely be
an O(n) operation. Such an approach would also leave the library developer
CHAPTER 6. QUEUES
52
Figure 6.2: Deque data structure after several mutations
CHAPTER 6. QUEUES
53
to look at array minimization techniques as well, it could be that after several
invocations of the resizing algorithm and various mutations on the deque later
that we have an array taking up a considerable amount of memory yet we are
only using a few small percentage of that memory.
An algorithm described
would also be O(n) yet its invocation would be harder to gauge strategically.
To bypass all the aforementioned issues a deque typically uses a doubly
linked list as its baking data structure. While a node that has two pointers
consumes more memory than its array item counterpart it makes redundant the
need for expensive resizing algorithms as the data structure increases in size
dynamically. With a language that targets a garbage collected virtual machine
memory reclamation is an opaque process as the nodes that are no longer ref-
erenced become unreachable and are thus marked for collection upon the next
invocation of the garbage collection algorithm. With C++ or any other lan-
guage that uses explicit memory allocation and deallocation it will be up to the
programmer to decide when the memory that stores the object can be freed.
6.4
Summary
With normal queues we have seen that those who arrive ﬁrst are dealt with ﬁrst;
that is they are dealt with in a ﬁrst-in-ﬁrst-out (FIFO) order. Queues can be
ever so useful; for example the Windows CPU scheduler uses a diﬀerent queue
for each priority of process to determine which should be the next process to
utilise the CPU for a speciﬁed time quantum. Normal queues have constant
insertion and deletion run times. Searching a queue is fairly unusual—typically
you are only interested in the item at the front of the queue. Despite that,
searching is usually exposed on queues and typically the run time is linear.
In this chapter we have also seen priority queues where those at the front
of the queue have the highest priority and those near the back have the lowest.
One implementation of a priority queue is to use a heap data structure as its
backing store, so the run times for insertion, deletion, and searching are the
same as those for a heap (deﬁned in §4).
Queues are a very natural data structure, and while they are fairly primitive
they can make many problems a lot simpler.
For example the breadth ﬁrst
search deﬁned in §3.7.4 makes extensive use of queues.
Chapter 7
AVL Tree
In the early 60’s G.M. Adelson-Velsky and E.M. Landis invented the ﬁrst self-
balancing binary search tree data structure, calling it AVL Tree.
An AVL tree is a binary search tree (BST, deﬁned in §3) with a self-balancing
condition stating that the diﬀerence between the height of the left and right
subtrees cannot be no more than one, see Figure 7.1. This condition, restored
after each tree modiﬁcation, forces the general shape of an AVL tree. Before
continuing, let us focus on why balance is so important.
Consider a binary
search tree obtained by starting with an empty tree and inserting some values
in the following order 1,2,3,4,5.
The BST in Figure 7.2 represents the worst case scenario in which the run-
ning time of all common operations such as search, insertion and deletion are
O(n). By applying a balance condition we ensure that the worst case running
time of each common operation is O(log n). The height of an AVL tree with n
nodes is O(log n) regardless of the order in which values are inserted.
The AVL balance condition, known also as the node balance factor represents
an additional piece of information stored for each node. This is combined with
a technique that eﬃciently restores the balance condition for the tree. In an
AVL tree the inventors make use of a well-known technique called tree rotation.
h
h+1
Figure 7.1: The left and right subtrees of an AVL tree diﬀer in height by at
most 1
54
CHAPTER 7. AVL TREE
55
1
2
3
4
5
Figure 7.2: Unbalanced binary search tree
2
4
5
1
3
4
5
3
2
1
a)
b)
Figure 7.3: Avl trees, insertion order: -a)1,2,3,4,5 -b)1,5,4,3,2
CHAPTER 7. AVL TREE
56
7.1
Tree Rotations
A tree rotation is a constant time operation on a binary search tree that changes
the shape of a tree while preserving standard BST properties. There are left and
right rotations both of them decrease the height of a BST by moving smaller
subtrees down and larger subtrees up.
14
24
11
8
2
8
14
24
2
11
Right
Rotation
Left
Rotation
Figure 7.4: Tree left and right rotations
CHAPTER 7. AVL TREE
57
1) algorithm LeftRotation(node)
2)
Pre: node.Right ! = ∅
3)
Post: node.Right is the new root of the subtree,
4)
node has become node.Right’s left child and,
5)
BST properties are preserved
6)
RightNode ←node.Right
7)
node.Right ←RightNode.Left
8)
RightNode.Left ←node
9) end LeftRotation
1) algorithm RightRotation(node)
2)
Pre: node.Left ! = ∅
3)
Post: node.Left is the new root of the subtree,
4)
node has become node.Left’s right child and,
5)
BST properties are preserved
6)
LeftNode ←node.Left
7)
node.Left ←LeftNode.Right
8)
LeftNode.Right ←node
9) end RightRotation
The right and left rotation algorithms are symmetric.
Only pointers are
changed by a rotation resulting in an O(1) runtime complexity; the other ﬁelds
present in the nodes are not changed.
7.2
Tree Rebalancing
The algorithm that we present in this section veriﬁes that the left and right
subtrees diﬀer at most in height by 1. If this property is not present then we
perform the correct rotation.
Notice that we use two new algorithms that represent double rotations.
These algorithms are named LeftAndRightRotation, and RightAndLeftRotation.
The algorithms are self documenting in their names, e.g. LeftAndRightRotation
ﬁrst performs a left rotation and then subsequently a right rotation.
CHAPTER 7. AVL TREE
58
1) algorithm CheckBalance(current)
2)
Pre: current is the node to start from balancing
3)
Post: current height has been updated while tree balance is if needed
4)
restored through rotations
5)
if current.Left = ∅and current.Right = ∅
6)
current.Height = -1;
7)
else
8)
current.Height = Max(Height(current.Left),Height(current.Right)) + 1
9)
end if
10)
if Height(current.Left) - Height(current.Right) > 1
11)
if Height(current.Left.Left) - Height(current.Left.Right) > 0
12)
RightRotation(current)
13)
else
14)
LeftAndRightRotation(current)
15)
end if
16)
else if Height(current.Left) - Height(current.Right) < −1
17)
if Height(current.Right.Left) - Height(current.Right.Right) < 0
18)
LeftRotation(current)
19)
else
20)
RightAndLeftRotation(current)
21)
end if
22)
end if
23) end CheckBalance
7.3
Insertion
AVL insertion operates ﬁrst by inserting the given value the same way as BST
insertion and then by applying rebalancing techniques if necessary. The latter
is only performed if the AVL property no longer holds, that is the left and right
subtrees height diﬀer by more than 1. Each time we insert a node into an AVL
tree:
1. We go down the tree to ﬁnd the correct point at which to insert the node,
in the same manner as for BST insertion; then
2. we travel up the tree from the inserted node and check that the node
balancing property has not been violated; if the property hasn’t been
violated then we need not rebalance the tree, the opposite is true if the
balancing property has been violated.
CHAPTER 7. AVL TREE
59
1) algorithm Insert(value)
2)
Pre: value has passed custom type checks for type T
3)
Post: value has been placed in the correct location in the tree
4)
if root = ∅
5)
root ←node(value)
6)
else
7)
InsertNode(root, value)
8)
end if
9) end Insert
1) algorithm InsertNode(current, value)
2)
Pre: current is the node to start from
3)
Post: value has been placed in the correct location in the tree while
4)
preserving tree balance
5)
if value < current.Value
6)
if current.Left = ∅
7)
current.Left ←node(value)
8)
else
9)
InsertNode(current.Left, value)
10)
end if
11)
else
12)
if current.Right = ∅
13)
current.Right ←node(value)
14)
else
15)
InsertNode(current.Right, value)
16)
end if
17)
end if
18)
CheckBalance(current)
19) end InsertNode
7.4
Deletion
Our balancing algorithm is like the one presented for our BST (deﬁned in §3.3).
The major diﬀerence is that we have to ensure that the tree still adheres to the
AVL balance property after the removal of the node. If the tree doesn’t need
to be rebalanced and the value we are removing is contained within the tree
then no further step are required. However, when the value is in the tree and
its removal upsets the AVL balance property then we must perform the correct
rotation(s).
CHAPTER 7. AVL TREE
60
1) algorithm Remove(value)
2)
Pre: value is the value of the node to remove, root is the root node
3)
of the Avl
4)
Post: node with value is removed and tree rebalanced if found in which
5)
case yields true, otherwise false
6)
nodeToRemove ←root
7)
parent ←∅
8)
Stackpath ←root
9)
while nodeToRemove ̸= ∅and nodeToRemove.V alue = V alue
10)
parent = nodeToRemove
11)
if value < nodeToRemove.Value
12)
nodeToRemove ←nodeToRemove.Left
13)
else
14)
nodeToRemove ←nodeToRemove.Right
15)
end if
16)
path.Push(nodeToRemove)
17)
end while
18)
if nodeToRemove = ∅
19)
return false // value not in Avl
20)
end if
21)
parent ←FindParent(value)
22)
if count = 1 // count keeps track of the # of nodes in the Avl
23)
root ←∅// we are removing the only node in the Avl
24)
else if nodeToRemove.Left = ∅and nodeToRemove.Right = null
25)
// case #1
26)
if nodeToRemove.Value < parent.Value
27)
parent.Left ←∅
28)
else
29)
parent.Right ←∅
30)
end if
31)
else if nodeToRemove.Left = ∅and nodeToRemove.Right ̸= ∅
32)
// case # 2
33)
if nodeToRemove.Value < parent.Value
34)
parent.Left ←nodeToRemove.Right
35)
else
36)
parent.Right ←nodeToRemove.Right
37)
end if
38)
else if nodeToRemove.Left ̸= ∅and nodeToRemove.Right = ∅
39)
// case #3
40)
if nodeToRemove.Value < parent.Value
41)
parent.Left ←nodeToRemove.Left
42)
else
43)
parent.Right ←nodeToRemove.Left
44)
end if
45)
else
46)
// case #4
47)
largestV alue ←nodeToRemove.Left
48)
while largestV alue.Right ̸= ∅
49)
// ﬁnd the largest value in the left subtree of nodeToRemove
50)
largestV alue ←largestV alue.Right
CHAPTER 7. AVL TREE
61
51)
end while
52)
// set the parents’ Right pointer of largestV alue to ∅
53)
FindParent(largestV alue.Value).Right ←∅
54)
nodeToRemove.Value ←largestV alue.Value
55)
end if
56)
while path.Count > 0
57)
CheckBalance(path.Pop()) // we trackback to the root node check balance
58)
end while
59)
count ←count −1
60)
return true
61) end Remove
7.5
Summary
The AVL tree is a sophisticated self balancing tree. It can be thought of as
the smarter, younger brother of the binary search tree. Unlike its older brother
the AVL tree avoids worst case linear complexity runtimes for its operations.
The AVL tree guarantees via the enforcement of balancing algorithms that the
left and right subtrees diﬀer in height by at most 1 which yields at most a
logarithmic runtime complexity.
Part II
Algorithms
62
Chapter 8
Sorting
All the sorting algorithms in this chapter use data structures of a speciﬁc type
to demonstrate sorting, e.g.
a 32 bit integer is often used as its associated
operations (e.g. <, >, etc) are clear in their behaviour.
The algorithms discussed can easily be translated into generic sorting algo-
rithms within your respective language of choice.
8.1
Bubble Sort
One of the most simple forms of sorting is that of comparing each item with
every other item in some list, however as the description may imply this form
of sorting is not particularly eﬀecient O(n2). In it’s most simple form bubble
sort can be implemented as two loops.
1) algorithm BubbleSort(list)
2)
Pre: list ̸= ∅
3)
Post: list has been sorted into values of ascending order
4)
for i ←0 to list.Count −1
5)
for j ←0 to list.Count −1
6)
if list[i] < list[j]
7)
Swap(list[i], list[j])
8)
end if
9)
end for
10)
end for
11)
return list
12) end BubbleSort
8.2
Merge Sort
Merge sort is an algorithm that has a fairly eﬃcient space time complexity -
O(n log n) and is fairly trivial to implement. The algorithm is based on splitting
a list, into two similar sized lists (left, and right) and sorting each list and then
merging the sorted lists back together.
Note: the function MergeOrdered simply takes two ordered lists and makes
them one.
63
CHAPTER 8. SORTING
64
54
2
74
75
4
0
1
2
3
4
54
2
74
75
4
0
1
2
3
4
54
2
75
74
4
0
1
2
3
4
54
75
2
74
4
0
1
2
3
4
75
54
2
74
4
0
1
2
3
4
75
54
2
74
4
0
1
2
3
4
75
54
2
74
4
0
1
2
3
4
75
54
74
2
4
0
1
2
3
4
75
74
54
2
4
0
1
2
3
4
75
74
54
2
4
0
1
2
3
4
75
74
54
4
2
0
1
2
3
4
75
74
54
4
2
0
1
2
3
4
75
74
54
4
2
0
1
2
3
4
75
74
54
4
2
0
1
2
3
4
75
74
54
4
2
0
1
2
3
4
Figure 8.1: Bubble Sort Iterations
1) algorithm Mergesort(list)
2)
Pre: list ̸= ∅
3)
Post: list has been sorted into values of ascending order
4)
if list.Count = 1 // already sorted
5)
return list
6)
end if
7)
m ←list.Count / 2
8)
left ←list(m)
9)
right ←list(list.Count −m)
10)
for i ←0 to left.Count−1
11)
left[i] ←list[i]
12)
end for
13)
for i ←0 to right.Count−1
14)
right[i] ←list[i]
15)
end for
16)
left ←Mergesort(left)
17)
right ←Mergesort(right)
18)
return MergeOrdered(left, right)
19) end Mergesort
CHAPTER 8. SORTING
65
54
2
74
75
4
75
4
54
2
74
4
75
74
54
2
2
5
4
Divide
54
2
75
4
74
54
2
75
74
54
4
2
Impera
(Merge)
Figure 8.2: Merge Sort Divide et Impera Approach
8.3
Quick Sort
Quick sort is one of the most popular sorting algorithms based on divide et
impera strategy, resulting in an O(n log n) complexity. The algorithm starts by
picking an item, called pivot, and moving all smaller items before it, while all
greater elements after it. This is the main quick sort operation, called partition,
recursively repeated on lesser and greater sub lists until their size is one or zero
- in which case the list is implicitly sorted.
Choosing an appropriate pivot, as for example the median element is funda-
mental for avoiding the drastically reduced performance of O(n2).
CHAPTER 8. SORTING
66
54
2
74
75
4
Pivot
54
2
74
75
4
Pivot
75
2
74
54
4
Pivot
75
54
74
2
4
Pivot
75
74
54
2
4
Pivot
2
4
Pivot
4
2
Pivot
75
74
Pivot
75
74
75
74
54
4
2
Pivot
Figure 8.3: Quick Sort Example (pivot median strategy)
1) algorithm QuickSort(list)
2)
Pre: list ̸= ∅
3)
Post: list has been sorted into values of ascending order
4)
if list.Count = 1 // already sorted
5)
return list
6)
end if
7)
pivot ←MedianValue(list)
8)
for i ←0 to list.Count−1
9)
if list[i] = pivot
10)
equal.Insert(list[i])
11)
end if
12)
if list[i] < pivot
13)
less.Insert(list[i])
14)
end if
15)
if list[i] > pivot
16)
greater.Insert(list[i])
17)
end if
18)
end for
19)
return Concatenate(QuickSort(less), equal, QuickSort(greater))
20) end Quicksort
CHAPTER 8. SORTING
67
8.4
Insertion Sort
Insertion sort is a somewhat interesting algorithm with an expensive runtime of
O(n2). It can be best thought of as a sorting scheme similar to that of sorting
a hand of playing cards, i.e. you take one card and then look at the rest with
the intent of building up an ordered set of cards in your hand.
54
2
74
75
4
54
2
74
75
4
54
2
74
75
4
74
54
2
75
74
4
2
75
54
75
74
4
2
54
75
74
54
4
2
4
Figure 8.4: Insertion Sort Iterations
1) algorithm Insertionsort(list)
2)
Pre:
list ̸= ∅
3)
Post: list has been sorted into values of ascending order
4)
unsorted ←1
5)
while unsorted < list.Count
6)
hold ←list[unsorted]
7)
i ←unsorted −1
8)
while i ≥0 and hold < list[i]
9)
list[i + 1] ←list[i]
10)
i ←i −1
11)
end while
12)
list[i + 1] ←hold
13)
unsorted ←unsorted + 1
14)
end while
15)
return list
16) end Insertionsort
CHAPTER 8. SORTING
68
8.5
Shell Sort
Put simply shell sort can be thought of as a more eﬃcient variation of insertion
sort as described in §8.4, it achieves this mainly by comparing items of varying
distances apart resulting in a run time complexity of O(n log2 n).
Shell sort is fairly straight forward but may seem somewhat confusing at
ﬁrst as it diﬀers from other sorting algorithms in the way it selects items to
compare. Figure 8.5 shows shell sort being ran on an array of integers, the red
coloured square is the current value we are holding.
1) algorithm ShellSort(list)
2)
Pre: list ̸= ∅
3)
Post: list has been sorted into values of ascending order
4)
increment ←list.Count / 2
5)
while increment ̸= 0
6)
current ←increment
7)
while current < list.Count
8)
hold ←list[current]
9)
i ←current −increment
10)
while i ≥0 and hold < list[i]
11)
list[i + increment] ←list[i]
12)
i−= increment
13)
end while
14)
list[i + increment] ←hold
15)
current ←current + 1
16)
end while
17)
increment / = 2
18)
end while
19)
return list
20) end ShellSort
8.6
Radix Sort
Unlike the sorting algorithms described previously radix sort uses buckets to
sort items, each bucket holds items with a particular property called a key.
Normally a bucket is a queue, each time radix sort is performed these buckets
are emptied starting the smallest key bucket to the largest. When looking at
items within a list to sort we do so by isolating a speciﬁc key, e.g. in the example
we are about to show we have a maximum of three keys for all items, that is
the highest key we need to look at is hundreds. Because we are dealing with, in
this example base 10 numbers we have at any one point 10 possible key values
0..9 each of which has their own bucket. Before we show you this ﬁrst simple
version of radix sort let us clarify what we mean by isolating keys. Given the
number 102 if we look at the ﬁrst key, the ones then we can see we have two of
them, progressing to the next key - tens we can see that the number has zero
of them, ﬁnally we can see that the number has a single hundred. The number
used as an example has in total three keys:
CHAPTER 8. SORTING
69
Figure 8.5: Shell sort
CHAPTER 8. SORTING
70
1. Ones
2. Tens
3. Hundreds
For further clariﬁcation what if we wanted to determine how many thousands
the number 102 has? Clearly there are none, but often looking at a number as
ﬁnal like we often do it is not so obvious so when asked the question how many
thousands does 102 have you should simply pad the number with a zero in that
location, e.g. 0102 here it is more obvious that the key value at the thousands
location is zero.
The last thing to identify before we actually show you a simple implemen-
tation of radix sort that works on only positive integers, and requires you to
specify the maximum key size in the list is that we need a way to isolate a
speciﬁc key at any one time. The solution is actually very simple, but its not
often you want to isolate a key in a number so we will spell it out clearly
here. A key can be accessed from any integer with the following expression:
key ←(number / keyToAccess) % 10. As a simple example lets say that we
want to access the tens key of the number 1290, the tens column is key 10 and
so after substitution yields key ←(1290 / 10) % 10
=
9. The next key to
look at for a number can be attained by multiplying the last key by ten working
left to right in a sequential manner. The value of key is used in the following
algorithm to work out the index of an array of queues to enqueue the item into.
1) algorithm Radix(list, maxKeySize)
2)
Pre: list ̸= ∅
3)
maxKeySize ≥0 and represents the largest key size in the list
4)
Post: list has been sorted
5)
queues ←Queue[10]
6)
indexOfKey ←1
7)
fori ←0 to maxKeySize −1
8)
foreach item in list
9)
queues[GetQueueIndex(item, indexOfKey)].Enqueue(item)
10)
end foreach
11)
list ←CollapseQueues(queues)
12)
ClearQueues(queues)
13)
indexOfKey ←indexOfKey ∗10
14)
end for
15)
return list
16) end Radix
Figure 8.6 shows the members of queues from the algorithm described above
operating on the list whose members are 90, 12, 8, 791, 123, and 61, the key we
are interested in for each number is highlighted. Omitted queues in Figure 8.6
mean that they contain no items.
8.7
Summary
Throughout this chapter we have seen many diﬀerent algorithms for sorting
lists, some are very eﬃcient (e.g. quick sort deﬁned in §8.3), some are not (e.g.
CHAPTER 8. SORTING
71
Figure 8.6: Radix sort base 10 algorithm
bubble sort deﬁned in §8.1).
Selecting the correct sorting algorithm is usually denoted purely by eﬃciency,
e.g. you would always choose merge sort over shell sort and so on. There are
also other factors to look at though and these are based on the actual imple-
mentation. Some algorithms are very nicely expressed in a recursive fashion,
however these algorithms ought to be pretty eﬃcient, e.g. implementing a linear,
quadratic, or slower algorithm using recursion would be a very bad idea.
If you want to learn more about why you should be very, very careful when
implementing recursive algorithms see Appendix C.
Chapter 9
Numeric
Unless stated otherwise the alias n denotes a standard 32 bit integer.
9.1
Primality Test
A simple algorithm that determines whether or not a given integer is a prime
number, e.g. 2, 5, 7, and 13 are all prime numbers, however 6 is not as it can
be the result of the product of two numbers that are < 6.
In an attempt to slow down the inner loop the √n is used as the upper
bound.
1) algorithm IsPrime(n)
2)
Post: n is determined to be a prime or not
3)
for i ←2 to n do
4)
for j ←1 to sqrt(n) do
5)
if i ∗j = n
6)
return false
7)
end if
8)
end for
9)
end for
10) end IsPrime
9.2
Base conversions
DSA contains a number of algorithms that convert a base 10 number to its
equivalent binary, octal or hexadecimal form. For example 7810 has a binary
representation of 10011102.
Table 9.1 shows the algorithm trace when the number to convert to binary
is 74210.
72
CHAPTER 9. NUMERIC
73
1) algorithm ToBinary(n)
2)
Pre: n ≥0
3)
Post: n has been converted into its base 2 representation
4)
while n > 0
5)
list.Add(n % 2)
6)
n ←n/2
7)
end while
8)
return Reverse(list)
9) end ToBinary
n
list
742
{ 0 }
371
{ 0, 1 }
185
{ 0, 1, 1 }
92
{ 0, 1, 1, 0 }
46
{ 0, 1, 1, 0, 1 }
23
{ 0, 1, 1, 0, 1, 1 }
11
{ 0, 1, 1, 0, 1, 1, 1 }
5
{ 0, 1, 1, 0, 1, 1, 1, 1 }
2
{ 0, 1, 1, 0, 1, 1, 1, 1, 0 }
1
{ 0, 1, 1, 0, 1, 1, 1, 1, 0, 1 }
Table 9.1: Algorithm trace of ToBinary
9.3
Attaining the greatest common denomina-
tor of two numbers
A fairly routine problem in mathematics is that of ﬁnding the greatest common
denominator of two integers, what we are essentially after is the greatest number
which is a multiple of both, e.g. the greatest common denominator of 9, and
15 is 3. One of the most elegant solutions to this problem is based on Euclid’s
algorithm that has a run time complexity of O(n2).
1) algorithm GreatestCommonDenominator(m, n)
2)
Pre: m and n are integers
3)
Post: the greatest common denominator of the two integers is calculated
4)
if n = 0
5)
return m
6)
end if
7)
return GreatestCommonDenominator(n, m % n)
8) end GreatestCommonDenominator
CHAPTER 9. NUMERIC
74
9.4
Computing the maximum value for a num-
ber of a speciﬁc base consisting of N digits
This algorithm computes the maximum value of a number for a given number
of digits, e.g.
using the base 10 system the maximum number we can have
made up of 4 digits is the number 999910. Similarly the maximum number that
consists of 4 digits for a base 2 number is 11112 which is 1510.
The expression by which we can compute this maximum value for N digits
is: BN −1. In the previous expression B is the number base, and N is the
number of digits. As an example if we wanted to determine the maximum value
for a hexadecimal number (base 16) consisting of 6 digits the expression would
be as follows: 166 −1. The maximum value of the previous example would be
represented as FFFFFF16 which yields 1677721510.
In the following algorithm numberBase should be considered restricted to
the values of 2, 8, 9, and 16.
For this reason in our actual implementation
numberBase has an enumeration type. The Base enumeration type is deﬁned
as:
Base = {Binary ←2, Octal ←8, Decimal ←10, Hexadecimal ←16}
The reason we provide the deﬁnition of Base is to give you an idea how this
algorithm can be modelled in a more readable manner rather than using various
checks to determine the correct base to use. For our implementation we cast the
value of numberBase to an integer, as such we extract the value associated with
the relevant option in the Base enumeration. As an example if we were to cast
the option Octal to an integer we would get the value 8. In the algorithm listed
below the cast is implicit so we just use the actual argument numberBase.
1) algorithm MaxValue(numberBase, n)
2)
Pre: numberBase is the number system to use, n is the number of digits
3)
Post: the maximum value for numberBase consisting of n digits is computed
4)
return Power(numberBase, n) −1
5) end MaxValue
9.5
Factorial of a number
Attaining the factorial of a number is a primitive mathematical operation. Many
implementations of the factorial algorithm are recursive as the problem is re-
cursive in nature, however here we present an iterative solution. The iterative
solution is presented because it too is trivial to implement and doesn’t suﬀer
from the use of recursion (for more on recursion see §C).
The factorial of 0 and 1 is 0. The aforementioned acts as a base case that we
will build upon. The factorial of 2 is 2∗the factorial of 1, similarly the factorial
of 3 is 3∗the factorial of 2 and so on. We can indicate that we are after the
factorial of a number using the form N! where N is the number we wish to
attain the factorial of. Our algorithm doesn’t use such notation but it is handy
to know.
CHAPTER 9. NUMERIC
75
1) algorithm Factorial(n)
2)
Pre: n ≥0, n is the number to compute the factorial of
3)
Post: the factorial of n is computed
4)
if n < 2
5)
return 1
6)
end if
7)
factorial ←1
8)
for i ←2 to n
9)
factorial ←factorial ∗i
10)
end for
11)
return factorial
12) end Factorial
9.6
Summary
In this chapter we have presented several numeric algorithms, most of which
are simply here because they were fun to design. Perhaps the message that
the reader should gain from this chapter is that algorithms can be applied to
several domains to make work in that respective domain attainable. Numeric
algorithms in particular drive some of the most advanced systems on the planet
computing such data as weather forecasts.
Chapter 10
Searching
10.1
Sequential Search
A simple algorithm that search for a speciﬁc item inside a list.
It operates
looping on each element O(n) until a match occurs or the end is reached.
1) algorithm SequentialSearch(list, item)
2)
Pre:
list ̸= ∅
3)
Post: return index of item if found, otherwise −1
4)
index ←0
5)
while index < list.Count and list[index] ̸= item
6)
index ←index + 1
7)
end while
8)
if index < list.Count and list[index] = item
9)
return index
10)
end if
11)
return −1
12) end SequentialSearch
10.2
Probability Search
Probability search is a statistical sequential searching algorithm. In addition to
searching for an item, it takes into account its frequency by swapping it with
it’s predecessor in the list. The algorithm complexity still remains at O(n) but
in a non-uniform items search the more frequent items are in the ﬁrst positions,
reducing list scanning time.
Figure 10.1 shows the resulting state of a list after searching for two items,
notice how the searched items have had their search probability increased after
each search operation respectively.
76
CHAPTER 10. SEARCHING
77
Figure 10.1: a) Search(12), b) Search(101)
1) algorithm ProbabilitySearch(list, item)
2)
Pre:
list ̸= ∅
3)
Post: a boolean indicating where the item is found or not;
in the former case swap founded item with its predecessor
4)
index ←0
5)
while index < list.Count and list[index] ̸= item
6)
index ←index + 1
7)
end while
8)
if index ≥list.Count or list[index] ̸= item
9)
return false
10)
end if
11)
if index > 0
12)
Swap(list[index], list[index −1])
13)
end if
14)
return true
15) end ProbabilitySearch
10.3
Summary
In this chapter we have presented a few novel searching algorithms. We have
presented more eﬃcient searching algorithms earlier on, like for instance the
logarithmic searching algorithm that AVL and BST tree’s use (deﬁned in §3.2).
We decided not to cover a searching algorithm known as binary chop (another
name for binary search, binary chop usually refers to its array counterpart) as
CHAPTER 10. SEARCHING
78
the reader has already seen such an algorithm in §3.
Searching algorithms and their eﬃciency largely depends on the underlying
data structure being used to store the data. For instance it is quicker to deter-
mine whether an item is in a hash table than it is an array, similarly it is quicker
to search a BST than it is a linked list. If you are going to search for data fairly
often then we strongly advise that you sit down and research the data structures
available to you. In most cases using a list or any other primarily linear data
structure is down to lack of knowledge. Model your data and then research the
data structures that best ﬁt your scenario.
Chapter 11
Strings
Strings have their own chapter in this text purely because string operations
and transformations are incredibly frequent within programs. The algorithms
presented are based on problems the authors have come across previously, or
were formulated to satisfy curiosity.
11.1
Reversing the order of words in a sentence
Deﬁning algorithms for primitive string operations is simple, e.g. extracting a
sub-string of a string, however some algorithms that require more inventiveness
can be a little more tricky.
The algorithm presented here does not simply reverse the characters in a
string, rather it reverses the order of words within a string. This algorithm
works on the principal that words are all delimited by white space, and using a
few markers to deﬁne where words start and end we can easily reverse them.
79
CHAPTER 11. STRINGS
80
1) algorithm ReverseWords(value)
2)
Pre:
value ̸= ∅, sb is a string buﬀer
3)
Post: the words in value have been reversed
4)
last ←value.Length −1
5)
start ←last
6)
while last ≥0
7)
// skip whitespace
8)
while start ≥0 and value[start] = whitespace
9)
start ←start −1
10)
end while
11)
last ←start
12)
// march down to the index before the beginning of the word
13)
while start ≥0 and start ̸= whitespace
14)
start ←start −1
15)
end while
16)
// append chars from start + 1 to length + 1 to string buﬀer sb
17)
for i ←start + 1 to last
18)
sb.Append(value[i])
19)
end for
20)
// if this isn’t the last word in the string add some whitespace after the word in the buﬀer
21)
if start > 0
22)
sb.Append(‘ ’)
23)
end if
24)
last ←start −1
25)
start ←last
26)
end while
27)
// check if we have added one too many whitespace to sb
28)
if sb[sb.Length −1] = whitespace
29)
// cut the whitespace
30)
sb.Length ←sb.Length −1
31)
end if
32)
return sb
33) end ReverseWords
11.2
Detecting a palindrome
Although not a frequent algorithm that will be applied in real-life scenarios
detecting a palindrome is a fun, and as it turns out pretty trivial algorithm to
design.
The algorithm that we present has a O(n) run time complexity. Our algo-
rithm uses two pointers at opposite ends of string we are checking is a palindrome
or not. These pointers march in towards each other always checking that each
character they point to is the same with respect to value. Figure 11.1 shows the
IsPalindrome algorithm in operation on the string “Was it Eliot’s toilet I saw?”
If you remove all punctuation, and white space from the aforementioned string
you will ﬁnd that it is a valid palindrome.
CHAPTER 11. STRINGS
81
Figure 11.1: left and right pointers marching in towards one another
1) algorithm IsPalindrome(value)
2)
Pre:
value ̸= ∅
3)
Post: value is determined to be a palindrome or not
4)
word ←value.Strip().ToUpperCase()
5)
left ←0
6)
right ←word.Length −1
7)
while word[left] = word[right] and left < right
8)
left ←left + 1
9)
right ←right −1
10)
end while
11)
return word[left] = word[right]
12) end IsPalindrome
In the IsPalindrome algorithm we call a method by the name of Strip. This
algorithm discards punctuation in the string, including white space. As a result
word contains a heavily compacted representation of the original string, each
character of which is in its uppercase representation.
Palindromes discard white space, punctuation, and case making these changes
allows us to design a simple algorithm while making our algorithm fairly robust
with respect to the palindromes it will detect.
11.3
Counting the number of words in a string
Counting the number of words in a string can seem pretty trivial at ﬁrst, however
there are a few cases that we need to be aware of:
1. tracking when we are in a string
2. updating the word count at the correct place
3. skipping white space that delimits the words
As an example consider the string “Ben ate hay” Clearly this string contains
three words, each of which distinguished via white space. All of the previously
listed points can be managed by using three variables:
1. index
2. wordCount
3. inWord
CHAPTER 11. STRINGS
82
Figure 11.2: String with three words
Figure 11.3: String with varying number of white space delimiting the words
Of the previously listed index keeps track of the current index we are at in
the string, wordCount is an integer that keeps track of the number of words we
have encountered, and ﬁnally inWord is a Boolean ﬂag that denotes whether
or not at the present time we are within a word. If we are not currently hitting
white space we are in a word, the opposite is true if at the present index we are
hitting white space.
What denotes a word? In our algorithm each word is separated by one or
more occurrences of white space. We don’t take into account any particular
splitting symbols you may use, e.g. in .NET String.Split1 can take a char (or
array of characters) that determines a delimiter to use to split the characters
within the string into chunks of strings, resulting in an array of sub-strings.
In Figure 11.2 we present a string indexed as an array. Typically the pattern
is the same for most words, delimited by a single occurrence of white space.
Figure 11.3 shows the same string, with the same number of words but with
varying white space splitting them.
1http://msdn.microsoft.com/en-us/library/system.string.split.aspx
CHAPTER 11. STRINGS
83
1) algorithm WordCount(value)
2)
Pre:
value ̸= ∅
3)
Post: the number of words contained within value is determined
4)
inWord ←true
5)
wordCount ←0
6)
index ←0
7)
// skip initial white space
8)
while value[index] = whitespace and index < value.Length −1
9)
index ←index + 1
10)
end while
11)
// was the string just whitespace?
12)
if index = value.Length and value[index] = whitespace
13)
return 0
14)
end if
15)
while index < value.Length
16)
if value[index] = whitespace
17)
// skip all whitespace
18)
while value[index] = whitespace and index < value.Length −1
19)
index ←index + 1
20)
end while
21)
inWord ←false
22)
wordCount ←wordCount + 1
23)
else
24)
inWord ←true
25)
end if
26)
index ←index + 1
27)
end while
28)
// last word may have not been followed by whitespace
29)
if inWord
30)
wordCount ←wordCount + 1
31)
end if
32)
return wordCount
33) end WordCount
11.4
Determining the number of repeated words
within a string
With the help of an unordered set, and an algorithm that can split the words
within a string using a speciﬁed delimiter this algorithm is straightforward to
implement. If we split all the words using a single occurrence of white space
as our delimiter we get all the words within the string back as elements of
an array. Then if we iterate through these words adding them to a set which
contains only unique strings we can attain the number of unique words from the
string. All that is left to do is subtract the unique word count from the total
number of stings contained in the array returned from the split operation. The
split operation that we refer to is the same as that mentioned in §11.3.
CHAPTER 11. STRINGS
84
Figure 11.4: a) Undesired uniques set; b) desired uniques set
1) algorithm RepeatedWordCount(value)
2)
Pre:
value ̸= ∅
3)
Post: the number of repeated words in value is returned
4)
words ←value.Split(’ ’)
5)
uniques ←Set
6)
foreach word in words
7)
uniques.Add(word.Strip())
8)
end foreach
9)
return words.Length −uniques.Count
10) end RepeatedWordCount
You will notice in the RepeatedWordCount algorithm that we use the Strip
method we referred to earlier in §11.1. This simply removes any punctuation
from a word. The reason we perform this operation on each word is so that
we can build a more accurate unique string collection, e.g. “test”, and “test!”
are the same word minus the punctuation. Figure 11.4 shows the undesired and
desired sets for the unique set respectively.
11.5
Determining the ﬁrst matching character
between two strings
The algorithm to determine whether any character of a string matches any of the
characters in another string is pretty trivial. Put simply, we can parse the strings
considered using a double loop and check, discarding punctuation, the equality
between any characters thus returning a non-negative index that represents the
location of the ﬁrst character in the match (Figure 11.5); otherwise we return
-1 if no match occurs. This approach exhibit a run time complexity of O(n2).
CHAPTER 11. STRINGS
85
t
s
e
t
0
1
2
3
4
s
r
e
t
p
0
1
2
3
4
5
6
Word
Match
i
t
s
e
t
0
1
2
3
4
s
r
e
t
p
0
1
2
3
4
5
6
i
index
t
s
e
t
0
1
2
3
4
s
r
e
t
p
0
1
2
3
4
5
6
i
index
index
a)
b)
c)
Figure 11.5: a) First Step; b) Second Step c) Match Occurred
1) algorithm Any(word,match)
2)
Pre: word, match ̸= ∅
3)
Post: index representing match location if occured, −1 otherwise
4)
for i ←0 to word.Length −1
5)
while word[i] = whitespace
6)
i ←i + 1
7)
end while
8)
for index ←0 to match.Length −1
9)
while match[index] = whitespace
10)
index ←index + 1
11)
end while
12)
if match[index] = word[i]
13)
return index
14)
end if
15)
end for
16)
end for
17)
return −1
18) end Any
11.6
Summary
We hope that the reader has seen how fun algorithms on string data types
are. Strings are probably the most common data type (and data structure -
remember we are dealing with an array) that you will work with so its important
that you learn to be creative with them. We for one ﬁnd strings fascinating. A
simple Google search on string nuances between languages and encodings will
provide you with a great number of problems. Now that we have spurred you
along a little with our introductory algorithms you can devise some of your own.
Appendix A
Algorithm Walkthrough
Learning how to design good algorithms can be assisted greatly by using a
structured approach to tracing its behaviour. In most cases tracing an algorithm
only requires a single table. In most cases tracing is not enough, you will also
want to use a diagram of the data structure your algorithm operates on. This
diagram will be used to visualise the problem more eﬀectively. Seeing things
visually can help you understand the problem quicker, and better.
The trace table will store information about the variables used in your algo-
rithm. The values within this table are constantly updated when the algorithm
mutates them. Such an approach allows you to attain a history of the various
values each variable has held. You may also be able to infer patterns from the
values each variable has contained so that you can make your algorithm more
eﬃcient.
We have found this approach both simple, and powerful. By combining a
visual representation of the problem as well as having a history of past values
generated by the algorithm it can make understanding, and solving problems
much easier.
In this chapter we will show you how to work through both iterative, and
recursive algorithms using the technique outlined.
A.1
Iterative algorithms
We will trace the IsPalindrome algorithm (deﬁned in §11.2) as our example
iterative walkthrough. Before we even look at the variables the algorithm uses,
ﬁrst we will look at the actual data structure the algorithm operates on. It
should be pretty obvious that we are operating on a string, but how is this
represented? A string is essentially a block of contiguous memory that consists
of some char data types, one after the other. Each character in the string can
be accessed via an index much like you would do when accessing items within
an array. The picture should be presenting itself - a string can be thought of as
an array of characters.
For our example we will use IsPalindrome to operate on the string “Never
odd or even” Now we know how the string data structure is represented, and
the value of the string we will operate on let’s go ahead and draw it as shown
in Figure A.1.
86
APPENDIX A. ALGORITHM WALKTHROUGH
87
Figure A.1: Visualising the data structure we are operating on
value
word
left
right
Table A.1: A column for each variable we wish to track
The IsPalindrome algorithm uses the following list of variables in some form
throughout its execution:
1. value
2. word
3. left
4. right
Having identiﬁed the values of the variables we need to keep track of we
simply create a column for each in a table as shown in Table A.1.
Now, using the IsPalindrome algorithm execute each statement updating
the variable values in the table appropriately. Table A.2 shows the ﬁnal table
values for each variable used in IsPalindrome respectively.
While this approach may look a little bloated in print, on paper it is much
more compact. Where we have the strings in the table you should annotate
these strings with array indexes to aid the algorithm walkthrough.
There is one other point that we should clarify at this time - whether to
include variables that change only a few times, or not at all in the trace table.
In Table A.2 we have included both the value, and word variables because it
was convenient to do so. You may ﬁnd that you want to promote these values
to a larger diagram (like that in Figure A.1) and only use the trace table for
variables whose values change during the algorithm. We recommend that you
promote the core data structure being operated on to a larger diagram outside
of the table so that you can interrogate it more easily.
value
word
left
right
“Never odd or even”
“NEVERODDOREVEN”
0
13
1
12
2
11
3
10
4
9
5
8
6
7
7
6
Table A.2: Algorithm trace for IsPalindrome
APPENDIX A. ALGORITHM WALKTHROUGH
88
We cannot stress enough how important such traces are when designing
your algorithm. You can use these trace tables to verify algorithm correctness.
At the cost of a simple table, and quick sketch of the data structure you are
operating on you can devise correct algorithms quicker. Visualising the problem
domain and keeping track of changing data makes problems a lot easier to solve.
Moreover you always have a point of reference which you can look back on.
A.2
Recursive Algorithms
For the most part working through recursive algorithms is as simple as walking
through an iterative algorithm. One of the things that we need to keep track
of though is which method call returns to who. Most recursive algorithms are
much simple to follow when you draw out the recursive calls rather than using
a table based approach. In this section we will use a recursive implementation
of an algorithm that computes a number from the Fiboncacci sequence.
1) algorithm Fibonacci(n)
2)
Pre: n is the number in the ﬁbonacci sequence to compute
3)
Post: the ﬁbonacci sequence number n has been computed
4)
if n < 1
5)
return 0
6)
else if n < 2
7)
return 1
8)
end if
9)
return Fibonacci(n −1) + Fibonacci(n −2)
10) end Fibonacci
Before we jump into showing you a diagrammtic representation of the algo-
rithm calls for the Fibonacci algorithm we will brieﬂy talk about the cases of
the algorithm. The algorithm has three cases in total:
1. n < 1
2. n < 2
3. n ≥2
The ﬁrst two items in the preceeding list are the base cases of the algorithm.
Until we hit one of our base cases in our recursive method call tree we won’t
return anything. The third item from the list is our recursive case.
With each call to the recursive case we etch ever closer to one of our base
cases. Figure A.2 shows a diagrammtic representation of the recursive call chain.
In Figure A.2 the order in which the methods are called are labelled. Figure
A.3 shows the call chain annotated with the return values of each method call
as well as the order in which methods return to their callers. In Figure A.3 the
return values are represented as annotations to the red arrows.
It is important to note that each recursive call only ever returns to its caller
upon hitting one of the two base cases. When you do eventually hit a base case
that branch of recursive calls ceases. Upon hitting a base case you go back to
APPENDIX A. ALGORITHM WALKTHROUGH
89
Figure A.2: Call chain for Fibonacci algorithm
Figure A.3: Return chain for Fibonacci algorithm
APPENDIX A. ALGORITHM WALKTHROUGH
90
the caller and continue execution of that method. Execution in the caller is
contiued at the next statement, or expression after the recursive call was made.
In the Fibonacci algorithms’ recursive case we make two recursive calls.
When the ﬁrst recursive call (Fibonacci(n −1)) returns to the caller we then
execute the the second recursive call (Fibonacci(n −2)). After both recursive
calls have returned to their caller, the caller can then subesequently return to
its caller and so on.
Recursive algorithms are much easier to demonstrate diagrammatically as
Figure A.2 demonstrates. When you come across a recursive algorithm draw
method call diagrams to understand how the algorithm works at a high level.
A.3
Summary
Understanding algorithms can be hard at times, particularly from an implemen-
tation perspective. In order to understand an algorithm try and work through
it using trace tables. In cases where the algorithm is also recursive sketch the
recursive calls out so you can visualise the call/return chain.
In the vast majority of cases implementing an algorithm is simple provided
that you know how the algorithm works. Mastering how an algorithm works
from a high level is key for devising a well designed solution to the problem in
hand.
Appendix B
Translation Walkthrough
The conversion from pseudo to an actual imperative language is usually very
straight forward, to clarify an example is provided. In this example we will
convert the algorithm in §9.1 to the C# language.
1) public static bool IsPrime(int number)
2) {
3)
if (number < 2)
4)
{
5)
return false;
6)
}
7)
int innerLoopBound = (int)Math.Floor(Math.Sqrt(number));
8)
for (int i = 1; i < number; i++)
9)
{
10)
for(int j = 1; j <= innerLoopBound; j++)
11)
{
12)
if (i ∗j == number)
13)
{
14)
return false;
15)
}
16)
}
17)
}
18)
return true;
19) }
For the most part the conversion is a straight forward process, however you
may have to inject various calls to other utility algorithms to ascertain the
correct result.
A consideration to take note of is that many algorithms have fairly strict
preconditions, of which there may be several - in these scenarios you will need
to inject the correct code to handle such situations to preserve the correctness of
the algorithm. Most of the preconditions can be suitably handled by throwing
the correct exception.
91
APPENDIX B. TRANSLATION WALKTHROUGH
92
B.1
Summary
As you can see from the example used in this chapter we have tried to make the
translation of our pseudo code algorithms to mainstream imperative languages
as simple as possible.
Whenever you encounter a keyword within our pseudo code examples that
you are unfamiliar with just browse to Appendix E which descirbes each key-
word.
Appendix C
Recursive Vs. Iterative
Solutions
One of the most succinct properties of modern programming languages like
C++, C#, and Java (as well as many others) is that these languages allow
you to deﬁne methods that reference themselves, such methods are said to be
recursive. One of the biggest advantages recursive methods bring to the table is
that they usually result in more readable, and compact solutions to problems.
A recursive method then is one that is deﬁned in terms of itself. Generally
a recursive algorithms has two main properties:
1. One or more base cases; and
2. A recursive case
For now we will brieﬂy cover these two aspects of recursive algorithms. With
each recursive call we should be making progress to our base case otherwise we
are going to run into trouble. The trouble we speak of manifests itself typically
as a stack overﬂow, we will describe why later.
Now that we have brieﬂy described what a recursive algorithm is and why
you might want to use such an approach for your algorithms we will now talk
about iterative solutions. An iterative solution uses no recursion whatsoever.
An iterative solution relies only on the use of loops (e.g. for, while, do-while,
etc). The down side to iterative algorithms is that they tend not to be as clear
as to their recursive counterparts with respect to their operation. The major
advantage of iterative solutions is speed. Most production software you will
ﬁnd uses little or no recursive algorithms whatsoever. The latter property can
sometimes be a companies prerequisite to checking in code, e.g. upon checking
in a static analysis tool may verify that the code the developer is checking in
contains no recursive algorithms. Normally it is systems level code that has this
zero tolerance policy for recursive algorithms.
Using recursion should always be reserved for fast algorithms, you should
avoid it for the following algorithm run time deﬁciencies:
1. O(n2)
2. O(n3)
93
APPENDIX C. RECURSIVE VS. ITERATIVE SOLUTIONS
94
3. O(2n)
If you use recursion for algorithms with any of the above run time eﬃciency’s
you are inviting trouble. The growth rate of these algorithms is high and in
most cases such algorithms will lean very heavily on techniques like divide and
conquer.
While constantly splitting problems into smaller problems is good
practice, in these cases you are going to be spawning a lot of method calls. All
this overhead (method calls don’t come that cheap) will soon pile up and either
cause your algorithm to run a lot slower than expected, or worse, you will run
out of stack space. When you exceed the allotted stack space for a thread the
process will be shutdown by the operating system. This is the case irrespective
of the platform you use, e.g. .NET, or native C++ etc. You can ask for a bigger
stack size, but you typically only want to do this if you have a very good reason
to do so.
C.1
Activation Records
An activation record is created every time you invoke a method. Put simply
an activation record is something that is put on the stack to support method
invocation. Activation records take a small amount of time to create, and are
pretty lightweight.
Normally an activation record for a method call is as follows (this is very
general):
• The actual parameters of the method are pushed onto the stack
• The return address is pushed onto the stack
• The top-of-stack index is incremented by the total amount of memory
required by the local variables within the method
• A jump is made to the method
In many recursive algorithms operating on large data structures, or algo-
rithms that are ineﬃcient you will run out of stack space quickly. Consider an
algorithm that when invoked given a speciﬁc value it creates many recursive
calls. In such a case a big chunk of the stack will be consumed. We will have to
wait until the activation records start to be unwound after the nested methods
in the call chain exit and return to their respective caller. When a method exits
it’s activation record is unwound. Unwinding an activation record results in
several steps:
1. The top-of-stack index is decremented by the total amount of memory
consumed by the method
2. The return address is popped oﬀthe stack
3. The top-of-stack index is decremented by the total amount of memory
consumed by the actual parameters
APPENDIX C. RECURSIVE VS. ITERATIVE SOLUTIONS
95
While activation records are an eﬃcient way to support method calls they
can build up very quickly.
Recursive algorithms can exhaust the stack size
allocated to the thread fairly fast given the chance.
Just about now we should be dusting the cobwebs oﬀthe age old example of
an iterative vs. recursive solution in the form of the Fibonacci algorithm. This
is a famous example as it highlights both the beauty and pitfalls of a recursive
algorithm. The iterative solution is not as pretty, nor self documenting but it
does the job a lot quicker. If we were to give the Fibonacci algorithm an input
of say 60 then we would have to wait a while to get the value back because it
has an O(gn) run time. The iterative version on the other hand has a O(n)
run time. Don’t let this put you oﬀrecursion. This example is mainly used
to shock programmers into thinking about the ramiﬁcations of recursion rather
than warning them oﬀ.
C.2
Some problems are recursive in nature
Something that you may come across is that some data structures and algo-
rithms are actually recursive in nature. A perfect example of this is a tree data
structure. A common tree node usually contains a value, along with two point-
ers to two other nodes of the same node type. As you can see tree is recursive
in its makeup wit each node possibly pointing to two other nodes.
When using recursive algorithms on tree’s it makes sense as you are simply
adhering to the inherent design of the data structure you are operating on. Of
course it is not all good news, after all we are still bound by the limitations we
have mentioned previously in this chapter.
We can also look at sorting algorithms like merge sort, and quick sort. Both
of these algorithms are recursive in their design and so it makes sense to model
them recursively.
C.3
Summary
Recursion is a powerful tool, and one that all programmers should know of.
Often software projects will take a trade between readability, and eﬃciency in
which case recursion is great provided you don’t go and use it to implement
an algorithm with a quadratic run time or higher. Of course this is not a rule
of thumb, this is just us throwing caution to the wind. Defensive coding will
always prevail.
Many times recursion has a natural home in recursive data structures and
algorithms which are recursive in nature. Using recursion in such scenarios is
perfectly acceptable. Using recursion for something like linked list traversal is
a little overkill. Its iterative counterpart is probably less lines of code than its
recursive counterpart.
Because we can only talk about the implications of using recursion from an
abstract point of view you should consult your compiler and run time environ-
ment for more details. It may be the case that your compiler recognises things
like tail recursion and can optimise them. This isn’t unheard of, in fact most
commercial compilers will do this. The amount of optimisation compilers can
APPENDIX C. RECURSIVE VS. ITERATIVE SOLUTIONS
96
do though is somewhat limited by the fact that you are still using recursion.
You, as the developer have to accept certain accountability’s for performance.
Appendix D
Testing
Testing is an essential part of software development. Testing has often been
discarded by many developers in the belief that the burden of proof of their
software is on those within the company who hold test centric roles.
This
couldn’t be further from the truth. As a developer you should at least provide
a suite of unit tests that verify certain boundary conditions of your software.
A great thing about testing is that you build up progressively a safety net. If
you add or tweak algorithms and then run your suite of tests you will be quickly
alerted to any cases that you have broken with your recent changes. Such a suite
of tests in any sizeable project is absolutely essential to maintaining a fairly high
bar when it comes to quality. Of course in order to attain such a standard you
need to think carefully about the tests that you construct.
Unit testing which will be the subject of the vast majority of this chapter
are widely available on most platforms. Most modern languages like C++, C#,
and Java oﬀer an impressive catalogue of testing frameworks that you can use
for unit testing.
The following list identiﬁes testing frameworks which are popular:
JUnit: Targeted at Jav., http://www.junit.org/
NUnit: Can be used with languages that target Microsoft’s Common Language
Runtime. http://www.nunit.org/index.php
Boost Test Library: Targeted at C++. The test library that ships with the incredibly popular
Boost libraries. http://www.boost.org. A direct link to the libraries doc-
umentation http://www.boost.org/doc/libs/1_36_0/libs/test/doc/
html/index.html
CppUnit: Targeted at C++. http://cppunit.sourceforge.net/
Don’t worry if you think that the list is very sparse, there are far more on
oﬀer than those that we have listed. The ones listed are the testing frameworks
that we believe are the most popular for C++, C#, and Java.
D.1
What constitutes a unit test?
A unit test should focus on a single atomic property of the subject being tested.
Do not try and test many things at once, this will result in a suite of somewhat
97
APPENDIX D. TESTING
98
unstructured tests. As an example if you were wanting to write a test that
veriﬁed that a particular value V is returned from a speciﬁc input I then your
test should do the smallest amount of work possible to verify that V is correct
given I. A unit test should be simple and self describing.
As well as a unit test being relatively atomic you should also make sure that
your unit tests execute quickly. If you can imagine in the future when you may
have a test suite consisting of thousands of tests you want those tests to execute
as quickly as possible. Failure to attain such a goal will most likely result in
the suite of tests not being ran that often by the developers on your team. This
can occur for a number of reasons but the main one would be that it becomes
incredibly tedious waiting several minutes to run tests on a developers local
machine.
Building up a test suite can help greatly in a team scenario, particularly
when using a continuous build server. In such a scenario you can have the suite
of tests devised by the developers and testers ran as part of the build process.
Employing such strategies can help you catch niggling little error cases early
rather than via your customer base. There is nothing more embarrassing for a
developer than to have a very trivial bug in their code reported to them from a
customer.
D.2
When should I write my tests?
A source of great debate would be an understatement to personify such a ques-
tion as this. In recent years a test driven approach to development has become
very popular. Such an approach is known as test driven development, or more
commonly the acronym TDD.
One of the founding principles of TDD is to write the unit test ﬁrst, watch
it fail and then make it pass.
The premise being that you only ever write
enough code at any one time to satisfy the state based assertions made in a unit
test. We have found this approach to provide a more structured intent to the
implementation of algorithms. At any one stage you only have a single goal, to
make the failing test pass. Because TDD makes you write the tests up front you
never ﬁnd yourself in a situation where you forget, or can’t be bothered to write
tests for your code. This is often the case when you write your tests after you
have coded up your implementation. We, as the authors of this book ourselves
use TDD as our preferred method.
As we have already mentioned that TDD is our favoured approach to testing
it would be somewhat of an injustice to not list, and describe the mantra that
is often associate with it:
Red: Signiﬁes that the test has failed.
Green: The failing test now passes.
Refactor: Can we restructure our program so it makes more sense, and easier to
maintain?
The ﬁrst point of the above list always occurs at least once (more if you count
the build error) in TDD initially. Your task at this stage is solely to make the
test pass, that is to make the respective test green. The last item is based around
APPENDIX D. TESTING
99
the restructuring of your program to make it as readable and maintainable as
possible. The last point is very important as TDD is a progressive methodology
to building a solution. If you adhere to progressive revisions of your algorithm
restructuring when appropriate you will ﬁnd that using TDD you can implement
very cleanly structured types and so on.
D.3
How seriously should I view my test suite?
Your tests are a major part of your project ecosystem and so they should be
treated with the same amount of respect as your production code. This ranges
from correct, and clean code formatting, to the testing code being stored within
a source control repository.
Employing a methodology like TDD, or testing after implementing you will
ﬁnd that you spend a great amount of time writing tests and thus they should
be treated no diﬀerently to your production code. All tests should be clearly
named, and fully documented as to their intent.
D.4
The three A’s
Now that you have a sense of the importance of your test suite you will inevitably
want to know how to actually structure each block of imperatives within a single
unit test. A popular approach - the three A’s is described in the following list:
Assemble: Create the objects you require in order to perform the state based asser-
tions.
Act: Invoke the respective operations on the objects you have assembled to
mutate the state to that desired for your assertions.
Assert: Specify what you expect to hold after the previous two steps.
The following example shows a simple test method that employs the three
A’s:
public void MyTest()
{
// assemble
Type t = new Type();
// act
t.MethodA();
// assert
Assert.IsTrue(t.BoolExpr)
}
D.5
The structuring of tests
Structuring tests can be viewed upon as being the same as structuring pro-
duction code, e.g. all unit tests for a Person type may be contained within
APPENDIX D. TESTING
100
a PersonTest type. Typically all tests are abstracted from production code.
That is that the tests are disjoint from the production code, you may have two
dynamic link libraries (dll); the ﬁrst containing the production code, the second
containing your test code.
We can also use things like inheritance etc when deﬁning classes of tests.
The point being that the test code is very much like your production code and
you should apply the same amount of thought to its structure as you would do
the production code.
D.6
Code Coverage
Something that you can get as a product of unit testing are code coverage
statistics. Code coverage is merely an indicator as to the portions of production
code that your units tests cover. Using TDD it is likely that your code coverage
will be very high, although it will vary depending on how easy it is to use TDD
within your project.
D.7
Summary
Testing is key to the creation of a moderately stable product. Moreover unit
testing can be used to create a safety blanket when adding and removing features
providing an early warning for breaking changes within your production code.
Appendix E
Symbol Deﬁnitions
Throughout the pseudocode listings you will ﬁnd several symbols used, describes
the meaning of each of those symbols.
Symbol
Description
←
Assignment.
=
Equality.
≤
Less than or equal to.
<
Less than.*
≥
Greater than or equal to.
>
Greater than.*
̸=
Inequality.
∅
Null.
and
Logical and.
or
Logical or.
whitespace
Single occurrence of whitespace.
yield
Like return but builds a sequence.
Table E.1: Pseudo symbol deﬁnitions
* This symbol has a direct translation with the vast majority of imperative
counterparts.
101


ID: https://www.youtube.com/embed/8hly31xKli0?si=jNSy4Yk7gnLrN9in
Document: this is a full-length course from treehouse we at free code camp are longtime fans of their learning platform they were kind enough to let our non-profit make this course freely available on our youtube channel if you like this course treehouse has a lot more courses like this one the link is in the description along with time codes to the different sections in this course [Music] hi my name is passan i'm an instructor here at treehouse and welcome to introduction to algorithms whether you are a high school or college student a developer in the industry or someone who is learning to code you have undoubtedly run into the term algorithm for many people this word is kind of scary it represents this body of knowledge that seems just out of reach only people with computer science degrees know about algorithms now to others this brings up feelings of imposter syndrome you might already know how to code but you're not a real developer because you don't know anything about algorithms personally it made me frame certain jobs as above my skill level because the interview contained algorithm questions well whatever your reasons are in this course our goal is to dispel all those feelings and get you comfortable with the basics of algorithms like any other subject i like to start my courses with what the course is and is not in this course we're going to cover the very basic set of knowledge that you need as a foundation for learning about algorithms this course is less about specific algorithms and more about the tools you will need to evaluate algorithms understand how they perform compare them to each other and make a statement about the utility of an algorithm in a given context now don't worry none of this will be theoretical and we will learn these concepts by using well-known algorithms in this course we will also be writing code so i do expect you to have some programming experience if you intend to continue with this topic you can definitely stick around even if you don't know how to code but you might want to learn the basics of programming in the meantime in this course we will be using the python programming language python reads a lot like regular english and is the language you will most likely encounter when learning about algorithms these days if you don't know how to code or if you know how to code in a different language check out the notes section of this video for links to other content that might be useful to you as long as you understand the fundamentals of programming you should be able to follow along pretty well if you're a javascript developer or a student who's learning javascript for example chances are good that you'll still be able to understand the code we write later i'll be sure to provide links along the way if you need anything to follow up on let's start with something simple what is an algorithm an algorithm is a set of steps or instructions for completing a task this might sound like an over simplification but really that's precisely what an algorithm is a recipe is an algorithm your morning routine when you wake up is an algorithm and the driving directions you follow to get to a destination is also an algorithm in computer science the term algorithm more specifically means the set of steps a program takes to finish a task if you've written code before any code really generally speaking you have written an algorithm given that much of the code we write can be considered an algorithm what do people mean when they say you should know about algorithms now consider this let's say i'm a teacher in a classroom and i tell everyone i have an assignment for them on their desks they have a picture of a maze and their task is to come up with a way to find the quickest way out of the maze everyone does their thing and comes up with a solution every single one of these solutions is a viable solution and is a valid example of an algorithm the steps one needs to take to get out of the maze but from being in classrooms or any group of any sort you know that some people will have better ideas than others we all have a diverse array of skill sets over time our class picks the best of these solutions and any time we want to solve a maze we go with one of these solutions this is what the field of algorithms is about there are many problems in computer science but some of them are pretty common regardless of what project you're working on different people have come up with different solutions to these common problems and over time the field of computer science has identified several that do the job well for a given task when we talk of algorithms we're referring to two points we're primarily saying there's an established body of knowledge on how to solve particular problems well and it's important to know what the solutions are now why is it important if you're unaware that a solution exists you might try to come up with one yourself and there's a likelihood that your solution won't be as good or efficient whatever that means compared to those that have been thoroughly reviewed but there's a second component to it as well part of understanding algorithms is not just knowing that an algorithm exists but understanding when to apply it understanding when to apply an algorithm requires properly understanding the problem at hand and this arguably is the most important part of learning about algorithms and data structures as you progress through this content you should be able to look at a problem and break it down into distinct steps when you have a set of steps you should then be able to identify which algorithm or data structure is best for the task at hand this concept is called algorithmic thinking and it's something we're going to try and cultivate together as we work through our content lastly learning about algorithms gives you a deeper understanding about complexity and efficiency in programming having a better sense of how your code will perform in different situations is something that you'll always want to develop in hone algorithmic thinking is why algorithms also come up in big tech interviews interviewers don't care as much that you are able to write a specific algorithm in code but more about the fact that you can break a seemingly insurmountable problem into distinct components and identify the right tools to solve each distinct component and that is what we plan on doing in this course though we're going to focus on some of the tools and concepts you'll need to be aware of before we can dive into the topic of algorithms if you're ready let's get started hey again in this video we're going to do something unusual we're going to play a game and by we i mean me and my two friends here brittany and john this game is really simple and you may have played it before it goes something like this i'm going to think of a number between 1 and 10 and they have to guess what the number is easy right when they guess a number i'll tell them if their guess is too high or too low the winner is the one with the fewest tries all right john let's start with you i'm thinking of a number between one and ten what is it between you and me the answer is three uh quick question does the range include one and ten that is a really good question so what john did right there was to establish the bounds of our problem no solution works on every problem and an important part of algorithmic thinking is to clearly define what the problem set is and clarify what values count as inputs yeah 1 and ten are both included is it one too low is it two too low is it three correct okay so that was an easy one it took john three tries to get the answer let's switch over to brittany and play another round using the same number as the answer okay brittany i'm thinking of a number between 1 and 10 inclusive so both 1 and 10 are in the range what number am i thinking of is it 5 too high 2 too low is it 3 correct all right so what we had there was two very different ways of playing the same game somehow with even such a simple game we saw different approaches to figuring out a solution to go back to algorithmic thinking for a second this means that with any given problem there's no one best solution instead what we should try and figure out is what solution works better for the current problem in this first pass at the game they both took the same amount of turns to find the answer so it's not obvious who has the better approach and that's mostly because the game was easy let's try this one more time now this time the answer is 10. all right john you first is it one too low is it two still too low is it three too low is it four too low is it five still too low is it six too low is it seven too low is it eight low is it nine do low is it ten correct you got it okay so now same thing but with britney this time is it five too low eight too low is it nine still too low it's ten all right so here we start to see a difference between their strategies when the answer was three they both took the same number of turns this is important when the number was larger but not that much larger 10 in this case we start to see that britney strategy did better she took four tries while john took 10. we've played two rounds so far and we've seen a different set of results based on the number they were looking for if you look at john's way of doing things then the answer being 10 the round we just played is his worst case scenario he will take the maximum number of turns 10 to guess it when we picked a random number like three it was hard to differentiate which strategy was better because they both performed exactly the same but in john's worst case scenario a clear winner in terms of strategy emerges in terms of algorithmic thinking we're starting to get a sense that the specific value they're searching for may not matter as much as where that value lies in the range that they've been given identifying this helps us understand our problem better let's do this again for a range of numbers from one to one hundred we'll start by picking five as an answer to trick them okay so this time we're going to run through the exercise again this time from one to one hundred and both one and one hundred are included is it one at this point without even having to run through it we can guess how many tries john is going to take since he starts at one and keeps going he's going to take five tries as we're about to see is it five cool correct okay now for brittany's turn is it 50 too high is it 25 still too high is it 13 too high is it seven too high is it four too low is it six too high is it five correct let's evaluate john took five tries brittany on the other hand takes seven tries so john wins this round but again in determining whose strategy is preferred there's no clear winner right now what this tells us is that it's not particularly useful to look at the easy answers where we arrive at the number fairly quickly because it's at the start of the range instead let's try one where we know john is going to do poorly let's look at his worst case scenario where the answer is 100 and see how britney performs in such a scenario okay john let's do this one more time one through 100 again is it one we can fast forward this scene because well we know what happens john takes 100 tries hi brittany you're up is it 50 too low is it 75 too low 88 too low 94 too low is it 97 too low 99 too low 100. okay so that took brittney seven turns again and this time she is the clear winner if you compare their individual performances for the same number set you'll see that britney's approach leaves john's in the dust when the answer was five so right around the start of the range john took five turns but when the answer was 100 right at the end of the range he took 100 tries it took him 20 times the amount of tries to get that answer compared to britney on the other hand if you compare britney's efforts when the number was 5 she took seven tries but when the number was 100 she took the same amount of tries this is pretty impressive if we pretend that the number of tries is the number of seconds it takes britney and john to run through their attempts this is a good estimate for how fast their solutions are ok we've done this a couple times and brittany and john are getting tired let's take a break in the next video we'll talk about the point of this exercise in the last video we ran through an exercise where i had some of my co-workers guess what number i was thinking so was the point of that exercise you might be thinking hey i thought i was here to learn about algorithms the exercise we just did was an example of a real life situation you will run into when building websites apps and writing code both approaches taken by john and brittany to find the number i was thinking of are examples of searching for a value it might be weird to think that there's more than one way to search but as you saw in the game the speed at which the result was obtained differed between john and brittany think about this problem from the perspective of a company like facebook at the time of this recording facebook has 2.19 billion active users let's say you're traveling in a different country and meet someone you want to add on facebook you go into the search bar and type out this person's name if we simplify how the facebook app works it has to search across these 2.19 billion records and find the person you are looking for the speed at which you find this person really matters imagine what kind of experience it would be if when you search for a friend facebook put up a spinning activity indicator and said come back in a couple hours i don't think we'd use facebook as much if that was the case from the company's perspective working on making search as fast as possible using different strategies really matters now i said that the two strategies britney and john used were examples of search more specifically these are search algorithms the strategy john took where he started at the beginning of the range and just counted one number after the other is a type of search called linear search it is also called sequential search which is a better description of how it works or even simple search since it really is quite simple but what makes his approach an algorithm as opposed to just looking for something remember we said that an algorithm is a set of steps or instructions to complete a task linear search is a search algorithm and we can define it like this we start at the beginning of the list or the range of values then we compare the current value to the target if the current value is the target value that we're looking for we're done if it's not we'll move on sequentially to the next value in the list and then repeat step 2. if we reach the end of the list then the target value is not in the list this definition has nothing to do with programming and in fact you can use it in the real world for example i could tell you to walk into a bookstore and find me a particular book and one of the ways you could do it is using the linear search algorithm you could start at the front of the bookstore and read the cover or the spine of every book to check that it matches the book that you're looking for if it doesn't you go to the next book and repeat until you find it or run out of books what makes this an algorithm is the specificity of how it is defined in contrast to just jumping into a problem and solving it as we go along an algorithm follows a certain set of guidelines and we use the same steps to solve the problem each time we face it an important first step to defining the algorithm isn't the algorithm itself but the problem we're trying to solve our first guideline is that an algorithm must have a clear problem statement it's pretty hard to define an instruction set when you don't have a clear idea of what problem you're trying to solve in defining the problem we need to specify how the input is defined and what the output looks like when the algorithm has done its job for linear search the input can be generally described as a series of values and the output is a value matching the one we're looking for right now we're trying to stay away from anything code related so this problem statement definition is pretty generic but once we get to code we can actually tighten this up once we have a problem an algorithm is a set of steps that solves this problem given that the next guideline is that an algorithm definition must contain a specific set of instructions in a particular order we really need to be clear about the order in which these instructions are executed taking our simple definition of linear search if i switched up the order and said move sequentially to the next value before specifying that first comparison step if the first value were the target one our algorithm wouldn't find it because we moved to the second value before comparing now you might think okay that's just an avoidable mistake and kind of common sense the thing is computers don't know any of that and just do exactly as we tell them so specific order is really important the third guideline is that each step in our algorithm definition must not be a complex one and needs to be explicitly clear what i mean by that is that you shouldn't be able to break down any of the steps into further into additional subtasks each step needs to be a distinct one we can't define linear search as search until you find this value because that can be interpreted in many ways and further broken down into many more steps it's not clear next and this one might seem obvious but algorithms should produce a result if it didn't how would we know whether the algorithm works or not to be able to verify that our algorithm works correctly we need a result now when using a search algorithm the end result can actually be nothing which indicates that the value wasn't found but that's perfectly fine there are several ways to represent nothing in code and as long as the algorithm can produce some results we can understand its behavior the last guideline is that the algorithm should actually complete and cannot take an infinite amount of time if we let john loose in the world's largest library and asked him to find a novel we have no way of knowing whether he succeeded or not unless he came back to us with a result okay so quick recap what makes an algorithm an algorithm and not just something you do one it needs to have a clearly defined problem statement input and output when using linear search the input needs to be just a series of values but to actually use brittany's strategy there's one additional precondition so to speak if you think about her strategy it required that the numbers be sorted in ascending order this means that where the input for john is just a series of values to solve the problem the input to brittany's algorithm needs to be a sorted series of values so clearly defined problem statement clearly defined input and clearly defined output second the steps in the algorithm need to be in a very specific order the steps also need to be distinct you should not be able to break it down into further subtasks next the algorithm should produce a result and finally the algorithm should complete in a finite amount of time these guidelines not only help us define what an algorithm is but also helps us verify that the algorithm is correct executing the steps in an algorithm for a given input must result in the same output every time if in the game i played the answer was 50 every time then every single time john must take 50 turns to find out that the answer is 50. if somehow he takes 50 turns in one round then 30 the next and we technically don't have a correct algorithm consistent results for the same set of values is how we know that the algorithm is correct i should stress that we're not going to be designing any algorithms on our own and we'll start off and spend most of our time learning the tried and true algorithms that are known to efficiently solve problems the reason for talking about what makes for a good algorithm though is that the same set of guidelines makes for good algorithmic thinking which is one of the most important skills we want to cultivate when we encounter a problem before rushing in and thinking about solutions what we want to do is work through the guidelines first we break down the problem into any possible number of smaller problems where each problem can be clearly defined in terms of an input and an output now that we know how to generally define an algorithm let's talk about what it means to have a good algorithm an important thing to keep in mind is that there's no one single way to measure whether an algorithm is the right solution because it is all about context earlier we touched on two concepts correctness and efficiency let's define correctness more clearly because before we can evaluate an algorithm on efficiency we need to ensure its correctness before we define our algorithms we start by defining our problem in the definition of that problem we have a clearly defined input satisfying any preconditions and a clearly defined output an algorithm is deemed correct if on every run of the algorithm against all possible values in the input data we always get the output we expect part of correctness means that for any possible input the algorithm should always terminate or end if these two are not true then our algorithm isn't correct if you were to pick up an algorithm's textbook and look up correctness you will run into a bunch of mathematical theory this is because traditionally algorithm correctness is proved by mathematical induction which is a form of reasoning used in mathematics to verify that a statement is correct this approach involves writing what is called a specification and a correctness proof we won't be going into that in this course proof through induction is an important part of designing algorithms but we're confident that you can understand algorithms both in terms of how and when to use them without getting into the math so if you pick up a textbook and feel daunted don't worry i do too but we can still figure things out without it all right so once we have a correct algorithm we can start to talk about how efficient an algorithm is remember that this efficiency ultimately matters because they help us solve problems faster and deliver a better end user experience in a variety of fields for example algorithms are used in the sequencing of dna and more efficient sequencing algorithms allow us to research and understand diseases better and faster but let's not get ahead of ourselves we'll start simple by evaluating john's linear search algorithm in terms of its efficiency first what do we mean by efficiency there are two measures of efficiency when it comes to algorithms time and space sounds really cool and very sci-fi huh efficiency measured by time something you'll hear called time complexity is a measure of how long it takes the algorithm to run time complexity can be understood generally outside the context of code and computers because how long it takes to complete a job is a universal measure of efficiency the less time you take the more efficient you are the second measure of efficiency is called space complexity and this is pretty computer specific it deals with the amount of memory taken up on the computer good algorithms need to balance between these two measures to be useful for example you can have a blazingly fast algorithm but it might not matter if the algorithm consumes more memory than you have available both of these concepts time and space complexity are measured using the same metric but it is a very technical sounding metric so let's build up to it slowly and start simple a few videos ago i played a game with brittany and john where they tried to guess the number i was thinking of effectively they were searching for a value so how do we figure out how efficient each algorithm is and which algorithm was more suited to our purposes if we consider the number of tries they took to guess or search for the value as an indicator of the time they take to run through the exercise this is a good indicator of how long the algorithm runs for a given set of values this measurement is called the running time of an algorithm and we'll use it to define time complexity in the game we play it four rounds let's recap those here focusing on john's performance in round one we had 10 values the target was 3 and john took 3 turns in round 2 we had 10 values the target was 10 and john took 10 turns in round 3 we had 100 values the target was john took five tries and finally in round four when the target was 100 given 100 values john took 100 tries on paper it's hard to gauge anything about this performance when it comes to anything with numbers though i like to put it up on a graph and compare visually on the vertical or y-axis let's measure the number of tries it took john to guess the answer or the running time of the algorithm on the horizontal or x-axis what do we put for each turn we have a number of values as well as a target value we could plot the target value on the horizontal axis but that leaves some context and meaning behind it's far more impressive that john took five tries when the range went up to 100 then when he took three tries for a maximum of 10 values we could plot the maximum range of values but then we're leaving out the other half of the picture there are data points however that satisfy both requirements if we only plot the values where the target the number john was looking for was the same as the maximum range of values we have a data point that includes both the size of the data set as well as his effort there's an additional benefit to this approach as well there are three ways we can measure how well john does or in general how well any algorithm does first we can check how well john does in the best case or good scenarios from the perspective of his strategy in the range of 100 values the answer being a low number like three at the start of the range is a good scenario he can guess it fairly quickly one is his best case scenario or we could check how well he does on average we could run this game a bunch of times and average out the running time this would give us a much better picture of john's performance over time but our estimates would be too high if the value he was searching for was at the start of the range or far too low if it was at the end of the range let's imagine a scenario where facebook naively implements linear search when finding friends they looked at the latest u.s census saw that 50 of names start with the letters a through j which is the first 40 of the alphabet and thought okay on average linear search serves us well but what about the rest of those whose names start with the letter after j in the alphabet searching for my name would take longer than the average and much longer for someone whose name starts with the letter z so while measuring the run time of an algorithm on average might seem like a good strategy it won't necessarily provide an accurate picture by picking the maximum in the range we're measuring how our algorithm does in the worst case scenario analyzing the worst case scenario is quite useful because it indicates that the algorithm will never perform worse than we expect there's no room for surprises back to our graph we're going to plot the number of tries a proxy for running time of the algorithm against the number of values in the range which will shorten to n n here also represents john's worst case scenario when n is 10 he takes 10 turns when n is 100 he takes 100 turns but these two values alone are insufficient to really get any sort of visual understanding moreover it's not realistic john may take a long time to work through 100 numbers but a computer can do that in no time to evaluate the performance of linear search in the context of a computer we should probably throw some harder and larger ranges of values at it the nice thing is by evaluating a worst case scenario we don't actually have to do that work we know what the result will be for a given value of n using linear search it will take n tries to find the value in the worst case scenario so let's add a few values in here to build out this graph okay so we have a good picture of what this is starting to look like as the values get really large the running time of the algorithm gets large as well we sort of already knew that before we dig into this runtime any deeper let's switch tracks and evaluate brittany's work by having something to compare against it should become easier to build a mental model around time complexity the algorithm john used linear search seemed familiar to us and you could understand it because it's how most of us search for things in real life anyway brittany's approach on the other hand got results quickly but it was a bit harder to understand so let's break it down just like john's approach britney started with a series of values or a list of numbers as her input where john just started at the beginning of the list and searched sequentially brittany's strategy is to always start in the middle of the range from there she asks a comparison question is the number in the middle of the range equal to the answer she's looking for and if it's not is it greater than or less than the answer if it's greater than she can eliminate all the values less than the one she's currently evaluating if it's lesser than the answer she can eliminate all the values greater than the one she's currently evaluating with the range of values that she's left over with she repeats this process until she arrives at the answer let's visualize how she did this by looking at round three in round three the number of values in the range was 100 the answer was 5. the bar here represents the range of values one of the left 100 at the right and this pointer represents the value britney chooses to evaluate so she starts in the middle at 50. she asks is it equal to the answer i say it's too high so this tells her that the value she is evaluating is greater than our target value which means there's no point in searching any of the values to the right of 50 that is values greater than 50 in this range so she can discard those values altogether she only has to consider values from 1 to 50 now the beauty of this strategy and the reason why britney was able to find the answer in such few turns is that with every value she evaluates she can discard half of the current range on her second turn she picks the value in the middle of the current range which is 25. she asks the same question i say that the value is too high again and this tells her that she can discard everything greater than 25 and the range of values drops from 1 to 25. again she evaluates the number in the middle roughly so that'd be 13 here i tell her this is still too high she discards the values greater moves to value at 7 which is still too high then she moves to 4 which is now too low she can discard everything less than 4 which leaves the numbers 4 through 7. here she picked 6 which was too high which only leaves one value 5. this seems like a lot of work but being able to get rid of half the values with each turn is what makes this algorithm much more efficient now there's one subtlety to using binary search and you might have caught on to this for this search method to work as we've mentioned the values need to be sorted with linear search it doesn't matter if the values are sorted since a linear search algorithm just progresses sequentially checking every element in the list if the target value exists in the list it will be fouled but let's say this range of values 100 was unsorted britney would start at the middle with something like 14 and ask if this value was too low or too high i say it's too high so she discards everything less than 14. now this example starts to fall apart here because well britney knows what numbers are less than 14 and greater than one she doesn't need an actual range of values to solve this a computer however does need that remember search algorithms are run against lists containing all sorts of data it's not always just a range of values containing numbers in a real use case of binary search which we're going to implement in a bit the algorithm wouldn't return the target value because we already know that it's a search algorithm so we're providing something to search for instead what it returns is the position in the list that the target occupies without the list being sorted a binary search algorithm would discard all the values to the left of 14 which over here could include the position where our target value is eventually we'd get a result back saying the target value doesn't exist in the list which is inaccurate earlier when defining linear simple search i said that the input was a list of values and the output was the target value or more specifically the position of the target value in the list so with binary search there's also that precondition the input list must be sorted so let's formally define binary search first the input a sorted list of values the output the position in the list of the target value we're searching for or some sort of values indicate that the target does not exist in the list remember our guidelines for defining an algorithm let me put those up again really quick the steps in the algorithm need to be in a specific order the steps also need to be very distinct the algorithms should produce a result and finally the algorithm should complete in a finite amount of time let's use those to define this algorithm step one we determine the middle position of the sorted list step two we compare the element in the middle position to the target element step three if the elements match we return the middle position and end if they don't match in step 4 we check whether the element in the middle position is smaller than the target element if it is then we go back to step 2 with a new list that goes from the middle position of the current list to the end of the current list in step five if the element in the middle position is greater than the target element then again we go back to step two with a new list that goes from the start of the current list to the middle position of the current list we repeat this process until the target element is found or until a sub list contains only one element if that single element sublist does not match the target element then we end the algorithm indicating that the element does not exist in the list okay so that is the magic behind how britney managed to solve the round much faster in the next video let's talk about the efficiency of binary search [Music] we have a vague understanding that britney's approach is better in most cases but just like with linear search it helps to visualize this much like we did with linear search when determining the efficiency of an algorithm and remember we're still only looking at efficiency in terms of time time complexity as it's called we always want to evaluate how the algorithm performs in the worst case scenario now you might be thinking well that doesn't seem fair because given a series of data if the target value we're searching for is somewhere near the front of the list then linear search may perform just as well if not slightly better than binary search and that is totally true remember a crucial part of learning algorithms is understanding what works better in a given context when measuring efficiency though we always use the worst case scenarios as a benchmark because remember it can never perform worse than the worst case let's plot these values on the graph we started earlier with the number of tris or the runtime of the algorithm on the y axis and the maximum number of values in the series or n on the horizontal axis to represent the worst case scenario we have two data points when n equals 10 britney took four tries using binary search and when n equals 100 it took seven tries but even side by side these data points are sort of meaningless remember that while there is quite a difference between the run time of linear search and binary search at an n value of 100 for a computer that shouldn't matter what we should check out is how the algorithm performs at levels of n that might actually slow a computer down as n grows larger and larger how do these algorithms compare to one another let's add that to the graph okay now a picture starts to emerge as n gets really large the performance of these two algorithms differs significantly the difference is kind of staggering actually even with the simple game we saw that binary search was better but now we have a much more complete idea of how much better for example when n is 1000 the runtime of linear search measured by the number of operations or turns is also 1000. for binary search it takes just 10 operations now let's look at what happens when we increase n by factor of 10 at 10 000 linear search takes 10 000 operations while binary search takes 14 operations and increased by a factor of 10 in binary search only needs four more operations to find a value if we increase it again by a factor of 10 once more to an n value of 100 000 binary search takes only 17 operations it is blazing fast what we've done here is plotted on a graph how the algorithm performs as the input set it is working on increases in other words we've plotted the growth rate of the algorithm also known as the order of growth different algorithms grow at different rates and by evaluating their growth rates we get a much better picture of their performance because we know how the algorithm will hold up as n grows larger this is so important in fact it is the standard way of evaluating an algorithm and brings us to a concept called big o you might have heard this word thrown about and if you found it confusing don't worry we've already built up a definition in the past few videos we just need to bring it all together let's start with a common statement you'll see in studies on algorithms big o is a theoretical definition of the complexity of an algorithm as a function of the size wow what a mouthful this sounds really intimidating but it's really not let's break it down big o is a notation used to describe complexity and what i mean by notation is that it simplifies everything we've talked about down into a single variable an example of complexity written in terms of big o looks like this as you can see it starts with an uppercase letter o that's why we call it big o it's literally a big o the o comes from order of magnitude of complexity so that's where we get the big o from now complexity here refers to the exercise we've been carrying out in measuring efficiency if it takes brittany 4 tries when n is 10 how long does the algorithm take when n is 10 million when we use big o for this the variable used which we'll get to distills that information down so that by reading the variable you get a big picture view without having to run through data points and graphs just like we did it's important to remember that complexity is relative when we evaluate the complexity of the binary search algorithm we're doing it relative to other search algorithms not all algorithms bigo is a useful notation for understanding both time and space complexity but only when comparing amongst algorithms that solve the same problem the last bit in that definition of big o is a function of the size and all this means is that big o measures complexity as the input size grows because it's not important to understand how an algorithm performs in a single data set but in all possible data sets you will also see big o referred to as the upper bound of the algorithm and what that means is that big o measures how the algorithm performs in the worst case scenario so that's all big o is nothing special it's just a notation that condenses the data points and graphs that we've built up down to one variable okay so what do these variables look like for john's strategy linear search we say that it has a time complexity of big o and then n so that's again big o with an n inside parentheses for britney strategy binary search we say that it has a time complexity of big o of log n that's big o with something called a log and an n inside parentheses now don't worry if you don't understand that we'll go into that in more detail later on in the course each of these has a special meaning but it helps to work through all of them to get a big picture view so over the next few videos let's examine what are called common complexities or common values of big o that you will run into and should internalize in our discussions of complexity we made one assumption that the algorithm as a whole had a single measure of complexity that isn't true and we'll get at how we arrive at these measures for the entire algorithm at the end of this exercise but each step in the algorithm has its own space and time complexity in linear search for example there are multiple steps and the algorithm goes like this start at the beginning of the list or range of values compare the current value to the target if the current value is the target value that we're looking for we're done if it's not we'll move on sequentially to the next value in the list and repeat step two if we reach the end of the list then the target value is not in the list let's go back to step two for a second comparing the current value to the target does the size of the data set matter for this step when we're at step two we're already at that position in the list and all we're doing is reading the value to make a comparison reading the value is a single operation and if we were to plot it on a graph of runtime per operations against n it looks like this a straight line that takes constant time regardless of the size of n since this takes the same amount of time in any given case we say that the run time is constant time it doesn't change in big o notation we represent this as big o with a 1 inside parentheses now when i first started learning all this i was really confused as to how to read this even if it was in my own head should i say big o of one when you see this written you're going to read this as constant time so reading a value in a list is a constant time operation this is the most ideal case when it comes to run times because input size does not matter and we know that regardless of the size of n the algorithm runtime will remain the same the next step up in complexity so to speak is the situation we encountered with the binary search algorithm traditionally explaining the time complexity of binary search involves math i'm going to try to do it both with and without when we played the game using binary search we notice that with every turn we were able to discard half of the data but there's another pattern that emerges that we didn't explore let's say n equals 10. how long does it take to find an item at the 10th position of the list we can write this out so we go from 10 to 5 to 8 to 9 and then down to 10. here it takes us four tries to cut down the list to just one element and find the value we're looking for let's double the value of n to 20 and see how long it takes for us to find an item at the 20th position so we start at 20 and then we pick 10 from there we go to 15 17 19 and finally 20. so here it takes us five tries okay let's double it again so that n is 40 and we try to find the item in the 40th position so when we start at 40 the first midpoint we're going to pick is 20 from there we go to 30 then 35 37 39 and then 40. notice that every time we double the value of n the number of operations it takes to reduce the list down to a single element only increases by 1. there's a mathematical relationship to this pattern and it's called a logarithm of n you don't really have to know what logarithms truly are but i know that some of you like underlying explainers so i'll give you a quick one if you've taken algebra classes you may have learned about exponents here's a quick refresher 2 times 1 equals 2. now this can be written as 2 raised to the first power because it is our base case two times one is two now two times two is four this can be written as two raised to the second power because we're multiplying two twice first we multiply two times one then the result of that times 2. 2 times 2 times 2 is 8 and we can write this as 2 raised to the 3rd power because we're multiplying 2 3 times in 2 raised to 2 and 2 raised to 3 the 2 and 3 there are called exponents and they define how the number grows with 2 raised to 3 we start with the base value and multiply itself 3 times the inverse of an exponent is called a logarithm so if i say log to the base 2 of 8 equals 3 i'm basically saying the opposite of an exponent instead of saying how many times do i have to multiply this value i'm asking how many times do i have to divide 8 by two to get the value one this takes three operations what about the result of log to the base two of sixteen that evaluates to four so why does any of this matter notice that this is sort of how binary search works log to the base 2 of 16 is 4. if n was 16 how many triads does it take to get to that last element well we start in the middle at 8 that's too low so we move to 12 then we move to 14 then to 15 and then to 16 which is 5 tries or log to the base 2 of 16 plus 1. in general for a given value of n the number of tries it takes to find the worst case scenario is log of n plus one and because this pattern is overall a logarithmic pattern we say that the runtime of such algorithms is logarithmic if we plot these data points on our graph a logarithmic runtime looks like this in big o notation we represent a logarithmic runtime as big o of log n which is written as big o with log n inside parentheses or even sometimes as l n n inside parentheses when you see this read it as logarithmic time as you can see on the graph as n grows really large the number of operations grows very slowly and eventually flattens out since this line is below the line for a linear runtime which we'll look at in a second you might often hear algorithms with logarithmic runtimes being called sublinear logarithmic or sub-linear runtimes are preferred to linear because they're more efficient but in practice linear search has its own set of advantages which we'll take a look at in the next video next up let's look at the situation we encountered with the linear search algorithm we saw that in the worst case scenario whatever the value of n was john took exactly that many tries to find the answer as in linear search when the number of operations to determine the result in the worst case scenario is at most the same as n we say that the algorithm runs in linear time we represent this as big o of n now you can read that as big o of n like i just said or you can say linear time which is more common when we put that up on a graph against constant time and logarithmic time we get a line that looks like this any algorithm that sequentially reads the input will have linear time so remember anytime you know a problem involves reading every item in a list that means a linear run time as you saw from the game we played brittany's strategy using binary search was clearly better and we can see that on the graph so if we had the option why would we use linear search which runs in linear time remember that binary search had a precondition the input set had to be sorted while we won't be looking at sorting algorithms in this course as you learn more about algorithms you'll find that sorting algorithms have varying complexities themselves just like search does so we have to do additional work prior to using binary search for this reason in practice linear search ends up being more performant up to a certain value of n because the combination of sorting first and then searching using binary search adds up the next common complexity you will hear about is when an algorithm runs in quadratic time if the word quadratic sounds familiar to you it's because you might have heard about it in math class quadratic is a word that means an operation raised to the second power or when something is squared let's say you and your friends are playing a tower defense game and to start it off you're going to draw a map of the terrain this map is going to be a grid and you pick a random number to determine how large this grid is let's set n the size of the grid to four next you need to come up with a list of coordinates so you can place towers and enemies and stuff on this map so how would we do this if we start out horizontally we'd have coordinate points that go 1 1 1 2 1 3 and 1 4. then you go up one level vertically and we have points 2 1 2 2 2 3 and 2 4. go up one more and you have the points 3 1 3 2 3 3 and 3 4 and on that last row you have the points 4 1 4 2 4 3 and 4 4. notice that we have a pattern here for each row we take the value and then create a point by adding to that every column value the range of values go from 1 to the value of n so we can generally think of it this way for the range of values from 1 to n for each value in that range we create a point by combining that value with the range of values from 1 to n again doing it this way for each value in the range of 1 to n we create an n number of values and we end up with 16 points which is also n times n or n squared this is an algorithm with a quadratic runtime because for any given value of n we carry out n squared number of operations now i picked a relatively easy so to speak example here because in english at least we often denote map sizes by height times width so we would call this a 4 by 4 grid which is just another way of saying 4 squared or n squared in big o notation we would write this as big o of n squared or say that this is an algorithm with a quadratic runtime many search algorithms have a worst case quadratic runtime which you'll learn about soon now in addition to quadratic runtimes you may also run into cubic runtimes as you encounter different algorithms in such an algorithm for a given value of n the algorithm executes n raised to the third power number of operations these aren't as common as quadratic algorithms though so we won't look at any examples but i think it's worth mentioning thrown up on our graph quadratic and cubic runtimes look like this so this is starting to look pretty expensive computationally as they say we can see here that for small changes in n there's a pretty significant change in the number of operations that we need to carry out the next worst case runtime we're going to look at is one that's called quasi-linear and a sort of easier to understand for lack of better word by starting with the big o notation quasi-linear runtimes are written out as big o of n times log n we learned what log n was right a logarithmic runtime whereas n grew the number of operations only increased by a small factor with a quasi-linear runtime what we're saying is that for every value of n we're going to execute a log n number of operations hence the run time of n times log n so you saw earlier with the quadratic runtime that for each value of n we conducted n operations it's sort of the same in that as we go through the range of values in n we're executing login operations in comparison to other runtimes a quasi-linear algorithm has a runtime that lies somewhere between a linear runtime and a quadratic runtime so where would we expect to see this kind of runtime in practical use well sorting algorithms is one place you will definitely see it merge sort for example is a sorting algorithm that has a worst case runtime of big o of n log n let's take a look at a quick example let's say we start off with a list of numbers that looks like this and we need to sort it merge sort starts by splitting this list into two lists down the middle it then takes each sub list and splits that in half down the middle again it keeps doing this until we end up with a list of just a single number when we're down to single numbers we can do one sort operation and merge these sub-lists back in the opposite direction the first part of merge sort cuts those lists into sub-lists with half the numbers this is similar to binary search where each comparison operation cuts down the range to half the values you know the worst case runtime in binary search is log n so these splitting operations have the same runtime big o of log n or logarithmic but splitting into half isn't the only thing we need to do with merge sort we also need to carry out comparison operations so we can sort those values and if you look at each step of this algorithm we carry out an n number of comparison operations and that brings the worst case runtime of this algorithm to n times log n also known as quasi linear don't worry if you didn't understand how merge sort works that wasn't the point of this demonstration we will be covering merge sorts soon in a future course the run times we've looked at so far are all called polynomial runtimes an algorithm is considered to have a polynomial runtime if for a given value of n its worst case runtime is in the form of n raised to the k power where k just means some value so it could be n squared where k equals 2 for a quadratic runtime n cubed for a cubic runtime and so on all of those are in the form of n raised to some power anything that is bounded by this and what i mean by that is if we had a hypothetical line on our graph of n raised to the k power anything that falls under this graph is considered to have a polynomial runtime algorithms with an upper bound or a runtime with a big o value that is polynomial are considered efficient algorithms and are likely to be used in practice now the next class of runtimes that we're going to look at are a runtimes that we don't consider efficient and these are called exponential runtimes with these runtimes as n increases slightly the number of operations increases exponentially and as we'll see in a second these algorithms are far too expensive to be used an exponential runtime is an algorithm with a big o value of some number raised to the nth power imagine that you wanted to break into a locker that had a padlock on it let's assume you forgot your code this lock takes a two digit code and the digit for the code ranges from zero to nine you start by setting the dials to zero and then with the first dial remaining on zero you change the second dial to one and try and open it if it doesn't work you set it to two then try again you would keep doing this and if you still haven't succeeded with the second dial set to 9 then you go back to that first dial set it to 1 and start the second dial over the range of values you'd have to go through is 0 0 to 9 9 which is 100 values this can be generalized as 10 to the second power since there are 10 values on each dial raised to two dials searching through each individual value until you stumble on the right one is a strategy called brute force and brute force algorithms have exponential run times here there are two dials so n is 2 and each dial has 10 values so again we can generalize this algorithm as 10 raised to n where n represents the number of dials the reason that this algorithm is so inefficient is because with just one more dial on the lock the number of operations increases significantly with three dials the number of combinations in the worst case scenario where the correct code is the last digit in the range is 10 raised to 3 or 1 000 values with an additional wheel it becomes 10 raised to 4 or 10 000 values as n increases the number of operations increases exponentially to a point where it's unsolvable in a realistic amount of time now you might think well any computer can crack a four digit numerical lock and that's true because n here is sufficiently small but this is the same principle that we use for passwords in a typical password field implemented well users are allowed to use letters of the english alphabet so up to 26 characters numbers from 0 to 9 and a set of special characters of which there can be around 33 so typically that means each character in a password can be one out of 69 values this means that for a one character password it takes 69 to the nth power so 1 which equals 69 operations in the worst case scenario to figure out the password just increasing n to 2 increases the number of operations needed to guess the password to 69 squared or 4761 operations now usually on a secure website there isn't really a limit but in general passwords are limited to around 20 characters in length with each character being a possible 69 values and there being 20 characters the number of operations needed to guess the password in the worst case scenario is 69 raised to the 20th power or approximately 6 followed by 36 zeros number of operations an intel cpu with five cores can carry out roughly about 65 000 million instructions per second that's a funny number i know to crack our 20-digit passcode in this very simplistic model it would take this intel cpu to race to 20th power years to brute force the password so while this algorithm would eventually produce a result it is so inefficient that it's pointless this is one of the reasons why people recommend you have longer passwords since brute forcing is exponential in the worst case each character you add increases the number of combinations by an exponent the next class of exponential algorithms is best highlighted by a popular problem known as the traveling salesman the problem statement goes like this given a list of cities and the distance between each pair of cities what is the shortest possible route that visits each city and then returns to the origin city this seems like a simple question but let's start with a simple case three cities a b and c to figure out what the shortest route is we need to come up with all the possible routes with three cities we have six routes in theory at least some of these routes can be discarded because abc is the same as c b a but in the opposite direction but as we do know sometimes going from a to c through b may go through a different route than c to a through b so we'll stick to the six routes and from there we could determine the shortest no big deal now if we increase this to four cities we jump to 24 combinations the mathematical relationship that defines this is called a factorial and is written out as n followed by an exclamation point factorials are basically n times n minus one repeated until you reach the number one so for example the factorial of three is three times two times one which is six which is the number of combinations we came up with for three cities the factorial of four is four times three times two times one or 24 which is the number of combinations we arrived at with four cities in solving the traveling salesman problem the most efficient algorithm will have a factorial runtime or a combinatorial runtime as it's also called at low values of n algorithms with a factorial runtime may be used but with an n value of say 200 it would take longer than humans have been alive to solve the problem for sake of completeness let's plot a combinatorial runtime on our graph so that we can compare an algorithm such as one that solves the traveling salesman problem as a worst case run time of big o of n factorial studying exponential runtimes like this are useful for two reasons first in studying how to make such algorithms efficient we develop strategies that are useful across the board and can potentially be used to make existing algorithms even more efficient second it's important to be aware of problems that take a long time to solve knowing right off the bat that a problem is somewhat unsolvable in a realistic time means you can focus your efforts on other aspects of the problem as beginners though we're going to steer clear of all this and focus our efforts on algorithms with polynomial runtimes since we're much more likely to work with and learn about such algorithms now that we know some of the common complexities in the next video let's talk about how we determine the complexity of an algorithm because there are some nuances over the last few videos we took a look at common complexities that we would encounter in studying algorithms but the question remains how do we determine what the worst case complexity of an algorithm is earlier i mentioned that even though we say that an algorithm has a particular upper bound or worst case runtime each step in a given algorithm can have different run times let's bring up the steps for binary search again assuming the list is sorted the first step is to determine the middle position of the list in general this is going to be a constant time operation many programming languages hold on to information about the size of the list so we don't actually need to walk through the list to determine the size now if we didn't have information about the size of the list we would need to walk through counting each item one by one until we reached the end of the list and this is a linear time operation but realistically this is a big o of 1 or constant time step 2 is to compare the element in the middle position to the target element we can assume that in most modern programming languages this is also a constant time operation because the documentation for the language tells us it is step 3 is our success case and the algorithm ends this is our best case and so far we have only incurred two constant time operations so we would say that the best case run time of binary search is constant time which is actually true but remember that best case is not a useful metric step 4 if we don't match is splitting the list into sub-lists assuming the worst case scenario the algorithm would keep splitting into sub-lists until a single element list is reached with the value that we're searching for the run time for this step is logarithmic since we discard half the values each time so in our algorithm we have a couple steps that are constant time and one step that is logarithmic overall when evaluating the run time for an algorithm we say that the algorithm has as its upper bound the same runtime as the least efficient step in the algorithm think of it this way let's say you're participating in a triathlon which is a race that has a swimming running and a cycling component you could be a phenomenal swimmer and a really good cyclist but you're a pretty terrible runner no matter how fast you are at swimming or cycling your overall race time is going to be impacted the most by your running race time because that's the part that takes you the longest if you take an hour 30 to finish the running component 55 minutes to swim and 38 minutes to bike it won't matter if you can fine tune your swimming technique down to finish in 48 minutes and your cycle time to 35 because you're still bounded at the top by your running time which is close to almost double your bike time similarly with the binary search algorithm it doesn't matter how fast we make the other steps they're already as fast as they can be in the worst case scenario the splitting of the list down to a single element list is what will impact the overall running time of your algorithm this is why we say that the time complexity or run time of the algorithm in the worst case is big o of log n or logarithmic as i alluded to though your algorithm may hit a best case runtime and in between the two best and worst case have an average run time as well this is important to understand because algorithms don't always hit their worst case but this is getting a bit too complex for us for now we can safely ignore average case performances and focus only on the worst case in the future if you decide to stick around we'll circle back and talk about this more now that you know about algorithms complexities and big o let's take a break from all of that and write code in the next video [Music] so far we've spent a lot of time in theory and while these things are all important things to know you get a much better understanding of how algorithms work when you start writing some code as i mentioned earlier we're going to be writing python code in this and all subsequent algorithm courses if you do have programming experience but in another language check the notes section of this video for an implementation in your language if you don't have any experience i'll try my best explain as we go along on the video you're watching right now you should see a launch workspaces button we're going to use a treehouse coding environment call workspaces to write all of our code if you're familiar with using python in a local environment then feel free to keep doing so workspaces is an in-browser coding environment and will take care of all the setup and installation so you can focus on just writing and evaluating code workspaces is quite straightforward to use on the left here we have a file navigator pane which is currently empty since we haven't created a new file on the top we have an editor where we write all our code and then below that we have a terminal or a command line prompt where we can execute the scripts that we write let's add a new file here so at the top in the editor area we're going to go to file new file and we'll name this linear underscore search dot pi in here we're going to define our linear search algorithm as a standalone function we start with the keyword def which defines a function or a block of code and then we give it the name linear underscore search this function will accept two arguments first the list we're searching through and then the target value we're looking for both of these arguments are enclosed in a set of parentheses and there's no space between the name of the function and the arguments after that we have a colon now there might be a bit of confusion here since we already have this target value what are we searching for unlike the game we played at the beginning where john's job was to find the value in a true implementation of linear search we're looking for the position in the list where the value exists if the target is in the list then we return its position and since this is a list that position is going to be denoted by an index value now if the target is not found we're going to return none the choice of what to return in the failure case may be different in other implementations of linear search you can return -1 since that isn't typically an index value you can also raise an exception which is python speak for indicating an error occurred now i think for us the most straightforward value we can return here is none now let's add a comment to clarify this so hit enter to go to the next line and then we're going to add three single quotes and then below that on the next line we'll say returns the position or the index position of the target if found else returns none and then on the next line we'll close off those three quotes this is called a doc string and is a python convention for documenting your code the linear search algorithm is a sequential algorithm that compares each item in the list until the target is found to iterate or loop or walk through our list sequentially we're going to use a for loop now typically when iterating over a list in python we would use a loop like this we'd say for item in list this assigns the value at each index position to that local variable item we don't want this though since we primarily care about the index position instead we're going to use the range function in python to create a range of values that start at 0 and end at the number of items in the list so we'll say 4 i i stands for index here in range starting at 0 and going all the way up to the length of the list we can get the number of items in the list using the len function now going back to our talk on complexity and how individual steps in an algorithm can have its own run times this is a line of code that we would have to be careful about python keeps track of the length of a list so this function call here len list is a constant time operation now if this were a naive implementation let's say we wrote the implementation of the list and we iterate over the list every time we call this length function then we've already incurred a linear cost okay so once we have a range of values that represent index positions in this list we're going to iterate over that using the for loop and assign each index value to this local variable i using this index value we can obtain the item at that position using subscript notation on the list now this is also a constant time operation because the language says so so we'll do if list so once we have this value which we'll get by using subscript notation so we'll say list i once we have this value we'll check if it matches the target so if the value at i equals target well if it does then we'll return that index value because we want the position and once we hit this return statement we're going to terminate our function if the entire for loop is executed and we don't hit this return statement then the target does not exist in the list so at the bottom here we'll say return none even though all the individual operations in our algorithm run in constant time in the worst case scenario this for loop here will have to go through the entire range of values and read every single element in the list therefore giving the algorithm a big o value of n or running in linear time now if you've written code before you've definitely written code like this a number of times and i bet you didn't know but all along you are implementing what is essentially a well-known algorithm so i hope this goes to show you that algorithms are pretty approachable topic like everything else this does get advanced but as long as you take things slow there's no reason for it to be impossible remember that not any block of code counts as an algorithm to be a proper implementation of linear search this block of code must return a value must complete execution in a finite amount of time and must output the same result every time for a given input set so let's verify this with a small test let's write a function called verify that accepts an index value if the value is not none it prints the index position if it is none it informs us that the target was not found in the list so def verify and this is going to take an index value and we'll say if index is not none then we'll print target found at index oops that's a colon here index else that needs to go back there we go else we'll say target not found in list okay using this function let's define a range of numbers now so this will be a list numbers and we'll just go from 1 to let's say 10. now if you've written python code before you know that i can use a list comprehension to make this easier but we'll keep things simple we can now use our linear search function to search for the position of a target value in this list so we can say result equal linear underscore search and we're going to pass in the numbers list that's the one we're searching through and we want to look for the position where the value 12 exists and then we'll verify this result if our algorithm works correctly the verify function should inform us that the target did not exist so make sure you save the file which you can do by going up to file and save or hitting command s and then below in the terminal you're going to type out python linear search or you can hit tab and it should auto complete linear search dot pi as you can see correct the target was not found in the list so the output of our script is what we expect for our second test let's search for the value 6 in the list so you can copy this command c to copy and then paste it again and we'll just change 12 here to 6 and then come back down to the terminal hit the up arrow to execute the same command again and hit enter you'll notice that i forgot to hit save so it did not account for that new change we'll try that again and there you'll see that if it works correctly which it did the index should be number five run the program on your end and make sure everything works as expected our algorithm returned a result in each case it executed in a finite time and the results were the ones we expect in the next video let's tackle binary search in the last video we left off with an implementation of linear search let's do the same for binary search so that we get an understanding of how this is represented in code so we'll do this in a new file back to file new file and we'll name this one binary search dot py like before we're going to start with a function named binary search so we'll say def binary underscore search that takes a list and a target if you remember binary search works by breaking the array or list down into smaller sets until we find the value we're looking for we need a way to keep track of the position of the list that we're working with so let's create two variables first and last to point to the beginning and end of the array so first equal zero now if you're new to programming list positions are represented by index values that start at zero instead of one so here we're setting first to zero to point to the first element in the list last is going to point to the last element in the list so we'll say last equal len list minus one now this may be confusing to you so a quick sidebar to explain what's going on let's say we have a list containing 5 elements if we called len on that list we should get 5 back because there are 5 elements but remember that because the position numbers start at 0 the last value is not at position 5 but at 4. in nearly all programming languages getting the position of the last element in the list is obtained by determining the length of the list and deducting 1 which is what we're doing okay so we know what the first and last positions are when we start the algorithm for our next line of code we're going to create a while loop a while loop takes a condition and keeps executing the code inside the loop until the condition evaluates to false for our condition we're going to say to keep executing this loop until the value of first is less than or equal to the value of last so while first less than or equal to last well why you ask why is this our condition well let's work through this implementation and then a visualization should help inside the while loop we're going to calculate the midpoint of our list since that's the first step of binary search midpoint equal so we'll say first plus last and then we'll use the floor division double slash here divided by two now the two forward slashes here are what python calls a floor division operator what it does is it rounds down to the nearest whole number so if we have an eight element array first is zero last is 7 if we divided 0 plus 7 which is 7 by 2 we would get 3.5 now 3.5 is not a valid index position so we round that down to 3 using the floor division operator okay so now we have a midpoint the next step of binary search is to evaluate whether the value at this midpoint is the same as the target we're looking for so say if list value at midpoint equals the target well if it is then we'll go ahead and return the midpoint so we'll say return midpoint the return statement terminates our algorithm and over here we're done this is our best case scenario next we'll say else if list at midpoint or value at midpoint is less than the target now here if the value is less the value at midpoint is less than the target then we don't care about any of the values lower than the midpoint so we redefine first to point to the value after the midpoint so we'll say midpoint plus 1. now if the value at the midpoint is greater than the target then we can discard the values after the midpoint and redefine last to point to the value prior to the midpoint so we'll say else last equal midpoint minus 1. let's visualize this we're going to start with a list of nine integers to make this easier to understand let's specify these integers to be of the same value as its index position so we have a range of values from 0 to 8. our target is the worst case scenario we're looking for the position of the value 8. at the start our algorithm sets first to point to the index 0 and last to point to the length of the list minus 1 which is 8. next we hit our while loop the logic of this loop is going to be executed as long as the value of first is not greater than the value of last or as we've defined it we're going to keep executing the contents of the loop as long as first is less than or equal to last on the first pass this is true so we enter the body of the loop the midpoint is first plus last divided by two and rounded down so we get a nice even four the value at this position is four now this is not equal to the target so we move to the first else if four is less than eight so now we redefine first to point to midpoint plus one which is five first is still less than last so we run through the body of the loop again the midpoint is now six six is less than eight so we move first to point to seven seven is still less than or equal to eight so we go for another iteration of the loop the midpoint is seven oddly enough and seven is still less than the target so we move first to point to eight first is equal to last now but our condition says keep the loop going as long as first is less than or equal to last so this is our final time through the loop the midpoint is now 8 which makes the value at the midpoint equal to the target and we finally exit our algorithm and return the position of the target now what if we had executed all this code and never hit a case where midpoint equal the target well that would mean the list did not contain the target value so after the while loop at the bottom will return none we have several operations that make up our binary search algorithm so let's look at the runtime of each step we start by assigning values to first and last the value assigned to last involves a call to the len function to get the size of the list but we already know this is a constant time operation in python so both of these operations run in constant time inside the loop we have another value assignment and this is a simple division operation so again the runtime is constant in the next line of code we're reading a value from the list and comparing the midpoint to the target both of these again are constant time operations the remainder of the code is just a series of comparisons and value assignments and we know that these are all constant time operations as well so if all we have are a series of constant time operations why does this algorithm have in the worst case a logarithmic runtime it's hard to evaluate by just looking at the code but the while loop is what causes the run time to grow even though all we're doing is a comparison operation by redefining first and last over here or rather in the last two steps over here we're asking the algorithm to run as many times as it needs until first is equal or greater than last now each time the loop does this the size of the data set the size of the list grows smaller by a certain factor until it approaches a single element which is what results in the logarithmic runtime okay just like with linear search let's test that our algorithm works so we'll go back to linear search.hi and we're going to copy paste so command c to copy if you're on a mac then go back to binary search and at the bottom oops we're going to paste in that verify function okay we'll also go back and grab this numbers you know what let's go ahead and copy all all of these things so numbers and the two verify cases we'll paste that in as well and the only thing we need to change here is instead of calling linear search this is going to call binary search okay we'll hit command s to save the file and then i'm going to drag up my console and we'll run python binary search dot and hit enter and you'll see like just like before we get the same results back now note that an extremely important distinction needs to be made here the numbers list that we've defined for our test cases right here has to be sorted the basic logic of binary search relies on the fact that if the target is greater than the midpoint then our potential values lie to the left or vice versa since the values are sorted in ascending order if the values are unsorted our implementation of binary search may return none even if the value exists in the list and just like that you've written code to implement two search algorithms how fun was that hopefully this course has shown you that it isn't a topic to be afraid of and that algorithms like any other topic with code can be broken down and understood piece by piece now we have a working implementation of binary search but there's actually more than one way to write it so in the next video let's write a second version i'm going to create a new file as always file new file and we'll name this recursive underscore binary underscore search dot p y okay so we're going to add our new implementation here so that we don't get rid of that first implementation we wrote let's call this new function recursive binary search unlike our previous implementation this version is going to behave slightly differently in that it won't return the index value of the target element if it exists instead it will just return a true value if it exists and a false if it doesn't so recursive underscore binary underscore search and like before this is going to take a list it accepts a list and a target to look for in that list we'll start the body of the function by considering what happens if an empty list is passed in in that case we would return false so i would say if the length of the list which is one way to figure out if it's empty if it's equal to zero then we'll return false now you might be thinking that in the previous version of binary search we didn't care if the list was empty well we actually did but in a roundabout sort of way so in the previous version of binary search our function had a loop and that loop condition was true when first was less than or equal to last so as long as it's less than or equal to last we continue the loop now if we have an empty list then first is greater than last and the loop would never execute and we return none at the bottom so this is the same logic we're implementing here we're just doing it in a slightly different way if the list is not empty we'll implement an else clause now here we'll calculate the midpoint by dividing the length of the list by 2 and rounding down again there's no use of first and last here so we'll say length of list and then using the floor division operator we'll divide that by 2. if the value at the midpoint which we'll check by saying if list using subscript notation we'll say midpoint as the index now if this value at the midpoint is the same as the target then we'll go ahead and return true so far this is more or less the same except for the value that we're returning let me actually get rid of all that okay all right so if this isn't the case let's implement an else clause now here we have two situations so first if the value at the midpoint is less than the target so if value at midpoint is less than the target then we're going to do something new we're going to call this function again this recursive binary search function that we're in the process of defining we're going to call that again and we're going to give it the portion of the list that we want to focus on in the previous version of binary search we moved the first value to point to the value after the midpoint now here we're going to create a new list using what is called a slice operation and create a sub list that starts at midpoint plus 1 and goes all the way to the end we're going to specify the same target as a search target and when this function call is done we'll return the value so we'll say return the return is important then we'll call this function again recursive binary search and this function takes a list and here we're going to use that subscript notation to perform a slice operation by using two indexes a start and an end so we'll say our new list that we're passing in needs to start at midpoint plus one and then we'll go all the way to the end and this is a python syntactic sugar so to speak if i don't specify an end index python knows to just go all the way to the end all right so this is our new list that we're working with and we need a target we'll just pass it through if you're confused bear with me just like before we'll visualize this at the end okay we have another else case here and this is a scenario where the value at the midpoint is greater than the target which means we only care about the values in the list from the start going up to the midpoint now in this case as well we're going to call the binary search function again and specify a new list to work with this time the list is going to start at the beginning and then go all the way up to the midpoint so it looks the same we'll say return recursive binary search we're going to pass in a list here so if we just put a colon here without a start index python knows to start at the beginning and we're going to go all the way up to the midpoint the target here is the same and this is our new binary search function so let's see if this works actually yes down here we'll make some space and we'll define a verify function we're not going to copy paste the previous one because we're not returning none or an integer here so we'll verify the result that we pass in and we'll say print target found and this is just going to say true or false whether we found it okay so like before we need a numbers list and we'll do something one two three four all the way up to eight okay and now let's test this out so we'll call our recursive binary search function and we'll pass in the numbers list and the target here is 12. we're going to verify this verify the result make sure it works and then we'll call it again this time making sure that we give it a target that is actually in the list so here we'll say 6 and we'll verify this again make sure you hit command s to save and then in the console below we're going to type out python recursive binarysearch.pi run it and you'll see that we've verified that search works while we can't verify the index position of the target value which is a modification to how our algorithm works we can guarantee by running across all valid inputs that search works as intended so why write a different search algorithm here a different binary search algorithm and what's the difference between these two implementations anyway the difference lies in these last four lines of code that you see here we did something unusual here now before we get into this a small word of advice this is a confusing topic and people get confused by it all the time don't worry that doesn't make you any less of a programmer in fact i have trouble with it often and always look it up including when i made this video this version of binary search is a recursive binary search a recursive function is one that calls itself this is hard for people to grasp sometimes because there's few easy analogies that make sense but you can think of it and sort this way so let's say you have this book that contains answers to multiplication problems you're working on a problem and you look up an answer in the book the answer for your problem says add 10 to the answer for problem 52 okay so you look up problem 52 and there it says add 12 to the answer for problem 85 well then you go and look up the answer to problem 85 and finally instead of redirecting you somewhere else that answer says 10. so you take that 10 and then you go back to problem 52 because remember the answer for problem 52 was to add 12 to the answer for problem 85 so you take that 10 and then you now have the answer to problem 85 so you add 10 to 12 to get 22. then you go back to your original problem where it said to add 10 to the answer for problem 52 so you add 10 to 22 and you get 32 to end up with your final answer so that's a weird way of doing it but this is an example of recursion the solution to your first lookup in the book was the value obtained by another lookup in the same book which was followed by yet another lookup in the same book the book told you to check the book until you arrived at some base value our function works in a similar manner so let's visualize this with an example of list like before we have a nine element list here with values zero through eight the target we're searching for is the value eight we'll check if the list is empty by calling len on it this list is not empty so we go to the else clause next we calculate the midpoint 9 divided by 2 is 4.5 rounded down is 4 so our first midpoint value is 4. we'll perform our first check is the value at the midpoint equal to the target not true so we go to our else clause we'll perform another check here is the value at the midpoint less than the target now in our case this is true earlier when we evaluated this condition we simply change the value of first here we're going to call the recursive binary search function again and give it a new list to work with the list starts at midpoint plus 1 so at index position 5 all the way to the end notice that this call to recursive binary search inside of recursive binary search includes a return statement this is important and we'll come back to that in a second so now we're back at the top of a new call to recursive binary search with effectively a new list although technically just a sub list of the first one the list here contains the numbers 6 7 and 8. starting with the first check the list is not empty so we move to the else the midpoint in this case length of the list 3 divided by 2 rounded down is 1. is the value of the midpoint equal to the target well the value at that position is 7 so no in the else we perform the first check is the value at the midpoint less than the target indeed it is so we call recursive binary search again and provided a new list this list starts at midpoint plus 1 and goes to the end so in this case that's a single element list since this is a new call to recursive binary search we start back up at the top is the list empty no the midpoint is zero is the value at the midpoint the same as the target it is so now we can return true remember a minute ago i pointed out that when we call recursive binary search from inside the function itself it's preceded by a return statement that plays a pretty important role here so back to our visualization we start at the top and recall binary search with a new list but because that's got a return statement before it what we're saying is hey when you run binary search on this whatever value you get back return it to the function that called you then at the second level we call binary search again along with another return statement like with the first call we're instructing the function to return a value back to the code that called it at this level we find the target so the function returns true back to the caller but since this inner function was also called by a function with instructions to return it keeps returning that true value back up until we reach the very first function that called it going back to our book of answers recursive binary search instructs itself to keep working on the problem until it has a concrete answer once it does it works its way backwards giving the answer to every function that called it until the original caller has an answer now like i said at the beginning this is pretty complicated so you should not be concerned if this doesn't click honestly this is not one thing that you're going to walk away with knowing fully how to understand recursion after your first try i'm really not lying when i say i have a pretty hard time with recursion now before we move on i do want to point out one thing even though the implementation of recursion is harder to understand it is easier in this case to understand how we arrive at the logarithmic run time since we keep calling the function with smaller lists let's take a break here in the next video let's talk a bit more about recursion and why it matters [Music] in the last video we wrote a version of binary search that uses a concept called recursion recursion might be a new concept for you so let's formalize how we use it a recursive function is one that calls itself in our example the recursive binary search function called itself inside the body of the function when writing a recursive function you always need a stopping condition and typically we start the body of the recursive function with this stopping condition it's common to call this stopping condition the base case in our recursive binary search function we had two stopping conditions the first was what the function should return if an empty list is passed in it seems weird to evaluate an empty list because you wouldn't expect to run search on an empty list but if you look at how our function works recursive binary search keeps calling itself and with each call to itself the size of the list is cut in half if we searched for a target that didn't exist in the list then the function would keep halving itself until it got to an empty list consider a three element list with numbers one two three where we're searching for a target of four on the first pass the midpoint is 2 so the function would call itself with the list 3. on the next pass the midpoint is 0 and the target is still greater so the function would call itself this time passing in an empty list because an index of 0 plus 1 in a single element list doesn't exist when we have an empty list this means that after searching through the list the value wasn't found this is why we define an empty list as a stopping condition or a base case that returns false if it's not an empty list then we have an entirely different set of instructions we want to execute first we obtain the midpoint of the list once we have the midpoint we can introduce our next base case or stopping condition if the value at the midpoint is the same as the target then we return true with these two stopping conditions we've covered all possible paths of logic through the search algorithm you can either find the value or you don't once you have the base cases the rest of the implementation of the recursive function is to call the function on smaller sub-lists until we hit one of these base cases going back to our visualization for a second we see that recursive binary search calls itself a first time which then calls itself again for the initial list we started with the function only calls itself a few times before a stopping condition is reached the number of times a recursive function calls itself is called recursive depth now the reason i bring all of this up is because if after you start learning about algorithms you decide you want to go off and do your own research you may start to see a lot of algorithms implemented using recursion the way we implemented binary search the first time is called an iterative solution now when you see the word iterative it generally means the solution was implemented using a loop structure of some kind a recursive solution on the other hand is one that involves a set of stopping conditions and a function that calls itself computer scientists and computer science textbooks particularly from back in the day favor and are written in what are called functional languages in functional languages we try to avoid changing data that is given to a function in our first version of binary search we created first and last variables using the list and then modified first and last as we needed to arrive at a solution functional languages don't like to do this all this modification of variables and prefer a solution using recursion a language like python which is what we're using is the opposite and doesn't like recursion in fact python has a maximum recursion depth after which our function will halt execution python prefers an iterative solution now i mentioned all of this for two reasons if you decide that you want to learn how to implement the algorithm in a language of your choice that's not python then you might see a recursive solution as the best implementation in that particular language i'm an ios developer for example and i work with a language called swift swift is different from python in that it doesn't care about recursion depth and does some neat tricks where it doesn't even matter how many times your function calls itself so if you want to see this in swift code then you need to know how recursion works well and now you have some idea now the second reason i bring it up is actually way more important and to find out on to the next video at the beginning of this series i mentioned that there were two ways of measuring the efficiency of an algorithm the first was time complexity or how the run time of an algorithm grows as n grows larger the second is space complexity we took a pretty long route to build up this example but now we're in a good place to discuss space complexity space complexity is a measure of how much working storage or extra storage is needed as a particular algorithm grows we don't think about it much these days but every single thing we do on a computer takes up space in memory in the early days of computing considering memory usage was of paramount importance because memory was limited and really expensive these days were spoiled our devices are rich with memory this is okay when we write everyday code because most of us aren't dealing with enormously large data sets when we write algorithms however we need to think about this because we want to design our algorithms to perform as efficiently as it can as the size of the data set n grows really large like time complexity space complexity is measured in the worst case scenario using big-o notation since you are familiar with the different kinds of complexities let's dive right into an example in our iterative implementation of binary search the first one we wrote that uses a while loop let's look at what happens to our memory usage as n gets large let's bring up that function let's say we start off with a list of 10 elements now inspecting the code we see that our solution relies heavily on these two variables first and last first points to the start of the list and last to the end when we eliminate a set of values we don't actually create a sub list instead we just redefine first and last as you see here to point to a different section of the list since the algorithm only considers the values between first and last when determining the midpoint by redefining first and last as the algorithm proceeds we can find a solution using just the original list this means that for any value of n the space complexity of the iterative version of binary search is constant or that the iterative version of binary search takes constant space remember that we would write this as big o of one this might seem confusing because as n grows we need more storage to account for that larger list size now this is true but that storage is not what space complexity cares about measuring we care about what additional storage is needed as the algorithm runs and tries to find a solution if we assume something simple say that for a given size of a list represented by a value n it takes n amount of space to store it whatever that means then for the iterative version of binary search regardless of how large the list is at the start middle and end of the algorithm process the amount of storage required does not get larger than n and this is why we consider it to run in constant space now this is an entirely different story with the recursive version however in the recursive version of binary search we don't make use of variables to keep track of which portion of the list we're working with instead we create new lists every time with a subset of values or sub-lists with every recursive function call let's assume we have a list of size n and in the worst case scenario the target element is the last in the list calling the recursive implementation of binary search on this list and target would lead to a scenario like this the function would call itself and create a new list that goes from the midpoint to the end of the list since we're discarding half the values the size of the sub list is n by 2. this function will keep calling itself creating a new sub list that's half the size of the current one until it arrives at a single element list and a stopping condition this pattern that you see here where the size of the sublist is reduced by a factor on each execution of the algorithmic logic well we've seen that pattern before do you remember where this is exactly how binary search works it discards half the values every time until it finds a solution now we know that because of this pattern the running time of binary search is logarithmic in fact the space complexity of the recursive version of binary search is the same if we start out with a memory allocation of size n that matches the list on each function call of recursive binary search we need to allocate additional memory of size n by 2 n by 4 and so on until we have a sub list that is either empty or contains a single value because of this we say that the recursive version of the binary search algorithm runs in logarithmic time with a big o of log n now there's an important caveat here this totally depends on the language remember how i said that a programming language like swift can do some tricks to where recursion depth doesn't matter the same concept applies here if you care to read more about this concept it's called tail optimization it's called tail optimization because if you think of a function as having a head and a tail if the recursive function call is the last line of code in the function as it is in our case we call this tail recursion since it's the last part of the function that calls itself now the trick that swift does to reduce the amount of space and therefore computing overhead to keep track of this recursive calls is called tail call optimization or tail call elimination it's one of those things that you'll see thrown around a loss in algorithm discussions but may not always be relevant to you now what if any of this is relevant to us well python does not implement tail call optimization so the recursive version of binary search takes logarithmic space if we had to choose between the two implementations given that time complexity or run time of both versions the iterative and the recursive version are the same we should definitely go with the iterative implementation in python since it runs in constant space okay that was a lot but all of this with all of this we've now established two important ways to distinguish between algorithms that handle the same task and determine which one we should use we've arrived at what i think is a good spot to take a long break and let all of these new concepts sink in but before you go off to the next course let's take a few minutes to recap everything we've learned so far while we did implement two algorithms in this course in actual code much of what we learned here was conceptual and will serve as building blocks for everything we're going to learn in the future so let's list all of it out the first thing we learned about and arguably the most important was algorithmic thinking algorithmic thinking is an approach to problem solving that involves breaking a problem down into a clearly defined input and output along with a distinct set of steps that solves the problem by going from input to output algorithmic thinking is not something you develop overnight by taking one course so don't worry if you're thinking i still don't truly know how to apply what i learned here algorithmic thinking sinks in after you go through several examples in a similar fashion to what we did today it also helps to apply these concepts in the context of a real example which is another thing we will strive to do moving forward regardless it is important to keep in mind that the main goal here is not to learn how to implement a specific data structure or algorithm off the top of your head i'll be honest i had to look up a couple code snippets for a few of the algorithms myself in writing this course but in going through this you now know that binary search exists and can apply to a problem where you need a faster search algorithm unlike most courses where you can immediately apply what you have learned to build something cool learning about algorithms and data structures will pay off more in the long run the second thing we learned about is how to define and implement algorithms we've gone over these guidelines several times i won't bore you here again at the end but i will remind you that if you're often confused about how to effectively break down a problem in code to something more manageable following those algorithm guidelines is a good place to start next we learned about big o and measuring the time complexity of algorithms this is a mildly complicated topic but once you've abstracted the math away it isn't as hazy a topic as it seems now don't get me wrong the math is pretty important but only for those designing and analyzing algorithms our goal is more about how to understand and evaluate algorithms we learned about common run times like constant linear logarithmic and quadratic runtimes these are all fairly new concepts but in time you will immediately be able to distinguish the runtime of an algorithm based on the code you write and have an understanding of where it sits on an efficiency scale you will also in due time internalize runtimes of popular algorithms like the fact that binary search runs in logarithmic time and constant space and be able to recommend alternative algorithms for a given problem all in all over time the number of tools in your tool belt will increase next we learned about two important search algorithms and the situations in which we select one over the other we also implemented these algorithms in code so that you got a chance to see them work we did this in python but if you are more familiar with a different language and haven't gotten the chance to check out the code snippets we've provided you should try your hand at implementing it yourself it's a really good exercise to go through finally we learned about an important concept and a way of writing algorithmic code through recursion recursion is a tricky thing and depending on the language you write code with you may run into it more than others it is also good to be aware of because as we saw in our implementation of binary search whether recursion was used or not affected the amount of space we used don't worry if you don't fully understand how to write recursive functions i don't truly know either the good part is you can always look these things up and understand how other people do it anytime you encounter recursion in our courses moving forward you'll get a full explanation of how and why the function is doing what it's doing and that brings us to the end of this course i'll stress again that the goal of this course was to get you prepared for learning about more specific algorithms by introducing you to some of the tools and concepts you will need moving forward so if you're sitting there thinking i still don't know how to write many algorithms or how to use algorithmic thinking that's okay we'll get there just stick with it as always have fun and happy coding [Music] hi my name is passant i'm an instructor at treehouse and welcome to the introduction to data structures course in this course we're going to answer one fundamental question why do we need more data structures than a programming language provides before we answer that question some housekeeping if you will in this course we're going to rely on concepts we learned in the introduction to algorithms course namely big-o notation space and time complexity and recursion if you're unfamiliar with those concepts or just need a refresher check out the prerequisites courses listed in addition this course does assume that you have some programming experience we're going to use data structures that come built into nearly all programming languages as our point of reference while we will explain the basics of how these structures work we won't be going over how to use them in practice if you're looking to learn how to program before digging into this content check the notes section of this video for helpful links if you're good to go then awesome let's start with an overview of this course the first thing we're going to do is to explore a data structure we are somewhat already familiar with arrays if you've written code before there's a high chance you have used an array in this course we're going to spend some time understanding how arrays work what are the common operations on an array and what are the run times associated with those operations once we've done that we're going to build a data type of our own called a linked list in doing so we're going to learn that there's more than one way to store data in fact there's way more than just one way we're also going to explore what motivates us to build specific kinds of structures and look at the pros and cons of these structures we'll do that by exploring four common operations accessing a value searching for a value inserting a value and deleting a value after that we're actually going to circle back to algorithms and implement a new one a sorting algorithm in the introductions to algorithms course we implemented a binary search algorithm a precondition to binary search was that the list needed to be sorted we're going to try our hand at sorting a list and open the door to an entirely new category of algorithms we're going to implement our sorting algorithm on two different data structures and explore how the implementation of one algorithm can differ based on the data structure being used we'll also look at how the choice of data structure potentially influences the run time of the algorithm in learning about sorting we're also going to encounter another general concept of algorithmic thinking called divide and conquer along with recursion dividing conquer will be a fundamental tool that we will use to solve complex problems all in due time in the next video let's talk about arrays a common data structure built into nearly every programming language is the array arrays are a fundamental data structure and can be used to represent a collection of values but it is much more than that arrays are also used as building blocks to create even more custom data types and structures in fact in most programming languages text is represented using the string type and under the hood strings are just a bunch of characters stored in a particular order in an array before we go further and dig into arrays what exactly is a data structure a data structure is a way of storing data when programming it's not just a collection of values and the format they're stored in but the relationship between the values in the collection as well as the operations applied on the data stored in the structure an array is one of very many data structures in general an array is a data structure that stores a collection of values where each value is referenced using an index or a key a common analogy for thinking about arrays is as a set of train cars each car has a number and these cars are ordered sequentially inside each car the array or the train in this analogy stores some data while this is the general representation of an array it can differ slightly from one language to another but for the most part all these fundamentals remain the same in a language like swift or java arrays are homogeneous containers which means they can only contain values of the same type if you use an array to store integers in java it can only store integers in other languages arrays are heterogeneous structures that can store any kind of value in python for example you can mix numbers and text with no issues now regardless of this nuance the fundamental concept of an array is the index this index value is used for every operation on the array from accessing values to inserting updating and deleting in python the language we're going to be using for this course it's a tiny bit confusing the type that we generally refer to as an array in most languages is best represented by the list type in python python does have a type called array as well but it's something different so we're not going to use it while python calls it a list when we use a list in this course we'll be talking about concepts that apply to arrays as well in other languages so definitely don't skip any of this there's one more thing in computer science a list is actually a different data structure than an array and in fact we're going to build a list later on in this course generally though this structure is called a linked list as opposed to just list so hopefully the terminology isn't too confusing to properly understand how arrays work let's take a peek at how arrays are stored under the hood an array is a contiguous data structure this means that the array is stored in blocks of memory that are right beside each other with no gaps the advantage of doing this is that retrieving values is very easy in a non-contiguous data structure we're going to build one soon the structure stores a value as well as a reference to where the next value is to retrieve that next value the language has to follow that reference also called a pointer to the next block of memory this adds some overhead which as you will see increases the runtime of common operations a second ago i mentioned that depending on the language arrays can either be homogeneous containing the same type of value or heterogeneous where any kind of value can be mixed this choice also affects the memory layout of the array for example in a language like c swift or java where arrays are homogeneous when an array is created since the kind of value is known to the language compiler and you can think of the compiler as the brains behind the language it can choose a contiguous block of memory that fits the array size and values created if the values were integers assuming an integer took up space represented by one of these blocks then for a five item array the compiler can allocate five blocks of equally sized memory in python however this is not the case we can put any value in a python list there's no restriction the way this works is a combination of contiguous memory and the pointers or references i mentioned earlier when we create a list in python there is no information about what will go into that array which makes it hard to allocate contiguous memory of the same size there are several advantages to having contiguous memory since the values are stored beside each other accessing the values happens in almost constant time so this is a characteristic we want to preserve the way python gets around this is by allocating contiguous memory and storing init not the value we want to store but a reference or a pointer to the value that's stored somewhere else in memory by doing this it can allocate equally sized contiguous memory since regardless of the value size the size of the pointer to that value is always going to be equal this incurs an additional cost in that when a value is accessed we need to follow the pointer to the block of memory where the value is actually stored but python has ways of dealing with these costs that are outside the scope of this course now that we know how an array stores its values let's look at common operations that we execute on an array regardless of the kind of data structure you work with all data structures are expected to carry out four kinds of operations at minimum we need to be able to access and read values stored in the structure we need to be able to search for an arbitrary value we also need to be able to insert a value at any point into the structure and finally we need to be able to delete structures let's look at how these operations are implemented on the array structure in some detail starting with access elements in an array are identified using a value known as an index and we use this index to access and read the value most programming languages follow a zero-based numbering system when it comes to arrays and all this means is that the first index value is equal to zero not one generally speaking when an array is declared a base amount of contiguous memory is allocated as the array storage computers refer to memory through the use of an address but instead of keeping a reference to all the memory allocated for an array the array only has to store the address of the first location because the memory is contiguous using the base address the array can calculate the address of any value by using the index position of that value as an offset if you want to be more specific think of it this way let's say we want to create an array of integers and then each integer takes up a certain amount of space in memory that we'll call m let's also assume that we know how many elements we're going to create so the size of the array is some number of elements we'll call n the total amount of space that we need to allocate is n times the space per item m if the array keeps track of the location in memory where the first value is held so let's label that m0 then it has all the information it needs to find any other element in the list when accessing a value in an array we use the index to get the first element in the list we use the zeroth index to get the second we use the index value 1 and so on given that the array knows how much storage is needed for each element it can get the address of any element by starting off with the address for the first element and adding to that the index value times the amount of storage per element for example to access the second value we can start with m0 and to that add m times the index value 1 giving us m1 as the location in memory for the second address this is a very simplified model but that's more or less how it works this is only possible because we know that array memory is contiguous with no gaps let's switch over to some code as i mentioned earlier we're going to be using python in this course if you don't know how to code or you're interested in this content but know a language other than python check the notes section of this video for more information while the code will be in python the concepts are universal and more importantly simple enough that you should have no issue following along in your favorite programming language and to get started click on the launch workspaces button on the video page that you're watching right now this should spin up an instance of a treehouse workspace an in-browser coding environment right now your workspace should be empty and that's expected so let's add a new file in here i'm going to go to file new file and we'll call this arrays dot py pi creating a list in python is quite simple so we'll call this new underscore list we use a set of square brackets around a set of values to create a list so one and we comma separate them so space two and space three this allocates a base amount of memory for the array to use or when i say array know that in python i mean a list since this is python the values aren't stored in memory instead the values 1 2 and 3 are stored elsewhere in memory and the array stores references to each of those objects to access a value we use a subscript along with an index value so to get the first value we use the index 0 and if we were to assign this to another variable we would say result equal new list we write out new lists since this is the array that we're accessing the value from and then a subscript notation which is a square bracket and then the index value as we saw since the array has a reference to the base location in memory the position of any element can be determined pretty easily we don't have to iterate over the entire list all we need to do is a simple calculation of an offset from the base memory since we're guaranteed that the memory is contiguous for this reason access is a constant time operation on an array or a python list this is also why an array crashes if you try to access a value using an index that is out of bounds of what the array stores if you've used an array before you've undoubtedly run into an error or a crash where you try to access a value using an index that was larger than the number of elements in the array since the array calculates the memory address on the fly when you access a value with an out of bounds index as it's called the memory address returned is not one that's part of the array structure and therefore cannot be read by the array now in python this is represented by an index error and we can make this happen by using an index we know our array won't contain now i'm writing out my code here inside of a text editor which obviously doesn't run the code so let's drag up this console area here and i'm going to write python to bring up the python interpreter and in here we can do the same thing so i can say new list equal one comma two comma three and now this is an interpreter so it's actually going to evaluate our code all right so now we have a new list if i type out new list it gets printed out into the console okay i can also do new list square bracket 0 and you'll see that i get the value 1 which is the value stored at the zeroth index now to highlight that index error we can do new list and inside the square brackets we can provide an index that we know our array doesn't contain so here i'll say index 10 and if i hit enter you'll see it say index error list index out of range and those are the basics of how we create and read values from an array in the next video let's take a look at searching in the last video we learned what happens under the hood when we create an array and read a value using an index in this video we're going to look at how the remaining data structure operations work on arrays if you took the introduction to algorithms course we spent time learning about two search algorithms linear search and binary search while arrays are really fast at accessing values they're pretty bad at searching taking an array as is the best we can do is use linear search for a worst case linear runtime linear search works by accessing and reading each value in the list until the element in concern is found if the element we're looking for is at the end of the list then every single element in the list will have been accessed and compared even though accessing and comparing our constant time operations having to do this for every element results in an overall linear time let's look at how search works in code in python we can search for an item in an array in one of two ways we can use the in operator to check whether a list contains an item so i can say if one in new underscore list then print true the in operator actually calls a contains method that is defined on the list type which runs a linear search operation in addition to this we can also use a for loop to iterate over the list manually and perform a comparison operation so i can say for n in new list if n equals one then print true and then after that break out of the loop this is more or less the implementation of linear search if the array were sorted however we could use binary search but because sort operations incur a cost of their own languages usually stay away from sorting the list and running binary search since for smaller arrays linear search on its own may be faster now again remember that since this is an editor this is just a text file none of these lines of code are evaluated so you can try that out in here so we'll copy that we can come down here and say python and hit enter and then when it starts up we can paste in our list and now we can try what we just did so if one in new list print true and there you go it prints true now because we've already learned about linear and binary search in a previous course there's nothing new going on here what's more interesting to look at in my opinion is inserting and deleting values in an array let's start with inserting in general most array implementations support three types of insert operations the first is a true insert using an index value where we can insert an element anywhere in the list this operation has a linear runtime imagine you wanted to insert an item at the start of the list when we insert into the first position what happens to the item that is currently in that spot well it has to move to the next spot at index value one what happens to the second item at index position one that one moves to the next spot at index position two this keeps happening until all elements have been shifted forward one index position so in the worst case scenario inserting at the zeroth position of an array every single item in the array has to be shifted forward and we know that any operation that involves iterating through every single value means a linear runtime now the second way we can insert an item into an array is by appending appending although technically an insert operation in that it inserts an item into an existing array doesn't incur the same runtime cost because appends simply add the item to the end of the list we can simplify and say that this is constant time this is a constant time operation but it depends on the language implementation of array to highlight why that matters let's consider how lists in python work in python when we create a list the list doesn't know anything about the size of the list and how many elements we're going to store creating a new empty list like so so numbers equal and two empty brackets so this creates a list and allocates a space of size n plus one since n here is zero there are no elements in this array in this list space is allocated for a one element list to start off because the space allocated for the list and the space used by the list are not the same what do you think happens when we ask python for the length of this list so i can say len numbers we correctly get 0 back this means that the list doesn't use the memory allocation as an indicator of its size because as i mentioned it has allocated space for a one element list but it returns zero so it determines it in other ways okay so numbers this list currently has space for one element let's use the append method defined on the type to insert a number at the end of the list so you can say numbers dot append and i'll pass in 2. now the memory allocation and the size of the list are the same since the list contains one element now what if i were to do something like this numbers.append there needs to be a dot and i'll add another value 200. now since the list only has an allocation for one item at this point before it can add the new element to the list it needs to increase the memory allocation and thereby the size of the list it does this by calling a list resize operation list resizing is quite interesting because it shows the ingenuity in solving problems like this python doesn't resize the list to accommodate just the element we want to add instead in this case it would allocate four blocks of memory to increase the size to a total of four contiguous blocks of memory it does this so that it doesn't have to resize the list every single time we add an element but at very specific points the growth pattern of the list type in python is 0 4 8 16 25 35 46 and so on this means that as the list size approaches these specific values resize is called again if you look at when the size of the list is four this means that when appending four more values until the size of eight each of those append operations do not increase the amount of space taken at specific points however when resizing is triggered space required increases as memory allocation increases this might signify that the append method has a non-constant space complexity but it turns out that because some operations don't increase space and others do when you average all of them out append operations take constant space we say that it has an amortized constant space complexity this also happens with insert operations if we had a four element array we would have four elements and a memory allocation of four an insert operation at that point doesn't matter where it happens on the list but at that point it would trigger a resize inserting is still more expensive though because after the resize every element needs to be shifted over one the last insert operation that is supported in most languages is the ability to add one list to another in python this is called an extend and looks like this so i'll say numbers now if you let me actually clear out the console oh actually you will let's exit python we'll clear this out so we're back at the top and we'll start again so i'll say numbers and we'll set it to an empty list and now we can say numbers dot extend and as an argument we're going to pass in a new list entirely so here we'll say 4 comma 5 comma 6 and then once i hit enter if i were to print out numbers you'll see that it now contains the values 4 5 and 6. so extend takes another list to add extend effectively makes a series of append calls on each of the elements in the new list until all of them have been appended to the original list this operation has a run time of big o of k where k represents the number of elements in the list that we're adding to our existing list the last type of operation we need to consider are delete operations deletes are similar to inserts in that when a delete operation occurs the list needs to maintain correct index values so where an insert shifts every element to the right a delete operation shifts every element to the left just like an insert as well if we delete the first element in the list every single element in the list needs to be shifted to the left delete operations have an upper bound of big o of n also known as a linear runtime now that we've seen how common operations work on a data structure that we're quite familiar with let's switch tracks and build our own data structure [Music] over the next few videos we're going to build a data structure that you may have worked with before a linked list before we get into what a linked list is let's talk about why we build data structures instead of just using the ones that come built into our languages each data structure solves a particular problem we just went over the basics of the array data structure and looked at the cost of common operations that we carry out on arrays we found that arrays were particularly good at accessing reading values happens in constant time but arrays are pretty bad at inserting and deleting both of which run in linear time linked lists on the other hand are somewhat better at this although there are some caveats and if we're trying to solve a problem that involves far more inserts and deletes than accessing a linked list can be a better tool than an array so what is a linked list a linked list is a linear data structure where each element in the list is contained in a separate object called a node a node models two pieces of information an individual item of the data we want to store and a reference to the next node in the list the first node in the linked list is called the head of the list while the last node is called the tail the head and the tail nodes are special the list only maintains a reference to the head although in some implementations it keeps a reference to the tail as well this aspect of linked lists is very important and as you'll see most of the operations on the list need to be implemented quite differently compared to an array the opposite of the head the tail denotes the end of the list every node other than the tail points to the next node in the list but tail doesn't point to anything this is basically how we know it's the end of the list nodes are what are called self-referential objects the definition of a node includes a link to another node and self-referential here means the definition of node includes the node itself linked lists often come in two forms a singly linked list where each node stores a reference to the next node in the list or a doubly linked list where each node stores a reference to both the node before and after if an array is a train with a bunch of cars in order then a linked list is like a treasure hunt when you start the hunt you have a piece of paper with the location of the first treasure you go to that location and you find an item along with a location to the next item of treasure when you finally find an item that doesn't also include a location you know that the hunt has ended now that we have a high level view of what a linked list is let's jump into code and build one together we'll focus on building a singly linked list for this course there are advantages to having a doubly linked list but we don't want to get ahead of ourselves let's start here by creating a new file we're going to put all our code for our linked list so we'll call this linked underscore list dot pi and first we're going to create a class to represent a node say class node now node is a simple object in that it won't model much so first we'll add a data variable it's an instance variable here called data and we'll assign the value none initially and then we'll add one more we'll call this next node and to this we'll assign none as well so we've created two instance variables data to hold on to the data that we're storing and next node to point to the next node in the list now we need to add a constructor to make this class easy to create so we'll add an init method here that takes self and some data to start off and all we're going to do is assign data to that instance variable we created so that's all we need to model node before we do anything else though let's document this so right after the class definition let's create a docs string so three quotes next line and we'll say an object for storing a single node of a linked list and then on the next line we'll say models two attributes data and the link to the next node in the list and then we'll close this doc string off with three more quotation marks okay using the node class is fairly straightforward so we can create a new instance of node with some data to store now the way we're going to do this is we're going to bring up the console and we're going to type out like we've been typing out before python followed by the name of the script that we wrote which is linked list linked underscore list.pi but before we do that we're going to pass an argument to the python command we're going to say dash or python i and then the name of the script linked underscore list dot pi so what this does is this is going to run the python repl the read evaluate print loop in the console but it's going to load the contents of our file into that so that we can use it so i'll hit enter and we have a new instance going and now we can use the node in here so we can say n1 equal node and since we defined that constructor we can pass it some data so we'll say 10 here now if we try to inspect this object the representation returned isn't very useful which will make things really hard to debug as our code grows so for example if i type out n1 you'll see that we have a valid instance here but it's not very helpful the way it's printed out so we can customize this by adding a representation of the object using the wrapper function now in the terminal still we'll type out exit like that hit enter to exit the console and then down here let's add in some room okay and here we'll say def double underscore wrapper another set of double underscores and then this function takes the argument self and in here we can provide a string representation of what we want printed to the console when we inspect that object inside of it inside of a console so here we'll say return again this is a string representation so inside quotes we'll say node so this represents a node instance and the data it contains here we'll say percent s which is a python way of substituting something into a string string interpolation and outside of the string we can say percent again and here we're saying we want to replace this percent s with self.data okay let's hit save and before we move on let's verify that this works so i'm going to come in here type clear to get rid of everything and then we'll do what we did again and you can just hit the up arrow a couple times to get that command all right so hit enter and now just so you know every time you run this you start off you know from scratch so n1 that we created earlier not there anymore so let's go ahead and create it n1 equal node 10 and we can type n1 again and hit enter and you have a much better representation now so we can see that we have a node and it contains the data 10. we can also create another one n2 equal node that contains the data 20 and now we can say n1.next n1.nextnode equal n2 so n1 now points to n2 and if we say n1.nextnode you'll see that it points to that node the node containing 20. nodes are the building blocks for a list and now that we have a node object we can use it to create a singly linked list so again i'm going to exit out of this and then go back to the text editor and here we'll create a new class so class linked list the linked list class is going to define a head and this attribute models the only node that the list is going to have a reference to so here we'll say head and we'll assign none initially and then like we did earlier let's create a constructor so double underscore init double underscore this takes self and then inside like before we'll say self dot head equal none this is the same as doing this so we can actually get rid of that and just use the constructor okay so again this head attribute models the only node that the list will have a reference to since every node points to the next node to find a particular node we can go from one node to the next in a process called list traversal so in the class constructor here we've set the default value of head to none so that new lists created are always empty again you'll notice here that i didn't explicitly declare the head attribute at the top of the class definition and don't worry that's not an oversight the self.head in the initializer means that it's still created okay so that's all there is to modeling a linked list now we can add methods that make it easier to use this data structure first a really simple docstring to provide some information so here we'll to create a docstring three quotation marks and then we'll say singly linked list and then close it off a common operation carried out on data structures is checking whether it contains any data or whether it's empty at the moment to check if a list is empty we would need to query these instance variables head and so on every time ideally we would like to not expose the inner workings of our data structure to code that uses it instead let's make this operation more explicit by defining a method so we'll say def is empty and this method takes self as an argument and here we'll say return self.head double equal none all we're doing here is checking to see if head is none if it is this condition evaluates to true which indicates the list is empty now before we end this video let's add one more convenience method to calculate the size of our list the name convenience method indicates that what this method is doing is not providing any additional functionality that our data structure can't handle right now but instead making existing functionality easier to use we could calculate the size of our linked list by traversing it every time using a loop until we hit a tail node but doing that every time is a hassle okay so we'll call this method size and as always it takes self unlike calling len on a python list not to be confused with a linked list which is a constant time operation our size operation is going to run in linear time the only way we can count how many items we have is to visit each node and call next until we hit the tail node so we'll start by getting a reference to the head we'll say current equal self.head let's also define a local variable named count with an initial value of 0 that will increment every time we visit a node once we hit the tail count will reflect the size of that list next we'll define a while loop that will keep going until there are no more nodes so say while current while current is the same as writing out while current does not equal none but it's more succinct so we'll go with this former if the ladder is more precise for you you can go with that now inside this loop we'll increment the count value so count plus equal one plus equal if you haven't encountered it before is the same as writing count equal count plus one so if count is zero initially so it's zero plus one is one and then we'll assign that back to count okay so count plus equal one next we're going to assign the next node in the list to current so current equal current dot next node this way once we get to the tail and call next node current will equal none and the while loop terminates so the end we can return count as you can see we need to visit every node to determine the size meaning our algorithm runs in linear time so let's document this up in our docs string which we'll add now to size we'll say returns the number of nodes in the list takes linear time let's take a break here we can now create lists check if they're empty and check the size in the next video let's start implementing some common operations at the moment we can create an empty list but nothing else let's define a method to add data to our list technically speaking there are three ways we can add data to a list we can add nodes at the head of the list which means that the most recent node we created will be the head and the first node we created will be the tail or we could flip that around most recent nodes are the tail of the list and the first node to be added is the head i mentioned that one of the advantages of linked lists over arrays is that inserting data into the list is much more efficient than to the array this is only true if we're inserting at the head or the tail technically speaking this isn't an insert and you'll often see this method called add prepend if the data is added to the head or append if it's added to the tail a true insert is where you can insert the data at any point in the list which is our third way of adding data we're going to circle back on that if we wanted to insert at the tail then the list needs a reference to the tail node otherwise we would have to start at the head and walk down the length of the list or traverse it to find the tail since our list only keeps a reference to the head we're going to add new items at the head of the list now before we add our new method i forgot that i didn't show you in the last video how to actually use the code we just added and how to check every time you know when we add new code that it works correctly so like before we're gonna bring up the console and here we're gonna say python dash i linked underscore list dot pi which should load it load the contents of our file and now we'll start here by creating a linked list so l equal linked list and then we'll use a node so n1 equal node with the value 10 and now we can assign n1 to the nodes or to the linked lists head attribute so l1 dot head equal n1 and then we can see if size works correctly so if we call l1 dot size and since this is a method we need a set of parentheses at the end and enter you'll see that we get back one correctly okay so it works now let's add our new method which we're going to call add add is going to accept some data to add to the list inside of a node so we'll say def add and every python method takes self as an argument and then we want to add some data to this node so we're going to say data for the second argument inside the method first we'll create a new node to hold on to the data so new underscore node equal node with the data before we set the new node as the head of the list we need to point the new node's next property at whatever node is currently at head this way when we set the new node as the head of the list we don't lose a reference to the old head so new underscore node dot next node equal self.head now if there was no node at head this correctly sets next node to none now we can set the new node as the head of the node so say self.head equal new underscore node because the insert operation is simply a reassignment of the head and next node properties this is a constant time operation so let's add that in as a docs string first what the method does so it adds a new node containing data at the head of the list this operation takes constant time which is our best case scenario okay let's test this out so i'm going to bring the console back up we'll exit out of our current reply and we'll load the contents of the file again and now we don't need to create a node like we did earlier so we can say l equal linked list l.add one okay let's see if this works we'll call size and if it worked the linked list should now have a size of one there we go you can also do l.add2 l.add three and l dot size should now be three there we go now if we i were to type l and just hit print again what we get in the repel is nothing useful so like before we'll implement the wrapper function for our linked list now i'm just going to copy paste this in and we'll walk through it okay so this is what our implementation of wrapper looks like for the linked list object you can grab this code from the notes section of this video okay so at the top you'll see a docs string where it says it returns a string representation of the list and like everything we need to do with a linked list we need to traverse it so this is going to take linear time we start by creating an empty list now i need to distinguish this is a python list not a linked list so we create an empty list called nodes and two nodes we're going to add strings that have a description that provide a description of each node but we're not going to use the description that we implemented in the node class because we're going to customize it a bit here next we start by assigning self.head to current so we sort of have a pointer to the head node as long as current does not equal none which means we're not at the tail we're going to implement some logic so in the first scenario if the node assigned to current is the same as the head then we're going to append this string to our nodes list and the string is simply going to say that hey this is a head node and it contains some data which will extract using current.data next scenario is if the node assigned to current's next node is none meaning we're at the tail node then we'll assign a different kind of string so it's the same as earlier except we're saying tail here and then finally in any other scenario which means we're not at the head or not of the tail we'll simply print the node's value inside and again we'll extract it using current.data with every iteration of the loop we'll move current forward by calling current.nextnode and reassigning it and then at the very end when we're done we'll join all the strings that are inside the nodes list together using the python join method and we'll say that with every join so when you join these two strings together to make one string you need to put this set of characters in between all right so let's see what this looks like so i'm going to come down here exit out of the console again clear it out load the contents of the file again and let's try that so we'll say l equal linked list all right so l dot add one l dot add two l dot add three that seems enough and then now if i type out l and hit enter we get a nice string representation of the list so you can see that we add every new node to the head so we added one first one ends up being the tail because it keeps getting pushed out then two and then finally three so three is at the head so far we've only implemented a single method which functions much like the append method on a python list or an array except it adds it to the start of the linked list it pre-pens it like append this happens in constant time in the next video let's add the ability to search through our list for the search operation we're going to define a method that takes a value to search for and returns either the node containing the value if the value is found or none if it isn't so right after actually you know what we'll make sure wrapper is the last function our last method in our class so we'll add it above it so here we'll say def search self and then key in the last video we implemented the wrapper method to provide a string representation of the list so we're going to use similar logic here to implement the search function we'll start by setting a local variable current to point to the head of the list while the value assigned to current is a valid node that is it isn't none we'll check if the data on that node matches the key that we're searching for so while current we'll say if current.data is the key then we'll return current if it does match we'll go ahead and return it like we've done here but if it doesn't we'll assign the next node in the list to current and check again so say else current equal current dot next node once we hit the tail node and haven't found the key current gets set to none and the while loop exits at this point we know the list doesn't contain the key so we can return none okay that completes the body of our method let's add a docs string to document this so up at the top we'll say search for the first node containing data that matches the key now this is important because if our linked list contains more than one node with the same value it doesn't matter we're going to return the first one with this implementation we'll also say here that it returns the node or none if not found in the worst case scenario we'll need to check every single node in the list before we find the key or fail and as a result this operation runs in linear time so i'll say takes o of n or linear time so far we haven't seen anything that indicates this data structure has any advantage over an array or a python list but we knew that i mentioned the strength of linked lists comes in inserts and deletes at specific positions we'll check that out in the next video but as always before we end this one let's make sure everything works so we'll load the contents of the file again l equal linked list and then we'll say l.add 10 l dot add 20 2 doesn't matter l dot add 45 and one more metal dot add 15. now we can say l.search and we need to give it a value so we'll say 45 and this returns a node or none so we'll say n equal and then we'll hit enter if this works n should be a node okay weirdly n does not work here at least it says it's not a node which means i made a mistake in typing out our code and looking at it immediately it's fairly obvious so this return none needs to be outside of the while loop okay so i'm going to hit save now so make sure it's on the same indentation here which means it's outside the while loop and then we'll run through this again okay so l is linked list l.add 10 l dot add 2 l.add 45 and what was the last one we did i believe it was 15 and now we should be able to say l.search remember we're assigning this to a node to a variable so l.search 45 and there you go we get that node back and we can hit l and we'll see a representation of our list okay so again in the next video inserts and deletes at specific positions insert operations on linked lists are quite interesting unlike arrays where when you insert an element into the array all elements after the particular index need to be shifted with a linked list we just need to change the references to next on a few nodes and we're good to go since each node points to the next one by swapping out these references we can insert a node at any point in the list in constant time much like binary search though there's a catch to find the node at that position we want to insert we need to traverse the list and get to that point we just implemented our search algorithm for the linked list type and we know that this runs in linear time so while actually inserting is fast finding the position in the list you want to insert it is not this is why i mentioned that there were some caveats to inserting anyway let's see what this looks like in code we'll define a method named insert that takes data to insert along with an index position so we'll do this after search right here say def insert and this takes some data to insert and a position to insert it at you may be thinking wait a minute linked lists don't have index positions right and you're correct but we can mimic that behavior by just counting the number of times we access next node if the index value passed into this argument is 0 that means we want to insert the new node at the head of the list this is effectively the same behavior as calling add which means the logic is the same so we don't need to repeat it we can call the add method we wrote earlier so we'll say if index if index equals 0 or if index is 0 then self dot add data if the index is greater than 0 then we need to traverse the list to find the current node at that index so if index is greater than zero now before we do that we need to create a new node containing the data we want to insert so we'll say new equal node with some data i'm going to assign index the argument passed to our function to a local variable named position and the head of the list to a variable named current position equal index current equal self.head every time we call current.nextnode meaning we're moving to the next node in the list we'll decrease the value of position by 1. when position is zero we'll have arrived at the node that's currently at the position we want to insert in in reality though we don't want to decrease it all the way to zero imagine we have a list with five nodes and we want to insert a node at position 3. to insert a node at position 3 we need to modify the nodes at positions 2 and 3. node 2's next node attribute is going to point to the new node and the new node's next node attribute will point to node 3. in this way an insert is a constant time operation we don't need to shift every single element we just modify a few next node references in a doubly linked list we can use node 3 to carry out both of these operations node 3 in a doubly linked list would have a reference to node 2 and we can use this reference to modify all the unnecessary links and a singly linked list though which is what we have if we kept decreasing position until we're at 0 we arrive at node 3. we can then set the new node's next node property to point to node 3 but we have no way of getting a reference to node 2 which we also need for this reason it's easier to decrease position to just 1 when it equals 1 and stop at node 2. so in here we'll say while position is greater than one now while the position is greater than one we'll keep calling next node and reassigning the current node so current equal node.next node and at the same time we'll decrement position so position equal to position minus one which you can also succinctly write as minus equal one this way when the position equals one the loop exits and current will refer to the node at the position before the insert point so outside the while loop we'll say previous equal current and next equal current dot next node to make things more clear what i've done here is name the node before the new one previous and the node after the new one next all that's left to do now is to insert the new node between previous and next so we'll say previous dot next node equal new and then new dot next node equal next now it seems like there's an issue with variable naming here and i'm most probably conflicting with some globally named next variable so actually go ahead and call this next node and previous node so that we don't mess things up here previous node so the dot next node is obviously the attribute on a node but this is just a local variable let's document this method so up at the top we'll add a docs string and it will say inserts a new node containing data at index position insertion takes constant time but finding the node at the insertion point takes linear time let's add this to the next line there we go and then we'll say therefore it takes an overall linear time this is why even though we can easily insert a new node without having to shift the rest ultimately adding to either the head or the tail if you have a reference is much more efficient we have one more operation to add to our linked list that will make it a robust data structure much like inserts removing a node is actually quite fast and occurs in constant time but to actually get to the node that we want to remove and modify the next connections we need to traverse the entire list in our worst case so in the worst case this takes linear time let's add this operation to our data structure there are two ways we can define the remove method one where we provide a key to remove as an argument and one where we provide an index now in the former the key refers to the data the node stores so in order to remove that node we would first need to search for data that matches the key i'm going to implement that first method which we'll call remove and i'll leave it up to you to get some practice in and implement a remove at index method to complete our data structure so we'll add this after the insert method right here remove is going to accept a key which we'll need to search for before we can remove a node earlier we defined a search method that found a node containing data that matches a key but we can't use that method as is for the implementation of remove when we remove a node much like the insert operation we need to modify the next node references the node before the match needs to point to the node after the match if we use the search method we defined earlier we get the node we want to remove as a return value but because this is a singly linked list we can't obtain a reference to the previous node like i said earlier if this was a doubly linked list we could use the search method since we would have a reference to that previous node we'll start here by setting a local variable named current to point to the head let's also define a variable named previous that will set to none to keep track of the previous node as we traverse the list finally let's declare a variable named found that we'll set to false found is going to serve as a stopping condition for the loop that we'll define we'll use the loop to keep traversing the linked list as long as found is false meaning we haven't found the key that we're looking for once we've found it we'll set found to true and the loop terminates so let's set up our loop so we'll say while current and not found here we're defining a while loop that contains two conditions first we tell the loop to keep iterating as long as current does not equal none when current equals none this means we've gone past the tail node and the key doesn't exist the second condition asks the loop to keep evaluating as long as not found equals true now this might be tricky because it involves a negation here right now found is set to false so not found not false equals true this not operator flips the value when we find the key and we set found to true not true not found we'll equal false then and the loop will stop the end in the while loop means that both conditions current being a valid node and not found equalling true both have to be true if either one of them evaluates to false then the loop will terminate now inside the loop there are three situations that we can run into first the key matches the current node's data and current is still at the head of the list this is a special case because the head doesn't have a previous node and it's the only node being referenced by the list let's handle this case so we'll say if current.data double equals the key and current is self.head which you can write out as current equal self.head or current is self.head now if we hit this case we'll indicate that we found the key by setting found to true and then this means that on the next pass this is going to evaluate to false because not true will be false and then the loop terminates once we do that we want to remove the current node and since it's the head node all we need to do is point head to the second node in the list which we can get by referencing the next node attribute on current self.head equal current.nextnode so when we do this there's nothing pointing to that first node so it's automatically removed the next scenario is when the key matches data in the node and it's a node that's not the head so here we'll say else if current dot data equal key if the current node contains the key we're looking for we need to remove it to remove the current node we need to go to the previous node and modify its next node reference to point to the node after current but first we'll set found to true and then we'll switch out the references so previous.nextnode equal current.nextnode so far we haven't written any code to keep track of the previous node we'll do that in our else case here so if we hit the else case it means that the current node we're evaluating doesn't contain the data that matches the key so in this case we'll make previous point to the current node and then set current to the next node so previous equal current and current equal current.nextnode and that's it for the implementation of remove now we're not doing anything at the moment with the node we're removing but it's common for remove operations to return the value being removed so at the bottom outside the while loop let's return current and with that we have a minimal implementation of a linked list and your first custom data structure how cool is that there's quite a bit we can do here to improve our data structure particularly in making it easy to use but this is a good place to stop before we move on to the next topic let's document our method so the top another docs string and here we'll say removes node containing data that matches the key also it returns the node or none if the key doesn't exist and finally this takes linear time because in the worst case scenario we need to search the entire list if you'd like to get in some additional practice implementing functionality for linked lists two methods you can work on are remove it index and node at index to allow you to easily delete or read values in a list at a given index now that we have a linked list let's talk about where you can use them the honest answer is not a lot of places linked lists are really useful structures to build for learning purposes because they're relatively simple and are a good place to start to introduce the kinds of operations we need to implement for various data structures it is quite rare however that you will need to implement a linked list on your own there are typically much better and by that i mean much more efficient data structures that you can use in addition many languages like java for example provide an implementation of a linked list already now that we have a custom data structure let's do something with it let's combine the knowledge we have and look at how a sorting algorithm can be implemented across two different data structures [Music] now that we've seen two different data structures let's circle back and apply what we know about algorithms to these new concepts one of the first algorithms you learned about was binary search and we learned that with binary search there was one precondition the data collection needs to be sorted over the next few videos let's implement the merge sort algorithm which is one of many sorting algorithms on both arrays or python lists and the singly linked list we just created this way we can learn a new sorting algorithm that has real world use cases and see how a single algorithm can be implemented on different data structures before we get into code let's take a look at how merge sort works conceptually and we'll use an array to work through this we start with an unsorted array of integers and our goal is to end up with an array sorted in ascending order merge sort works like binary sort by splitting up the problem into sub problems but it takes the process one step further on the first pass we're going to split the array into two smaller arrays now in binary search one of these subarrays would be discarded but that's not what happens here on the second pass we're going to split each of those subarrays into further smaller evenly sized arrays and we're going to keep doing this until we're down to single element arrays after that the merge sort algorithm works backwards repeatedly merging the single element arrays and sorting them at the same time since we start at the bottom by merging to single element arrays we only need to make a single comparison to sort the resulting merge array by starting with smaller arrays that are sorted as they grow merge sort has to execute fewer sort operations than if it sorted the entire array at once solving a problem like this by recursively breaking down the problem into subparts until it is easily solved is an algorithmic strategy known as divide and conquer but instead of talking about all of this in the abstract let's dive into the code this way we can analyze the runtime as we implement it for our first implementation of merge sort we're going to use an array or a python list while the implementation won't be different conceptually for a linked list we will have to write more code because of list traversal and how nodes are arranged so once we have these concepts squared away we'll come back to that let's add a new file here we'll call this merge underscore sort dot pi in our file let's create a new function named merge sort that takes a list and remember when i say list unless i specify linked list i mean a python list which is the equivalent of an array so we'll say def merge underscore sort and takes a list in the introduction to algorithms course we started our study of each algorithm by defining the specific steps that comprise the algorithm let's write that out as a docstring in here the steps of the algorithm so that we can refer to it right in our code this algorithm is going to sort the given list in an ascending order so we'll start by putting that in here as a simple definition sorts a list in ascending order there are many variations of merge sort and in the one we're going to implement we'll create and return a new sorted list other implementations will sort the list we pass in and this is less typical in an operation known as sort in place but i think that returning a new list makes it easier to understand the code now these choices do have implications though and we'll talk about them as we write this code for our next bit of the docs string let's write down the output of this algorithm so returns a new sorted list merge sort has three main steps the first is the divide step where we find the midpoint of the list so i'll say divide find the mid point of the list and divide into sub-lists the second step is the conquer step where we sort the sub-list that we created in the divide step so we'll say recursively sort the sub-lists created in previous step and finally the combine the combined step where we merge these recursively sorted sub-lists back into a single list so merge the sorted sub-lists created in previous step when we learned about algorithms we learned that a recursive function has a basic pattern first we start with a base case that includes a stopping condition after that we have some logic that breaks down the problem and recursively calls itself our stopping condition is our end goal a sorted array now to come up with a stopping condition or a base case we need to come up with the simplest condition that satisfies this end result so there are two possible values that fit a single element list or an empty list now in both of these situations we don't have any work to do if we give the merge sort function an empty list or a list with one element it's technically already sorted we call this naively sorting so let's add that as our stopping condition we'll say if len list if the length of the list is less than or equal to one then we can return the list okay so this is a stopping condition and now that we have a stopping condition we can proceed with the list of steps first we need to divide the list into sub lists to make our functions easier to understand we're going to put our logic in a couple different functions instead of one large one so i'll say it left half comma right half equal split list so here we're calling a split function that splits the list we pass in and returns two lists split at the midpoint because we're returning two lists we can capture them in two variables now you should know that this split function is not something that comes built into python this is a global function that we're about to write next is the conquer step where we sort each sub-list and return a new sorted sub-list so we'll say left equal merge sort left half and right equal merge sort right half this is the recursive portion of our function so here we're calling merge sort on this divided sub list so we divide the list into two here and then we call merge sort on it again this further splits that sublist into two in the next pass through of merge sort this is going to be called again and again and again until we reach our stopping condition where we have single element lists or empty lists when we've subdivided until we cannot divide any more then we'll end up with a left and a right half and we can start merging backwards so we'll say return merge left and right that brings us to the combined step once two sub-lists are sorted and combined we can return it now obviously none of these functions merge merge sort well merge sort is written but merge and split haven't been written so all we're going to do here if we run it is raise an error so in the next video let's implement the split operation the first bit of logic we're going to write is the divide step of the algorithm this step is fairly straightforward and only requires a few lines of code but is essential to get the sorting process going all right so as we saw earlier we're going to call the function for the divide step split so we'll say def split and split is going to take as an argument a list to split up let's document how this function works so we'll say divide the unsorted list at midpoint into sub lists and it's always good to say what we're returning as well so we'll say returns to sub-lists left and right all right so the first step is to determine the midpoint of this list of this array we're going to use the floor division operator for this floor division carries out a division operation and if we get a non-integer value like 2.5 back it just gets rounded down to two we'll define the midpoint to be the length of the list divided by two and then rounded down so lan list and using the two forward slashes for the floor division operator we'll put number two after it okay once we have the midpoint we can use the slicing notation in python to extract portions of the list we want to return for instance we can define left as the left sub-list that goes all the way from the start of the list all the way up to the midpoint without including the midpoint now over here we're using the slicing syntax where it's like using the you know subscript notation to access a value from a list but instead we give two index values as a start and stop if we don't include a start value as i've done here python interprets that as starting from the zeroth index or the start of the list now similarly we can define right [Music] to be values on the right of the midpoint so starting at the midpoint and going all the way up to the end of the list so a couple things to note as i said earlier when you don't include the starting index it interprets it as to start at the very beginning of the list the index you give as the stopping condition that value is not included in the slice so over here we're starting at the very beginning of list and we go all the way up to midpoint but not including midpoint and then right starts at midpoint so it includes that value and then goes all the way to the end of the list now once we have these two sub-lists we can return them so we'll return left and right notice that we're returning two values here and then in the merge sort function when we call that split function we're declaring two variables left half and right half to assign so that we can assign these two sub lists to them okay and that's all there is to the split function in the next video let's implement the crucial portion of the merge sort logic once we run the split function recursively over the array we should end up with several single member or empty arrays at this point we need to merge them all back and sort them in the process which is what our merge function is for the merge function is going to take two arrays or lists as arguments and to match the naming conventions we used in the split function we'll call this left and right as well so we'll say def merge takes a left and a right list now like before let's add some documentation to our function so this function merges to lists or arrays sorting them in the process and then it returns a new merged list since our function is going to return a new list let's start by creating one now in the process of merging we need to sort the values in both lists to sort we need to compare values from each array or each list so next let's create two local variables to keep track of index values that we're using for each list so the convention here is i and j so we'll stick to it so i equals 0 j equals 0. as we inspect each value in either list we'll use the variables to keep track of the indexes of those values so we'll use i to keep track of indexes in the left list and j for indexes in the right list when merging we want to keep sorting the values until we've worked through both lists so for our loop let's set up two conditions with an and operator so we'll say while let's just stay up here while i is less than while i is less than the length of the left list and j is less than the length of the right list then we'll keep executing our loop so here we're ensuring that as long as i is less than the length of the left list and the and is important and j is less than the length of the right list we're going to keep executing the code now i and j are both set to zero initially which means that our first comparison operation will be on the first element of each list respectively so we'll say if left i so i zero so this is going to get the first value out of the left list is less than right j and again here j is zero so we're going to get the first value out of the right list now if the value at index i in the left list is less than the value at index j in the right list what do we do well that means the value being compared in left is less than the value in the right and can be placed at position 0 in the new array l that we created earlier so here we'll say l dot append left i since we've read and done something with the value at position i let's increment that value so we move forward to evaluate the next item in the left list i plus one or we can say i plus equal one okay next is an else statement and here we'll say if the value at index i so i don't have to write out the actual logic because it's implied so here we're saying that left the value at left is less than the value at right now in the else clause if the value at so i equal is greater and i haven't written out that condition because it's implied so here we're saying if the value in the left is less than the value in the right so in the else clause it's going to mean that the value in the left is either greater than or equal to the value in the right but when we hit the else clause if the value at index i in the left list is greater then we place the value at index j from the right list at the start of the new one list l and similarly increment j so here we'll say l dot append right j and then j equal j plus one doing this doesn't necessarily mean that in one step we'll have a completely sorted array but remember that because we start with single element arrays and combine with each merge step we will eventually sort all the values more than one time and by the time the entire process is done all the values are correctly sorted now this isn't all we need to do in the merge step however there are two situations we can run into one where the left array is larger than the right and vice versa so this can occur when an array containing an odd number of elements needs to be split so how do you split a three element array or list well the left can have two elements and the right can have one or the other way around in either case our while loop uses an and condition where the variables used to store the indexes need to be less than the length of the lists if the left list is shorter than the right then the first condition returns false and the entire loop returns false because it's an and condition this means that in such an event when the while loop terminates not all the values in the right list will have been moved over to the new combined list so to account for this let's add two more while loops the first while loop is going to account for a situation where the right list is shorter than the left and the previous loop terminated because we reached the end of the right list first so in this case what we're going to do is simply add the remaining elements in the left to the new list we're not going to compare elements because we're going to assume that within a list the elements are already sorted so while i is less than length of left then it's the same logic l dot append left i and i plus equal one so the while loop is going to have the similar condition keep the loop going until it's at the last index inside the body we're incrementing the index with every iteration of the loop our final loop accounts for the opposite scenario where the left was shorter than the right the only difference here is that we're going to use the variable j along with the right list so we'll say while j is less than length of right l dot append right j and j plus equal one okay let's stop here in the next video let's test out merge sort make sure our code is running correctly and everything is written well and then we'll wrap up this stage by documenting our code and evaluating the run time of our algorithm in the last video we completed our implementation for the merge sort algorithm but we didn't test it in any way let's define a new list at the bottom that contains several numbers you can put whatever you want in there but make sure that the numbers are not in order i'll call mine a list and in here we'll say 54 26 or 62 doesn't matter 93 17 77 31 just add enough so that you can make out that it's sorted okay next we're going to call the merge sort algorithm and pass in our list let's assign this to some variables so we'll say l equal merge underscore sort a list and then if it works correctly we should be able to print this list and see what it looks like so i'm going to hit save down here in the console we'll tap out python merge sort dot pi and before i hit enter i actually noticed i made an error in the last video but i'll hit enter anyway and you should see the error pop up okay so what i forgot to do which is a pretty crucial part of our algorithm is in the merge function i forgot to return the list containing the sorted numbers after carrying out all this logic so here at the bottom we'll say return l all right we'll save again and now we'll clear this out and try that one more time and there we go you should see a sorted list printed out we can write out a more robust function to test this because with bigger arrays visually evaluating that printed list won't always be feasible so bring this back down let's get rid of this and we'll call our function verify sorted and this will take a list first we're going to check inside the body of the function we'll check the length of the list if the list is a single element list or an empty list we don't need to do any unnecessary work because remember it is naively sorted so we'll say if n equals 0 or if n equals 1 then we'll return true we've verified that it's sorted now to conclude our function we're going to write out one line of code that will actually do quite a bit of work so first we'll say return list zero so we'll take the first element out of the list and we'll compare and see if that's less than the second element in the list okay so first we'll check that the first element in the list is less than the second element in the list this returns either true or false so we can return that directly but this isn't sufficient if it were we could trick the verify function by only sorting the first two elements in the list so to this return statement we're going to use an and operator to add on one more condition for this condition we're going to make a recursive function call back to verify sorted and for the argument we're going to pass in the list going from the second element all the way to the end let's visualize how this would work we'll use a five element list as an example so we'll call verify sorted and pass in the entire list this list is not one or zero elements long so we skip that first if statement there's only one line of code left in the function and first we check that the element at index 0 is less than the element at index 1. if this is false the function returns immediately with a false value an and operator requires both conditions to be true for the entire line of code to return true since the first condition evaluates to false we don't need to bother evaluating the second the second condition is a recursive call with a sub-list containing elements from the original list starting at position 1 and going to the end so on the second call again we can skip that first if statement and proceed to check whether the value at element 0 is less than the value at element 1. remember that because this list is a sub-list of the original starting at the element that was the second element in the original list by comparing the elements at position 0 and 1 in the sub list we're effectively comparing the elements at position 1 and 2 in the original list with each recursive call as we create new sub lists that start at index position 1 we're able to check the entire list without having to specify any checks other than the first two elements since this is a recursive function it means we need a stopping condition and we have it already it's that first if condition as we keep making sub lists once we reach a single element list that element is already sorted by definition so we can return true since this recursive function call is part of an and condition it means that every single recursive call has to return true all the way back to the beginning for our top level function to return true and for the function to say yes this is sorted now we could have easily done this using an iterative solution and a for loop but this way you get another example of recursion to work through and understand so let's use this function at the bottom we'll say print verify sorted and first we'll pass in a list oops we got rid of that didn't we okay let me write it out again so a list equal and i think i have those original numbers here somewhere so we'll say 54 26 93 okay and then we assigned to l the result of calling merge sort on a list okay so now here we're going to use the verify sorted function and we'll check first that a list is sorted that should return false and then we'll check the same call on we'll pass an l and this should return true okay so now at the bottom here in the console we'll call python merge sort dot pi and there we go it returned false for a list meaning it's not sorted but l is sorted cool so our merge sort function works in the next video let's talk about the cost of this algorithm if we go back to the top level the merge sort function what is the run time of this function look like and what about space complexity how does memory usage grow as the algorithm runs to answer those questions let's look at the individual steps starting with the split function in the split function all we're doing is finding the midpoint of the list and splitting the list at the midpoint this seems like a constant time operation but remember that the split function isn't called once it's called as many times as we need it to to go from the initial list down to a single element list now this is a pattern we've seen a couple times now and we know that overall this runs in logarithmic time so let's add that as a comment so here i'll say takes overall big o of log n time now there's a caveat here but we'll come back to that so next up is the merge step in the merge step we've broken the original list down into single element lists and now we need to make comparison operations and merge them back in the reverse order for a list of size n we will always need to make an n number of merge operations to get back from single element lists to a merge list this makes our overall runtime big o of n times log n because that's an n number of merge steps multiplied by log n number of splits of the original list so to our merge step here let's add a comment we'll say it runs in overall oops there we go runs an overall linear time right it takes an n number of steps number of merge steps but now that we have these two so linear here and logarithmic here we can multiply these and say that the merge sort function the top level function we can conclude that the runtime of the overall sorting process is big o of n times log n now what about that caveat i mentioned earlier so if we go back to our split function here right here there we go let's take a look at the way we're actually splitting the list so we're using python's list slicing operation here and passing in two indexes where the split occurs now if you go and poke around the python documentation which i've done it says that a slicing operation is not a constant time operation and in fact has a runtime of big o of k where k represents the slice size this means that in reality our implementation of split this implementation of split does not run in logarithmic time but k times logarithmic time because there is a slice operation for each split this means that our implementation is much more expensive so overall that makes our overall top level merge sort function not n times log n but k n times log n which is much more expensive now let's get rid of all that to fix this we would need to remove this slicing operation now we can do that by using a technique we learned in a previous course in the introduction to algorithms course we looked at two versions of binary search in python a recursive and an iterative version in the recursive one we use list slicing with every recursion call but we achieve the same end result using an iterative approach without using list slicing over there we declared two variables to keep track of the starting and ending positions in the list we could rewrite merge sort to do the same but i'll leave that as an exercise for you if you want some hints if you want any direction i've included a link in the notes with an implementation so that is time complexity now just so we know before moving on for python here our overall run time is not what i've listed here but this is what the actual run time of the merge sort algorithm looks like so the merge step runs in linear time and the split step takes logarithmic time for an overall n times log n and that is how merge sort actually works okay so what about space complexity the merge sort algorithm takes linear space and this is weird to think about it first but as always a visualization helps so if we start at the top again with our full list and carry out the split method until we have single element lists each of these new lists take up a certain amount of space so the second level here we have two lists where each take up an n by two amount of space now this makes it seem that the sum of all this space is the additional space needed for merge sort but that's not actually the case in reality there are two factors that make a difference first not every single one of these sub lists are created simultaneously at step two we create two n by two size sub lists when we move to the next step however we don't hold on to the n by two sub lists and then create four n by four size sub lists for the next split instead after the four n by four size sub lists are created the n by two ones are deleted from memory there's no reason to hold on to them any longer now the second point is that our code doesn't execute every path simultaneously think of it this way when we pass our list to the top level merge sort function our implementation calls split which returns a left half and a right half the next line of code then calls merge sort on the left half again this runs the function the merge sort function again with a new list in that second run of the function split is called again we get a second left and right half and then again like before we call merge sort on this left half as well what this means is that the code walks down the left path all the way down until that initial left half is sorted and merged back into one array then it's going to walk all the way down the right path and sort that until we're back to that first split with two n by two sized sublists essentially we don't run all these paths of code at once so the algorithm doesn't need additional space for every sub-list in fact it is the very last step that matters in the last step the two sub-lists are merged back into the new sorted list and returned that sorted list has an equal number of items as the original unsorted list and since this is a new list it means that at most the additional space the algorithm will require at a given time is n yes at different points in the algorithm we require log n amount of space but log n is smaller than n and so we consider the space complexity of merge sort to be linear because that is the overall factor okay that was a lot so let's stop here don't worry if you've got questions about merge sort because we're not done yet over the next few videos let's wrap up this course by implementing merge sort on a linked list [Music] over the last few videos we implemented the merge sort algorithm on the array or list type in python merge sort is probably the most complicated algorithm we've written so far but in doing so we learned about an important concept divide and conquer we also concluded the last video by figuring out the run time of merge sort based on our implementation over the next few videos we're going to implement merge sort again this time on the linked list type in doing so we're going to get a chance to see how the implementation differs based on the data structure while still keeping the fundamentals of the algorithm the same and we'll also see how the run time may be affected by the kinds of operations we need to implement let's create a new file to put our second implementation of merge sort in so file over here new file and it's going to have a rather long name we'll call this linked list merge sort with underscores everywhere dot pi we're going to need the linked list class that we created earlier so we'll start at the top by importing the linked list class from the linkedlist.pi file the way we do that is we'll say from linked list import linked list right so that imports the class uh let's test if this works really quick we'll just do something like l equal linked list l.add ten or one doesn't matter print l okay and if i hit save and then down here we'll say python linked list merge sword dot pi okay it works so this is how we get some of the code how we reuse the code that we've written in other files into this current file and get rid of this now okay like we did with the first implementation of merge sort we're going to split the code up across three functions the main function merge sort a split function and a merge function now if you were to look up a merge sort implementation in python both for a regular list an array or a linked list you would find much more concise versions out there but they're kind of hard to explain so splitting it up into three will sort of help it you know be easier to understand so we'll call this merge sort at the top level and this time it's going to take a linked list let's add a dog string to document the function so say that this function sorts a linked list in ascending order and like before we'll add the steps in here so we'll say you first recursively divide the linked list into sub lists containing a single node then we repeatedly merge these sub-lists to produce sorted sub-lists until one remains and then finally this function returns a sorted linked list the implementation of this top level merge function is nearly identical to the array or list version we wrote earlier so first we'll provide a stopping condition or two if the size of the list is one or it's an empty list we'll return the linked list since it's naively sorted so if linked list dot size remember that function we run equal one then we'll return linked list else if linked list dot head is none meaning it's an empty list then we'll return linked list as well okay next let's split the linked list into a left and right half conceptually this is no different but in practice we need to actually traverse the list we'll implement a helper method to make this easier but we'll say left half comma right half equal split linked list now once we have two sub lists like before we can call merge sort the top level function on each so left equal merge sort left half and right equal merge sort on the right half finally we'll merge these two top-level sub-lists and return it so merge left and right okay nothing new here but in the next video let's implement the split logic the next step in the merge sort algorithm is the divide step or rather an implementation of the split function so down here we'll call this split like before and this is going to take a linked list documenting things is good and we've been doing it so far so let's add a docstring divide the unsorted list at midpoint into sub-lists now of course when i say sub-lists here i mean sub-linked lists but that's a long word to say now here's where things start to deviate from the previous version with the list type we could rely on the fact that finding the midpoint using an index and list slicing to split into two lists would work even if an empty list was passed in since we have no automatic behavior like that we need to account for this when using a linked list so our first condition is if the linked list is none or if it's empty that is if head is equal to none so we'll say if linked list equal none or you can write is there it doesn't matter or linked list dot head is none well linked list can be none for example if we call split on a linked list containing a single node a split on such a list would mean left would contain the single node while right would be none now in either case we're going to assign the entire list to the left half and assign none to the right so we'll say left half equal linked list and then right half equal none you could also assign the single element list or none to left and then create a new empty linked list assigned to the right half but that's unnecessary work so now that we've done this we can return left half and right half so that's our first condition let's add an else clause to account for non-empty linked lists first we'll calculate the size of the list now this is easy because we've done the work already and we can just call the size method that we've defined we'll say size equal linked underscore list dot size using this size we can determine the midpoint so mid equal size and here we'll use that floor division operator to divide it by two once we have the midpoint we need to get the node at that midpoint now make sure you hit command s to save here and we're going to navigate back to linkedlist.hi in here we're going to add a convenience method at the very bottom right before the wrapper function right here and this convenience method is going to return a node at a given index so i'll call this node at index and it's going to take an index value this way instead of having to traverse the list inside of our split function we can simply call node at index and pass it the midpoint index we calculated to give us the node right there so we can perform the split okay so this method accepts as an argument the index we want to get the node for if this index is zero then we'll return the head of the list so if index double equals zero return self.head the rest of the implementation involves traversing the linked list and counting up to the index as we visit each node the rest of the implementation involves traversing the linked list and counting up to the index as we visit each node so i'll add an else clause here and we'll start at the head so we'll say current equal self.head let's also declare a variable called position to indicate where we are in the list we can use a while loop to walk down the list our condition here is as long as the position is less than the index value so i'll say while position is less than index inside the loop we'll assign the next node to current and increment the value of position by one so current equal current dot next node position plus equal one once the position value equals the index value current refers to the node we're looking for and we can return it we'll say return current let's get rid of all this empty space there we go now back in linked list merge sort dot pi we can use this method to get at the node after we've calculated the midpoint to get the node at the midpoint of the list so we'll say mid node equal linked list dot node at index and here i'm going to do something slightly confusing i'm going to do mid minus 1. remember we're subtracting 1 here because we used size to calculate the midpoint and like the len function size will always return a value greater than the maximum index value so think of a linked list with two nodes size would return two the midpoint though and the way we're calculating the index we always start at zero which means size is going to be one greater than that so we're going to deduct one from it to get the value we want but we're using the floor division operator so it's going to round that down even more no big deal with the node at the midpoint now that we have this midnote we can actually split the list so first we're going to assign the entire linked list to a variable named left half so left half equal linked list this seems counterintuitive but make sense in a second for the right half we're going to assign a new instance of linked list so right half equal linked list this newly created list is empty but we can fix that by assigning the node that comes after the midpoint so after the midpoint of the original linked list we can assign the node that comes after that midpoint node as the head of this newly created right linked list so here we'll say right half dot head equal mid node dot node once we do that we can assign none to the next node property on mid node to effectively sever that connection and make what was the mid node now the tail node of the left linked list so i'll say mid node dot next node equal none if that's confusing here's a quick visualization of what just happened we start off with a single linked list and find the midpoint the node that comes after the node at midpoint is assigned to the head of a newly created linked list and the connection between the midpoint node and the one after is removed we now have two distinct linked lists split at the midpoint and with that we can return the two sub lists so we'll return left half and right half in the next video let's tackle our merge function in the last video we defined an implementation for the version of the split function that works on linked lists it contained a tiny bit more code than the array or list version that was expected the merge function is no different because like with the split function after we carry out a comparison operation we also need to swap references to corresponding nodes all right let's add our merge function over here at the bottom below the split functions we'll call this merge and it's going to take a left and right now because this can get complicated we're going to document this function extensively and as always we're going to start with a doc string so we'll say that this function merges two linked lists sorting by data in the nodes and it returns a new merged list remember that in the merge step we're going to compare values across two linked lists and then return a new linked list with nodes where the data is sorted so first we need to create that new linked list let's add a comment in here we'll say create a new linked list that contains nodes from let's add a new line merging left and right okay and then create the list so merged equal new linked list to this list we're going to do something unusual we're going to add a fake head this is so that when adding sorted nodes we can reduce the amount of code we have to write by not worrying about whether we're at the head of the list once we're done we can assign the first sorted node as the head and discard the fake head now this might not make sense at first but not having to worry about whether the new linked list already contains a head or not makes the code simpler we'll add another comment and a fake hand that is discarded later we'll say merged dot add zero like we've been doing so far we'll declare a variable named current to point to the head of the list set current to the head of the linked list and then current equal merged dot head next we'll get a reference to the head on each of the linked lists left and right so we'll say obtain head nodes for left and right linked lists and here's call this left head equal left dot head and right hand equal right dot head okay so with that setup out of the way let's start iterating over both lists so another comment iterate over left and right as long or we'll say until the until we reach the tail node of either and we'll do that by saying while left head or right head so this is a pattern that we've been following all along we're going to iterate until we hit the tail nodes of both lists and we'll move this pointer forward every time so that we traverse the list with every iteration if you remember the logic behind this from the earlier version once we hit the tail note of one list if there are nodes left over in the other linked list we don't need to carry out a comparison operation anymore and we can simply add those nodes to the merged list the first scenario we'll consider is if the head of the left linked list is none this means we're already past the tail of left and we can add all the nodes from the right linked list to the final merge list so here i'll say if the head node of left is none we're past the tail add the node from the right from right to merged linked list so here we'll say if left head is none current dot next node remember current points to the head of the merge list that we're going to return so here we're setting its next node reference to the head node on the right link list so we'll say right head then when we do that we'll move the right head forward to the next node so let's say right head equal right hand dot next node this terminates the loop on the next iteration let's look at a visualization to understand why let's say we start off with a linked list containing four nodes so we keep calling split on it until we have lists with just a single head single node linked lists essentially so let's focus on these two down here that we'll call left and right we haven't implemented the logic for this part yet but here we would compare the data values and see which one is less than the other so we'll assume that left's head is lesser than right's head so we'll set this as the next node in the final merge list left is now an empty length list so left dot head equals none on the next pass through the loop left head is none which is the situation we just implemented here we can go ahead and now assign right head as the next note in the merge link list we know that right is also a singly linked list here's the crucial bit when we move the pointer forward by calling next node on the right node there is no node and the right link the right linked list is also empty now which means that both left head and right head are none and either one of these would cause our loop condition to terminate so what we've done here is encoded a stopping condition for the loop so we need to document this because it can get fuzzy so right above that line of code i'll say call next on right to set loop condition to false okay there's another way we can arrive at this stopping condition and that's in the opposite direction if we start with the right head being none so here we'll say i'm going to add another comment if oops not there there if the head node of right is none we're past the tail then we'll say add the tail node from left to merged linked list and then we'll add that condition we'll say else if right head is none now remember we can enter these even if left head is none we can still go into this condition we can still enter this if statement and execute this logic because the while loop the loop condition here is an or statement so even if left head is false if this returns true because there's a value there there's a node there the loop will keep going okay now in this case we want to set the head of the left linked list as the next node on the merge list so this is simply the opposite of what we did over here we'll set current dot next node equal to left head and then we'll move so after doing that we can move the variable pointing to left head forwards which as we saw earlier is past the tail node and then results in the loop terminating so we'll say left hand equal left head dot next node and we'll add that comment here as well so we'll say call next on left to set loop condition to false because here right head is none and now we make left head none these two conditions we looked at where either the left head or right head were at the tail nodes of our respective lists those are conditions that we run into when we've reached the bottom of our split where we have single element linked lists or empty linked lists let's account for our final condition where we're evaluating a node that is neither the head nor the tail of the list and this condition we need to reach into the nodes and actually compare the data values to one another before we can decide which node to add first to the merged list so here this is an else because we've arrived at our third condition third and final and here we'll say not at either tail node obtain no data to perform comparison operations so let's get each of those data values out of the respective nodes so that we can compare it so we'll say left data equal left head dot data and write data equal right head righthead.data okay what do we do next well we compare but first let's add a comment so we'll say if data on left is less than right set current to left node and then move actually we'll add this in a second so here we'll say if left data is less than write data then current dot next node equal left head and then we'll add a comment and we'll say move left head to next node on that list so we'll say left head equal left head dot next node just as our comment says we'll check if the left data is less than the right data if it is since we want a list in ascending order we'll assign the left node to be the next node in the merged list we'll also move the left head forward to traverse down to the next node in that particular list now if left is larger than right then we want to do the opposite so we'll go back to spaces another comment if data on left is greater than right set current to right node okay so else here we assign the right head to be the next node in the merge list so current.nextnode equal right head and then comment move right head to next node so right head equal right head dot next node okay after doing that we move the right head pointer to reference the next node in the right list and finally at the end of each iteration of the while loop so not here but two spaces back right make sure we're indented at the same level as the while so we got to go yep or not the same level as the wild but the same outer scope and then there we're going to say move current to next node so current equal current dot next node okay don't worry if this is confusing as always we'll look at a visualization in just a bit so we'll wrap up this function by discarding that fake head we set earlier setting the correct node as head and returning the linked list so we'll add a comment discard fake head and set first merged node as head so here we'll say head equal merged dot head dot next node and then merged dot head equal head and finally return merged okay we wrote a lot of code here a lot of it was comments but still it's a bunch let's take a quick break in the next video we'll test this out evaluate our results and determine the runtime of our algorithm okay first things first let's test out our code now we'll keep it simple because writing a robust verify function would actually take up this entire video instead i'll leave that up to you to try as homework okay so at the very end let's create a new linked list let's add a few notes to this so l add i'm going to copy paste this so it makes it easier for me not to have to retype a bunch so i'll add 10 uh then set 2 44 15 and something like 200. okay then we'll go ahead and print l so that we can inspect this list next let's create a declare variable here so we'll call this sorted linked list and to this we're going to assign the result of calling merge sort on l and then we'll print this so sorted linked list okay since we've taken care of all the logic we know that this gets added in as nodes and then let's see what this looks like all right so hit save and then bring up the console we're going to type out python linked list underscore merge sort dot pi and then enter okay so we see that linked list we first created remember that what we add first right that eventually becomes a tail or right yeah so 10 is the tail 200 is the last one so 200 is the head because i'm calling add it simply adds each one to the head of the list so here we have 10 to 44 15 and 200 in the order we added and then the sorted linked list sorts it out so it's 2 10 15 44 and 200. look at that a sorted linked list okay so let's visualize this from the top we have a linked list containing five nodes with integers 10 2 4 15 and 200 as data respectively our merge sort function calls split on this list the split function calls size on the list and gets back 5 which makes our midpoint 2. using this midpoint we can split the list using the node at index method remember that when doing this we deduct 1 from the value of mid so we're going to split here using an index value of 1. effectively this is the same since we're starting with an index value of 0 1 means we split after node 2. we assign the entire list to left half then create a new list and assign that to right half we can assign node 3 at index value 2 as the head of the right list and remove the references between node two and node three so far so good right okay so now we're back in the merge sort function after having called split and we have two linked lists let's focus on just the left half because if you go back and look at our code we're going to call merge sort on the left linked list again this means the next thing we'll do is run through that split process since this is a linked list containing two nodes this means that split is going to return a new left and right list each with one node again we're back in the merge sort function which means that we call merge sort on this left list again since this is a single node linked list on calling merge sort on it we immediately return before we split since we hit that stopping condition so we go to the next line of code which is calling merge sort on the right list as well but again we'll get back immediately because we hit that stopping condition now that we have a left and right that we get back from calling merge sort we can call merge on them inside the merge function we start by creating a new linked list and attaching a fake head then we evaluate whether either the left or the right head is none since neither condition is true we go to the final step where we evaluate the data in each node in this case the data in the right node is less than the left node so we assign the right node as the next node in the merge link list and move the right head pointer forward in the merge link list we move our current pointer forward to this new node we've added and that completes one iteration of the loop on the next iteration righthead now points to none since that was a single node list and we can assign the rest of the left linked list which is effectively the single node over to the merge link list here we discard the fake head move the next node up to be the correct head and return the newly merged sorted linked list remember that at this point because right head and left head pointed to none are while loop terminated so in this way we recursively split and repeatedly merge sub-lists until we're back with one sorted linked list the merge sort algorithm is a powerful sorting algorithm but ultimately it doesn't really do anything complicated it just breaks the problem down until it's really simple to solve remember the technique here which we've talked about before is called divide and conquer so i like to think of merge sort in this way there's a teacher at the front of the room and she has a bunch of books that she needs to sort into alphabetical order instead of doing all that work herself she splits that pile into two and hands it to two students at the front each of those students split it into two more and hand it to the four students seated behind them as each student does this eventually a bunch of single students has two books to compare and they can sort it very easily and hand it back to the student who gave it to them in front of them who repeats the process backwards so ultimately it's really simple work is just efficiently delegated now back to our implementation here let's talk about runtime so far other than the node swapping we had to do it seems like most of our implementation is the same right in fact it is including the problems that we ran into in the list version as well so in the first implementation of merge sort we thought we had an algorithm that ran in big o of n log n but turns out we didn't why well the python list slicing operation if you remember actually takes up some amount of time amounting to big o of k a true implementation of merge sort runs in quasi-linear or log linear time that is n times log n so we almost got there but we didn't now in our implementation of merge sort on a linked list we introduce the same problem so if we go back up to the merge or rather the split function this is where it happens now swapping node references that's a constant time operation no big deal comparing values also constant time the bottleneck here like list slicing is in splitting a late list at the midpoint if we go back to our implementation you can see here that we use the node at index method which finds the node we want by traversing the list this means that every split operation incurs a big o of k cost where k here is the midpoint of the list effectively n by 2 because we have to walk down the list counting up the index until we get to that node given that overall splits take logarithmic time our split function just like the one we wrote earlier incurs a cost of big o of k log n so here we'll say it takes big o of k times log n now the merge function also like the one we wrote earlier takes linear time so that one is good that one runs in the expected amount of time so here we'll say runs in linear time and that would bring our overall run time so up at the merge sort function we can say this runs in big o of k n times log n it's okay though this is a good start and one day when we talk about constant factors and look at ways we can reduce the cost of these operations using different strategies we can come back and re-evaluate our code to improve our implementation for now as long as you understand how merge sort works conceptually what the run time and space complexities look like and where the bottlenecks are in your code that's plenty of stuff if you're interested in learning more about how we would solve this problem check out the notes in the teachers video in the next video let's wrap this course up and with that let's wrap up this course in the prerequisite to this course introduction to algorithms we learned about basic algorithms along with some concepts like recursion and big o that set the foundation for learning about implementing and evaluating algorithms in this course we learned what a data structure is and how data structures go hand in hand with algorithms we started off by exploring a data structure that many of us use in our day-to-day programming arrays or lists as they are known in python we take a peek under the hood at how arrays are created and stored and examine some of the common operations carried out on arrays these are operations that we write and execute all the time but here we took a step back and evaluated the run times of these operations and how they affect the performance of our code after that we jumped into an entirely new world where we wrote our own data structure a singly linked list admittedly linked lists aren't used much in day-to-day problem solving but it is a good data structure to start off with because it is fairly straightforward to understand and not that much different from an array we carried out the same exercise as we did on arrays in that we looked at common data operations but since this was a type we defined on our own we implemented these operations ourselves and got to examine with a fine-tooth comb how our code and the structure of the type affected the runtime of these operations the next topic we tackled was essentially worlds colliding we implemented a sorting algorithm to sort two different data structures here we got to see how all of the concepts we've learned so far algorithmic thinking time and space complexity and data structures all come together to tackle the problem of sorting data this kind of exercise is one we're going to focus on moving forward as we try to solve more real-world programming problems using different data structures and algorithms if you've stuck with this content so far keep up the great work this can be a complex topic but a really interesting one and if you take your time with it you will get a deeper understanding of programming and problem solving as always check the notes for more resources and happy coding [Music] you may have heard that algorithms and computer science are boring or frustrating they certainly can be hard to figure out especially the way some textbooks explain them but once you understand what's going on algorithms can seem fascinating clever or even magical to help further your understanding of algorithms this course is going to look at two categories sorting algorithms and searching algorithms you could argue that these are the easiest kinds of algorithms to learn but in learning how these algorithms are designed we'll cover useful concepts like recursion and divide and conquer that are used in many other sorts of algorithms and can even be used to create brand new ones by the way all the code samples i'm going to show in the videos will be in python because it's a popular language that's relatively easy to read but you don't need to know python to benefit from this course you can see the teacher's notes for each video for info on implementing these algorithms in your own favorite language our goal with this course is to give you an overview of how sorting and searching algorithms work but many algorithms have details that can be handled in different ways some of these details may distract from the big picture so we've put them in the teachers notes instead you don't need to worry about these when completing the course for the first time but if you're going back and referring to it later be sure to check the teacher's notes for additional info suppose we have a list of names it's a pretty big list a hundred thousand names long this list could be part of an address book or social media app and we need to find the locations of individual names within the list possibly to look up additional data that's connected to the name let's assume there's no existing function in our programming language to do this or that the existing function doesn't suit our purpose in some way for an unsorted list our only option may be to use linear search also known as sequential search linear search is covered in more detail elsewhere on our site check the teacher's notes for a link if you want more details you start at the first element you compare it to the value you're searching for if it's a match you return it if not you go to the next element you compare that to your target if it's a match you return it if not you go to the next element and so on through the whole list the problem with this is that you have to search the entire list every single time we're not doing anything to narrow down the search each time we have to search all of it if you're searching a big list or searching it repeatedly this amount of time can slow your whole lap down to the point that people may not want to use it anymore that's why it's much more common to use a different algorithm for searching lists binary search binary search is also covered in more detail elsewhere on our site check the teacher's notes for a link binary search does narrow the search down for us specifically it lets us get rid of half the remaining items we need to search through each time it does this by requiring that the list of values be sorted it looks at the value in the middle of the list if the value it finds is greater than the target value it ignores all values after the value it's looking at if the value it finds is less than the target value it ignores all values before the value it's looking at then it takes the set of values that remain and looks at the value in the middle of that list again if the value it finds is greater than the target value it ignores all values after the value it's looking at if the value it finds is less than the target value it ignores all values before the value it's looking at but as we mentioned binary search requires the list of values you're searching through to be sorted if the lists weren't sorted you would have no idea which half of the values to ignore because either half could contain the value you're looking for you'd have no choice but to use linear search so before we can use binary search on a list we need to be able to sort that list we'll look at how to do that next our end goal is to sort a list of names but comparing numbers is a little easier than comparing strings so we're going to start by sorting a list of numbers i'll show you how to modify our examples to sort strings at the end of the course to help make clear the importance of choosing a good sorting algorithm we're going to start with a bad one it's called bogosort basically bogosort just randomizes the order of the list repeatedly until it's sorted here's a python code file where we're going to implement bogosort it's not important to understand this code here at the top although we'll have info on it in the teachers notes if you really want it all you need to know is that it takes the name of a file that we pass on the command line loads it and returns a python list which is just like an array in other languages containing all the numbers that it read from the file let me have the program print out the list of numbers it loads so you can see it we'll call the print method and we'll pass it the list of numbers save that let's run it real quick with python bogosort.pi oh whoops and we need to provide it the name of the file here on the command line that we're going to load so it's in the numbers directory a slash separates the directory name from the file name five dot text and there's our list of numbers that was loaded from the file okay let me delete that print statement and then we'll move on bogo sort just randomly rearranges the list of values over and over so the first thing we're going to need is a function to detect when the list is sorted we'll write an is sorted function that takes a list of values as a parameter it'll return true if the list passed in is sorted or false if it isn't we'll loop through the numeric index of each value in the list from 0 to 1 less than the length of the list like many languages python list indexes begin at 0 so a list with a length of 5 has indexes going from 0 through 4. if the list is sorted then every value in it will be less than the one that comes after it so we test to see whether the current item is greater than the one that follows it if it is it means the whole list is not sorted so we can return false if we get down here it means the loop completed without finding any unsorted values python uses white space to mark code blocks so unindenting the code like this marks the end of the loop since all the values are sorted we can return true now we need to write the function that will actually do the so-called sorting the bogosort function will also take the list of values it's working with as a parameter we'll call our is sorted function to test whether the list is sorted we'll keep looping until is sorted returns true python has a ready-made function that randomizes the order of elements in the list since the list isn't sorted we'll call that function here and since this is inside the loop it'll be randomized over and over until our is sorted function returns true if the loop exits it means is sorted returned true and the list is sorted so we can now return the sorted list finally we need to call our bogosort function pass it the list we loaded from the file and print the sorted list it returns okay let's save this and try running it we do so with python the name of the script bogosort.pi and the name of the file we're going to run it on numbers directory5.txt it looks like it's sorting our list successfully but how efficient is this let's add some code to track the number of times it attempts to sort the list up here at the top of the bogus sort function we'll add a variable to track the number of attempts it's made we'll name it attempts and we'll set its initial value to zero since we haven't made any attempts yet with each pass through the loop we'll print the current number of attempts and then here at the end of the loop after attempting to shuffle the values we'll add one to the count of attempts let's save this and let's try running it again a couple times in the console i can just press the up arrow to bring up the previous command and re-run it so it looks like this first run to sort this five element list took 363 attempts let's try it again this time it only took 91 attempts we're simply randomizing the list with each attempt so each run of the program takes a random number of attempts now let's try this same program with a larger number of items python bogo sort numbers i have a list of eight items set up here in this other file this time it takes 11 000 attempts only 487 this time and this time thirteen thousand you can see that the trend is increasing steadily the problem with bogosort is that it doesn't make any progress toward a solution with each pass it could generate a list where just one value is out of order but then on the next attempt it could generate a list where all the elements are out of order again stumbling on a solution is literally a matter of luck and for lists with more than a few items it might never happen up next we'll look at selection sort it's a sorting algorithm that's still slow but it's better than bogo's sort previously we showed you bogo sort a terrible sorting algorithm that basically randomizes the order of a list and then checks to see if it happens to be sorted the problem with bogo's sort is that it doesn't get any closer to a solution with each operation and so with lists that have more than a few items it'll probably never finish sorting them now we're going to look at an algorithm named selection sort it's still slow but at least each pass through the list brings it a little closer to completion our implementation of selection sort is going to use two arrays an unsorted array and a sorted one some versions move values around within just one array but we're using two arrays to keep the code simpler the sorted list starts out empty but we'll be moving values from the unsorted list to the sorted list one at a time with each pass we'll look through each of the values in the unsorted array find the smallest one and move that to the end of the sorted array we'll start with the first value in the unsorted array and say that's the minimum or smallest value we've seen so far then we'll look at the next value and see if that's smaller than the current minimum if it is we'll mark that as the new minimum then we'll move to the next value and compare that to the minimum again if it's smaller that becomes the new minimum we continue that way until we reach the end of the list at that point we know whatever value we have marked as the minimum is the smallest value in the whole list now here's the part that makes selection sort better than bogo sort we then move that minimum value from the unsorted list to the end of the sorted list the minimum value isn't part of the unsorted list anymore so we don't have to waste time looking at it anymore all our remaining comparisons will be on the remaining values in the unsorted list then we start the process over at this point our list consists of the numbers 8 5 4 and 7. our first minimum is 8. we start by comparing the minimum to five five is smaller than eight so five becomes the new minimum then we compare five to four and four becomes the new minimum four is not smaller than seven though so four remains the minimum four gets moved to the end of the sorted array becoming its second element the process repeats again eight is the first minimum but five is smaller so that becomes the minimum seven is larger so five stays is the minimum and five is what gets moved over to the sort of array and so on until there are no more items left in the unsorted array and all we have left is the sorted array so that's how selection sort works in general now let's do an actual implementation of it this code here at the top is the same as we saw in the bogo sword example it just loads a python list of numbers from a file let's implement the function that will do our selection sort we're going to pass in our python list containing all the unsorted numbers we'll create an empty list that will hold all our sorted values we'll loop once for each value in the list we call a function named index submin which we're going to write in just a minute that finds the minimum value in the unsorted list and returns its index then we call the pop method on the list and pass it the index of the minimum value pop will remove that item from the list and return it we then add that value to the end of the sorted list going up a level of indentation signals to python that we're ending the loop after the loop finishes we return the sorted list now we need to write the function that picks out the minimum value we pass in the list we're going to search we mark the first value in the list as the minimum it may or may not be the actual minimum but it's the smallest we've seen on this pass through the list it's also the only value we've seen on this pass through the list so far now we loop through the remaining values in the list after the first we test whether the value we're currently looking at is less than the previously recorded minimum if it is then we set the current index as the new index of the minimum value after we've looped through all the values we return the index of the smallest value we found lastly we need to actually run our selection sort method and print the sorted list it returns let's save this and now let's try running it we run the python command and pass it the name of our script selectionsort.pi in the numbers directory i've saved several data files filled with random numbers one on each line five dot text has five lines eight dot text has eight lines and to help us really measure the speed of our algorithms ten thousand dot text has ten thousand lines i've even created a file with a million numbers our script takes the path of a file to load as an argument so i'll give it the path of our file with five numbers numbers slash five dot text the script runs reads the numbers in the file into a list calls our selection sort method with that list and then prints the sorted list let me add a couple print statements within the selection sort function so you can watch the sort happening don't worry about figuring out the python formatting string that i use it's just there to keep the two lists neatly aligned i'll add the first print statement before the loop runs at all i'll have it print out the unsorted list and the sorted list i'll add an identical print statement within the loop so we can watch values moving from the unsorted list to the sorted list let's save this and we'll try running the same command again the output looks like this you can see the unsorted list on the left and the sorted list on the right initially the sorted list is empty on the first pass it selects the lowest number 1 and moves it to the sorted list then it moves the next lowest number over four this repeats until all the numbers have been moved to the sorted list i have another file with eight different numbers in it let's try our program with that python selection sort dot pi numbers 8.text you can see the same process at work here notice that this file had some duplicate values too that's okay though because the index of min function only updates the minimum index if the current value is less than the previous minimum if they're equal it just keeps the first minimum value it found and waits to move the duplicate value over until the next pass through the list so now we know that the selection sort algorithm works but the data sets we've been giving it sort are tiny in the real world algorithms need to work with data sets of tens of thousands or even millions of items and do it fast i have another file with ten thousand random numbers in it let's see if selection sort can handle that if i run this as it is now though it'll print out a lot of debug info as it sorts the list so first i'm going to go into the program and remove the two print statements in the selection sort function now let's run the program again on the dot text file and see how long it takes python selection sort dot pi numbers ten thousand dot text one one thousand two one thousand three one four one thousand five one thousand six one thousand seven one thousand eight one thousand nine one thousand ten one thousand eleven thousand twelve thousand thirteen thousand and it prints out all ten thousand of those numbers neatly sorted it took a little bit though how long well counting the time off vocally isn't very precise and other programs running on the system can skew the amount of time your program takes to complete let me show you a unix command that's available here in workspaces which can help you type time followed by a space and then the command you want to run so this command by itself will print the contents of our 5.txt file cat as in concatenate numbers 5.text and this command will do the same thing but it'll also keep track of how long it takes the cat program to complete and report the result time cat numbers five dot text the real row in the results is the actual amount of time for when the program started running to when it completed we can see it finished in a fraction of a second but as we said other programs running on the system can take cpu resources in which case your program will seem slower than it is so we generally want to ignore the real result the user result is the amount of time the cpu actually spent running the program code so this is the total amount of time the code inside the cat program took to run the sys result is the amount of time the cpu spent running linux kernel calls that your code made the linux kernel is responsible for things like network communications and reading files so loading the 5.txt file is probably included in this result in evaluating code's performance we're generally going to want to add together the user and sys results but cad is a very simple program let's try running the time command on our code and see if we get a more interesting result time python selection sort dot pi numbers ten thousand dot text this takes much longer to complete nearly 12 seconds according to the real time measurement but as we said the real result is often skewed so let's disregard that if we add the user and cis runtimes together we get about 6 seconds the time for the program to complete will vary a little bit each time you run it but if it's doing the same operations it usually won't change more than a fraction of a second if i run our selection sort script on the same file you can see it completes in roughly the same time now let's try it on another file with 1 million numbers time python selection sort dot pi numbers 1 million dot text how long does this one take i don't even know while designing this course i tried running this command and my workspace connection timed out before it completed so we'll just say that selection sort takes a very very long time to sort a million numbers if we're going to sort a list that big we're going to need a faster algorithm we'll look into alternative sorting algorithms shortly the next two sorting algorithms we look at will rely on recursion which is the ability of a function to call itself so before we move on we need to show you how recursion works recursive functions can be very tricky to understand imagine a row of dominoes stood on end where one domino falling over causes the next domino to fall over which causes the next domino to fall over causing a chain reaction it's kind of like that let's suppose we need to write a function that adds together all the numbers in an array or in the case of python a list normally we'd probably use a loop for this sort of operation the function takes a list of the numbers we want to add the total starts at zero we loop over every number contained in the list and we add the current number to the total once we're done looping we return the accumulated total if we call this sum function with a list of numbers it'll return the total when we run this program it'll print out that return value 19. let's try it real quick python recursion.pi oh whoops mustn't forget to save my work here and run it and we see the result 19. to demonstrate how recursion works let's revise the sum function to use recursion instead note that recursion is not the most efficient way to add a list of numbers together but this is a good problem to use to demonstrate recursion because it's so simple one thing before i show you the recursive version though this example is going to use the python slice syntax so i need to take a moment to explain that for those not familiar with it a slice is a way to get a series of values from a list let's load up the python repel or read evaluate print loop so i can demonstrate we'll start by creating a list of numbers to work with numbers equals a list with 0 1 2 3 and 4 containing those numbers like arrays in most other languages python list indexes start at 0 so numbers 1 will actually get the second item from the list with slice notation i can actually get several items back it looks just like accessing an individual index of a list but then i type a colon followed by the list index that i want up to but not including so numbers 1 colon 4 would get us the second up to but not including the fifth items from the list that is it'll get us the second through the fourth items now i know what you're thinking and you're right that up to but not including rule is a little counterintuitive but you can just forget all about it for now because we won't be using a second index with any of our python slice operations in this course here's what we will be using when you leave the second index off of a python slice it gives you the items from the first index up through the end of the list wherever that is so numbers 1 colon with no index following it will give us items from the second index up through the end of the list numbers 2 colon will give us items from the third index up to the end of the list you can also leave the first index off to get everything from the beginning of the list numbers colon 3 will get us everything from the beginning of the list up to but not including the third index it's also worth noting that if you take a list with only one item and you try to get everything from the non-existent second item onwards the result will be an empty list so if i create a list with just one item in it and i try to access from the second element onwards the second element doesn't exist so the result will be an empty list don't worry too much about remembering python slice syntax it's not an essential part of sorting algorithms or recursion i'm only explaining it to help you read the code you're about to see so i'm going to exit the python rebel now that we've covered recursion we can convert our sum function to a recursive function it'll take the list of numbers to add just like before now here's the recursive part we'll have the sum function call itself we use slice notation to pass the entire list of numbers except the first one then we add the first number in the list to the result of the recursive function call and return the result so if we call sum with four numbers first it'll call itself with the remaining three numbers that call to sum will then call itself with the remaining two numbers and so on but if we save this and try to run it pythonrecursion.pi well first we get a syntax error it looks like i accidentally indented something i shouldn't have so let me go fix that real quick there we go that's suggested to python that there was a loop or something there when there wasn't so let's go back to the terminal and try running this again there we go now we're getting the error i was expecting recursion error maximum recursion depth exceeded this happens because some gets into an infinite loop it keeps calling itself over and over the reason is that when we get down to a list of just one element and we take a slice from the non-existent second element to the end the result is an empty list that empty list gets passed to the recursive call to sum which passes an empty list in its recursive call to sum and so on until the python interpreter detects too many recursive calls and shuts the program down what we need is to add a base case to this recursive function a condition where the recursion stops this will keep it from getting into an infinite loop with the sum function the base case is when there are no elements left in the list in that case there is nothing left to add and the recursion can stop a base case is the alternative to a recursive case a condition where recursion should occur for the sum function the recursive case is when there are still elements in the list to add together let's add a base case at the top of the function python treats a list that contains one or more values as a true value and it treats a list containing no values as a false value so we'll add an if statement that says if there are no numbers in the list we should return a sum of zero that way the function will exit immediately without making any further recursive calls to itself we'll leave the code for the recursive case unchanged if there are still numbers in the list the function will call itself with any numbers after the first then add the return value to the first number in the list let's save this and try running it again python recursion dot pi output the sum of the numbers in the list 19 but it's still not really clear how this worked let's add a couple print statements that will show us what it's doing we'll show the recursive call to sum and what it's being called with we'll also add a call to print right before we return showing which of the calls the sum is returning and what it's returning let me save this and resize the console a bit and let's try running it again python recursion.pi since the print calls are inside the sum function the first call to sum 1279 isn't shown only the recursive calls are this first call to sum ignores the first item in the list 1 and calls itself recursively it passes the remaining items from the list 2 7 and 9. that call to sum again ignores the first item in the list it receives 2 and again calls itself recursively it passes the remaining items in the list 7 and 9. that call ignores the 7 and calls itself with a 9 and the last call shown here ignores the 9 and calls itself with an empty list at this point none of our recursive calls to sum have returned yet each of them is waiting on the recursive call it made to sum to complete python and other programming languages use something called a call stack to keep track of this series of function calls each function call is added to the stack along with the place in the code that it needs to return when it completes but now the empty list triggers the base case causing the recursion to end and the sum function to return zero that zero value is returned to its caller the caller adds the zero to the first and only value in its list nine the result is nine that nine value gets returned to the caller which adds it to the first value in the list it received seven the result is sixteen that sixteen value is returned to the caller which adds it to the first value in the list it received two the result is 18. that 18 value is returned to the caller which adds it to the first value in the list it received one the result is 19. that 19 value is returned to the caller which is not the sum function recursively calling itself but our main program this is our final result which gets printed it's the same result we got from the loop-based version of our program the end we don't want the print statements in our final version of the program so let me just delete those real quick and there you have it a very simple recursive function well the function is simple but as you can see the flow of control is very complex don't worry if you didn't understand every detail here because we won't be using this particular example again there are two fundamental mechanisms you need to remember a recursive function needs a recursive case that causes it to call itself and it also needs to eventually reach a base case that causes the recursion to stop you've seen bogo sort which doesn't make any progress towards sorting a list with each pass either it's entirely sorted or it isn't you've seen selection sort which moves one value over to a sorted list with each pass so that it has fewer items to compare each time now let's look at an algorithm that speeds up the process further by further reducing the number of comparisons it makes it's called quick sort here's some python code where we'll implement quick sort again you can ignore these lines at the top we're just using them to load a file full of numbers into a list the quick sort algorithm relies on recursion to implement it we'll write a recursive function we'll accept the list of numbers to sort as a parameter quicksort is recursive because it keeps calling itself with smaller and smaller subsets of the list you're trying to sort we're going to need a base case where the recursion stops so it doesn't enter an infinite loop lists that are empty don't need to be sorted and lists with just one element don't need to be sorted either in both cases there's nothing to flip around so we'll make that our base case if there are zero or one elements in the list passed to the quick sort function we'll return the unaltered list to the caller lastly we need to call our quick sort function with our list of numbers and print the list it returns that takes care of our base case now we need a recursive case we're going to rely on a technique that's common in algorithm design called divide and conquer basically we're going to take our problem and split it into smaller and smaller problems until they're easy to solve in this case that means taking our list and splitting it into smaller lists viewers a suggestion the process i'm about to describe is complex there's just no way around it if you're having trouble following along remember the video playback controls feel free to slow the play back down rewind or pause the video as needed after you watch this the first time you may also find it helpful to rewind and make your own diagram of the process as we go okay ready here goes suppose we load the numbers from our 8.txt file into a list how do we divide it it would probably be smart to have our quicksort function divide the list in a way that brings it closer to being sorted let's pick an item from the list we'll just pick the first item for now four we'll call this value we've picked the pivot like the center of a seesaw on a playground we'll break the list into two sublists the first sub-list will contain all the items in the original list that are smaller than the pivot the second sub-list will contain all the items in the original list that are greater than the pivot the sub list of values less than and greater than the pivot aren't sorted but what if they were you could just join the sub lists and the pivot all together into one list and the whole thing would be sorted so how do we sort the sublist we call our quick sort function recursively on them this may seem like magic but it's not it's the divide and conquer algorithm design technique at work if our quick sort function works on the big list then it will work on the smaller list too for our first sub list we take the first item it's the pivot again that's three we break the sub list into two sub lists one with everything less than the pivot and one with everything greater than the pivot notice that there's a value equal to the pivot that gets put into the less than sub-list our finished quicksort function is actually going to put everything that's less than or equal to the pivot in the first sub-list but i don't want to say less than or equal to over and over so i'm just referring to it as the less than pivot sub-list also notice that there are no values greater than the pivot that's okay when we join the sub-lists back together that just means nothing will be in the return list after the pivot we still have one sub list that's more than one element long so we call our quick sort function on that too you and i can see that it's already sorted but the computer doesn't know that so it'll call it anyway just in case it picks the first element 2 as a pivot there are no elements less than the pivot and only one element greater than the pivot that's it for the recursive case we've finally hit the base case for our quick sort function it'll be called on both the empty list of elements less than the pivot and the one item list of elements greater than the pivot but both of these lists will be returned as they are because there's nothing to sort so now at the level of the call stack above this the return sorted lists are used in place of the unsorted sub-list that's less than the pivot and the unsorted sub-list that's greater than the pivot these are joined together into one sorted list remember that any empty lists get discarded then at the level of the call stack above that the return sorted lists are used in place of the unsorted sub-lists there again they were already sorted but the quick sort method was called on them anyway just in case the sub-lists are joined together into one sorted list at the level of the call stack above that the return sorted list is used in place of the unsorted sub-list that's less than the pivot so now everything that's less than or equal to the pivot is sorted now we call quick sort on the unsorted sub-list that's greater than the pivot and the process repeats for that sub-list we pick the first element six is the pivot we split the sub-list into sub-lists of elements that are less than and greater than this pivot and we recursively call the quicksort function until those sub-lists are sorted eventually a sorted sub-list is returned to our first quick sort function call we combine the sub-list that's less than or equal to the pivot the pivot itself and the sub-list that's greater than the pivot into a single list and because we recursively sorted the sub lists the whole list is sorted so that's how the quick sort function is going to work in the next video we'll show you the actual code quicksort works by picking a pivot value then splitting the full list into two sub-lists the first sub-list has all the values less than or equal to the pivot and the second sub-list has all the values greater than the pivot the quick sort function recursively calls itself to sort these sub-lists and then to sort the sub-lists of those sub-lists until the full list is sorted now it's time to actually implement this in code we already have the base case written any list passed in that consists of 0 or 1 values will be returned as is because there's nothing to sort now we need to create a list that will hold all the values less than the pivot that list will be empty at first we do the same for values greater than the pivot next we need to choose the pivot value for now we just grab the first item from the list then we loop through all the items in the list following the pivot we check to see whether the current value is less than or equal to the pivot if it is we copy it to the sub-list of values less than the pivot otherwise the current value must be greater than the pivot so we copy it to the other list this last line is where the recursive magic happens we call quick sort recursively on the sub-list that's less than the pivot we do the same for the sub-list that's greater than the pivot those two calls will return sorted lists so we combine the sort of values less than the pivot the pivot itself and the sort of values greater than the pivot that gives us a complete sorted list which we return this took a lot of prep work are you ready let's try running it python quick sort dot pi numbers 8.text it outputs our sorted list i don't know about you but this whole thing still seems a little too magical to me let's add a couple print statements to the program so we can see what it's doing first we'll add a print statement right before the first call to the quick sort function so we can see the unsorted list we'll also add a print right within the quick sort function right before the recursive calls again this string formatting code is just to keep the info aligned in columns let's try running this again and now you can see our new debug output each time quicksort goes to call itself recursively it prints out the pivot as well as the sub list of items less than or equal to the pivot if any and the sub list of items greater than the pivot if any you can see that first it sorts the sub list of items less than the pivot at the top level it goes through a couple levels of recursion to do that there are actually additional levels of recursion but they're from calls to quick sort with a list of 0 or 1 elements and those calls return before the print statement is reached then it starts sorting the second sub list from the top level with items greater than the original pivot you can see a couple levels of recursion for that sort as well finally when both sublists are recursively sorted the original call to the quicksort function returns and we get the sorted list back so we know that it works the next question is how well does it work let's go back to our file of ten thousand numbers and see if it can sort those first though i'm going to remove our two debug calls to print so it doesn't produce unreadable output a quick note if you try running this on a file with a lot of repeated values it's possible you'll get a runtime error maximum recursion depth exceeded if you do see the teacher's notes for a possible solution now let's try running our quick sort program against the ten thousand dot text file python quick sort dot pi numbers 10 000 dot text there we go and it seems pretty fast but how fast exactly let's run it with the time command to see how long it takes time python quick sort dot pi numbers 10 000.text remember we need to ignore the real result and add the user and sys results it took less than a second of cpu time to sort 10 000 numbers with quicksort remember that selection sort took about 13 seconds that's a pretty substantial improvement and with a million numbers selection sort took so long that it never even finished successfully let's see if quicksort performs any better time python quick sort dot pi numbers 1 million dot text not only did quicksort sort a million numbers successfully it only took about 11 seconds of cpu time quicksort is clearly much much faster than selection sort how much faster that's something we'll discuss in a later video what we've shown you here is just one way to implement quicksort although the basic algorithm is always the same the details can vary like how you pick the pivot see the teacher's notes for more details let's review another sorting algorithm merge sort so that we can compare it with quick sort merge sort is already covered elsewhere on the site so we won't go into as much detail about it but we'll have more info in the teacher's notes if you want it both quicksort and merge sword are recursive the difference between them is in the sorting mechanism itself whereas quicksort sorts a list into two sub-lists that are less than or greater than a pivot value merge sort simply splits the list in half recursively and then sorts the halves as it merges them back together that's why it's called merge sort you may recognize this code at the top by now it just loads a file full of numbers into a list let's define a recursive merge sort function as usual it'll take the list or sub-list that we want it to sort our base case is the same as with quicksort if the list has zero or one values there's nothing to sort so we return it as is if we didn't return it means we're in the recursive case so first we need to split the list in half we need to know the index we should split on so we get the length of the list and divide it by two so for example if there are eight items in the list we'll want an index of four but what if there were an odd number of items in the list like seven we can't have an index of 3.5 so we'll need to round down in that case since we're working in python currently we can take advantage of a special python operator that divides and rounds the result down the floor division operator it consists of a double slash now we'll use the python slice syntax to get the left half of the list we'll pass that list to a recursive call to the merge sort function we'll also use slice syntax to get the right half of the list and pass that to merge sort as well now we need to merge the two halves together and sort them as we do it we'll create a list to hold the sorted values and now we get to the complicated part merging the two halves together and sorted them as we do it we'll be moving from left to right through the left half of the list copying values over to the sorted values list as we go this left index variable will help us keep track of our position at the same time we'll also be moving from left to right through the right half of the list and copying values over so we need a separate write index variable to track that position as well we'll keep looping until we've processed all of the values in both halves of the list we're looking to copy over the lowest values first so first we test whether the current value on the left side is less than the value on the right side if the left side value is less that's what we'll copy over to the sorted list and then we'll move to the next value in the left half of the list otherwise the current value from the right half must have been lower so we'll copy that value to the sorted list instead and then we'll move to the next value in the right half of the list that ends the loop at this point one of the two unsorted halves still has a value remaining and the other is empty we won't waste time checking which is which we'll just copy the remainder of both lists over to the sorted list the one with the value left will add that value and the empty one will add nothing all the numbers from both halves should now be copied to the sorted list so we can return it finally we need to kick the whole process off we'll call the merge sort function with the list of numbers we loaded and print the result let's save this and we'll try it out on our file with eight numbers python merge sort dot pi numbers eight dot text and it prints out the sorted list but again this seems pretty magical let's add some print statements to get some insight into what it's doing first we'll print the unsorted list so we can refer to it we'll add a print statement right before we call the merge sort function for the first time then we'll add another print statement within the merge sort function right after the recursive calls this will show us the sorted left half and right half that it's returning again don't worry about the fancy python formatting string it just keeps the values neatly aligned let me resize my console clear the screen and then we'll try running this again what we're seeing are the values being returned from the recursive merge sort function calls not the original calls to merge sort so what you see here is after we reach the base case with a list that's only one item in length and the recursive calls start returning the original list gets split into two unsorted halves four six three and two and nine seven three and five the first half gets split in half again four and six and three and two and each of those halves is halved again into single element lists there's nothing to sort in the single element list so they're returned from the merge sort function as is those single element lists get merged into two sub lists and sorted as they do so the four and six sub-list looks the same after sorting as it did before sorting but the three and the two get sorted as they're combined into a sub-list the new order is two three the order is shifted again when those two sub-lists get combined back into a single list two three four six then we recursively sort the right half of the original list nine seven three five it gets split in half again nine seven and three five and each of those halves get broken into single element lists there's nothing to sort there so the single element lists are returned as is the first two are sorted as they're merged seven nine and so are the second three five and then those two sub lists get sorted as they're combined into another sub list three five seven nine and finally everything is sorted as it's merged back into the full sorted list two three three four five six seven nine that's how merge sort works on a list of eight numbers let's see if it works on a bigger list first i'll remove the two print statements so we don't get an overwhelming amount of debug output then i'll run it on a list of ten thousand items python merge sort dot pi numbers ten thousand dot text not only did it work it was pretty fast but which is faster merge sort or quick sort we'll look at that next i've removed the call to print that displays the sorted list at the end of our selection sort quick sort and merge sort scripts that way it'll still run the sort but the output won't get in the way of our comparing runtimes let's try running each of these scripts and see how long it takes time python selection sort we'll do that one first numbers 10 000 dot text we combine the user and sys results and that gives us about six seconds now let's try quick sort time python quick sort dot pi numbers ten thousand dot text much faster less than a second and finally time python merge sort dot pi numbers ten thousand dot text a little longer but far less than a second so even on a list with just 10 000 numbers selection sort takes many times as long as quicksort and merge sort and remember i ran the selection sort script on a file with a million numbers and it took so long that my workspace timed out before it completed it looks like selection sort is out of the running as a viable sorting algorithm it may be easy to understand and implement but it's just too slow to handle the huge data sets that are out in the real world now let's try quicksort and merge sort on our file with a million numbers and see how they compare there time python quicksort dot pi numbers million dot text looks like it took about 11 seconds of cpu time now let's try merge sort time python merge sort dot pi numbers 1 million dot text that took about 15 seconds of cpu time it looks like quicksort is marginally faster than merge sort on this sample data we had to learn a lot of details for each algorithm we've covered in this course developers who need to implement their own algorithms often need to choose an algorithm for each and every problem they need to solve and they often need to discuss their decisions with other developers can you imagine needing to describe all the algorithms in this same level of detail all the time you'd spend all your time in meetings rather than programming that's why big o notation was created as a way of quickly describing how an algorithm performs as the data set it's working on increases in size big o notation lets you quickly compare several algorithms to choose the best one for your problem the algorithms we've discussed in this course are very well known some job interviewers are going to expect you to know their big o run times so let's look at them remember that the n in big o notation refers to the number of elements you're operating on with selection sort you need to check each item in the list to see if it's the lowest so you can move it over to the sorted list so that's in operations suppose you're doing selection sort on a list of five items and in this case would be five so that's five operations before you can move an item to the sorted list but with selection sort you have to loop over the entire list for each item you want to move there are five items in the list and you have to do five comparisons to move each one so it's more like 5 times 5 operations or if we replace 5 with n it's n times n or n squared but wait you might say half of that 5 by 5 grid of operations is missing because we're testing one fewer item in the unsorted list with each pass so isn't it more like one half times n times n and this is true we're not doing a full n squared operations but remember in big o notation as the value of n gets really big constants like one half become insignificant and so we discard them the big o runtime of selection sword is widely recognized as being o n squared quicksort requires one operation for each element of the list it's sorting it needs to select a pivot first and then it needs to sort elements into lists that are less than or greater than the pivot so that's n operations to put that another way if you have a list of eight items then n is eight so it will take eight operations to split the list around the pivot but of course the list isn't sorted after splitting it around the pivot just once you have to repeat those eight operations several times in the best case you'll pick a pivot that's right in the middle of the list so that you're dividing the list exactly in half then you keep dividing the list in half until you have a list with a length of one the number of times you need to divide n in half until you reach one is expressed as log n so you need to repeat n sorting operations log n times that leaves us with the best case run time for quick sort of o n log n but that's the best case what about the worst case well if you pick the wrong pivot you won't be dividing the list exactly in half if you pick a really bad pivot the next recursive call to quicksort will only reduce the list length by one since our quicksort function simply picks the first item to use as a pivot we can make it pick the worst possible pivot repeatedly simply by giving it a list that's sorted in reverse order if we pick the worst possible pivot every time we'll have to split the list once for every item it contains and then do end sorting operations on it you already know another sorting algorithm that only manages to reduce the list by one element with each pass selection sort selection sort has a runtime of o n squared and in the worst case that's the run time for quicksort as well so which do we consider when trying to decide whether to use quicksort the best case or the worst case well as long as your implementation doesn't just pick the first item as a pivot which we did so we could demonstrate this issue it turns out that on average quicksort performs closer to the best case many quicksort implementations accomplish this simply by picking a pivot at random on each recursive loop here we are sorting our reverse sorted data again but this time we pick pivots at random which reduces the number of recursive operations needed sure random pivots sometimes give you the best case and sometimes you'll randomly get the worst case but it all averages out over multiple calls to the quick sort function now with merge sort there's no pivot to pick your list of n items always gets divided in half log n times that means merged sort always has a big o runtime of o and log in contrast that with quicksort which only has a runtime of o and log n in the best case in the worst case quick sorts runtime is o n squared and yet out in the real world quicksort is more commonly used than merge sort now why is that if quicksort's big o runtime can sometimes be worse than merge sorts this is one of those situations where big o notation doesn't tell you the whole story all big o can tell you is the number of times an operation is performed it doesn't describe how long that operation takes and the operation mergesor performs repeatedly takes longer than the operation quicksort performs repeatedly big-o is a useful tool for quickly describing how the runtime of an algorithm increases is the data set it's operating on gets really really big but you can't always choose between two algorithms based just on their big o runtimes sometimes there's additional info you need to know about an algorithm to make a good decision now that we can sort a list of items we're well on our way to being able to search a list efficiently as well we'll look at how to do that in the next stage [Music] now that we've covered sorting algorithms the groundwork has been laid to talk about searching algorithms if you need to search through an unsorted list of items binary search isn't an option because you have no idea which half of the list contains the item you're looking for your only real option is to start at the beginning and compare each item in the list to your target value one at a time until you find the value you're looking for this algorithm is called linear search or sequential search because the search proceeds in a straight line or sequence even though linear search is inefficient searching for just one name will happen so fast that we won't be able to tell anything useful about the algorithm's runtime so let's suppose we had a hundred different names and that we needed to know where they appear in a list of unsorted names here's some code that demonstrates as usual this code at the top isn't relevant to the search algorithm it's just like the code that loaded a list of numbers from a file in the previous stage but this code calls a different function load strings that loads a list of strings in if you want the load strings python code we'll have it for you in the teacher's notes here's a separate hard-coded list containing the 100 names we're going to search for we'll loop through each name in this list and pass it to our search function to get the index within the full list where it appears now let's implement the search function compared to the sorting algorithms this is going to be short the index of item function takes the python list you want to search through and a single target value you want to search for now we need to loop over each item in the list the range function gives us a range of numbers from its first argument up to but not including its second argument so if our list had a length of 5 this would loop over the indexes 0 through 4. we test whether the list item at the current index matches our target if it does then we return the index of the current item this will exit the index of item function without looping over the remaining items in the list if we reach the end of the loop without finding the target value that means it wasn't in the list so instead of returning an index we return the special python value none which indicates the absence of a value other languages have similar values like nil or null but if yours doesn't you might have to return a value that would otherwise be impossible like an index of negative 1. now let's call our new search function we start by looping over the list of 100 values we're looking for we're using the values themselves this time not their indexes within the list so there's no need to mess with python's range function here's the actual call to the index of item function we pass it the full list of names that we loaded from the file plus the name we want to search for within that list then we store the index it returns in a variable and lastly we print the index we get back from the index of item function let's save this and go to our console and see if it works python linear search dot pi names unsorted dot text and it'll print out the list of indexes for each name i actually set it up so that the last two items in the list of names we're going to search for corresponded to the first and last name within the file so if we open up our unsorted.txt file we'll see mary rosenberger is the first name and alonso viviano is the last name and those are the last two values in our list of names we're searching for so it returned an index of zero for that second to last name and you can see that name here on line one of the file the line numbering starts at one and the python list indexes start at zero so that makes sense and for the last name it returned an index of 109873 and you can see that name here on line 109 874 so we can see that it's returning the correct indexes but right now we're just searching for a hundred different names in a list of one hundred thousand names in the real world we're going to be looking for many more names than that within much bigger lists than that can we do this any faster yes but we'll need to use the binary search algorithm and for that to work we need to sort our list of strings we'll do that in the next video before we can use the binary search algorithm on our list of names we need to sort it let's do that now we need to load our unsorted list of names from a file sorted and write the sorted names back out to a new file again this code at the top just loads a file full of strings into a list we'll use our quick sort method to sort the list of names its code is completely unchanged from when you saw it in the previous stage we just call our quick sort function on the list of names loaded from the file and save the list to a variable then we loop through each name in the sorted list and we print that name that's all there is to it let's save this script and try running it python quicksort strings stop pi and we'll pass it the names unsorted.text file let me resize the console window here a little bit that prints the sorted list of names out to the terminal but we need it in a file so we'll do what's called a redirect of the program's output we'll run the same command as before but at the end we'll put a greater than sign followed by the path to a file that we want the program output written to names sorted dot text redirecting works not only on linux based systems like workspaces but also on macs and even on windows machines you just need to be careful because if you redirect to an existing file its contents will be overwritten without asking you let me refresh the list of files in the sidebar and you'll see that we now have a new sorted dot text file in the names directory it's the same number of lines as the unsorted dot text file but all the names are sorted now now we can load this file of sorted names into a list and we'll be able to use that list with the binary search algorithm we'll see how to do that next now that we have our list of names sorted we can use the binary search algorithm on it let's see if we can use it to speed up our search for the indexes of 100 names binary search keeps narrowing down the list until it has the value it's looking for it's faster than linear search because it discards half the potential matches each time our code here at the top of our binary search script is unchanged from the previous scripts we just call the load strings function to load our 100 000 sorted names from a file here we've hard coded the list of 100 names we're going to search for again it's identical to the list from the linear search script except that i've again changed the last two names to correspond to the names on the first and last lines of the file we'll be loading now let's write the function that will implement our binary search algorithm like the linear search function before it'll take two arguments the first is the list we're going to search through and the second is the target value we'll be searching for again the binary search function will return the index it found the value at or the special value none if it wasn't found binary search is faster than a linear search because it discards half the values it has to search through each time to do this it needs to keep track of a range that it still needs to search through to start that range is going to include the full list the first variable will track the lowest index in the range we're searching to start it's going to be 0 the first index in the full list likewise the last variable will track the highest index in the range we're searching to start we'll set it to the highest index in the full list if the first and last variables are equal then it means the size of the search range has shrunk to zero and there is no match until that happens though we'll keep looping to continue the search we want to divide the list of potential matches in half each time to do that we need to check the value that's in the middle of the range we're searching in we add the indexes in the first and last variables then divide by two to get their average we might get a fractional number which can't be used as a list index so we also round down using python's double slash floor division operator all this will give us the index of the list element that's the midpoint of the range we're searching we store that in the midpoint variable whoops looks like my indentation got mixed up there let me fix that real quick there we go now we test whether the list element at the midpoint matches the target value if it does we return the midpoint index without looping any further our search is complete otherwise if the midpoint element's value is less than the target value then we know that our target value can't be at the midpoint or any index prior to that so we move the new start of our search range to just after the old midpoint otherwise the midpoint element's value must have been greater than the target value we know that our target value can't be at the midpoint or any index after that so we move the new end of our search range to just before the old midpoint by unindenting here we mark the end of the loop if the loop completes it means the search range shrank to nothing without our finding a match and that means there's no matching value in the list so we return the special python value none to indicate this lastly just as we did in our linear search script we need to search for each of the 100 names we loop over each name in our hard-coded list and we call the binary search function with the sorted list of names we're going to load from the file and the current name we're searching for we store the returned list index in the index variable and finally we print that variable let's save this and go to our console and try running it python binarysearch.pi and it's important to give it the name of the sorted file if it loads the unsorted file the binary search won't work so names sorted dot text again it prints out the list of indexes for each name i once again set it up so the last two items in the list of names we're going to search for corresponded to the first and last name in the file so it returned an index of zero for the second to last name and you can see that name here's the second to last name aaron augustine you can see that name here on line one of the file and for the last name it returned an index of one zero nine eight seven three and you can see that name here on line one zero nine eight seven four let's check the third to last name for good measure it looks like an index of 97022 was printed for that name stephen daras let's search for steve and daras within the file and here it is on line 97023 remember that line numbers start on one instead of zero so this actually matches up with the printed list index of 97022 it looks like our binary search script is working correctly let's try our linear search and binary search scripts out with the time command and see how they compare i've commented out the lines that print the indexes of matches in the two scripts that way they'll still call their respective search functions what the 100 names we're searching for but they won't actually print the indexes out so we won't have a bunch of output obscuring the results of the time command first let's try the linear search script time python linear search dot pi names and we can just use the unsorted list of names for linear search remember we want to ignore the real result and add the user and sys results together it looks like it took about .9 seconds for linear search to find the 100 names in the list of one hundred thousand now let's try timing the binary search script time python binarysearch.pi names and for this one we need to use the sorted list of names looks like that took around a quarter second so less than half as long bear in mind that part of this time is spent loading the file of names into a list the difference between linear search and binary search will be even more pronounced as you search through bigger lists or search for more items let's wrap up the course by looking at the big o runtimes for linear search and binary search these are going to be much simpler to calculate than the sorting algorithms were for linear search you need to do one comparison to the target value for each item in the list again theoretically we could find the target value before searching the whole list but big o notation is only concerned with the worst case where we have to search the entire list so for a list of eight items that means eight operations the big o runtime for linear search is o n where n is the number of items we're searching through this is also known as linear time because when the number of items and number of operations are compared on a graph the result is a straight line linear search looks pretty good until you compare it to binary search for binary search the number of items you have to search through and therefore the number of operations is cut in half with each comparison remember the number of times you can divide n by two until you reach one is expressed as log n so the run time of binary search in big o notation is o log n even for very large values of n that is very large lists you have to search through the number of operations needed to search is very small binary search is a very fast efficient algorithm that's our tour of sorting and searching algorithms be sure to check the teacher's notes for opportunities to learn more thanks for watching

ID: https://www.youtube.com/embed/zOjov-2OZ0E?si=26mU22TUsuvORadm
Document: Welcome to Introduction to programming. My name 
is Steven in my name is Shawn. Over the next 90   minutes, we'll be taking you through this series 
consisting of 21 different segments that hope to   cover the basics of computer programming, which 
can apply to any and all programming languages you   might want to learn. We'll be starting with the 
simplest question of what is programming. And from   there, we will be working our way up as we talk 
about common features of computer science such   as loops and arrays, we'll discuss how to read 
and write code, debug code that you've written   some strategies to help you plan out your code 
and much, much more. The complete list of topics   that are going to be covered in this lecture style 
video are shown on the screen. Now, additionally,   there will be timestamps in the description, 
so feel free to skip around. If you're already   proficient in some areas of computer science, or 
just want to know about a specific topic we will   be covering. Hopefully, by the end of the series, 
you'll have a basic understanding of what computer   science is, along with an armory of useful skills 
that will help you unravel whichever programming   language you decide to learn. First, we'll only 
be covering the major key points that apply to   all programming languages. So we'll be shying 
away from topics such as object oriented coding,   and command line navigation, as those are things 
which are language specific. Additionally, there   will be no software required for you to download 
in order to follow along with this tutorial,   as we won't be writing any code in an ID to 
keep things simple and concentrated. This video   is meant for those who are interested in computer 
science and programming but have no idea where to   start and have little to no background information 
on coding. And so if that sounds like you,   then strap in, as Shawn and I work our way 
through the wacky world of computer science,   starting with the biggest question probably on 
your mind, which is what even is programming?   Well, the dictionary defines it as the process of 
preparing an instructional program for a device.   But that's a really confusing definition. So 
in layman's terms, what exactly does that mean?   Essentially, it is attempting to get a computer to 
complete a specific task without making mistakes.   Imagine this for example, you want your less 
than intelligent friend to build a Lego set,   except he has lost the instructions and can only 
build based on your commands. Remember, though,   your friend is far from competent. And so if they 
are not given very specific instructions on how to   build the set, there are many mistakes that they 
could make. If he thinks like a computer, then if   there's even one piece that you have not told him 
specifically where to place and how to place it,   the entire Lego set will be ruined, and you will 
be left to suffer a complete mental breakdown,   causing the whole goal of the project to be 
corrupted. giving instructions to your friend   is very similar to how programmers code. Instead 
of a less than intelligent friend, you have a   less than intelligent computer. And instead 
of instructions on how to build a Lego set,   we are feeding information on how to complete a 
program like a game or a web application. And an   important thing to note is that computers are 
actually very dumb. We built them up to be this   super sophisticated piece of technology, when in 
actuality, a computer's main functionality comes   from how we manipulate it to serve our needs. 
Now, programming isn't as simple as giving your   friend instructions. Since in a programmers case, 
the computer doesn't speak the same language as   you. The computer only understands machine 
code, which is a numerical language known as   binary that is designed so that the computer can 
quickly read it and carry out instructions. Every   instruction fed to the computer is converted into 
a string of ones and zeros and then interpreted by   the computer to carry out a task. Going back to 
the Lego example, this process wouldn't be like   if he was not only less than intelligent. But 
to make matters worse, he could not understand   English and only speaks in Mandarin Chinese. 
In order to speak with him, you have to convert   the instructions that you understand in English 
into the language that your friend understand.   This process is essentially what you must do for 
your computer in order to make it understand the   instructions that you give. The big difference 
between the two examples, however, is that it is   very difficult for people to understand machine 
code in binary. Directly translating what you   want the computer to do into machine code is 
extremely difficult, in fact, almost impossible,   and will take a very long time to do it if you 
could. Each program is composed of millions upon   millions of those ones and zeros. So how exactly 
are we supposed to translate our instructions   into machine code. This is where programming 
languages come into play. programming languages   are fundamentally a middleman for translating a 
program into machine code. These languages are   much easier for humans to learn than machine code, 
and thus are very useful for programmers. Going   back to our Lego example, a programming language 
would sort of be like an interpreter that's able   to take the instructions you give them in English 
and translate them into instructions your non   English speaking friend can understand. This makes 
programming languages extremely useful and the   backbone of any good program. Think of programming 
languages as not English and not machine code, but   somewhere in the middle. There are many different 
programming languages out there that each have   their own unique uses. languages such as Python 
and Java, are just general purpose languages that   can perform a variety of computational tasks, or 
robots C or HTML or CSS, or languages designed for   more specific purposes, such as moving a robot 
or constructing a website. languages can also   vary and how powerful they are. For instance, 
JavaScript is a scripting language that is   designed for smaller tasks, or Java or Python 
can carry out much more computationally taxing   processes. We can measure a programming languages 
power, or level by how similar it is to machine   code, the series of zeros and ones we talked 
about earlier. low level programming languages,   such as assembly, or C, are closer to binary than 
a high level programming language, such as Java or   Python. The basic idea is that the lower the level 
of your programming language, the more your code   will resemble what the machine can interpret as 
instructions. Aside from the different purposes   that each language fulfills, choosing a language 
typically comes down to a matter of preference,   as are usually many languages that can accomplish 
similar tasks. Try different languages,   and decide which ones rules interface and 
level of simplification you like best?   So now that we know what programming is, how do we 
actually write code? It sounds like we can simply   type words into a text document and automatically 
assume that the computer can translate it into   machine code, read it and carry out a task 
like opening up a browser. And additionally,   we can't just write down rubbish in certain 
programming languages mentioned in the previous   segment, and expect the computer to understand. 
So how are we supposed to write code then? Well,   the answer is with an ID. And ID, which stands 
for integrated development environment allows the   facilitation of code by a computer. It is provide 
a graphic interface on your computer in which the   programmer can easily write, run and debug code 
without having to worry about problems with   complication or interpretation of the program. 
Think of an ID is any other program on your   computer, such as a game browser, or even the file 
explorer, except we'll be using it to write code,   IDs are able to turn your code into machine 
code and run it through the computer to produce   results. In addition to providing a place for 
programmers to develop their code IDs provide   some extremely useful tools for programmers 
to ease the job of writing code, such as built   in error checking, because as we'll talk about 
later, code doesn't always run correctly. Auto   filling for frequently used words or phrases, and 
a project hierarchy, which will help you organize   and manipulate the files within your project. 
Back in the olden days before IDs code used to   be written on punch cards and then fed into 
computers, which would take hours and cause   a lot of pain. IDs nowadays act as sort of a fast 
track to writing code and make things a whole lot   easier for programmers. An example of a specific 
ID can be seen on your screen now. In the center,   you can see the program that is currently being 
written. And right below it is the console,   which can print out useful information for the 
programmer. This specific ID is used to write   Java code. IDs are extremely powerful and will be 
used in almost 100% of your programming projects.   So through these IDs, we are finally able to write 
and compile code smoothly without worrying about   the computer not being able to understand it. 
The next problem we run into then becomes how   do we write this code in the ID. Because it's not 
like we can just type random words from a certain   programming language and expect the computer to 
understand this is where a programming languages   syntax comes into play. Now, just as if you were 
learning a real language, learning a computer   language can be very similar. Some have different 
styles that may seem odd. Some may make you use   weird or abstract concepts which may be confusing. 
And like all languages, programming languages have   a set of rules that you must follow when writing 
code in that language. And at the forefront of   those rules is grammar. Programming grammar is 
referred to as syntax and is very similar to   real world grammar. Each programming language has 
its own syntax or rules that you have to follow to   a tee if you want your program to run correctly, 
just as if you were speaking in real life. These   can be things such as how you type out certain 
functions, what you put at the end of the line of   code, and how you set up certain functions. Each 
language is unique in its syntax, and while some   may share similar rules, all will have some quirk 
which makes it stand out from the rest. syntax is   something that catches a lot of people off guard 
since many expect every programming language to   follow the same set of rules. But as we spoke 
about in the last segment, because each language   is specialized for a specific task, each needs 
its own set of rules to function. Breaking or   disregarding these rules will result in an error. 
Just how breaking or disregarding rules in real   life will result in an unintended message. As an 
example, if you wanted to do something simple,   such as initialize a variable, which is something 
that we haven't covered yet, but the example is   still relevant. In Java, you'll notice how we have 
to specify what type of variable we're defining,   in this case an integer and also add a 
semi colon after the statement. In Python,   we don't even need to define that we are trying 
to create a variable and just have to type what   we want to create. And in JavaScript, we 
just specify that we are making a variable,   but we don't include what type of variable we want 
to make like in Java. Even in this simple example,   you can see how much a syntax matters when 
learning a new language. Since while the   goal of our program remained the same, which 
was to define an integer with the value three,   all the programming languages shown took different 
approaches. All these languages require that you   follow this syntax because remember, computers 
are extremely dumb. If you forget one semi colon   or misplace a character, the entire program 
will not run and send you back a syntax error,   which is something we'll talk about later. Think 
of this as if you forget a comma in a sentence and   the entire context of what you're trying to say 
gets misinterpreted. For example, in the sentence,   let's eat grandma. If you were to forget that 
comma. While it may seem like a small mistake,   it changes the entire context of the sentence, 
making it sound like you're going to eat your   grandma. The same rules follow for programming. 
If you forget a semi colon, the entire context of   your program can be corrupted and misinterpreted 
by the ID. Now another thing which makes it so   useful is that they will let you know if and 
when there are syntax errors in your code. syntax   errors, of course, being parts of your code, which 
do not follow the same rules where we talked about   previously, the ID will tell you where in your 
code the errors, and also won't let you run your   program until the error has been fixed. Because 
of how important syntax is to writing code and   learning a new language. It's recommended that 
you learn the rules and syntax of a language   before beginning to write complex programs in 
that language. Most of the rules are tedious   to learn but easy to master. And as soon as you 
can do that, you'll be able to easily identify   syntax errors and take care of them easily and 
be writing code in no time. That covers the basic   gist of syntax and programming rules. So now that 
we know how to write code and where to write code,   we next need to cover what happens after we 
have typed out our program and run our code.   Because writing a piece of code for a game or for 
a database is cool and all. But after the computer   interprets the program, how will we know what's 
happening and whether or not is working? Well,   programmers do this by looking at the console. The 
console is a text interface within your computer   that us programmers can use for a variety 
of different purposes. If you remember,   a short while ago, we heard a picture of a basic 
ID. And one of the main parts of the picture was   the console. The main use of the console is to 
output text from the program. This is usually done   by using a print statement. A print statement is a 
command that does exactly what it sounds like. It   prints text to the console. The print statement 
is the first piece of actual code we've talked   about in this series. And it's about as simple 
as the print statement. Despite its simplicity   is one of the most important functions in 
programming and exists in some form in just   about every programming language. The most basic 
thing you can ask the print statement to do is   to just simply make it Say something. This 
is done by instructing the console to print,   and then include wherever you want to be printed 
inside the parentheses. For example, in Python,   the segment of code print hello world will cause 
a message reading HelloWorld to appear onto the   console. Pretty neat. The print statement is also 
vital for viewing interpreting the computer's   output from program. For instance, if you could 
tell a computer to run a simple calculation. For   example, to determine what four plus three is, 
they will run the program internally and compute   an answer. However, what is the purpose of having 
the computer run this program if you will not be   able to tell what the result is, instead of simply 
telling the computer to perform this calculation,   instruct the computer to print the 
output of the program to the console,   and upon the program's completion, seven 
will appear on the console. As you can see,   the console allows us to easily print information 
out to the developer for a variety of uses. It is   important to note that the print statement varies 
depending on the programming language being used.   For example, in Java, there are multiple versions 
of the print statement depending upon whether you   would like a line break after the printed text 
or not, as well as specialized print statements   which make your code run more efficiently. Also, 
the general syntax of using a print statement and   certain nuances of its function contains between 
languages. However, you can generally rely on it   to carry out the same overall function as it 
is a foundational statement for programming in   general. All of its functionality makes a print 
statement along with the console and very useful   developer tool. However, it is important to 
remember that that is all it is the developer   tool. The console is not really meant to be viewed 
by the end user of your program. It tends to be   hidden away behind the scenes and other methods of 
displaying information, such as displaying text,   graphics, or images are used to convey information 
to the user instead, think of it like this. When   you're using your phone, you see the console 
and none of the programs you use. So while you   can use the console to give yourself information 
about how your program is performing, don't try   to implement it in the final product because it 
fundamentally just isn't meant for that. Overall,   remember to use the console to its fullest extent 
when writing and fixing problems in your programs,   as it is a great tool to use to tell how 
your program is performing behind the scenes.   So now that we know a bunch of information about 
programming languages, and how and where to write   them, along with the print statement under our 
belts, let's go over some intuitive things that   the computer can do all by itself without you 
having to tell it how To. More specifically,   we'll be covering some basic number mathematics 
as well as string math. Starting off with basic   mathematics, the computer already knows how to 
do simple arithmetic. This includes addition,   subtraction, multiplication, and division, all of 
which are represented by the symbol shown on the   screen now, in any ID that you may install, you'll 
be able to print out the answer to simple math   problems using the print statement. Which may seem 
counterintuitive, because why would you use the   computer to do math when you have a perfectly good 
calculator on your phone. But you have to remember   that computers are dumb. And anything we want a 
computer to do, we have to build up from scratch.   basic arithmetic, while simple helps out in almost 
any program you may write. For example, if we   wanted to build a basic calculator app, we need to 
utilize this functionality in order to correctly   display the answer to an arithmetic problem when 
our user tries to add, subtract, multiply or   divide two numbers. Now in addition to the four 
basic math equations, most programming languages   include an additional operator known as modulus. 
If this is your first time hearing this word,   don't worry, since it's not usually taught in math 
classes. modulus allows us to get the remainder of   a divisional operation. For example, when we take 
10 modulus three, we're essentially telling the   computer to take 10 divided by three, ignore the 
actual answer and just give us the remainder of   the operation. In this case, one, since when we 
divide 10 by one, the answer is three remainder   one. The one in this case is what gets printed 
out to the console. If there is no remainder,   say in the case that we take 50 modulus two, since 
the remainder is zero, the function would return   zero if we were to print it out to the console. 
This can be extremely useful. In many cases,   the most obvious being if we want to determine 
whether or not a certain integer is even or odd.   If we take a certain number, modulus two, and it 
returns zero, then we know that is even because   any number divided by two will always result in a 
full answer without a remainder. But if the system   returns one, then we know that the integer is 
odd, you will find yourself using the basic math   operators a lot more than you think. So it's good 
to keep them in mind when running your program.   Now, not only can our computer work with numbers, 
but it can also work with strings. strings,   by the way, are just another way to say text. For 
example, hello world is a string, the letter A is   a string, and anything enclosed by quotation marks 
is denoted as a string in programming languages.   We'll cover more about strings in a bit when we 
talk about variables. But for now, let's continue.   We already talked about printing strings to the 
console. But let's say we're making a game and we   wanted to print out the statement, game over 
for was your final score. Now while we could   just make a string that says that exact phrase 
and print it out to the console, in some cases,   it would be more useful to print out the actual 
integer value, especially in the case of a game   where the score can change each time you play. 
Because score definitely isn't always going to be   for. Well, we're also able to print out multiple 
strings of text and even integers by adding them   together in the print statement. This is known as 
concatenation. Continuing with our score example,   if we wanted to print out the statement gameover 
for was your final score, using four as an integer   rather than a string. We could do this by 
breaking down the statement into two strings   and an integer like so. Print game over plus 
four plus was your final score. We of course   begin with a print statement, which again will be 
different across all languages. But in this case,   we're using Python. Inside the print statement, 
we start off by printing the string game over. Now   here comes the important part. From there, we use 
a plus sign and add four to the print statement.   Just like if you were adding two numbers, then 
we can repeat this process with another plus   sign for the final string was your final score. 
And we're able to print out the entirety of our   statement easily. Doing this we can easily 
print out multiple different strings and   integers together in one print statement. We could 
also combine the two lessons we've learned thus   far and do something such as game over plus four 
plus four plus was your final score. In the case,   let's say where you have a game which gives you 
a base score and then four points for a certain   task that you complete it. This demonstration also 
displays Another important part of programming,   which is that oftentimes to get your program 
to be the most efficient, you have to combine   aspects of code. Now it's important to note 
that the computer will take whatever you put   in the parentheses and print it out character for 
character. So oftentimes programmers will forget   to add a space onto the end of their strings. This 
can result in a small mistake in which the string   from the previous example would be printed out 
as if to say gameover four was your final score,   which isn't that appealing when displayed on the 
screen to the user. So it's a good practice to   always put a space after and before your strings 
to make sure this doesn't happen, and your string   doesn't end up like that. Another important 
thing to note is the difference between four in   quotation marks, and four without quotation marks. 
Now for in quotation marks is treated as a string,   rather than a four without quotation marks, which 
is treated as a number. This may not seem like a   big deal, but again, computers are dumb. And if 
you try to do math with a number in quotation   marks, it will return an error. Because the 
computer doesn't understand that you're trying   to perform the operation on a number and thinks 
you're trying to add an integer to a string,   which is a big no no in programming when you're 
adding numbers. So when you're programming,   make sure to make a mental note of whether or not 
you want to make something an integer or string,   because that type of stuff makes a big difference. 
All right, that concludes our segment on the base   power of computers. Now Next up, we're going to 
be covering one of the most important components   of computer science. So make sure you pay 
attention because next up we're going to be   discussing variables, what they are and how 
we use them. First of all, what exactly is   a variable? A variable is simply something that 
can store information and can be referenced and   manipulated. Think of variables like a cardboard 
box. cardboard boxes, servers means to store items   in them, which can be changed that replaced and 
modified variables are like cardboard boxes to   store information for the programmer to reference 
or manipulate. each variable simply has a type,   a name, and a piece of information stored inside 
of it. The type and piece of information will be   covered next, and the name is simply a name for 
the variable. Think of it as writing out a label   on the cardboard box in Sharpie. Now there 
are many different types of variables that   a programmer can use, or right now, we will just 
be covering what are called primitive variables,   which include integers, Boolean, floats, and 
doubles, strings, and characters. We'll start   off by talking about an integer. An integer 
or int for short, is as simple as it sounds,   a variable that can store an integer value. 
This includes all whole numbers from negative   2,147,483,648 to 2,147,483,648. Notice how I 
said whole numbers, integer values can not and   will not hold any decimal values. So keep that in 
mind when using variables. Secondly is a Boolean.   A Boolean is very primitive variable which can 
store a value of either true or false. Boolean   variables can only hold these two values, and 
are extremely useful for conditional statements,   which we will cover soon. The next few types of 
variables are floats and doubles. Both of these   variable types are floating point data types, 
which essentially means that these variables   can store numbers with decimal places. Whereas 
integers values cannot hold decimal values,   floats and doubles can. The main difference 
between the two is that a float variable can   store numbers of our precision up to 32 bit. All 
doubles can store numbers with a precision up to   64 bit. Essentially, a double can store more 
decimal places than a float. So it all comes   down to how precise you want the variable to be. 
Up. Next, we have string variables, which are like   the strings we've talked about beforehand, except 
store somewhere in a value. String variables can   store strings of letters, which are just words and 
sentences. Strings are useful for displaying text   and storing input information. Strings can also 
be concatenated together to form combinations   of string variables and pre written strings. This 
can be very useful for outputting information in a   readable format for the user. For example, imagine 
we have a string called name. The code asked for   input and storage that string of text and name. 
To output this information to the user. Rather   than simply displaying their name, you can add the 
phrase Your name is and make it into a sentence by   concatenating. Your name is plus a name plus a 
period. This makes it easier to read your code,   while also adding variability to your code, which 
always makes things more interesting for the   end user. Finally, we have char variables. char 
stands for character, and just as a name suggests,   they can each hold one character. This is useful 
when a programmer wants to read one button press   or one character in a string without using a 
string variable. a specific example is being   a game that is controlled by the keyboard, the 
program needs to recognize the character that is   pressed and translate that into carrying out some 
function. Now strings can also hold one character,   but chars can hold more than one character. So 
keep that in mind when defining variables. Now,   why are variables so useful? Well, being 
able to store information in a format that   can be easily referenced later is essential 
for any good program. Oftentimes, in code,   you're going to want to keep track of things such 
as a user's name, or score. And so by creating   a variable called name or score, you store this 
information in the variable and then reference it,   add to it or modify it. Also, many times to 
program will want to take input from the user,   which cannot be pre programmed into the code, 
and thus the variables required to store the   information. A program may also rely on factors 
that will change as the program progresses,   in which case a variable is once again required. 
Also, taking these variables and manipulating them   is quite necessary for carrying out many 
of the tasks you want to program to carry   out. For instance, multiplying in variables or 
concatenating string variables. Overall variables   are the backbone of any program, and you'll find 
yourself using them often if you want to clean and   efficient code. So it's best that you learn what 
types of variables you need to use and when. So   now that we know all about the different variable 
types, and we've talked about them a little bit,   we're going to delve further into what happens 
when we actually define or create a variable,   how we reference them, and how we can 
manipulate them for our programs. To start,   let's go over what happens when we actually define 
a variable. Now when we write a line of code,   which initializes a variable, and that code is 
executed, the computer essentially creates a   little space in memory that stores your variable 
name and its contents so that it can be referenced   later. Going back to our cardboard box example 
from the previous segment. Think of this as if   you had your own storage facility, and you make a 
new cardboard box labeled name. And inside of it,   you put a piece of paper with the word no 
pointer exception on it. Now, anytime you   want to know the contents of your name box, you 
could simply look inside and see that it has   the contents no pointer exception. This is what 
the computer does, except the storage facility   is the memory in your computer. The box is a 
variable and the contents of the box or whatever   the variable is set to be equal to. Anytime you 
want to know the contents of the name variable,   you can simply call it and the computer will pull 
the information that is stored in that variable,   and use it how the user see fits. Another thing 
to note really quickly is that you can actually   make a variable without putting information inside 
of it. This would simply be like if you built up a   new cardboard box, gave it a label with a sharpie, 
but just didn't put information inside of it.   You're simply saving that space in your storage 
facility for later. This can be maybe because   you want to store information in it later down 
the road. Or if you're going to use it to store   information given to you by the user, in which 
case you can't give it information since you don't   know what the user will input. Just to note that 
if you try to reference or point to a variable,   which does not have any information in it, you'll 
get what's known as a null pointer exception,   which despite being an amazing name for a YouTube 
channel is something you generally want to avoid   when programming. Now programming languages allow 
us to do some pretty cool things with these boxes   that we've created. For example, let's say we 
created a second variable called channel name.   And instead of setting it equal to no pointer 
exception, we instead set it equal to our already   created named variable. This doesn't create a 
space in memory for this new variable. However,   it simply points to the same location of memory we 
have already created for the name variable. Going   back to our storage facility example, this would 
be like instead of creating a whole new box label   channel name and storing sheet of paper with the 
word no pointer exception on it, we instead simply   added another label below the name box, and 
titled channel name. Now we have two variables   which point to the same contents, that being 
the string no pointer exception, we usually do   this to save space in our code for things that we 
know are going to have the same value. variables   can also be updated throughout your code. For 
example, let's say you had an age variable,   and inside of it was the integer 17. Then you 
celebrated a birthday and wanted to update your   age, all you would have to do is reference the 
variable and set it equal to whatever new integer   you want the variable to hold. In this case, 18. 
This would be the same as having a box labeled age   with a sheet of paper eating 17 inside of it, and 
then taking that piece of paper out, erasing 17,   replacing it with 18 and then placing it back in 
the box. Doing this we are able to easily update   the contents of our variables throughout the code 
as things dynamically shift. As another example,   if you were making an RPG, your character would 
likely have stats such as attack, defense manner,   etc. As the game progressed, you could 
continuously update the variables so that the   player could get more powerful, the further along 
they went through the game. And you wouldn't have   to create new variables, you would simply need 
to just keep grabbing that box from your storage   facility, erasing and replacing the numbers on 
the piece of paper and then continue along with   your code. Just keep in mind that these variables 
are nothing more than places in memory in which a   certain value is stored. So we can easily update 
the numbers and their place will remain constant.   After the code has run its course the place in 
memory is deleted until you run the code again,   and the program dedicated space for the variable 
again, each time you run the code, you're making   new boxes in your storage facility. And at the end 
of the code, you destroy them all to make room for   the new boxes next time. Another cool thing you 
can do with integer float and double variables   is add them subtract them, divide them, multiply 
them and even modulus them. For example, if you're   making a calculator app and you store the first 
number, the user entered as number one and the   second as number two. You could then multiply 
num one and num two together and either print   them or store them in a new variable entitled 
result. Then each time you run the program,   the user could input new numbers into the number 
one and number two variables. And they would   simply be set to those new integers that the user 
inputted and return the result that correspond   Through those specific numbers, this allows you 
to keep easy track of which numbers are which,   and what's going on in your program, which is 
extremely useful. Also, while you cannot subtract,   multiply, divide or take the modulus of strings, 
you are able to add them. Like we said previously,   let's say you had a string str one with the 
contents Hello, and a string str two with the   contents there, you could add str one and str 
two to create a string that had the contents   Hello there, either storing it in a third 
variable or printing it out to the console.   The last topic we'll be covering on the topic of 
variables is the naming conventions of variables,   which will be it may seem odd, but it's extremely 
important when trying to read your code. So we'll   be covering it now. Now variables have to be one 
continuous string. And so if you wanted to make a   variable that store the player score, you'd have 
to find some way to combine the words player and   score. Since you can't have the phrase player 
score be the name of a variable. All programmers   have their own personal preference when it comes 
to naming variables. But the one we'll be using   in this lecture is called camelcase, which is 
the process of not capitalizing the first word,   but capitalizing every word that follows 
it. Going back to the player score example,   using the camel case method, the variable 
would be called player score. This allows   us to easily see and identify each word and 
becomes really useful for long variable names,   like the player score before the final boss. 
Whereas if we just type it out without camelcase,   it would be really confusing and hard to read. 
This will help you out a ton when we start finding   bugs in our code and need to quickly scan through 
our program to figure out what is wrong and adds   to the overall readability of the program. 
Other programmers might use different naming   conventions like using underscores to separate the 
words in a phrase. But for now, and this series,   we'll be sticking with camel case. Next, 
we'll be moving on to conditional statements,   which at their core, are statements that change 
the path of our code depending on certain   conditions. For the sake of keeping things simple 
for this section, where Atlanta will connote that   our code will not be following the specific path. 
In Greenland's I mean, our code is following the   path. The main type of conditional statement 
that programmers use is the if statement,   and this will show up countless amount of times 
in any program you write. It is as simple as it   sounds, if some condition is true, and usually 
that condition will be enclosed by braces, then   carry out the instructions located within the if 
statements brackets, else do another thing. Now,   brackets are used in most programming languages 
to indicate a segment of code which will run it   works like this. If the condition in parentheses 
is true, then all of the code contained within the   brackets will run. And if the condition within 
the parentheses is not true, then it will skip   over all the statements within the brackets. A 
quick note is that while this is the case, with   most programming languages, some, like Python, 
use columns and whitespace to determine where a   piece of code starts and ends. But for the sake of 
this series, we'll be using curly braces. Now, the   condition within the parentheses can take on 1000s 
of different forms, such as if the value of the   string variable name is equal to Steven, or if the 
player score stored in an int variable is greater   than five. The list goes on and on. Each of these 
statements is evaluated as a Boolean, which you   will remember from when we talked about variables 
is either true or false. If the Boolean is true,   we run the code inside the curly braces. If it's 
not, we pretend everything inside the curly braces   never existed, and move on with our code. The 
if statement comes with two more additional   statements that go with it elsif and eltons. 
elsif is a conditional statement used directly   after an if statement, and carries out mainly 
the same function as an if statement. However,   the elsif statement will only be evaluated if the 
proceeding F or the preceding elsif statement is   bypassed due to its condition being false. So we 
will run through it like so. If something is true,   we will run the code inside of that statements 
curly braces out if that's something is not true.   But another statement inside of the parentheses 
is true, we would then run that code segment. And   if neither of them are true, we would skip both 
segments of code and move on in our program. This   can be a hard concept to wrap your head around 
to so let's do an example. If we had a program   that evaluated the if statement, if age is equal 
to 10, we then have a statement under that which   stated outs if age is equal to 12. Now, if the age 
variable was 10, which we can see from the example   that it is, then the code immediately following 
that conditional statement in the brackets would   run. The Ultra statement we made will not even 
be tested. Since we know that it is going to be   false. And thus the print statement inside of that 
conditional statements brackets will be ignored,   and the code will move on to the rest of the 
program. Now for example, let's say we change the   age variable to be 12 instead of 10. Now instead 
of the first conditional statement being true,   it actually evaluates as false since age is no 
longer equal to 10. So what we do now is first   skip over the print statement, which prints out 
that ages 10 and does not. And then we evaluate   the elsif statement, we check if age is equal to 
12, which again it is. And so now we run all the   code inside of that conditional statement before 
finally moving on to the rest of our program. So   as a review, we check the initial if statement. 
If it's good, then we run all the code within that   if statements curly brackets and move on with our 
program. If the initial if statement is not true,   we then move on to any elsif statements and 
evaluate if those conditional statements are   true. We can have as many elsif statements as we 
want, although this could lead to clutter amongst   your code. So we'll talk about some alternatives 
later to help us out. Now that takes care of   the FL statement. So now we'll move on to the 
else statement. The out statement, once again,   it comes after an IF or an elsif statement, 
and we'll carry out its instructions no matter   what. As long as the proceeding statement slash 
statements are evaluated as false. If we went   back to our previous program, we could add an 
elf statement, which would only have the code in   his brackets run at the age variable wasn't 10, 
or 12. This will catch all cases of the program   that didn't fit into our parameters. It's good 
practice to always have another statement at the   end of your conditional statements to catch any 
weird cases that may come up in your program.   Now remember back to the fact that we could have 
1000s of Elif statements after a while that can   get pretty cluttered. And so another very useful 
conditional statement helps circumnavigate this   problem is a switch statement. A switch statement 
is functionally similar to many if and else   statements together, you write a switch statement 
in the form of switch variable. And then below   that you write out how many cases the variable 
can be. For instance, if we wrote switch var,   and then under read write out five cases that the 
variable var could be and then the instructions   listed under each case would be carried out 
if the var variable it would be equal to that   case. Now switch statements are different sets. 
Instead of using brackets, they use a column to   signify the start of a set of instructions and a 
break statement to end them. This is very useful,   because you are able to essentially use many if 
and else if statements without having to write   nearly as much. In switch statements, you just 
always have to remember to include default case   at the bottom of the expression to denote any and 
all cases that don't meet the above requirements.   There simply catches all the inputs that don't fit 
within the program's main cases. It's very similar   to just case the end of an if else chain. Now, 
why are these statements so useful? Well, many   times programmers want their programs to function 
differently depending on different conditions.   For instance, a program could function differently 
depending on the information that the user inputs,   such as allowing user to use a program or not user 
program if they are above or below 18 years old,   respectively. Or in say, a video game. If the user 
experiences above a certain threshold, you might   want to give them harder opponents to battle. 
Another example could be a program was changing   the color scheme depending on the time of day. Or 
even more simply, if a user presses a button that   is meant to move on to another screen in an app, 
the programmer would only want that app to change   screens if the user clicks that button. A program 
without conditional statements would do the same   thing every time, and would be very primitive 
compared to one that can change depending on   its conditions. So now that we know how to make 
and use variables, how to compare them, and what   we can do with those comparisons, let's move on to 
another foundational concept of computer science.   And that is arrays. Now we've already talked about 
variables, and how great they are for storing   singular bits of information for making our code 
more simplistic. But one of the biggest drawbacks   that comes with variables is their inability to 
hold more than one piece of different information.   For example, let's say you're making an app which 
allows a user to create a grocery list. Well,   there's no real easy way to create lists using 
variables. Because it's not like you can have one   variable store the names of six or seven different 
food items. Remember, we can only put one piece of   paper in our cardboard box no more. And besides, 
even if you were able to add multiple items to one   string variable, you would still have a lot of 
trouble doing simple tasks you might want from   a list such as searching through it, splitting it 
or even deleting items from the list when you're   done with them. This is the problem that using 
arrays solves for us. An array is as you may have   guessed by now, a list, you can have an array 
of integers, an array of strings, and even an   array of other arrays, which is something we'll 
cover in a minute. Programmers use arrays when   they want to store a lot of variables containing 
information that is all related to each other,   such as a grocery list or a high score list in 
the game. Think of arrays as a column in Excel   or Google Sheets. Here the title at the top and 
then below it are a bunch of bits of information,   which all relate back to the title. Arrays are 
super useful when programmers want to store a lot   of information that can be easily searched 
through because programmers have developed   methods of breaking down and using arrays to find 
specific information in arrays full of 1000s of   different variables. As an example to show just 
how useful arrays are. Let's say you're a startup   company that owns an app that has 100,000 users. 
Every time a user wants to create a new account,   they input the username they want and then your 
program will have to check to make sure the   account name hasn't already been taken. Doing this 
requires you to search through the information of   all 100,000 of your users to see if that username 
has an account with your service and array would   be able to get Pain all of this information 
and make it easy to search through and find   out if the account name has already been taken 
with little to no delay. Now, the single most   important thing to note about arrays is how you 
reference each element of the array within them.   Let's create a basic array called numbers and 
inside of it, put the digits one through 10. Now,   when we want to refer to each cell in his array, 
we would call upon its index. an index is just a   fancy way of saying that numbers placed within the 
array. Now you would think that the first integer   in this array would be the first index, the 
second would be the second index and so on. But   that's simply not the case. In computer science, 
programming languages refer to the first cell as   zero with element in the array. This means that 
if we were talking about our array of numbers   we just made, the number four would actually be 
in the third index, five would be in the fourth,   and so on. So instead of starting our count from 
one, we start from zero. It's extremely weird and   confusing, but it's one of those programming 
quirks, you're going to have to memorize and   commit to memory. If you were to not follow this 
nomenclature, and refer to the last element in   this array as the 10th, you get what is referred 
to as an array out of bounds error, since you're   trying to reference the 10th element, but there 
is no 10th element, where you're actually trying   to do is reference the ninth element. Another 
extremely important thing to note about arrays   has to do with their size. When you initialize 
an array, you can do it in either one of two   ways. You can either populate it with the elements 
that you want contained in the array right then in   there, creating and filling the array at the same 
time. Or you can define how many elements you want   the array to hold, essentially the array size, 
and then populate it with elements later. This   is because when we initialize an array, it creates 
a space in memory that has a size of exactly what   you give it. no more and no less. This is great 
for when we want to access elements in the array,   because we can do so instantaneously because the 
computer knows exactly where in memory the array   is stored. But the one downside is that we can't 
increase the size of the array later on. All array   sizes are final. Think of this like setting up 
a bookshelf with books by populating a bookshelf   with a certain number of books. And then moving on 
and filling the next shelf with different books,   we have no way to go back and add books to that 
first shelf without shifting everything over. Once   we decide how much space to dedicate for an array, 
in this case, there's no way to add more space.   Once again, because this is extremely important to 
remember. This means that once an array has been   defined, there is no way to change the size of it. 
If you have an array titled names with a size of   eight, and you try to add another name to the 
array, you will receive an error. So be careful   when messing around with array sizes. Of course, 
you can always go back to the start of your code,   when you initially make the array and allocate 
more space to it, increasing its size. If you   find out that you need more space to hold items, 
but once it's defined, you cannot change its size   through conventional methods. Another small thing 
I want to touch upon really quickly is that when   you initialize an array, you must determine 
which type of array it is right then in there,   for example, you have to specifically say it 
will be an array of strings or integers when   defining it. And also you're not allowed to mix 
and match. Meaning that you can't have an array   full of integers with a few strings and some 
doubles thrown into the mix, they all have to   be the same type. Now the last thing we're going 
to cover on arrays is a little funky. And that is   the practice of putting arrays inside of arrays. 
If you make an array of arrays is referred to as   a 2d or two dimensional array. Think of these as 
matrices if you've taken an algebra class before.   Now, if you haven't Think back to our Google 
Sheets example, but instead of using columns,   we would add rows as well. So now each element in 
an array would simply just be a string variable   or an integer variable. But an entirely new array 
with its own set of values and elements. The way   we index these is mostly the same, except we would 
have two numbers to index instead of one. We start   with the row and then the column. So a number 
in the positions 02 would be in the first row,   three columns down, in this case, the name 
Clint a number in the position one one would   be two rows down and to columns across, in this 
case, the name Chris, you get the idea. Now you   can also make three dimensional arrays by putting 
an array inside of an array inside of an array,   but that's a little above what we're going to 
be covering. So I'm going to cut it off there.   Next up, we're going to be talking about loops. 
So what exactly are loops? Next up, we're going   to be talking about loops. So what exactly are 
loops? Next up, we're going to be talking about   loops. So what exactly are loops? Next up, we're 
going to be talking about loops. So what exactly   are loops? Next up, we're going to be talking 
about loops. So what exactly are loops? Well,   as you can probably tell by that statement right 
there. A programming loop is a statement that is   used to run certain instructions repeatedly. Just 
like how the opening statement of this topic was   repeated five times. loops are very useful for a 
variety of reasons. For instance, imagine you want   to print something 15 Sure, you could just copy 
and paste the print statement 15 times, but this   is really annoying to have to do, it becomes even 
more unrealistic when that number goes up to say   100 or so. Now what if instead of rewriting 
the same instructions over and over again,   you would simply place the print statement inside 
of a loop, and it will occur as many times as you   would like. Now that's the power of loops. With 
loops were able to repeat parts of code multiple   times. Now, there are three different types 
of loops that we will be discussing today.   And first is the for a for loop is very useful 
for situations like the one described above,   where you would like to carry out a certain set of 
instructions numerous times. The syntax for a for   loop varies depending on the language, however, it 
usually consists of three parts an integer value,   a condition which the integer value must meet in 
order to exit the loop, and an operation to modify   the integer value at the instructions inside the 
loop are completed. Each time the for loop runs,   the operation you set will be performed on the 
integer as long as that integer still needs to   condition your set, usually being greater than 
or less than a constant value, the for loop will   continue to run. Eventually, when the integer has 
been modified by either increasing or decreasing   it to the point where it no longer meets the 
condition, the for loop will terminate and the   code will continue to run. For example, let's say 
our integer value was I and we set it equal to   zero, then we set the conditional statement 
as I being less than three. So basically,   we're saying that as long as I the variable we 
just created is less than three, continue running   the instructions contained within the loop. 
Finally, we make the operation i plus plus,   meaning each time the loop runs, we increase it 
by one, and inside of the loop, let's just put   a simple print statement. Now let's run through 
the for loop, we start with i equals 00 is less   than three, so we enter the loop and print out 
hello world. Now that the instructions are done,   we add one two, I'm making it one moving on. One 
is again less than three. So we want to get into   the loop and print out hello world. Again, we had 
one two, I'm making a two now to is still less   than three, so enter the loop again and print out 
hello world. Finally, we add one to it once again,   and it becomes three. Three is not less than three 
though, is equal to three, and so we don't enter   the loop and it terminates. Moving on to the next 
segment of code. This is a simple example. But you   can extrapolate it across programming to fit your 
needs. Now when using a for loop, we have to make   sure to set up a condition that given the initial 
integer value and the operation will at some point   not be met to avoid creating an infinite loop 
and crashing your program. an infinite loop   occurs when you give a for loop a condition which 
will always be met given the parameters of the   program. And so software crashes. For example, a 
for the beginning at 10. And checking if is over   less than zero, and then adding one to either the 
end of the loop will never terminate since I will   suggest increase infinitely. After the for loop is 
the very similar for each loop. A for each loop,   or a for in a list loop in Python is used for 
iterating through arrays or lists. Essentially,   the loop will go through each element in the 
array and carry out some server instructions   for each value. If you would like to read all of 
the elements in an array and compare them to some   value, or perform some operation on them, a for 
each loop is extremely useful. So for example,   we could have a for each loop which iterated 
across an array and simply printed out the   value of each array location. Next up we have the 
while loop. A while loop will continually carry   out instructions while a conditional statement 
given to it is true. This can be as long as a   certain variable is true. As long as the numbers 
that's another number, or while a value is still   equal to another value. For example, while loops 
are different than for loops in that the loop is   not contained within one statement but stretched 
out and will continue to run. As long as this   condition is true. Like a for loop, you could make 
the condition such that it will eventually return   false and exit the loop. However, while loops 
will not crash your computer should you create an   infinite loop. In fact, it is very common for wild 
lips to run infinitely. As for certain programs,   you would like the program to continually 
be iterated through instead of running once   all the way through until you exit out of the 
program. When programming a game for instance,   a while loop would be used to iterate through your 
code, continually refreshing the screen as the   game runs. From there you can perform operations 
on the screen to make the game playable. Creating   infinite while loop could be done by simply using 
the syntax, while true, as the condition true will   always be evaluated as true. Finally, I'd quickly 
like to cover the extension of a while loop   the do while loop. Do while loops are very similar 
to while loops, except they will carry out their   instructions at least once even if the condition 
is false. And then we'll carry on like a basic   while loop. Essentially, the conditions inside 
of the loop will run at least once. And then if   the condition is still met, they will run again 
and function as a normal while loop would. As you   can see loops in there many varieties has some 
extremely useful functions. using them, you're   able to perform an operation many times in a 
row. You can iterate through arrays and lists and   overall decrease the clutter of your code. Next 
up, we're going to be taking a break from learning   about common programming statements and dive into 
what happens when the code we write doesn't work.   More specifically, we'll be covering the different 
types of errors that can occur when you're   programming and what causes them. Now when you're 
writing code, you have to understand that things   aren't always going to go the way you expected 
them to. And sometimes the program doesn't always   work as you had intended. too. We programmers call 
these errors. And while annoying, they're always   going to come up in computer science, and so 
it's best to learn what they are and how to deal   with them. Often referred to as bugs, errors and 
scripting languages can be narrowed down to one   of three types, syntax errors, runtime errors, and 
logic errors, all three of which we'll be covering   in today's video. To kick things off, let's talk 
about syntax errors. These are usually the easiest   of the three to solve, since they are oftentimes 
something that can be fixed within seconds. If   you remember back to earlier in the video, when we 
talked about syntax and programming rules, we said   that if you were to break the programming rules or 
syntax that would result in an error. Well, that's   what syntax errors are parts in your program where 
you fail to meet the programming rules, and so the   computer doesn't know how to interpret your code. 
This can be anything from forgetting a semicolon   at the end of a statement in Java, accidentally 
defining a variable with two words instead of one,   or even just misspelling the word string when 
you're trying to define a string variable.   Lucky for you guys, these errors are extremely 
easy to fix, since you just need to figure out   where the error occurred, and what the syntax 
rule you broke was. Now thinking back to IDs,   we mentioned that IDs are so useful because they 
do precisely that. They underline the syntax   errors and usually provide helpful hints as to 
how to fix them. Think of syntax errors as small   misspellings or grammatical errors in an essay 
you're writing annoying, yes, but not the most   infuriating things. Another useful thing about 
it is when it comes to syntax errors is that the   program will actually restrict you from running 
the code unless all syntax errors are cleared,   making them even easier to identify and fix. The 
second type of error we will be covering is the   runtime error. These errors don't show until you 
actually run the code, hence the name runtime   error. runtime errors are usually caused by a 
statement in your code that seems logically sound,   but the computer physically has no way of 
computing it in a reasonable amount of time.   The most common of these errors is one which 
we've already talked about the infinite loop,   as a refresher or an example. Think of an infinite 
loop like this. Say you set your friend down in   front of the TV, put on the office, and told him 
he could leave as soon as Michael made it. That's   what she said joke. Seems pretty simple, right? 
Wrong, because instead of putting in the office,   you put in friends on blu ray. Now, Michael, 
no inappropriate joke, meaning your friend   would be sitting there for the rest of his life. 
This is basically what happens with a computer,   you give it some condition that it has to complete 
before the program can terminate. However,   you give it no feasible way to finish that task. 
This puts the computer in error mode, and most   likely it will crash your program. As the computer 
desperately tries to complete the condition you   gave it. As a computer example, if we try to have 
a program terminate when integer i is no longer   greater than 99. But eyes initially 100 and only 
ever increases, the loop will never terminate,   and the program will crash. To avoid these, you 
generally want to think through the flow of your   code before running it, especially with loops 
to make sure that all of your statements can be   completed by the computer. Carefully planning out 
your code before you begin writing is an extremely   useful practice, and something we'll be covering 
towards the later part of this video. The final   type of error that we'll be covering is a logic 
error. This error is also pretty self explanatory.   A logic error occurs when the code runs smoothly 
without any runtime or syntax errors. But the   result that you get just isn't what you want it. 
For example, let's say you had a calculator app,   and you want it to instruct a program to add two 
numbers, except it multiplied them because you use   the multiplication symbol on accident. This leads 
to the sum being 36 instead of 13. nothing went   wrong with the code syntax or runtime wise, the 
code runs just fine. It just doesn't work as you   had intended it to. These are often the hardest 
types of errors to debug. Since most of the time,   you'll have no idea why the code isn't working, 
and certainly not any idea of how to fix it.   This is why it's a good idea to test your 
code incrementally. Don't wait until you've   been programming for an hour before testing your 
application. We're all to run into a lot of logic   errors. Logic errors can be extremely fury ating, 
and could cost you a lot of time making them a   huge pain. But if you know how to effectively 
debug your code, you'll be just fine. Speaking   of debugging your code that brings us straight 
into our next topic, which is how to debug your   program. Now let's say you've written a program, 
you think it's ready and you're ready to test.   You've been working hard on this and you're just 
wanting to see it in action. You run the program   and wait for it to run smoothly and efficiently. 
Only it doesn't work. you've encountered one of   the three errors we've just mentioned. You really 
want this code to work but how this is where   debugging comes into play. If the code is giving 
you an error, the first thing you should do is   read the error. Oftentimes for syntax and runtime 
errors, the ID will print an error message out to   the console. See what line or lines it points to 
since those little lines with the occurred, and   see if you can understand and fix what the problem 
is. If the error isn't clear, or you've never   heard of it, then try googling it as there are 
many websites out there. So just Stack Overflow,   which service forums to ask an answer problems 
with code. Chances are, if you've had a problem,   someone else has had the same issue and there's 
likely a tested solution. Usually, when the syntax   or runtime error pops up, you should be able 
to find a fix for it fairly easily. However,   as I said before, the issue may arise from some 
loophole or oversight in the code you hadn't   planned for beforehand. Maybe you did something 
as simple as multiply two variables instead of   adding them. These are logic errors we talked 
about previously, these problems usually won't   have red text show up to explain what went wrong, 
you'll have to figure it out yourself. Now, there   are a few different strategies that you can use in 
order to track down and fix a logic error. First,   you could use print statements and the console 
in order to determine where the code is going   wrong. Imagine you have a conditional statement 
that will run one segment of code if an integer   x is greater than five, and it will run another 
segment of code if not, if in your program. X is   supposed to be greater than five when the program 
reached this conditional, but for some reason,   the program is still printing out x is small, 
you can use a wrench they're meant to help. For   this problem. Specifically, you could place 
the print statement before the branch or the   conditional that would print the value of x. Now 
when you run the program, you know exactly what   the computer is thinking, printing out the value 
of x just before the FL statement. While you know   the variable has the value you wanted to have. And 
if it doesn't, you know that somewhere above that   conditional is something went wrong, and x was set 
to a value you didn't want it to. In this case,   x is equal to two, which is why x is small is 
being printed out. Now that we know what the   problem is, we can track down where and when in 
the code, we modify x in order to solve it. Use   print statements to determine where your program 
goes wrong, and then try to track down the cause   of these issues and solve them. If you use this 
strategy, make sure you end up deleting the print   statements afterwards to avoid clutter in the 
console. The situation described above could   also be solved using a breakpoint. a breakpoint 
pauses your program when the line you placed a   breakpoint at is reached. If say you would like to 
program to run through a certain conditional and   set a variable based on that conditional. But you 
are unsure if this actually happens in your code,   you can place a breakpoint inside the conditional 
path that you expect to run. Upon the breakpoint   being reached, the program will pause and wait 
for you to continue it through a button press.   This signals that this button occurred where the 
breakpoint was placed. In this case, the correct   conditional path has been reached by your program. 
You can then continue the program knowing that   this was or wasn't where the error in your code 
occurred. breakpoints can be used in conjunction   with print statements. In order to do both pause 
the program and perhaps view the values of your   variables at the moment in time to give yourself 
all of the information you could want. You can   also have multiple breakpoints to help slowly work 
your way through your program and determine where   an error has occurred. A combination of these two 
strategies will help you easily determine where   in your code you have incurred a logic error. 
Next, let's go over what to do if you think you   have tracked down the section of code that causes 
the problem. You may think you should delete it,   but it's likely you put it there for a reason. 
And you don't want to lose all that work if you   don't have to. Firstly, try commenting it out. 
Comments are used to markup code and explain their   surrounding sections. They can also be used to the 
bug. Anything that is designated as a comment will   not be read by the program as code and will be 
skipped over. Essentially, it becomes something   that is only there for you, the programmer to 
read. The syntax varies from language to language,   but it usually involves placing some symbols 
before or around the code you would like to be   commented, examples of how to comment in different 
languages can be seen on the screen now. Also,   when you comment something, the ID will grayscale 
that line of code, making it extremely easy   to determine what's commented and what's not 
commenting code deletes it in the computer's   eyes without actually deleting it. If a problem is 
present before you comment a section of code, but   it's gone afterwards, then that section of code is 
the culprit. If you comment part of the code out   and there are still issues and move on to another 
section until you find the culprit. Once you do,   you can tweak it until it works as intended 
or deleted entirely. And you'll have a fully   functioning program once again. Now that we've 
talked about what to do if you've encountered an   error, and a strategy on how to find and fix it, 
I'd like to talk about some strategies you can use   to avoid errors in the first place. Firstly, 
backup your code frequently. In the event of   the code completely bugging out and you being 
unable to fix it, you will want the ability to   revert to a previous version where the code was 
still working. If you save frequently enough,   you will probably not lose too much work. Version 
managers like GitHub or subversion can help with   this as they backup code to an online cloud 
service, which you can easily pull previous   versions of the program from at any point. Also on 
top of saving, running your program frequently to   ensure that the current version works as intended. 
This accomplishes two things. First of all,   it prevents you from saving a backup that 
doesn't work second If you encounter a problem,   it will be easier to find if you have only 
made a small number of changes since the last   time you ran it, and it worked. And thus, you 
will only have to look through the new code for   problems. If you've spent five hours coding 
and hadn't run it during that time period,   it's going to be likely that at some point, 
during that five hour code session, you messed up,   and it's going to be even harder to figure out 
where you went wrong. errors, while annoying and   extremely frustrating, are a fundamental part 
of making you a better programmer. Alright,   now that we've covered errors for a bit, let's 
hop back onto the programming statement train   and talk about one of the most important concepts 
in computer science, they'll function. Now, you   may not know it, but we've actually been talking 
about a few functions, this entire series, print   statements for loops. And even the basic math 
operations we've talked about are all examples   of functions, which of course, begs the question 
of what actually defines a function? Well,   a function is a segment of code that can be easily 
run by calling the function name. And depending on   the type of function will do something in return. 
functions can be called numerous times and in   numerous places in your code. Essentially, they're 
like wrapping up a segment of code into a nice   present, and giving it a name, which, when called, 
will unwrap the present and go through the code   that you had wrapped up. For example, the print 
statements we've been using this series allow   us to print something to the console anytime we 
want. Those are functions, you see, we just call   the print function and enter in what we want to be 
printed to the console into the parentheses, and   the computer does it for us. Behind the scenes, 
there's actually even more complex code that is   in charge of taking your text and translating it 
to the console to be printed. The developers of   almost all programming languages realize that you 
don't want to program something that manually has   to print something to the console through the use 
of complex programming. And so they implemented   the print statement to reduce the stress and 
complexity of code on the user, abstracting it   to the single line of code that is print. All of 
that code that is used to print something to the   console is wrapped up like a present and given 
to us in the form of one line. This is actually   the main theme of all functions and the backbone 
of any good program. Oftentimes, in your program,   there are going to be sections of code which are 
repeated and serve the same purpose, or equations,   which you want to allow different inputs of. And 
so you can use functions in order to condense   these down into singular lines of code to save 
both time and reduce clutter on your code. As   you will see soon functions are extremely 
powerful, and will definitely be something   you utilize all the time in your computer science 
journey. The print statement is just one example   of functions in everyday code. There are 1000s 
of functions that are available to you through   the IDs. However, because we won't always use 
all the functions that are available to you in   a single program, you have to import these 
functions from packages found in the ID E,   which is something that we'll be covering later 
on. Now, there are four main types of functions   in most programming languages. And they are 
separated by two defining features, whether or   not they take in arguments and whether or not 
they return values. Let's start by separating   them by whether or not they take arguments. But 
first we have to cover what arguments actually   are. arguments are essentially variables that we 
pass into the function in order to be manipulated,   and then either returned back to us printed to 
the console or used in another operation. Think of   functions with arguments like this. If you walked 
up to your local Five Guys, and told them that   you wanted to get food without supplying a type of 
food, they would probably look at you confused. In   order to get the food that you want, you need to 
tell them exactly what you want to order so that   they can give it to you. In this case, getting 
food is the function and what you order in terms   of food is being passed in as the argument based 
on what you tell them or the argument that you   pass into the get food function, they will 
do something different. You should also note   that the argument can be many different things. It 
could be fries, burgers, sodas, really anything on   the menu, and such as the case with arguments in 
programming. Arguments can be strings, integers,   arrays, pretty much anything. As an example of a 
function that takes in arguments, let's look at   the max function, which takes in two integers as 
arguments and returns the maximum number between   the two. Now for this function, if you don't 
input two numbers or variables for it to compare,   it's going to throw you an error. Just like the 
five guys employee. He doesn't know what you   want to eat Since you didn't provide him with any 
arguments. And the computer doesn't know which two   numbers you want it to compare and return Since 
you didn't provide it with two integers. arguments   are a way for programmers to have one function 
that can do many different things depending   on whichever variables can be passed through 
arguments, add variability to programming and can   help diversify your code. Think of it like this, 
a restaurant that only allows one type of food to   be made regardless of what you order isn't going 
to be very useful or diversified but We're able to   pass in arguments and tell them what food we want, 
our experience can be heightened and more options   can become available to us, which is exactly what 
happens when you start using arguments in your   function. Now that we've talked about functions 
that take in arguments, let's move on to functions   which do not, because functions can also be 
created and used without taking arguments in   and still be incredibly useful to the programmer. 
For example, let's say you're making a text based   RPG game, and one of the options you give your 
player is the ability to view their stats at   various points throughout the game. Now every 
time you come upon this option, and they choose   the view stats button, you don't have to type out 
six different print statements for every statistic   they may have, your code would get cluttered and 
messy very quickly. Instead, what you could do   is you could package the six different print 
statements in a simple function called print   stats, you don't need to pass in any arguments 
into the function, since the function will do the   same thing no matter what the statistics on the 
player are. Now, every time the user wants to view   their stats, you could simply call the print stats 
function, and voila, the user stats are printed   for them to view. This allows you to save a lot of 
time writing code, but also a lot of space, which   is extremely important when your programs begin 
getting into hundreds and 1000s of lines of code,   and you want to easily search through it to maybe 
debug. Okay, now that we've separated functions   into those that take arguments and those that 
do not, let's again, split these up into those   that return values and those that do not. Another 
thing you have to understand is that when you're   making your own functions, which is something 
that we'll be covering very soon, you have to   choose what your function will return, if anything 
at all, functions are able to return values back   to the user, whether they be in the form of string 
variables, integer variables, or even arrays. Now,   the thing to note about returning variables is 
that calling the function alone won't do anything,   you have to return the value into something or 
print it out. As an example, the max function we   talked about previously would return an integer 
back to the user. But in order to do something   with it, we would have to either set a new integer 
variable equal to the result of that max function.   Or we can print out the result of the function, 
which in this case, which is print out the maximum   value between the two integers. Using functions 
which returned values don't do much on their own,   you have to pair it with something in order to 
gain the use from it. Let's do another example.   Let's say you had created a function which took in 
two string variables as arguments and combine that   using that fancy string that we talked about 
earlier, and then return them as a singular   string. This combined string function could then 
be used to create new string variables. Since what   it returns is basically a string, the variable 
would simply be set to whatever is returned from   this combined string function. The last type of 
function is one that does not return anything. And   these are known as void functions. Oftentimes, 
these are like the print stack functions that   we created earlier. Simply use to condense large 
amounts of print statements that appear often in   your code. These cannot be set to variables since 
they don't return anything, and just get the code   that's within them run through. So there you have 
it, the four types of functions, ones that taking   arguments and return something, ones that take in 
arguments and don't return something. ones that   don't take in arguments, but still return values, 
and ones that take in arguments and don't return   anything. Each of these four types of functions 
are useful and unique in their own way. And you   will probably find yourself using each of them 
through your programming journey. So get used to   the different types of functions and know how to 
make the most of them, as they are all extremely   powerful. Finally, I'd like to talk about one of 
the major benefits of functions, which is that   it makes it super useful to make large changes 
to your code without having to go through the   entire program. Each function call is essentially 
just a copy of that functions original code. And   so it's very easy to make changes to that initial 
function, and have it translate across your entire   code. Let's go back to our print stats function 
and say that you wanted to go back and add in a   new statistic that the player could level up and 
through experience in the game. Without functions,   you'd have to go back into your code and find 
every instance that you'd printed out the user   stats and create another print statement 
to display the new statistic. However,   if you had created a print stats function like 
we did just a while ago, all you would need to   do is find out where you define that function and 
add in a print statement, which displays the new   statistic and you're done. Now every place which 
you had previously called the print stats function   will now also print the new statistic as well. 
You can see just how powerful functions can be   if used properly, and we haven't even scratched 
the surface yet. Now, up next, we're going to   cover how we can import other people's functions 
that they've written and use them in our code.   Before we get technical, close your eyes and 
imagine you're trying to build a house. Sure,   you could grow your own trees, chop down your own 
wood, make your own tools and nails and build from   scratch. But why do that when you can simply go to 
your local Home Depot and buy these materials that   others have already made ready for you. That's 
the main idea behind importing functions into   your code. Importing functions allows you to gain 
access to libraries of functions that other people   have already made for you. This is just as useful 
as it sounds. There are so many functions that   are super useful for any given program, that it 
will take you forever to write them all yourself.   Luckily, other people have already done most 
of this for you. In each programming language,   you were able to use an import statement to import 
libraries of functions into your program that you   can use as you write it. A library is simply a 
collection of functions that all have the same   theme, and maybe a math library, a data analysis 
library, a library that was translated text,   or anything you can think of really, there's such 
a variety of libraries for any given language that   most functions you require that are not hyper 
specific to your program can likely be found   at some library. In fact, a good portion of any 
programmers job is looking online for packages,   which can make his or her job easier, instead of 
hand writing functions. Now I can hear you saying,   Wow, that's sick. How do I do it? Well, it's quite 
simple, an import statement. In most languages,   an import statement consists of three parts. The 
library you would like to import from the package   you would like to import from that library, and 
then which class from that package you would   like to use. For example, we can load up the Java 
library. And from there import the util package,   short for utilities. And then from that utilities 
package, import the scanner class, a class which   allows us to read information from the user. A 
package is simply a smaller set of functions and   methods to help differentiate between the 1000s 
of methods contained in a library, and a class is   even more specialized than that. Now, if you don't 
know what specific classes you're going to want to   pull methods from, you can use a start import all 
classes within the package you'd like. However,   it can be beneficial to be more specific, 
and only import the classes you would like,   as it helps with the efficiency of the program in 
the long run. For instance, in Python, the syntax   to import a library is import followed by the 
library name. However, importing an entire library   is more computationally taxing than importing 
specific functions from a library. Imagine you   would only be using the factorial function from 
the Python math library, it would be a waste of   computing power to import the entire library, and 
it would increase the load time for your program.   For smaller programs, this isn't a big deal. 
But it really starts to add up when dealing with   larger projects. Therefore, you would instead use 
from math import factorial, or the Java equivalent   import java dot math dot factorial, and now have 
access to that one math command only. This limits   the functions that you can use. However, it saves 
programming runtime, if you decide you want to use   another function that you hadn't planned for, 
you can always go back and import that too.   Many times. If you try to use a function from a 
common package, and you have not yet imported, the   ID, he will prompt you to do so if you're trying 
to figure out which libraries you want to import,   think of the functions you're going to need in 
your program, perform a simple Google search. And   you will probably run into a package or library 
that already exists in your ID that you can use.   And if you can't, there are ways to download and 
import additional projects to fit your needs. But   what if, after all that you still can't find a 
library that contains the function you're looking   for? Well, that's a perfect segue into what we're 
going to talk about next, which is the basic   structure for writing your own functions. So at 
this point, we've talked about both what functions   are and how we can get some very useful functions 
by importing them through packages. But there are   definitely going to be moments in your programming 
career where you're going to want to make your   own functions because you want one to be made 
specifically to your program in code. Luckily,   making your own functions is extremely simple. 
There are just some basic rules that I want to   cover. Now we've previously used making functions 
as an example. For other topics such as the Player   Stats function from a little bit ago, they were 
extremely abstract and didn't go into depth   into what is needed for an actual function to 
operate. So right now, we're going to be covering   a skeletal system of everything that needs to 
be included in a function in order to get it to   work. Now think back to the four different types 
of functions that we talked about previously,   functions that do and don't return values 
and functions that both do and don't take   in arguments. For creating your own functions. 
We're just going to have to go down the list and   talk about how to approach creating each one of 
them. Starting with the most basic of the bunch,   one which takes in no arguments and returns no 
values. Before we start that there are a few   small things I want to note about function naming 
conventions, the variable naming conventions we   talked about previously. also translate over 
to function names. So you can't have two word   functions, and you can't use special characters 
like periods or commas. Generally, you're going   to want to follow the same camel case style, 
which we talked about in the variables video,   which is not capitalizing the first word, but 
capitalizing each word after that. Alright,   so in general, for making functions, each language 
differentiates on how you tell the computer,   that it's actually a function. In Java, you have 
to define the function scope, which is something   you don't really need to know unless you're going 
to become more invested in Java. But basically, it   tells the computer which parts of the code can use 
the function in which type can, for this series,   all of our functions that we make are going to 
be public. From there, you then determine which   type of function it is. So in this case, since 
it won't be returning any variables, we'll just   put void to signify this type of function will 
not be returning anything. Finally, you put the   function name after those two identifiers, along 
with a set of parentheses after it like so, the   parentheses are where your arguments would go, if 
you were making a function that took in arguments.   But since for our first type of function, we're 
not incorporating arguments into this function,   let's just leave those blank. All of that 
is just for Java, Python, on the other hand,   all you have to do is put the word def, short for 
define, and then the function name with a set of   parentheses. So as you can see, each language is 
going to be a little bit different in how you make   functions. But the main thing we want to remember 
is to always add parentheses. From there, we just   have what we want our void function to do within 
the confines of the function and close it off,   and we're done. In Java, the confines of the loop 
would be whatever is contained within the curly   braces. And in Python, it would be until you are 
no longer indented. At its core, this is the most   primitive type of function, we've made. Something 
which takes in no arguments and returns no values,   quite similar to the print stats function from 
early on. Moving on to the next type of function,   creating a void function that takes in arguments. 
Now this process is going to seem very similar   to the previous except for one small adjustment. 
Remember the parentheses that I mentioned earlier?   Well, we put any variables, we want the user to 
pass into the function into these parentheses.   And then when we call that specific function, 
it will be required to have those variables   passed into it. For example, in Java, let's make a 
function that takes in two numbers and prints out   the product of those numbers. We start with the 
public void plus name of function setup again,   since we won't be returning any values, and 
here comes a new part. Inside the parentheses,   you define which type of variables you would like 
to pass in as arguments, in this case, an integer   and then a name for that variable. This name is 
what you will use to refer to the integer that the   user passes in. For example, let's just call it 
num one. Then if we want to add another argument,   we simply add a comma in between the two and 
we can make another integer variable num two to   hold the second number. We can do this for however 
many variables we want to pass into the function.   But for now, let's close off the parentheses 
and just print out the product of num one and   number two, as you can see, we refer to the two 
numbers that the user will input into the function   has num one and m two, whatever numbers that the 
user passes into the function will be converted   into num one and m two. Now, whenever we want to 
call the multiply numbers function, we just have   to make sure that we are putting two numbers 
in as arguments. In this case, the number five   becomes num one and the number eight becomes num 
two. From there, we simply run the code and the   number 40 is printed to the console. It's pretty 
important to note that you can also mix and match   variables when making arguments. So you can have 
some function which takes in a car, an integer,   and two strings all within one function. The last 
thing I want to mention about arguments is that   when you call a function, you have to follow the 
variables you defined when making the function. So   for our multiply numbers function, you couldn't 
put in a string and then an int, it has to be   two integers, because that's what the computer is 
expecting to be passed into the function. So now   that we've gone over how to make functions that 
don't return variables, we have to cover those   that do. And we'll start with ones that don't 
take in arguments. Now the main difference between   defining functions that return variables and 
defining ones that do not is that in some cases,   you have to specify that you want this function to 
return an integer variable. This is most common in   Java, where you would replace void with int to 
tell the computer that you want this function   to give you something back to you in the form of 
an integer. This works the same as if you wanted   to return a string care or even in an array. 
You simply replace the word after public with   whatever variable you want to be returned by that 
function. The most important thing to remember   about making functions that return variables is 
that no matter what path your code takes, it must   return a variable no matter What? What does this 
mean? Well, let's say you had some string function   in a game. And inside of it, there was an if 
statement where if the player score was above 10,   you returned a congratulatory message. This works 
fine if you printed the result of this function,   and the player score is above 10. But if the 
player score was less than 10, then you don't   enter the if statement, and then you don't have 
something prepared to be returned to the user.   And so the function is going to throw you an 
error, you have to have all your paths covered,   which may seem simple. But if you're making a 
function with a switch statement in it containing   high amounts of cases, then this can get out of 
hand very quickly. Something I like to do to make   sure this doesn't happen is put a return statement 
at the bottom of a function with a string or an   integer so unique that I'm able to tell that the 
code is not running properly and can fix it. Also,   usually, an ID will let you know if there's a path 
in your code or in a function that does not return   a variable when it should. The main point I'm 
trying to get across however, is always cover your   exits and make sure you have a return statement 
prepared for any case the user may throw at you.   Another small thing to note is that you can't 
return one type of variable if you've already   defined the function to return another type. For 
example, you can't return a string and an integer   function or vice versa. The return statement must 
always match the type of function no matter what   the final type of function is one that returns 
variables and also takes in arguments. And   for these, all you need to do is combine what 
we've learned from the previous cases. First,   you assign your arguments in between the 
parentheses making sure that you've also defined   what type of variable you want to return, and then 
ensure that no matter what path the code takes,   that you're always returning that variable type. 
That concludes our discussion on functions. As you   can probably tell, functions are an extremely vast 
subject area, and require a little bit of practice   to fully understand, which is why later on in this 
series will recommend some websites you can use   to practice those more difficult topics. Now, I'd 
like to switch gears a little bit and continue our   discussion from earlier on arrays. arrays, while 
useful aren't the only way to store and manipulate   information. In fact, there are a multitude of 
different ways to store data in computer science,   including linked lists, stacks, queues, maps, 
trees, and many others to right now though,   I'd like to talk about two cool, wacky and zany 
ways to store data that we haven't previously   covered, array lists and dictionaries. But before 
we get into those, let's get a little review and   reinforcement of arrays. As you may remember, 
arrays are basically lists of values that are   stored together. When you initialize an array, you 
give it a size and this size is fixed, you won't   be able to increase the size of the array. So when 
you make an array of length is final. To access   the values in an array, you reference them using 
an index for starts at zero. What this means is   that the first item of an array is not at position 
one, it is that position zero. And its position is   commonly referred to as its index location. So to 
find the nth item in an array, you would refer to   it as index location n minus one. However, as the 
size of an array is fixed, you have to be careful   to not reference a position that's beyond the 
total size of the array, or to append too many   items to it. As this will return an error. We also 
have what are known as two dimensional arrays,   which is an array containing an array and each of 
its indexes. Or you could have an array containing   arrays containing arrays containing arrays 
containing arrays, depending on what you're trying   to do. multi dimensional arrays can be useful 
in more advanced programs for organizing a wide   volume of related values. If that's confusing 
at all, just get back to earlier for our full   discussion on arrays, the timestamps will be in 
the description. Now that we've reviewed arrays,   let's go over array lists. Array lists are just 
lists in Python can be thought of as a growing   array. Earlier, we mentioned how you have to be 
careful to set an appropriate size of your array,   and to make sure that you only referenced in the 
pin values such that you remain within the size.   However, with array lists, this isn't a problem. 
After you initialize an array list instinctively   has a size of 10. What if you append values, such 
that the size of the array list goes beyond 10   elements, an array list will grow itself, meaning 
that the computer will allocate more memory to   the array to increase its total size so that the 
new values can be appended. This is quite useful   when you don't know the exact number of values 
that the array will need to store. Or you want   the ability to store more values to your heart's 
content. such as when you're making a database   with an unknown amount of users that will sign up. 
There's a lot more to uncover when regarding array   lists. But for this surface level series, that 
is all you pretty much need to know. So let's   move on to dictionaries. Now when we're talking 
about dictionaries, we're not referencing that   thick book you probably have lying around your 
house, which has 1000s of definitions. In computer   science. dictionaries are like arrays in that they 
store multiple values. Use, however, their values   are stored very differently. Rather than being 
referenced by their linear position within the   dictionary, each value is tied to another value 
that is used to reference it, or its key. Because   of this, we need to throw away all conceptions 
of dictionaries as a linear way of looking at   data. Since in actuality, it is much more fluid 
and entertaining. Basically, we say that each   position in a dictionary holds a key value pair. 
When referencing a value in a dictionary, you   will use its unique key, and the dictionary will 
tell you the value that it is tied to think of it   like this. Each time when item to your dictionary, 
your computer creates the handcrafted box to store   the data. And also a custom makes a jewel key one 
of a kind, no other like in the world. This way,   there's only one key that goes to the box 
that stores a certain bit of information.   Because each key must be unique, we're using 
the key in a dictionary, it will result in an   error being thrown. Because having two keys 
that are exactly the same will confuse the   computer as to what box or piece of information 
that key leads to. However, you can store the   same value in multiple key value pairs since the 
keys would all be different. Now, like I said,   dictionaries are more fluid, making them easier 
to organize and then arrays as everything is set   up in a more logical manner. That is to say, 
it is easier to find the value you are looking   for when you're using keys, rather than simply 
referencing their positions. Let me explain what   I mean. Imagine you have a dictionary of prices at 
a store where the key is the name of the product,   and the value is the price of the item. Maybe 
apples cost $1 milk costs $2 and bread costs $3.   You can see the in the dictionary, each key is the 
name of a product, and each value corresponds to   the price of each product. So to find the price 
of bread, all you need to do is simply call the   dictionary using the key bread. This makes it 
extremely easy to track values through your code.   Since you're working with tangible values rather 
than numbers which don't mean anything to you. You   can also manipulate dictionaries and money the 
same way as you can manipulate arrays and array   lists. You can iterate through a dictionary and 
perform many operations and comparisons on the   values. If you want to find the product with 
the highest price for example, you can iterate   through the dictionary to find the value that is 
highest amongst the grocery store items. arrays,   array lists and dictionaries are useful in their 
own right, as are the mass amounts of other ways   to store data, and each boasts certain advantages 
over one another. We already covered the basics of   these three. But since there are so many, we 
don't have time to go in depth into each and   every one of them. And so in order to help you 
grasp the basics of storing information, we're   now going to talk about one of the most important 
functions needed to understand arrays, which are   searching algorithms. Now just as there are many 
ways to store information in computer science,   there are even more ways of searching through 
lists. Searching algorithms at their core are   ways in which we can look through a list of values 
stored in an array, say a patient name list or a   high score list and find a particular piece of 
data. The goal of a searching algorithm is simply   to give the algorithm a string or object you 
want it to find and have it return the index of   the array that contains that string or object as 
fast as possible. Now while this may seem simple,   lots of software runs on the backbone of being 
able to search through lists extremely quickly,   making searching algorithms and in particular, 
efficient searching algorithms an important   topic to cover. Additionally, this is the main 
functionality that arrays are used for. And it's   the backbone of many of the methods used within 
ArrayList as well as many other storage methods.   So knowing them will take you a very long way. 
Typically, searching algorithms are used to return   the index of a particular data points so that 
it can be used, modified or updated or checked   on. For example, if you're about to check into 
a hospital run on an array system for patients,   the staff must search through your name in the 
database. And by returning the index of where   your name is, they now have a quantifiable number 
that they can use to easily check you in, rent out   prescriptions schedule you for checkups, update 
your personal information, etc. Without having to   search through the list for your name every single 
time. You may think that there's little difference   between searching algorithms since computers 
nowadays can perform millions of calculations   per second. But when you're a huge multi billion 
dollar corporation trying to find a certain data   point in a list containing 1000s, or even millions 
of data points, small differences in efficiency   are going to make or break the user experience. 
Even a 1% improvement in efficiency can mean a big   differences in the amount of time that a user is 
waiting for a simple task. Now before we jump into   different types of searching algorithms, we must 
discern between the two states that a razor list   can be in either sorted or unsorted. A sorted 
list of information is characterized by some   sort of rankl value, whether that be a patient ID, 
credit card number, or even by alphabetical values   like usernames or legal names. An unsorted list is 
just some random assortment of related information   not sorted by any particular order or reason. Some 
searching algorithms only work for sorted lists,   usually the more efficient ones, and some work 
for both sorted and unsorted lists. Although these   are usually less efficient if you end up pursuing 
computer science further, you'll have to deal with   both sorted and unsorted lists. So it's good to 
know a common searching practice for both. Another   thing to note is that we determine the efficiency 
of searching algorithms, based on both the worst   case scenario and the average number of items 
that must search in order to find the index. We   call this big O notation in which each searching 
algorithm has an equation which takes in the size   of the array as an integer and, and will output a 
worst case scenario efficiency value that we can   use to compare with other searching algorithms. 
We can then also look at how long on average it   takes to find an element in a list. Using these 
two methods allows us to easily compare how   efficient two algorithms are. Alright, now that 
we've got some background on searching algorithms,   let's hop right into it. The first type of search 
we'll be talking about is called a linear search.   And Eve honestly probably uses multiple times 
throughout your life. Every time you have to   search for your name on a list of people, you 
probably follow the same pattern, you start at   the top check to see if the first name on the list 
is yours. If it is great. If not, you move on to   the next name on the list until either you find 
your name or you don't in which case you leave.   A linear search works in the same way, you start 
with the first element in the list compared to the   value that you're trying to find. And if they're 
the same, you found your match and you return the   index of that element. And if not, you move on 
to the next element in the list until you either   find the thing you're searching for, or you run 
out of lists to check. Pretty simple, right? This   is because linear searches are pretty bad when 
it comes to efficiency, especially in the worst   case scenario. If the item you're searching for in 
the list is the last element, you're going to have   to check the entire list of items before you find 
the one you're searching for. On average, however,   you're going to get it about halfway through the 
list. This makes the linear search oven worst case   scenario since in the worst possible case, it will 
take the entire length of the array or n to find   the correct value. But linear search on average 
will return the correct index in O of n divided by   two. We're halfway through the list. Now while the 
linear search is in great, it can work with both   sorted and unsorted lists, because of the fact 
that it will eventually cover every element in   the list. The other search we're going to cover 
requires the list to be sorted, which may seem   like a drawback, but having a sorted list allows 
you to use algorithms that are far more efficient   than the linear search. So overall, the linear 
search is a good basic searching algorithm for   if you have an unsorted list. But if your list is 
sorted, there are way more efficient options out   there for you, such as the binary search, which 
we'll be talking about now. The binary search uses   a recursive process to break the data in your list 
down into more and more manageable bites. Taking   advantage of the fact that it's sorted in order to 
find the item you're looking for faster. This one   is much harder to wrap your head around. So let's 
start with an example. Let's say you have a list   of 10 names sorted alphabetically, like shown on 
the screen now, and you want it to find your name   within that list. in binary search, you would look 
for the middle most name, in this case, the one at   the fourth index. Just a quick aside, since there 
is no true middle since the list is 10 names long,   the computer automatically uses the next one 
down as the middle value. Now, once you find your   middle value, you first check to see if the name 
you're searching for at the index you've chosen is   the name that you're looking for. If it is you 
simply return that index. But 99% of the time   it's not going to be including right now. So let's 
keep going. If the value at the middle name is not   equal to the one you're searching for, you check 
to see if the value you're searching for comes   before or after the middle index. For example, 
if you were looking for the name Brandon, and   the value at the middle index was Carl, Brandon 
obviously comes before Carl alphabetically. And   since we know that the list is sorted, what we 
can now do is ignore the entire bottom half of the   list and just focus on the top. Since we know that 
if Brendon is even in the list, it's going to be   in that top half. Now we simply treat the top half 
of the list as an entirely new entity and repeat   the process over again. Again, we would find the 
middle most element of this new list of names and   again compared to the name you're trying to find. 
If it's the name we're trying to find we return   that index, but if not, we compare it to see if it 
comes before or after the middle index. Going back   to our example. Let's say the middle index of this 
new list is AJ. Now we know that Brennan comes   after AJ alphabetically. So what we can now do 
is ignore the top half of the list. Since we know   that if Brennan is in the list, it's not going 
to be in the top half of our list. Now we again   repeat this process again and again until we find 
the name we are looking for. So if For example,   the middle index is time is Brenden. And that's 
what we're searching for. So finally, we would   return the index to in binary search. Eventually, 
the index we were compared to our search term   will be the same. And once it is we can return the 
index and move on. Now if we don't find it, which   happens after we have eliminated the entirety 
of the list without finding our search term,   the algorithm will simply return a null value to 
let you know that the item you're searching for   cannot be found in the list. The binary search 
is way faster and more efficient than a linear   search. Since we are drastically cutting down the 
amount of elements, we have to look at making the   program run faster. In almost 99.9% of cases, in 
which your list is sorted, the binary search it's   going to return a result faster than the linear 
search. So if you have a sorted list, your best   option is to go for binary. As for efficiency, 
the binary search is O log n for the worst case   scenario, which could be confusing if you don't 
fully understand logarithms. But all you need to   know is that it is way more efficient than the 
linear search. Its average scenario is actually   also o log n as well, which again, is infinitely 
times more efficient than linear cases. Now while   there are other types of searching algorithms you 
can use, these two are the most common for both   unsorted and sorted lists. So we will stop there 
for now. Up next, we're going to be covering one   of the most confusing and important topics in 
computer science recursion. Let's start with   the most important question, what exactly does 
recursion mean? in programming recursion refers   to functions that repeatedly call themselves 
meaning that any instructions that occur within   a function, one of the instructions will be a call 
to that same function you're already in. In the   extremely primitive example, on your screen. 
Now, you can see we have some function which,   in the confines of itself, calls itself, a 
recursive function will usually take into account   some integer as an argument. And we'll use this to 
carry out some instructions, modifying the integer   that was entered before calling itself again 
with a new integer as its argument. To better   understand these functions, let's discuss the 
basics of how we go about programming one of them.   A really good and easy example of a recursive 
function is one which sums up all numbers from   one to n. So let's make a recursive function 
that does just that. The first thing we need   is the actual function. And we're going to make 
it an integer function, which takes an integer   and as its argument, the reason we do this will be 
explained later. But for now, let's move on to the   base case. A base case is simply a definite value, 
which all recursive statements are the ones that   are being repeatedly called as we go through the 
function tried to get towards at the beginning of   the function, we test the value that was passed 
in by the argument against the base case to see   if it is satisfied. Usually, these base cases are 
some requirements like of n as I described before,   which has a certain value or is equal to a 
certain value, it is extremely important that   the base case is set to some requirement that and 
will eventually meet for the same reason that it   is important to avoid an infinite loop. We do not 
want a Stack Overflow error to occur. For example,   if our base case, what's the stop calling the 
recursive function when n was greater than 100.   And if it is not, we will call the same function 
again. But with n minus one. And we started with   ns, say 99, we would never reach the base case 
and the recursive functional or purely call itself   over and over again, subtracting one from n and 
hoping that somehow it will eventually be greater   than 100 until your computer crashes. Not fun. 
So anyways, back to our recursive some example,   let's make our base case when n is less than 
or equal to one. This way when you start at   some positive integer and and subtract from 
it until it is less than or equal to one,   in which case we can exit the recursive statement. 
Cool. Now, if n is not less than or equal to one,   what we want to do is return the sum of both n 
and then the returning value of our recursive sum   method minus one. Why do we add and the function 
call? Well, let's actually go through the function   as if we were at the computer and see why we start 
with a call of recursive sum with n equals three,   we know that three is not less than or equal to 
one. So now we tried to return a recursive sum   of n, which is three and the returning value of 
recursive sum within n of two. We don't know what   the returning value of recursive sum with an N 
of two is. So we have to go through the function   again, only this time and is two again, and is not 
less than or equal to one. And so this function   will go through the lF statement and return to 
plus another recursive statement, in this case,   the returning value of recursive sum with an 
N of one. So once again, we have to go through   the recursive sum function to get that value that 
will be added to two and then returned and added   to three And then returned, hang in there, we're 
close now in this function, and is less than or   equal to one, and so we return n, which is 
one. Now we take that n, which again is one,   and that is what gets added to to the previous 
function call, and then return. So this would   return three. Now, this three is what gets added 
to the first function call, which is three, and   so it becomes three plus three, which is six. And 
finally, after all that time, we get six return   from the function, which if you've been following 
along at home, three plus two plus one is indeed   six. Now this may seem like a waste of time, since 
three plus two plus one is not a hard operation.   But those of you saying that I asked you to please 
give me a sum of all the numbers from one to 3567.   Godspeed. Now recursion is a very difficult 
concept to wrap your head around. So if you're   not 100% comfortable with it at the moment, feel 
free to rewatch this section of the video in order   to better familiarize yourself with it. Alright, 
cool. Now that we have a little background on   recursion, let's talk about why it works so well. 
Now to understand why and how recursion works,   we must first understand what a stack is. A stack 
is a data structure that contains all of the tasks   you instruct your program to complete. Based on a 
certain method, your program will then carry out   the tasks you give it is called a stack. Because 
if we start another process before the previous   one completes, the process is stacked on top 
of the other one, such as the animation on your   screen is showing now, programs we write will 
follow the LIFO structure. For those unfamiliar   with accounting LIFO means lastin. First out, or 
the last item put on the stack will be the first   one removed from it. Essentially, every time you 
ask your computer to complete a task, that task is   added to the stack, and will be the first one to 
be resolved. Think of it like a stack of stones,   you can keep adding stones on top of your pile. 
But in order to get to the one at the bottom,   you must first remove all the rocks on top of 
it. Now when your functions continually cause   itself without end, without a base case, like in 
our infinite loop example, then this stack will   never be resolved, as items will be continually 
added to the stack without any of them ever been   completed. In this case, the memory allocated 
to the stack exceeds the maximum allowed and   a Stack Overflow error occurs resulting in your 
program crashing. Think of this as if you're doing   chores. And before you complete one chore, you 
get called to do another chore. And then before   you can complete that one, you get called to do 
another one. Since you keep stacking tasks, or   shores on top of one another, the stack of tasks 
will never be completed. And you will probably   die before ever finishing all of your chores. 
This is the same logic that makes infinite loops   crash your program. recursion works on these same 
principles. The initial call makes a second call,   which is added to the stack. And now that one 
must be taken care of first. But in that one,   another function is called which gets added to 
the stack, and so on until you reach the base   case and what you slowly start going back down 
the stack. In conclusion, recursion in general   is extremely useful, because by calling the same 
functions repeatedly, it breaks down the problem   into smaller sections, and results in the program 
being more efficient. small parts of problems are   easier to solve and less taxing to compute than 
the entire problem at once. And the computer can   combine these small solutions into the whole 
solution at the end. Now as we wind down our   introduction to programming series, we want to 
take some time and go over some of the soft skills   needed to be successful computer scientists. 
Since it's not all about writing code. In fact,   many professional computer scientists will tell 
you that the majority of their job is spent   thinking about code rather than actually writing 
it. This is because much of programming boils   down to problem solving. How do we optimize the 
system? How can we make this feature for our app?   What type of movement Do we want for our game? 
And how can we program it? The harsh truth is   that no good program has ever been written simply 
from the programmer, getting the prompter idea,   sitting down, hopping on an ID and starting to 
write code. There are many tasks we should go   through beforehand in order to plan out our code. 
So we ensure that when the time comes to program,   it's a clean and easy process and not riddled with 
mistakes and bugs. This is where pseudocode comes   into play. Think of pseudocode like this, if you 
wanted to take a family trip to the Grand Canyon,   would you simply hop in your car and drive off and 
figure out things later? No, because that would be   ridiculous. Instead, you would spend some time 
planning out the trip. What sites or places do   you want to visit? What hotel reservations are you 
going to have to make? What kinds of things are   you going to do when you get there? What routes 
or highways are you going to take and why? All   of these things must be determined before you can 
even think about hopping in your Ford Explorer.   So how does this translate to pseudocode? 
Well think of our family trip to the Grand   Canyon as a program, programmers use pseudocode 
pseudo meaning not real, and code, meaning code   as a means to plan out their programs before they 
write them. Just like how we planned out our trip   before going. They throw away syntax and naming 
conventions for variables and just focus on what   they want the program to accomplish, and how they 
plan on doing that. pseudocode is very similar to   constructing an outline for a paper that you're 
writing, you write down the main topics of the   essay, and plan out your major talking points. 
But you don't worry about the nitty gritty   details of it all, such as word choice, grammar, 
conventions, and proper formatting. By doing this,   we allow ourselves to think freely and not worry 
about stressing the small stuff, at least not   yet. Alright, now that we know what pseudocode is, 
let's talk about how we write pseudocode. You see,   the best part about pseudocode is that it can 
take the form of many different things for many   different people. Each computer scientist 
has their own methodology for planning out   their code. And there are probably hundreds of 
different methods of writing pseudocode that   are out there today. Today, however, I'd like to 
focus on three popular ones that I think you might   find to be extremely useful. The first of these 
is known as flowcharts. And mainly they can be   used to think through the process of a particular 
function. a flowchart is fundamentally a graphical   representation of a function and how it might 
flow. Many programmers do this and lay out the   conditional statements and loops that they want 
as different blocks in the flow chart connected   by arrows and charting out every path of their 
function. From there, it's extremely easy to   create test cases and follow them through the flow 
of the function through the different blocks and   arrows. For example, we could have a flow chart 
that goes something like this, a user enters in   a number, and if the number is eight, I want the 
program to return true. However, if the number is   not eight, then I want it to return false. It's a 
great way to visualize what the functions overall   purpose is, and also look for any errors that you 
may have missed when thinking about the function,   such as a missing path. It also abstracts the 
programming statements up to simple blocks,   making it easier to modify or change completely. 
The best part is that when you have finished   testing cases, you can simply convert the blocks 
into programming statements, and you have a well   written function without any debugging. Another 
popular pseudocode technique that is often used   is to simply write out what you want your code 
to do chronologically. don't necessarily think   about what programming statements and functions 
you want to use. just jot down from start to   finish what it is the program you're writing 
is going to do step by step. For example,   let's say you're making an app that takes in two 
numbers and divides them. The pseudocode for that   would look a little something like this. First, 
I want to prompt the user to enter a number. And   then I want to wait for the user to enter in that 
first number. After I get the first number, I want   to again prompt the user to input a second number. 
Once they do, I complete the operation by defining   the two numbers entered and returning the result 
back to the user. This all seems like it would be   common sense. But remember that oftentimes, we're 
not going to be working with simple multiplication   or division functions. We may be working with full 
scale games, algorithms or user interfaces with   many different options. This method allows you 
the programmer to not get bogged down with the   syntax and conventions that you have to follow, 
you're simply making a note of what the program's   ultimate goal should be, as if you were explaining 
it to a friend of yours. This method really lets   you plan out everything that needs to happen in 
your program in order for it to run smoothly.   It also ensures you don't forget about a piece of 
an algorithm or a certain function that you need   to write in afterwards. And the final pseudocode 
strategy that I'd like to talk about to you today   is writing out the main features you want the 
user to have when using your program, and what   functions or smaller programs, you're going to 
need to complete these features. Let's do another   example. Say you're making a banking interface. 
And on startup, you want the user to initially   have two options, they can set up a new account, 
or log into an existing account. From there,   if they log into their account, then you want 
them to have the functionality to withdraw money,   deposit money, take out a loan or pay back a 
loan. If they decide to set up a new account,   you want them to be able to create an account, 
store their information in a database, and then   access all of the features that are returning 
member would have. This may look very similar   to the flow chart method. The only difference 
being that this is abstracted one level higher   over an entire program, rather than just a single 
function. If you really wanted to, you could also   create a flowchart that would go through the 
functionality of all the four methods described   above. Setting up a hierarchy like seeing on your 
screen now makes it easy and clear to see every   function interface you're going to have to make. 
This prevents you from having to try to shoehorn   a function or feature into an already finished 
program at the last second, which is not a very   fun experience in the slightest. So There you have 
it three pseudocode strategies you can use to plan   out your code before you even start writing any 
the flowchart method, which is good for thinking   through the flow of a certain function. The write 
up method, which is good for getting the general   idea down for a program, or the functionality 
planning method, good for listing out the   functions of a certain programs, you can use 
all of them, none of them are a mixture of them,   or even disregard these and find and create your 
own pseudocode methods. The main goal here is   to drastically minimize the amount of errors that 
occurred during your program and relieve a lot of   stress on your head. The importance of pseudocode 
cannot be stressed enough. And if you don't   believe me, I urge you to try to complete a large 
project without it. Okay, so if you've watched the   series up until this point, you've gotten a pretty 
good understanding of many aspects of programming,   and also how to plan out your programs. Now it's 
time to go out into the real world and write some   actual code. But what kind of program I can hear 
you asking me? And the answer is truly whatever   you want, really, as I'm sure you know, by now, 
you can program just about anything you have on   your mind. Anything from simple games to complex 
software. This video has equipped you with the   basics that are going to need to be used in pretty 
much any program you decide to write. But that   doesn't mean that every programming language is 
perfect for every application. Each language has   its own strengths and weaknesses. and choosing the 
right one is very important for making it easier,   and sometimes just even possible for you to 
program what you want. So that's what we're   going to be talking about now, choosing the best 
language for what you want to accomplish. Now,   we talked earlier about low level versus high 
level programming languages. In case you forgot,   let's do a quick refresher. higher level 
programming languages have a higher level   of abstraction from machine language, that 
series of zeros and ones from way back when,   while lower level programming languages have a 
low level of abstraction for machine language.   For example, block program where you can drag 
and drop programming statements together like   2d Legos would be a high level language, as it 
does not take a high level of understanding of   the inner workings of a computer to programming. 
The theoretical highest level of a programming   language would be if I could just write down what 
I wanted the computer to do in Simple English,   and it would just work. But sadly, that doesn't 
exist yet. On the other side of the spectrum,   the lowest level programming language would be 
just feeding zeros and ones into the computer at   supersonic speed, which would be almost impossible 
and extremely absurd. So how do you choose   what type of language is best for your needs? 
Well, it depends on what you are trying to do,   as sometimes you need very specialized languages 
to get done what you want. The world of computer   science is vast and contains many fields. So 
trying to cover everything in one language would   be impossible. This has led to the creation of 
hundreds of different programming languages, each   designed for a specific task. Right now though, 
we'll cover some of the most popular languages   and their uses. Now, if you are trying to design a 
website, using HTML and CSS is probably your best   bet. HTML is a markup language that is designed 
for writing the content of a website. While CSS is   great for designing the style of the website. you 
interact with HTML every day. And you can even see   it right now. If you right click and hit Inspect 
Element. This will truly show you how complex HTML   and CSS can be. Maybe it would be best for you to 
use a scripting language. A scripting language is   a language that has many commands for you to use. 
And that can also be run without needing to be   compiled. Scripts can be faster to write in most 
programs, and tend to be easier to port between   operating systems allowing for cross platform 
support. Scripts can also be used with websites,   oftentimes adding to the overall user experience 
of the site. If you want to go into web design,   this might also be a path for you to go down. 
Examples of scripting languages are Perl, PHP,   Ajax, and JavaScript. For most programs, you 
could probably use a general purpose language.   General Purpose languages, as they sound 
have a wide range of applications. Usually,   these should be your go to languages. Examples 
of general purpose languages are Java, c++,   and Python. They each have their own different 
benefits over one another. Java is very useful   for developing games and interactive web pages. 
Python can act as a scripting language for web   programming, as well as writing applications 
and data analysis. And c++ tends to be used for   writing applications and system programs. They all 
have a variety of packages that you can import and   use to achieve the functionality you need from 
them. while selecting the right general purpose   language for your big projects is very important. 
For most of your programs, any one of them will   work. It really comes down to preference. Get to 
know each language and decide which ones syntax   rules you like best and find most comfortable. 
If you get to know one general purpose language   really well and enjoy programming with it, you 
can apply it to just about any of the programs   you plan on writing. Personally, I tend to use 
Python for most of my projects. This is mostly   not due to any functional difference between 
Python and any other general purpose language,   though there are a few, but it is mainly because 
I find it syntax rules most convenient and easiest   to write programs with. Overall, either you 
can consider the product you plan on doing and   research and see which language boasts the most 
advantages for your purposes. Or you can simply   become comfortable with a language and use it for 
most of the programs you decide to write. will now   be looking at our final topic of this introduction 
to programming miniseries, you now have the basic   knowledge of programming, which will take you 
far in any language that you decide to learn,   you know, some good pre programming pseudocode 
strategies to help you design your code from   the ground up. And you might already have a good 
idea as to the type of programming language you   might want to start with. So what's the next 
step? How can I learn that language? And what   applications can it be used for? Well, that's 
what we're going to be covering now. So let's   just jump right into it. Starting with the biggest 
question, which is what is the next step? Well,   now that you might know which type of language 
you might be interested in, research that language   and find out whether or not you truly want to 
pursue that programming language. Most languages   like Python or c++ will have either an official 
website where you can read up on the language,   or Wikipedia page, which will provide you with 
useful information in deciding whether or not   you want to pursue that path. From there, the 
next step is to actually learn the language,   which can be done right here on YouTube. While 
we've taught you the basics of any programming   language, each specific language is going to 
expand upon these concepts. And so watching   tutorial videos on a certain language is going 
to be very beneficial. I would start with an   introduction series, like the one you're currently 
watching both for the language you've chosen and   work your way through that series, picking up on 
the syntax and rules of that language until you   become comfortable with it. Once you do that, you 
come to a crossroads. You know how to program in   a certain language, but you may be completely 
clueless as to what to make in that language.   Programmers blog can leave you uninspired and 
not want to continue programming. So I'd like   to give you a few websites to help out. First 
is coding bat, a completely free website which   has hundreds of coding challenges in both Java and 
Python to help you refine your programming skills,   and even learn some new programming shortcuts and 
tips. This is great if you want to get better at   improving your efficiency and need something to 
hone your skills as a developer. The next is coder   bite, which offers over 200 plus challenges that 
you can complete in over 10 different languages,   something that is sure to help you improve. The 
final website I'd like to talk about is hacker   rank, which not only provides programming 
challenges to keep you on your toes,   but also provides support for you using your 
programming skills to find jobs or internships.   These and many more websites exists solely to 
keep you interested in code and work on refining   your skills to become better. Now if you're a 
teenager watching this series in high school,   I also encourage you to take programming 
classes in your high school. AP Computer   science principles and AP Computer Science a are 
both amazing courses which can help you greatly   in the future, and are also incredibly informative 
and important to colleges. Your school might also   offer other classes in the field of computer 
science, including ones on key data structures,   game design, and data science. Any and all classes 
you can take to help expand your knowledge of   programming and help you find your niche is going 
to be extremely helpful. As you can see, the world   of code has now been opened up to you. These are 
just a few examples of where you can go from here.   But there are many more we didn't talk about. You 
could get into GitHub and start contributing to   projects. You could work on your own projects 
and collaborate with others. The possibilities   are endless. The next step is up to you. This 
concludes our introduction to programming mini   series. We hope you enjoyed watching it as 
much as we enjoyed making it. If you enjoyed   the series as a whole consider subscribing to 
our channel, no pointer exception, which will   be linked in the description for more content like 
this coming soon. Thank you so much for watching.

ID: https://www.youtube.com/embed/NU_1StN5Tkk?si=0yxDZc6csBMZOGuJ
Document: [Music] welcome to my ultimate design patterns course I'm mosh and I'm super excited to be your instructor let me give you a quick overview what this course is all about and what you need to know before you get started in this course you're gonna learn how to design reusable and extensible object-oriented software in order to take this course you should have at least three months of programming experience it doesn't matter what language you're familiar with you just need some basic programming experience also if you're familiar with basic object-oriented programming concepts such as classes on interfaces that will be great but not required I'll give you a basic overview of these concepts in the next section now before we get started I want to set the expectation in this course we're not gonna work on any algorithms you're not gonna see me working with loops or Eve statements or implement complex logic that is not the purpose of this course I've covered all the algorithmic topics in my data structure as an algorithms course also we're not gonna build an application instead we're gonna talk about designing object-oriented software we're gonna talk about how you should structure your classes and how this classes should collaborate our focus will be on building reusable and extensible software software that can be easily extended the techniques we are going to cover in this course are extremely important and every software engineer working with object-oriented system should master this so I'm super excited to be your instructor design patterns is one of my favorite topics and a lot of you guys have been waiting for this course for a long time so let's jump in and get started [Music] you might ask what art design patterns well design patterns are elegant solutions to repeating problems in software design for example may want to implement the undo mechanism in your application that's a repeating problem in software design right now we have a couple of different patterns for implementing the undo feature one of them is the momento pattern so a design pattern shows you how you should structure your classes and how these classes should talk to each other now in this series we'll be exploring 23 design patterns that were originally documented in the 90s in the book called design patterns elements of reusable object-oriented software the book was written by four authors that are known as Gang of Four so quite often we refer to these patterns as Gang of Four patterns the Gang of Four patterns include 23 design patterns in three categories creational structural and behavioral creational patterns are all about different ways to create objects structural patterns are about the relationships between these objects and behavioral patterns are about the interaction or communication between these objects in the first part of this series we'll be talking about the behavioral design patterns and by the way these design patterns don't represent all the patterns in their work there are many unofficial and undocumented patterns out there that you might find useful in certain situations but these 23 design patterns are the classic ones that every software engineer must understand one of the benefits of design patterns is that they help us communicate with other developers at a more abstract level for example you may tell your coworker hey we can use the command pattern to improve this code you can simply use the name of the pattern to communicate the idea you don't have to write a lot of code to express that idea another benefit of studying and understanding this design patterns is that it makes you a better designer you will learn how to build reusable extensible and maintainable software no matter what programming language you use or what kind of applications you build and finally another benefit of learning design patterns is that they help you learn and use new frameworks faster one of the questions I often get is marché how do you learn various things quickly I tell you what I'm not a genius yes I do have years of experience in fact I started programming when I was seven and now I'm 37 but one thing that I believe has helped me enormously is understanding this design patterns because I see these design patterns used in various frameworks and libraries so every time I learn a new framework it kind of looks familiar to me it's just a different syntax that I have to memorize so these are the benefits of learning design patterns unlike other courses on books that teach you design patterns like a list of recipes to follow in this course I'm going to teach you the art of designing object-oriented software so I'm not gonna give you a catalog of design patterns ordered alphabetically I'm specifically ordered the patterns in this course to teach you various important concepts so even though you can jump to a specific pattern to learn more about it it's best if you take the course from the beginning to the end because throughout the sections I'll talk about various principles and if you skip those you're gonna miss out a lot so if you want to get the most out of this course watch all the sections in order every section is short and sweet and you can watch it in half an hour or less if you have taken any of my courses you know that I don't waste your time by long slow and repetitive explanations also in this course I'll be using Java but you don't have to be a Java developer in order to take this course in the next section I'm gonna give you a quick overview of the Java syntax so you can easily understand the code we write if you use Python or C sharp or some other language you can take the concepts in this course and apply them in your favorite programming language again our focus is on the art of designing object-oriented software not a particular programming language now if you are a Java developer I still encourage you to watch the next section even though it may appear a little bit basic for you because in the next section I'm going to talk about the essential object-oriented programming concepts such as encapsulation abstraction inheritance and polymorphism a lot of developers don't really understand this concept properly so I'll see you in the next section in this section I'm going to give you a quick tour of Java and the essential object-oriented programming concepts you need to understand in order to take this course we'll be talking about classes interfaces encapsulation abstraction inheritance polymorphism and UML which is the graphical notation we'll be using throughout this course if you know Java you can skip the first video or two where I create a new project and show you how to work with a class but I highly encourage you to watch all the other lessons especially the lesson about interfaces because interfaces are one of the most misunderstood concepts in Java and in many programming languages also make sure to watch all the other lessons such as encapsulation abstraction inheritance and polymorphism these are extremely important I want to make sure we're on the same page and you really understand what these concepts are if you don't understand these concepts properly you're not going to be able to understand design patterns so let's jump in and get started all right in this course I'm gonna use IntelliJ which is a very popular Java IDE but you can use any ID that you prefer if you want to use IntelliJ and code along with me we can get it from jetbrains comm slash idea slash download it comes in two editions ultimate which is paid and community which is free and open source here in IntelliJ let's create a brand new project so we select Java on the left next we select create project from template we want to create a command line application next we shall give this project a name let's call it design patterns over here we should specify the base package name a package in Java is a container for one or more classes in some languages like C sharp it's called and namespace so here we should type the base package name by convention we use the reverse domain name my domain is code with match calm so here we have calm that code with Marsh this is just a convention it doesn't mean you should have a domain name registered on an Internet you can type anything here okay all right as you can see every Java project has this main file main dat Java and in this file we have a class with the exact same name this class is declared in this package comm that code with wash so the package statement on top of the file determines where this class is going to be defined okay now in this class we have a method called main both this method and this class are declared as public this means they're accessible anywhere in this codebase we'll talk about this later in this section now the main method is declared as static this means we can call this method directly without having to create an instance of the main class void is the return type of this method which means this method is not gonna return a value and here in parentheses we have the parameters of this method in this case we have a single parameter which is a string array called args if we execute this program from the command line and pass a few different arguments we can capture those arguments using the string array okay now in Java we use curly braces to represent a block of code and by convention we put the left brace on the same line in some languages like C sharp we put the left brace on a new line but this is unconventional in Java so let's bring it back where it was so this is the basics of a Java program next I'm going to show you how to create and use classes all right let me show you how to work with classes so in the project window we expand the project folder here we have the source folder this is where we have all the source code for this project and it's folder we have our base package which contains the main class now we right-click the package name and add a new class we're going to call this user in this class we can have filled or attributes for storing data and methods let's declare a field for storing the users name so public string name and we terminated with a semicolon so in Java we terminate our statements with a semicolon now technically this is a bad practice to declare fields as public I'm going to talk about this later in this section for now let's declare everything as public so string is the type of this field and it's called name now we can go to the main class and create a new instance of the user class so we type user user equals new user so we're declaring a variable called user the type of is variable is our user class and here we're setting this to a new instance of the user class once again we are terminating the statement with a semicolon now using the dot operator we can access the field and methods in this class so we can set the name field to Marsh and once again we terminate this with a semicolon note that in Java we use double quotes to surround strings now we can print this field on the terminal so we have the system class this class has a field called out this is an object that has a method called print line this is like console to write line of c-sharp now here we can pass user that name and then we can run this program using ctrl + R there you go so here's my name on the terminal beautiful now we can specify the name when creating a new user so we go back to the user class we add a constructor a constructor is a method that gets called when we create a new instance of a class so here we type public then we type the name of the class and then we had parentheses this is where we can declare parameters next we add our curly braces so let's add a parameter here called string name now we can set the name field to the value of the name parameter however both the parameter and the field have the same identifier so if we type name equals name the Java compiler thinks we're referring to this name parameter so on the left side we should prefix this with this dot so we're saying set the name field of the current object to the value of the name parameter so this is a reference to the current object if we type this dot we can see all the fields and methods in this class okay now back to the main method when creating a new user object we can pass the name we don't need to set it explicitly and then we can print it on a terminal so run we get the same result as before beautiful now let's add a method in this class so we start with public we don't wanna return a value so we use void we call this method say hello and here we're gonna print a message like hi my name is and then we can combine this string with the value of the name field now in this context we don't have a name parameter so we don't have to use that this keyword we can simply reference the name field directly okay now back in the main method instead of printing the name of a user we can call user dot say hello then run and we get this message so this is how we can create and use classes in Java one of the important concepts in object-oriented systems is coupling which determines how much a class is coupled or dependent on another class for example here in the main class we are using the user class so the main class is coupled or dependent on the user class so if you change the user class the main class might be affected we have to change it or at least we have to recompile and redeploy let me show you so I'm going to go back to the user class and introduce a new parameter in this constructor let's say integer H so we have changed the user class now the main class is broken we cannot compile this code we have to pass this argument over here so this is the problem with coupling let me show you another example back in the user class let's add a hyphen before this message now back in the main class we don't have a breaking change our code compiler fect li well however because we have changed the code in the user class this class has to be recompiled and that means all the classes that are dependent on this class have to be recompile as well that this is a very simple program we only have two classes but what if we had hundreds or thousands of classes and many of them were highly dependent on each other in an application like that if it change the class we could end up with lots of cascading changes an application built this way is really hard to change hard to extend let me give you a metaphor think of your car if you get a flat tire you only need to replace that tire you don't need to replace this steering wheel or the engine right your car is an example of a loosely coupled system the components in your car work together but they are not tightly coupled or dependent on each other so you can replace individual parts independently our applications should be the same way but how can we build loosely coupled applications using interfaces and that's what I'm going to cover next interfaces are one of the most misunderstood constructs in Java and in many other programming languages I talked about this in detail in the second part of my ultimate java course that is about 4 hours long but let me explain very briefly an interface is a contract that specifies the capabilities that a class should provide let me give you a metaphor imagine you want to open a restaurant you need a chef it doesn't matter who the chef is so you're not dependent on a particular chef you're only dependent on someone who can perform the role of a chef someone with certain capabilities this is an example of a loosely coupled system now I told you that an interface is a contract that specifies the capabilities that a class should provide so in this example we can represent the role of a chef with an interface and the actual chef's with classes that implement the chef's interface so this is the idea behind interfaces with interfaces we can build loosely coupled applications let me show you this in code so let's say you want to build a tax calculator tax calculation is complex and the rules may change from one year to another we can have a calculator for year 2019 and another for year 2020 just like we can have different people filling the role of a chef at a restaurant right but what do all tax calculators have in common they probably have a method called calculate tax we can represent this with an interface so in this package let's add a new class first we change the kind to interface and call it tax calculator so this is just a contract that specifies the methods that our calculator classes should implement so here we had a method float calculate tax note that we only have a method declaration so we're terminating the statement with a semicolon this method does not have a body it doesn't have implementation if you have curly braces here we get a compilation error so this interface is saying hey if you want to build a tax calculator class that class should have a method with this signature okay let's add a real tax calculator in this project so we add a new class we call this tax calculator 2019 now over here we type implements tax calculator now we have a compilation error because we haven't implemented the calculate tax method in this class we can put the caret over here press alternator and select implement methods intellij added the calculate tax method in our class but don't worry about this overwrite this is called an annotation I talked about this in the second part of my ultimate Java series for now all that matters is that this class has a method with this signature here we can return one now let's create another calculator so once again we add a new class we call it tax calculator 2020 once again we say implements tax calculator then alternator implement methods beautiful now in year 2020 and we can return to so we have two different implementations of this interface now in our application instead of working with these concrete implementations we should work with this interface this is called programming to an interface so anywhere we need a tax calculator in this program we're gonna work with this interface for example we can go back in the main class let's add a public static method I made the static so we can call it directly from the main method okay now this method should return a tax calculator so here we're using our interface let's call it get calculator for now we're gonna return a new tax calculator 2019 now in our main method we're gonna call the get calculator method and store the result in a variable called calculator so in this method we have a dependency or coupling to this interface now this interface is very simple it's very lightweight all it has is a method called calculate tax as long as we keep the signature of this method exactly as these we're not gonna have a breaking change this is how we achieve loose coupling so with this style of programming if we go to our tax calculator 2019 and let's say add a new method here public float calculate insurance we have changed this class but this change is not gonna impact our main method over here because we're programming to an interface not a concrete implementation now if you have been paying close attention and you might say but marsh over here we are newing up a tax calculator 2019 so if you make any changes in this class this class has to be recompiled and that means the main class should also be recompile that is true but this is a very simple example to demonstrate this concept in a real enterprise application we're now going to write code like this we use what we call a dependency injection framework that gives us real implementations of an interface so in our code we work with interfaces now if this concept is new to you don't worry we're gonna talk about this more and more throughout the course so you learn the basics of classes on interfaces over the next few videos we're going to talk about the four core principles of object-oriented programming it's easier to explain it using a real example so in this project I'm going to add a new class called account this represents a bank account a human is a field for storing the balance of this account so public float balance now with this implementation we can go to the main class and create a new account now we have repeated the class name twice so it's better to use the VAR keyword over here now with this implementation we can set the balance to any amount we can set it to a positive value or a negative value but what if negative balances are not allowed in our application we shouldn't be able to write code like this in other words we shouldn't allow other classes like the main class to change the state of this object directly they shouldn't be able to change the data in this object so to solve this problem we go back to our account class and replace this public keyword with private public and private are examples of access modifiers many other object-oriented languages have the same concept now back in the main class we have a compilation error because we cannot access the balanced field from outside of this class it's hidden inside this class so within this class we can use it anywhere but we cannot access it from outside of this class but what if you really need to change the balance how are we gonna be able to do that well here in the account class we can add a method public void set balance we give it a parameter called balance and here we set this that balance to balance now because we have a method here in this method we can perform some kind of validation so before setting the balance we can make sure it's a positive value so if balance is greater than zero then we can set it now a better implementation is to throw an exception or an error if the balance is an invalid value but let's not worry about that we don't want to do too much Java in this course we're gonna stick to the basics this is what we call a setter a method that is used for setting the value of a field by the same token we can have a getter so if you want to read the value of the balance field we can call a method called get balance so public float get balance and here we return the value of the banners field this is the encapsulation principle in action so encapsulation is really about bundling the data and methods that operate on the data within one unit or one class and hiding the values or state of an object inside the class so with this we can create robust applications we can prevent our objects from going in an invalid state so this is the encapsulation principle now we can take this to the next level instead of this method set balanced it would be better if you had methods like withdraw and deposit so instead of sending the balance to some kind of random value it's better to record some kind of transaction so we know when we deposited or withdrew money from this account so let's add a new method public void deposit we give it a parameter called amount and then we can set this that balance to this that balance plus amount or in Java we can use the Augmented assignment operator so we can rewrite the statement like this this the balance plus equals amount these two statements are identical right in this case we don't even need the disk keyword because our parameter is called amount so that is better of course here we need to do some kind of validation as well you want to make sure that amount is a positive value so if amount is greater than zero then we update the ballas similarly we're going to add a method called withdraw for taking money out of this account once again we add our validation logic if amount is greater than zero then we reduce the balance by this amount this is a better implementation so let's get rid of the set balance method now from the main method instead of setting the balance to some random value we can use the deposit or withdrawal methods that we created so initially we deposit $10 into this account then we withdraw $5 finally we get the balance and printed so sou t-tap that's our print line statement and here we can call account that get balance let's run the program and the balance is five dollars beautiful so this is all about encapsulation next we're going to talk about abstraction now let's talk about the second principle of object-oriented programming abstraction abstraction means that we should reduce complexity by hiding unnecessary details in our classes let me give you a metaphor think of the remote control of your TV this remote control has a bunch of buttons that allow you to work with your TV inside the remote control you have an electronic board and bunch of transistors and so on now we don't directly work with this transistors their implementation detail there's so much complexity there we don't want to worry about that complexity we don't care what happens inside that remote control when we press the turn on button this is the abstraction principle in action so the abstraction principle says that we should hide the unnecessary details in our classes and this helps us reduce complexity let's say this in code let's say we want to implement a class for sending emails to our users so let's add a new class we call this mail service in this class we need a method for sending an email so public void send email now in a real application here we should have a parameter of type email but let's not worry about it in this demo that's part of sending an email there are a number of things that should happen under the hood we have to connect to a mail server we have to authenticate we have to send the email and then disconnect so we could have a method like connect in this method we simply print a message like connect similarly we can have a method called disconnect and here we print this message and let's add one more method public void authenticate here we're gonna send our username and password to the mail server so let's say I authenticate now in our send email method we're gonna call these methods one by one first we're gonna connect then we're gonna authenticate next we're gonna send the actual email and finally we're going to disconnect now let's use this in our main class so over here let's create a mail service and set it to a new mail service now look at the interface of this class and by interface I'm not talking about the interface construct in Java I'm just talking about the interface of a class like the interface of a remote control what we see on that remote control or what we see in this class here we have four methods but the first three are implementation detail we don't care about this you don't care about connecting to a mail server we don't care about authentication all we care about is the ability to send an email so these three methods are adding extra complexity to this class they're making it harder for the consumers of this class to use this class so we applied the abstraction principle we go to our mail service and make this methods private now there are implementation detail and they're hidden from outside of this class one more time we make this private and one last time now back in the main class look at the interface of this class it has a single method it's much easier to use it's like a remote control with only four buttons have you seen how hard it is to use one of those remote controls that have 50 buttons you really don't know how to use them if you want to change the volume you have to look all over the place now this mail service class has a single method its phrase easy to use and more importantly if we change any of those private methods the main class is not going to get affected so if I introduce a parameter in this method let's say timeout the only breaking change that we have is over here the main class is not affected because the main class cannot see the connect method this is the benefit of applying the abstraction principle we can change the implementation detail without affecting other classes in our application next we're going to talk about inheritance let's talk about the third principle of object-oriented programming inheritance inheritance is a mechanism for reusing code let's say we want to build a Glee framework a graphical user interface framework in this framework we want to have classes like text box button checkbox and so on now Onis classes should have some common behavior for example we should be able to enable or disable them should be able to set their focus we should be able to set their position and so on now when implementing this class is we don't want to implement these behaviors in every single class that's a lot of code duplication inheritance is a mechanism that allows us to reuse code across our classes so we can implement all these common behaviors in a parent or base class and then have all these other classes inherit those behaviors let me show you so let's add a new class we're gonna call this UI control that's the base or the parent class for all widgets on the user interface now in this class we want to have the ability to enable or disable a control so a method called enable and here let's just print a message called enable now let's create a textbox class so we have a new class called textbox we run this class to inherit the code that we wrote in the UI control class so over here we type extends UI control now you can go to the main class and create a textbox object so VAR textbox will send it to a new text box I'll take a look here we have the enable method we didn't implement it in the textbox class we implemented it in the UI control class but the textbox inherited this code from its parent now when we run this program we can see the enabled message beautiful now there is more to inheritance than we can cover in this video I've dedicated an entire section about inheritance in the second part of my ultimate Java serious so if you want to learn more go watch that course next we're going to talk about polymorphism let's talk about the fourth principle of object-oriented programming polymorphism poly means many more fins form so polymorphism means many forms and it's basically the ability of an object to take on many forms let me show you this in code so continuing with a GUI framework we want to have the ability to draw each widget on the screen so in a UI control class let's add a method public void draw now this method is not gonna have an implementation because we don't know how to draw a UI control because the algorithm for drawing a widget is specific to the type of the widget drawing a text box is different from drawing a check box so we can leave the implementation empty or better we can declare this as abstract so public abstract void draw now we have a couple of compilation errors the first one is here because an abstract method cannot have a body so we remove the braces and terminate this with a semicolon this is like a method that we declare in an interface it's only a method declaration it doesn't have implementation now because we have an abstract method in this class we should declare this class as abstract as well this is like a half-baked cake we cannot use it directly we cannot instantiate it we cannot create a new instance of the UI control we can only extend it now if you go to our text box class we see a compilation error because this class has not implemented the draw method of the UI control so we put the caret over here press alt + enter' and implement methods exactly like how we implement the methods on an interface so now we have this public void draw method over here let's print drawing a text box now let's add another class in this project new class we're going to call this checkbox this classroom inherits all the code from the UI control so we type extends UI control then we have IntelliJ implement the abstract methods of this class there you go now we print drawing a checkbox so each widget knows how to draw itself okay now in our main class let's add a public static method public static void draw UI control we give it a parameter of type UI control and in this method we call control dot draw now in our main method we're going to call this method so draw your eye control now the UI control class is the parent or the base of the text box and check box classes so every textbox is a UI control and every check box is a UI control as well so we're calling this method we can pass a new instance of the textbox class and run the program here we see drawing a textbox if we pass and you check box we see drawing a check box so even though in this method we are working with a UI control object at runtime this object can take on many different forms it can behave like a check box or a text box or a button and so on this is polymorphism in action so an object can take on many different forms that's all about polymorphism so we have covered all the essential object-oriented principles next we're going to talk about um L which is the graphical notation we're gonna use throughout this course now that we have covered the essentials of Java let's talk about UML yeoman is short for unified modeling language and it's a visual language that we use to model our systems we're going to use it throughout this course to represent our classes and the relationship here are a few examples this is how we can represent a class in UML so we have this rectangle on the top we have the name of the class in the middle section we have the fields and down below we have the methods so here we have a class called shape in this class we have a field called position X and the type of this field is integer so after the colon we specify the type of a field or a parameter or the return type of a method so here we have a method called render it doesn't have any parameters that is why we have an empty pair of parentheses and it doesn't return any values so we don't have a colon after the name of the method so that means the return type of this method is void now this minus sign means this field is declared as private you can see that over here and obviously the plus sign means this is declared as public now in this course we're assuming that all of our fields are private and all of our methods are public so in the future diagrams I'm not going to display the minus and plus signs to keep things simple so this is how we can represent a class in UML now let's talk about the three types of relationships between classes this is what we call the inheritance relationship so this diagram is saying that the rectangle class inherits from or extends the shape class you can verify that over here so class rectangle extends shape now we're accurately in UML the inheritance relationship is indicated by an arrow with an empty triangle but in the software I'm using we don't have such an arrow so I'm gonna display my inheritance relationships with an arrow with a filled triangle ok now let's talk about the second type of relationship between classes this is called the composition relationship it's indicated by an arrow with a diamond so that means the shape class is composed of the size class in practical terms that means in the shape class we have a field of type size so the shape class is composed of this size class as another example you can say the car class is composed of the wheel class because every car has four wheels now in UML we have another type of relationship called aggregation which is kind of similar to composition but I don't want to bring too much UML in this course you want to keep things simple and focus on design patterns so if you have some background in UML you may argue that here we should use an aggregation relationship instead of composition let's not worry about these subtle details so this is the composition relationship now let's talk about the third type of relationship between classes this is what we call the dependency relationship it's indicated by dashed arrow so that means somewhere in the shape class we have a reference to the document class here's an example in the shape class we have a method called render and this method has a parameter of type document so document is not a field in this class but it's used somewhere in this class in this case it's a parameter but it could also be a local variable defined in the render method so somewhere in the shape class we have a reference or a dependency to the document class okay so here are the three types of relationships we're going to use in this course inheritance composition and dependency hey guys maj here i just wanted to let you know that this video you've been watching is the first hour of my ultimate design patterns course in this youtube video we talked about two design patterns but my ultimate design patterns course includes over 20 design patterns these are the design patterns that every software engineer must master so if you want to learn more I highly encourage you to enroll in my ultimate design patterns course the first 200 students can get the course with a big discount I'll put the link down below if you're interested the first design pattern we're going to talk about is the momento pattern we use this pattern for implementing undo mechanisms let me show you first of all I'm gonna add a new package to this project so in your package we call this momentum this is where we're gonna write all the code for this pattern now let's say we want to build a code editor that supports the undo mechanism so we add a new class in this package we call it editor in this class we need a feel for storing the current content of the editor so private string content we also need a getter and a setter for this field now we don't have to type these manually by hand we can have IntelliJ create these for us so we put the carrot on the field name press alt' + enter' and select create getter and setter for content there you go so here's our editor class now before talking about the momento pattern I want you to spend 10 to 15 minutes and think about a solution to implement the undo feature in this class so in our main class we should be able to create a new editor let's say editor equals new editor then we should be able to set the content of your times let's say a and B and C and then we should be able to undo the content so it spent 10 to 15 minutes and think about a solution to implement this feature this is extremely important because I want to teach you the art of problem solving unlike other courses I'm not gonna give you a UML diagram saying this is the moment of pattern and this is how it works I want to take you through the same thought process that Gang of Four have been through so you understand how and why they came up with a momento pattern so spend 10 to 15 minutes and propose a solution when you're done come back see the next lesson all right here's our editor class with the content field not to keep the screen clean I didn't add the getter and the setter that we created in the last video now the simplest way to solve this problem is by introducing a new field called previous content so every time we want to change the value of the content field we store the current value in the previous content field and then change the content field that's a very simple solution and it works however with this approach we can only undo once if you want to be able to undo multiple times we need a list so we should rename this field to previous contents note the plural name and the type of this field is gonna be a list that's a reasonable solution now what if some time in the future we introduce a new field like title so our editor window is gonna have a content and a title now to support the undo mechanism we need another field like previous titles to keep track of all the changes to the title field now as you can see this solution is not very extensible every time we introduce a new field we need to add an extra field for storing all the changes to that field so we need to come up with a better solution now let me remove these two fields okay that's better so instead of having multiple fields in this class we need a separate class like editor state this class will be purely responsible for storing the state of our editor at a given time correctly we have only one field in this class called content in the future we can add title and other fields all these fields are gonna be in a single class okay so in our editor class we need to store a list of editor States so we need a composition relationship between these two classes and that means we should rename this field from previous contents to previous States so you have a list of editor States inside the area class beautiful now this is a better solution because it allows us to undo multiple times and we're not gonna pollute the editor class with too many fields okay however this solution is violating a very important principle in object-oriented design that is a single responsibility rinsable that basically means every class should have a single responsibility let me give you a metaphor think of a restaurant in a restaurant every person has a specific role they do a single thing the waiter is purely responsible for taking orders they don't cook for you now imagine a restaurant where the waiter takes your order he cooks for you he goes shopping he also does taxes it doesn't make sense a restaurant like that is gonna be very unmanageable we have the same situation in software to build maintainable software we should design our classes in such a way that they have a single responsibility now back to our design our editor class correctly has two responsibilities one of them is state management the other is providing the features that we need from an editor we need to take all the state management work outside of this class and put it somewhere else so we shouldn't have this field inside this class previous States let's delete this that means we're not gonna have an association with the editor of state class so delayed that's better we need to introduce a new class called history this class will have a single responsibility and that would be state management so it will keep track of the changes in the state of the editor okay now in this class we need a field called States this is the field that we previously had in our editor class okay so we have this field here and that means we're gonna have a composition relationship with the editor state the history class is gonna store 0 or more editor state objects in a list ok we also need two methods push and pop with push we add a new state in the history and we pop we remove and return the last state now technically we could use a stat here instead of a list but that's implementation detail let's not worry about it too much at this stage now let the area class no longer stores state objects internally we should give it two new methods create state and restore state the create state method stores the current state of the editor inside a state object and returns it so we call this method and say hey save your current state and give it to me we'll get an editor state object then we call the push method of the history class say hey history save this state this is how these classes collaborate okay the restor method takes a state object and brings this editor back to that state so it will reset its fields based on what we have in this state object now look at the type of relationship we have between the editor and the editor state classes we have a dependency relationship that means the editor class uses the editor of state because to create state method returns an editor a state object okay well congratulations you came up with your first pattern this is called the momento pattern we use the momentum pattern to implement undo mechanisms in our classes now here's our representation of the momentum pattern but if you look at the Gang of Four book or any of the courses or books on this topic you will see different names for these classes the editor is called the originator the editor state is called the momentum and the history is called the caretaker these are just some abstract names that Gang of Four came up with to demonstrate the concept it doesn't mean you have to use them to name your classes always use meaningful names for your classes so this is the moment of pattern in this pattern we have three participants or three players originator momentum and caretaker now that you understand this pattern let's go ahead and implement it in code alright first of all in the moment a package let's add a new class we call this editor state currently we need only a single field in this class so private string content it would be nice to initialize this field from the constructor so we can press alt + enter' and add a constructor with a parameter there you go so we have a constructor this constructor has a single parameter and in the body of this constructor we initialize this field with the value of this parameter pretty simple now I would prefer to declare this field as final this will make sure that once we initialize this field we cannot accidentally change it on our program so this will add robustness to our code now we also need a getter here for reading the value of this field later on so I'll turn enter and create getter for content that's it we're done with this class now let's go to our editor class here we need two new methods create state and restore so public editor state create state when we call this method the editor will save its current state inside an editor state object and return it so return new editor State and here we pass the value of the content field now let's create the restore method it's pretty easy public void restore we give it a state object and here we set the content field to stay it but get content as simple as that the last piece of the puzzle is the history class so in this package let's add in your class we call it history here we can use a stack or a list I don't want this course to be wait Java is specific so I'm gonna go with a list private list of editor State now what is going on here well this list is an interface that is declared in the Java that util package so first we need to import it otherwise the compiler doesn't recognize it we can press alt' + enter' and intellij imported it on the top so import java.util that list now this list interface is a generic interface which means we can use it to build a list of different types of objects we can have a list of strings we can have a list of integers a list of editor states so with this angle brackets we specify the type of objects we want to store in this list in this case we want to store editor state objects okay now let's call this field state and set it to new array list what is going on here well I told you that this list is an interface that is declared in the java.util package in this package we have a class called ArrayList that implements this interface so you're programming to an interface because the ArrayList class might have other methods that we are not interested in we only need the functionality that is declared in the list interface okay now here we need two methods push on pub public void push it takes an editor state object and here we call States then add state this will add the state object at the end of the list okay now public editor state pop here we need to calculate the index of the last item in this list that is very easy so far last index now the list interface has a method called size this returns the number of items in this list now the index of the first item in the list is 0 so to get the index of the last item we should get the size and reduce it by 1 now we get the last item last item or last state that's better states that get with this we can get an item at a given index so let's get this item then we need to remove it from this list so we call States done remove and pass the last state object and finally we return the last date from this method that is our history class now let's put all of this together and see the undo mechanism in action so here in the main method first we create an editor object next we create a history object so of our history equals new history here we set the content to a at the same time you want to save this date in the history so we call editor that creates date this will return the current state and we'll add it to our history so we call history that push with this object a simple a stack one more time we set the content to be and right after that we save this date in the history next we set the content to see now here we can undo so we call history but pop this will return the Prima state and then we'll give this to our editor so we say hey earlier restore yourself with this date like this now if you print the current state of the editor it should be be take a look so print editor but get content take a look we get B if you undo one more time you're gonna see a so let's duplicate this line now run there you go so this is how we implement the momento pattern in this section I'm going to talk about the state pattern let's say you want to build a drawing application like Photoshop in Photoshop and in many other applications we have a palette of tools over here and this canvas behaves differently depending on the tool that we select for example if you select the selection tool you can see the icon of the cursor changes now when we click and drag we say this - rectangle similarly if you select the brush tool and click and drag we see this orange line so basically this canvas object is responding to Mouse events like Mouse up and mouse down but what it does changes depending on the currently selected tool let's simulate this in code so in this project first I'm gonna add a new package state we're gonna write all the code for this section in this package now here we need a new class called canvas this class should respond to Mouse events like Mouse down and mouse up so here when the two methods public void Mouse down and I'm gonna duplicate this and rename the second one to Mouse up now in both these methods we should do different things depending on the currently selected tool the first minute to figure out what is the currently selected tool we can represent that using an enum an enum in Java is like a set of constants let me show you so in this package we add a new class first we change the kind from class to enum and then call it tool type I hear we need to define a few constants like selection note that I'm using uppercase letters to name this constant this is a convention in Java so this is our selection tool we also need a brush and an eraser now back in our canvas class here may need a field to store the currently selected tool that is really easy so private tool type current - we also need a getter and a setter for this field so we put the carrot over here press alt' + enter' and create getter and setter beautiful now in our mouse down method we should write code like this if current 2 equals tool type dot selection here we should change the icon of the cursor to the selection icon so we simulate that by printing something on the terminal selection icon now else if current tool equals tool type that brush then we're going to print a different message brush icon one more time elsif current total equals tool type that eraser then we're gonna print eraser icon now when it's similar code in the mouse up method so to save time I'm gonna copy this and then paste it over here and then change what we print on the terminal so the moment the user releases the mouse button if the current tool is a selection tool you're gonna draw a dashed rectangle so draw dashed rectangle if the current tool is brush we're gonna draw a line and if it's an eraser we're gonna erase something okay we could also implement this using a switch and case statement now if you have been programmed for a while you have probably seen patterns like this in your code you have a long list of if an LS or Sushant case statements and you have probably repeated these statements in different places in your code so in this example we have this decision making statements in these two methods chances are in a real application in a real drawing application we should also respond to keyboard events like e up and key down and we probably have to repeat all this decision-making inside those methods as well so the approach that we have taken is not maintainable the more tools with support the longer these decision making statements are going to be and maintaining this code is going to become really difficult also here we have the lack of extensibility it's not easy to extend this application let's say tomorrow we're going to add a new tool for drawing a circle we have to go to different parts of our code and make changes for example in our mouse down method we should add another else--if statement to see if the current tool is the circle tool then we change the icon to the circle icon we have to make a similar change in the mouse up method so extending this application is not easy now what we really need here is given the canvas the ability to behave differently based on the currently selected tool so in both these methods we're executing different code depending on the currently selected tool we want this method to behave differently depending on the current tool in the course we talked about the four essential principles of object-oriented programming encapsulation abstraction inheritance and polymorphism which one of these principles do you think we cannot play here to solve this problem I want you to spend ten minutes on this exercise and figure out a way to solve this problem when you're done come back watch the next lesson earlier in the course we talked about polymorphism I told you that polymorphism is a mechanism that allows an object to take on many different forms so earlier we built this UI control class we declared this as abstract because it has a single abstract method abstract methods are methods that have no implementation so here we have a draw method but we don't know how to draw a UI control the drawing algorithm will be dependent on the type of the UI control so we created two specific UI controls one of them was the textbox class which extends the UI control and this is where we're implementing the logic for drawing a textbox now in our main class we had code like this we declared a static method called draw UI control which takes a UI control and simply calls control that draw that depending on the type of the object that we pass to this method our application behaves differently this is polymorphism in action so if it has an instance of the textbox class the draw method of the textbox class will be called even though we're working with the UI control class here so this control object can take on many different forms this is polymorphism here's the UML diagram of this classes so our main class talks to the UI control which is the parent or the base of these two classes text box and checkbox in UI control we have an abstract method called draw and we have implemented this method in our child classes now we can use the same technique to get rid of those ugly if and else statements in our canvas class so here's our canvas class we have the current tool field and these two methods we want these methods to behave differently depending on the current tool so we introduce a new class called tool this is going to be an abstract class like our UI control in this class we're going to declare two abstract methods mouse up and mouse down what happens when the user releases the mouse button will be determined in child classes so we introduce new classes like selection and brush in this classes we're gonna implement the logic for mouse up and mouse down events now our canvas class is going to work with the abstract tool class it doesn't care about any specific tools but it will behave differently depending on this specific tool that we give it at runtime and this is what we call the state pattern because the state pattern allows an object to behave differently when it state changes now if you look at the classic definition of the state pattern in the Gang of Four book or other books on courses you're gonna sit different labels so instead of canvas we have context and instead of tool we have state with two concrete implementations also instead of mouse up and mouse down methods we have the request method that is handled by the state class so as I told you before this is just an abstract concept it doesn't mean you should name your classes context or state there are two abstract always use meaningful names that fit the domain of your application next I'm going to show you how to implement this state pattern in code so here in the state package let's add a new class tool in this class we need to abstract methods so public abstract void mouse down and mouse up now because these methods are abstract we should mark the class as abstract as well now we could also use an interface here because an interface is simply a contract that determines the capabilities that a class should provide so earlier you saw that the metals in an interface don't have an implementation they're exactly like our abstract methods here now what is the difference between an interface and an abstract class well they're both abstract concepts we cannot instantiate them we cannot create a new instance of this tool class or the tool interface so because they're abstract and don't have much code they allow us to build loosely coupled applications we prefer to use an abstract class if you want to provide some common code to all the child classes in this case we're not providing any common code to our tools so I'm gonna replace this abstract class with that interface take a look public interface now in interfaces we don't need the abstract keyword because these methods are considered abstract by default so we remove the abstract keyword also these methods are considered to be public so we don't need the public keyword either that makes our code cleaner so we have an interface for a person take a tool now let's implement specific tools so let's add a class called selection tool here we type implements tool now note that here we have two interfaces with the same name the first one is the one that we just created we also have a tool interface in Java X package don't worry about that let's import the interface that we created okay now we should implement this interface so we press alt' + enter' and implement these methods so this is where we implement the logic with the selection tool when the user presses the mouse button we should change the icon to the selection icon and when they release the mouse button we should draw a dashed rectangle okay now let's add one more class this one is going to be our brush tool brush tool also implements the tool interface here we have a different logic so when the user presses the mouse button we should display the brush icon and when they release the mouse button we should draw a line now let's see how we can incorporate these into our canvas class so let's open up the canvas class first we should change the type of this field from tool type to tool so we're programming to an interface okay now we have a bunch of compilation errors it doesn't matter we're going to delete all the code in these methods all this nasty disgusting code now we should change the return type of our getter instead of tool type we're going to use tool and similarly for our setter we're gonna pass a tool object beautiful now in our mouse down metha we're gonna call current tool dot mouse down and similarly here we call current tool dot mouse up that's all we have to do isn't this code beautiful so the canvas class is simply delegating for your specific tool to determine what should happen when the user process or releases the mouse button with this implementation we don't have a long list of decision-making statements so our application is more maintainable and we can also easily extend it let me show you so right now we only have two types of tools a selection tool and a brush tool let's use this and then I'll show you how to extend this application to support a new tool so we go to our main class first we create a canvas object so Camus's now we set the current tool set current tool here we should pass an object that implements the tool interface so we can pass a selection tool then we call mouse down and finally mouse up let's see what happens so the icon change to the selection icon and then we draw a - rectangle beautiful if we pass an instance of the brush tool class will get different result there you go now let's say tomorrow we're gonna support a new tool that's really easy all we have to do is to add a new class that implements the tool interface take a look so here I'm gonna add a new class let's say eraser tool you have this class implement the tool interface and over here we implement our logic so erase your icon and here erase something now we go back to our main class and simply pass a new instance of the eraser tool class take a look we get different result and that brings us to a very important principle in object-oriented programming open-closed principle that basically means our classes should be open for extension but closed for modification so we're not allowed to change the code in our classes we can only extend it now with this principle we can add new functionality without changing the existing code we can support new functions by adding new classes now why does this matter well how many times have you found yourself changing the code in a class and then breaking something your application the open closed principle prevents situations like that every time we want to support a new feature we simply add new classes and we test those glasses okay so following this principle makes our applications extensible and robust if this concept is new to you don't worry you're going to see more examples of this later in the course so design planners are great they help us build maintainable extensible and reusable objects however sometimes they get misused here's an example you've got this guy over here his name is John Smith he's a fairly arrogant developer you've probably seen him in my other courses he recently learned about design patterns and started refactoring some existing code to apply these patters now he feels superior to his coworkers he feels like a superstar developer just because he learned about this date pattern and applied it in code that is what I call abusing patterns remember this every pattern has a context it's there to solve a particular problem and that's why I've taken a problem driven approach in this course so you learn and understand when and how to apply these patterns if you just blindly apply these patterns in your code you're gonna increase complexity because you're gonna end up with more moving parts so not only haven't you solved the problem but you actually created a new problem you created what we call a design smell in your application that is an application with an overly complicated design some people call it over-engineered I don't like to use that term because a real engineer always tries to understand a problem first and then they think of various solutions and pick the one that best fits the problem that is the definition of an engineer at least for me over engineering a solution is what code monkeys do programmers will blame the right code without understanding the problem they're trying to solve as Leonardo da Vinci said simplicity is the ultimate sophistication so keep things simple and pragmatic don't blindly apply these design patterns without understanding the problem you're trying to solve next I'm gonna show you a real example of abusing the state pattern all right let me show you how the state pattern can easily be abused let's say you want to implement a stopwatch app in this app we need a stopwatch class with a click method when we click it it either starts counting or stops so in our state package let's add a sub package I'm going to call this abuse now this package we're going to add a new class called stop watch here we need the click method now depending on the state of this object we should do different things we can represent the state with an enum with two states or we can use a boolean I think a boolean is easier so let's go with a boolean so private boolean is running now when we click the stopwatch if it's running then we're gonna stop it so we set is running to false and then we print stopped otherwise we're gonna set is running to true and then print running let's test our implementation after this point so in the main class we create a stopwatch and then click it initially it stopped so when we run this application we should see the running message there you go beautiful now if you click it one more time we see two messages running and then stop if we click it one more time we see running stopped running beautiful so this is a very simple straightforward implementation now John Smith takes away this code he's sitting in the office and he thinks hmm the click method is behaving differently depending on the state of the stopwatch so that is the case for the state pattern it's gonna refactor this code like this first it's going to create a new class or an interface called state so we need an interface here this interface is going to have one method click and you're gonna have two classes that implement this interface so John adds two classes one of them is stopped state the other is running state running state now both these glasses should implement the state interface if the stopwatch is running we should stop it and then print a message but how are we going to be able to stop this stopwatch we don't have access to the stopwatch object here well we can add a constructor so public running state we give this constructor a parameter of type stopwatch and then store it in a field so we declare a private field here private stopwatch we call it stopwatch and we initialize it in the constructor this the stopwatch equals stopwatch now in the click method we should change the state of the stopwatch so first we need to go to the stopwatch class an out of field to store the current state of this object so we don't in this field anymore let's declare a private field of type state called current state now let's generate a getter and a setter for this field that is super easy there you go up so back to the running State when we call the click method we should change the state of the stopwatch so we call stopwatch that set state and here we pass the next date that is the stopped state so new stopped State now here we have a compilation error because this class doesn't implement the state interface so let's add it real quick implements state all right the back in the running State class the problem is gone beautiful so we change the state and then print a message saying stopped now we need a similar approach in the stopped state class so here we generate a constructor I'm going to show you a shortcut if you're on Mac press command + n if you're on Windows press ctrl + n with this we can bring up the generate palette and generate a constructor now here we can add a parameter that is stopwatch and at the same time we can create and initialize a private field so we put the carrot on the parameter name press alt' + enter' and select create field for parameter stopwatch there you go so we got a private field and this field is initialized over here beautiful now in the click method we should change the state of the stopwatch so we call stopwatch that's that current state if it stopped we should set it to the running state so new running state now here we should pass a reference to the stopwatch that is the stopwatch field that we have in this class okay then we print a message saying ready okay now we have a compilation error and the running state class because when we try to change the state of the stopwatch we're passing a new instance of the stop state class the constructor of the stop state class expects a stopwatch object so we pass that object over here problem so so you have to state classes and the final part you go to the stopwatch and replace this implementation with current state dot click so we're delegating the task of clicking the stopwatch to the state object and by the way initially we should set this to the stopped state so Neil stop state now here we should pass a reference to a stopwatch object that is gonna be this that represents the current object we're done now back in the main method so internally we changed the implementation of the stopwatch but it behaves the same thing let's run the program we see the exact same result as before beautiful however this implementation is way more complex than the simple if a nail statement that we had before so there is absolutely nothing wrong with even else or Sushant case statements if you have a few decision making branches in a single method like how we did in the stopwatch class we had those decision-making statements in a single place there is absolutely nothing wrong with that implementation but in our previous example in our canvas class we had those decision-making statements in multiple places in the mouse down and mouse op methods and more importantly if you wanted to support a new tool we had to modify different parts of our code that is the reason why we refactor this code we change this structure and use this state pattern in contrast in the stopwatch all that decision-making was in a single place and we know that this Dulwich is not going to have a new state in the future it's either stopped or running a simple as that so we don't have a maintainability issue here we don't have extensibility issue we ended up refactoring this code well I didn't just smoothly that but he made this code overly complicated without gaining any benefits now we have more moving parts we have an interface plus two implementations and our logic is spread over these two different classes in contrast and the previous implementation all that logic was in a single place so here is the bottom line don't abuse the design patterns congratulations on completing this YouTube tutorial as I told you before this video is the first hour of my ultimate design patterns course if you want to learn more I highly encourage you to enroll in my course where we talk about twenty other design patterns these are the essential design patterns that every software engineer must master the first 200 students can get the course with a big discount so if you're interested and will now before this offer expires you can find the link below this video thank you and have a fantastic day [Music] you

